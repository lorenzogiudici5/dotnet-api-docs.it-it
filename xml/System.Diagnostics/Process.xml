<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f877e9571f09e703e3507d9a3489b76fa6b7a4e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52235525" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce l'accesso ai processi locali e remoti e permette di avviare e arrestare i processi locali del sistema.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.Process> componente fornisce l'accesso a un processo in esecuzione in un computer. È un processo, in termini semplici, un'app in esecuzione. Un thread è l'unità di base a cui il sistema operativo alloca tempo processore. Un thread può eseguire qualsiasi parte del codice del processo, comprese le parti in fase di esecuzione da un altro thread.  
  
 Il <xref:System.Diagnostics.Process> componente è uno strumento utile per avviare, arrestare, controllare e monitorare le app. È possibile usare il <xref:System.Diagnostics.Process> componente, per ottenere un elenco dei processi in esecuzione, oppure è possibile avviare un nuovo processo. Oggetto <xref:System.Diagnostics.Process> componente viene utilizzato per accedere a processi di sistema. Dopo un <xref:System.Diagnostics.Process> componente è stato inizializzato, può essere utilizzato per ottenere informazioni sul processo in esecuzione. Tali informazioni includono il set di thread, i moduli caricati (file con estensione dll ed .exe), e l'utilizzo di informazioni sulle prestazioni, ad esempio la quantità di memoria del processo.  
  
 Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `finally` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
> [!NOTE]
>  i moduli di un processo a 64 bit non è possibile accedere a processi a 32 bit. Se si prova a ottenere informazioni su un processo a 64 bit da un processo a 32 bit, si otterrà un <xref:System.ComponentModel.Win32Exception> eccezione. Un processo a 64 bit, d'altra parte, possa accedere i moduli di un processo a 32 bit.  
  
 Il componente di elaborazione di ottenere informazioni su un gruppo di proprietà in una sola volta. Dopo il <xref:System.Diagnostics.Process> componente ha ottenuto le informazioni su un membro di alcun gruppo, nella cache i valori per le altre proprietà in tale gruppo e non ottengono nuove informazioni su altri membri del gruppo finché non si chiama il <xref:System.Diagnostics.Process.Refresh%2A> (metodo). Pertanto, un valore della proprietà non è garantito a essere più l'ultima chiamata a qualsiasi recente il <xref:System.Diagnostics.Process.Refresh%2A> (metodo). Suddivisioni di gruppo sono dipendenti dal sistema operativo.  
  
 Se si dispone di una variabile di percorso dichiarata nel sistema di uso delle virgolette, è necessario qualificare completamente tale percorso durante l'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e aggiungerlo utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` quando il riavvio.  
  
 Un processo di sistema viene identificato in modo univoco dal rispettivo identificatore di processo nel sistema. Analogamente a molte risorse di Windows, un processo viene inoltre identificato dal relativo handle, che potrebbe non essere univoco nel computer. Il termine generico per un identificatore di una risorsa è un handle. Il sistema operativo conserva l'handle di processo, accessibile tramite il <xref:System.Diagnostics.Process.Handle%2A> proprietà del <xref:System.Diagnostics.Process> componente, anche quando il processo è terminato. Di conseguenza, è possibile ottenere le informazioni del processo amministrativo, ad esempio la <xref:System.Diagnostics.Process.ExitCode%2A> (in genere, zero per esito positivo o un codice di errore diverso da zero) e il <xref:System.Diagnostics.Process.ExitTime%2A>. Gli handle sono una risorsa molto utile, in modo che verifica una perdita di handle è molto più grave perdita di memoria.  
  
> [!NOTE]
>  Questa classe contiene una richiesta di collegamento e una richiesta di ereditarietà a livello di classe che si applica a tutti i membri. Oggetto <xref:System.Security.SecurityException> viene generata quando il chiamante immediato o la classe derivata non dispone dell'autorizzazione di attendibilità. Per informazioni dettagliate sui requisiti di sicurezza, vedere [richieste di collegamento](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Note  
 In .NET Framework, il <xref:System.Diagnostics.Process> classe per impostazione predefinita Usa <xref:System.Console> codifiche, che sono in genere le codifiche della tabella, per i flussi di input, output e di errore del codice. Ad esempio di codice, nei sistemi con le impostazioni cultura è l'inglese (Stati Uniti), la tabella codici 437 è la codifica predefinita per il <xref:System.Console> classe. Tuttavia, [!INCLUDE[net_core](~/includes/net-core-md.md)] può rendere disponibili solo un subset limitato di queste codifiche. In questo caso, Usa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> come codifica predefinita.  
  
 Se un <xref:System.Diagnostics.Process> oggetto dipende dalle specifiche codifiche della tabella codici, è possibile comunque rendere loro disponibili eseguendo le operazioni seguenti *prima* si chiama qualsiasi <xref:System.Diagnostics.Process> metodi:  
  
1.  Aggiungere un riferimento all'assembly System.Text.Encoding.CodePages.dll al progetto.  
  
2.  Recuperare il <xref:System.Text.EncodingProvider> dall'oggetto di <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> proprietà.  
  
3.  Passare il <xref:System.Text.EncodingProvider> dell'oggetto per il <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> metodo per apportare le codifiche aggiuntive supportate dal provider di codifica disponibili.  
  
 Il <xref:System.Diagnostics.Process> classe quindi userà automaticamente la codifica di sistema predefinita anziché UTF8, condizione che è stato registrato il provider di codifica prima di chiamare qualsiasi <xref:System.Diagnostics.Process> metodi.  
  
   
  
## Examples  
 L'esempio seguente usa un'istanza di <xref:System.Diagnostics.Process> classe avvii un processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 L'esempio seguente usa il <xref:System.Diagnostics.Process> classe se stesso e un valore statico <xref:System.Diagnostics.Process.Start%2A> metodo per avviare un processo.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Il seguente F# esempio definisce un `runProc` funzione che avvia un processo, acquisisce tutte le informazioni di errore e di output e registra il numero di millisecondi che il processo è stato eseguito.  Il `runProc` funzione presenta tre parametri: il nome dell'applicazione da avviare, gli argomenti da fornire all'applicazione e la directory di avvio.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Il codice per il `runProc` funzione è stata scritta dal [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) ed è disponibile con il [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per un'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Usando la classe Process .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si specifica il <xref:System.Diagnostics.Process.MachineName%2A> proprietà, il valore predefinito è il computer locale, (".").  
  
 Sono disponibili due opzioni per l'associazione di un nuovo <xref:System.Diagnostics.Process> componente con un processo nel computer. La prima opzione consiste nell'utilizzare il costruttore per creare il <xref:System.Diagnostics.Process> i membri appropriati dell'insieme di componenti, il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e chiamare <xref:System.Diagnostics.Process.Start%2A> associare la <xref:System.Diagnostics.Process> con un nuovo processo di sistema. La seconda opzione consiste nell'associare il <xref:System.Diagnostics.Process> con un processo di sistema in esecuzione usando <xref:System.Diagnostics.Process.GetProcessById%2A> o una del <xref:System.Diagnostics.Process.GetProcesses%2A> restituiscono valori.  
  
 Se si usa una `static` eseguire l'overload del <xref:System.Diagnostics.Process.Start%2A> crea un nuovo metodo per avviare un nuovo processo di sistema, il metodo <xref:System.Diagnostics.Process> componente e associa il processo.  
  
 Quando la <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> proprietà è impostata sul valore predefinito, `true`, è possibile avviare le applicazioni e i documenti in modo che è simile all'utilizzo di `Run` finestra di dialogo di Windows `Start` menu. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> è `false`, è possibile avviare solo file eseguibili.  
  
 Qualsiasi file eseguibile che è possibile chiamare dalla riga di comando può essere avviato in uno dei due modi: tramite l'impostazione dei membri appropriati del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata il <xref:System.Diagnostics.Process.Start%2A> metodo senza parametri oppure passando il parametro appropriato per il `static` <xref:System.Diagnostics.Process.Start%2A> membro.  
  
 È possibile creare un <xref:System.Diagnostics.Process> componente mediante il costruttore, uno dei statica <xref:System.Diagnostics.Process.Start%2A> overload o una qualsiasi delle <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, o <xref:System.Diagnostics.Process.GetProcessesByName%2A> metodi. Dopo aver eseguito questa operazione, disponibile una visualizzazione di processo associato. Non si tratta di una visualizzazione dinamica che viene aggiornata automaticamente le proprietà del processo sono stati modificati in memoria. In alternativa, è necessario chiamare <xref:System.Diagnostics.Process.Refresh%2A> per il componente aggiornare il <xref:System.Diagnostics.Process> informazioni sulle proprietà dell'applicazione.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la priorità base del processo associato.</summary>
        <value>Priorità base, calcolata dalla proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> del processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> del processo è la priorità di partenza per i thread creati all'interno del processo associato. È possibile visualizzare informazioni sulla priorità di base tramite contatore di Base di priorità del Monitor di sistema.  
  
 In base al tempo trascorso o altri degli incrementi, il sistema operativo è possono modificare la priorità di base quando un processo deve essere inserito prima degli altri.  
  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà consente di visualizzare la priorità di Avvia assegnata a un processo. Tuttavia, poiché si tratta di sola lettura, è possibile usare il <xref:System.Diagnostics.Process.BasePriority%2A> per impostare la priorità del processo. Per modificare la priorità, usare il <xref:System.Diagnostics.Process.PriorityClass%2A> proprietà. Il <xref:System.Diagnostics.Process.BasePriority%2A> visualizzabile tramite il monitoraggio di sistema, mentre il <xref:System.Diagnostics.Process.PriorityClass%2A> non. Sia la <xref:System.Diagnostics.Process.BasePriority%2A> e il <xref:System.Diagnostics.Process.PriorityClass%2A> possono essere visualizzati a livello di codice. La tabella seguente illustra la relazione tra <xref:System.Diagnostics.Process.BasePriority%2A> i valori e <xref:System.Diagnostics.Process.PriorityClass%2A> valori.  
  
|BasePriority|Classe di priorità|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è stato terminato.  
  
oppure 
Il processo non è avviato, quindi non c'è nessun ID del processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia le operazioni di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.StandardError%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output di errori del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardError%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. Questo metodo consente al gestore dell'evento designato per l'output del flusso e torna immediatamente al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
 Seguire questi passaggi per eseguire operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardError%2A> per un <xref:System.Diagnostics.Process> :  
  
1.  Impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> su `false`.  
  
2.  Impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> su `true`.  
  
3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.ErrorDataReceived> evento. Il gestore dell'evento deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma del delegato.  
  
4.  Avviare il <xref:System.Diagnostics.Process>.  
  
5.  Chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per il <xref:System.Diagnostics.Process>. Questa chiamata inizia le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Quando start operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta che l'oggetto associato <xref:System.Diagnostics.Process> scrive una riga di testo al relativo <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile annullare un'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>. L'operazione di lettura può essere annullata dal chiamante o dal gestore dell'evento. Dopo l'annullamento, è possibile chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per riprendere le operazioni di lettura asincrone.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura sincrone e asincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> nel <xref:System.Diagnostics.Process.StandardError%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modi diversi. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
   
  
## Examples  
 L'esempio seguente usa il `net view` comando per elencare le risorse di rete disponibili in un computer remoto. L'utente fornisce il nome del computer di destinazione come argomento della riga di comando. L'utente può fornire anche un nome di file per l'output di errore. L'esempio raccoglie l'output del comando net, attende il completamento del processo e quindi scrive l'output risultante nella console. Se l'utente fornisce il file di errore facoltativo, vengono scritti gli errori nel file.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="false" />.  
  
\- oppure - 
È già in corso un'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
\- oppure - 
Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> è stato usato da un'operazione di lettura sincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia le operazioni di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e torna immediatamente al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
 Seguire questi passaggi per eseguire operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardOutput%2A> per un <xref:System.Diagnostics.Process> :  
  
1.  Impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> su `false`.  
  
2.  Impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> su `true`.  
  
3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore dell'evento deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma del delegato.  
  
4.  Avviare il <xref:System.Diagnostics.Process>.  
  
5.  Chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per il <xref:System.Diagnostics.Process>. Questa chiamata inizia le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Quando start operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta che l'oggetto associato <xref:System.Diagnostics.Process> scrive una riga di testo al relativo <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 È possibile annullare un'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>. L'operazione di lettura può essere annullata dal chiamante o dal gestore dell'evento. Dopo l'annullamento, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per riprendere le operazioni di lettura asincrone.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura sincrone e asincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modi diversi. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 L'esempio seguente illustra come eseguire operazioni di lettura asincrona sul reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso dei `sort` comando. Il `sort` comando è un'applicazione console che legge e ordina il testo immesso.  
  
 Nell'esempio viene creato un delegato per il `SortOutputHandler` gestore dell'evento e la associa il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore eventi riceve le righe di testo da reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, formatta il testo e scrive il testo sullo schermo.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> è <see langword="false" />.  
  
\- oppure - 
È già in corso un'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
\- oppure - 
Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> è stato usato da un'operazione di lettura sincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla l'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato di un'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Avvia un'operazione di lettura asincrona sul <xref:System.Diagnostics.Process.StandardError%2A> flusso. <xref:System.Diagnostics.Process.CancelErrorRead%2A> Termina l'operazione di lettura asincrona.  
  
 Dopo l'annullamento, è possibile riprendere l'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuovamente.  
  
 Quando si chiama <xref:System.Diagnostics.Process.CancelErrorRead%2A>, tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardError%2A> vengono completate e quindi il gestore eventi è disabilitato. Ogni output per un'ulteriore reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> viene salvato in un buffer. Se si abilita nuovamente il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, l'output salvato viene inviato al gestore dell'evento e riprenderanno le operazioni di lettura asincrone. Se si desidera modificare il gestore eventi prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell'evento esistente prima di aggiungere il nuovo gestore eventi:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Non è possibile combinare le operazioni di lettura sincrone e asincrone su reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> flusso. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Se si annulla un'operazione di lettura asincrona sul <xref:System.Diagnostics.Process.StandardError%2A> ed è quindi necessario leggere dal flusso anche in questo caso, è necessario usare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per riprendere le operazioni di lettura asincrone. Non seguire <xref:System.Diagnostics.Process.CancelErrorRead%2A> con una chiamata a sincroni i metodi di lettura <xref:System.Diagnostics.Process.StandardError%2A> , ad esempio <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviato il `nmake` gli argomenti di comando con utente specificati. I flussi di errore e di output vengono letti in modo asincrono; le righe di testo raccolti vengono visualizzate nella console, nonché scritte in un file di log. Se l'output del comando supera un numero di righe specificato, vengono annullate le operazioni di lettura asincrone.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> non è abilitato per le operazioni di lettura asincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla l'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato di un'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Avvia un'operazione di lettura asincrona sul <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. <xref:System.Diagnostics.Process.CancelOutputRead%2A> Termina l'operazione di lettura asincrona.  
  
 Dopo l'annullamento, è possibile riprendere le operazioni di lettura asincrone chiamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuovamente.  
  
 Quando si chiama <xref:System.Diagnostics.Process.CancelOutputRead%2A>, tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardOutput%2A> vengono completate e quindi il gestore eventi è disabilitato. Ogni output per un'ulteriore reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> viene salvato in un buffer. Se si abilita nuovamente il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, l'output salvato viene inviato al gestore dell'evento e riprenderanno le operazioni di lettura asincrone. Se si desidera modificare il gestore eventi prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell'evento esistente prima di aggiungere il nuovo gestore eventi:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Non è possibile combinare le operazioni di lettura sincrone e asincrone su reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Se si annulla un'operazione di lettura asincrona sul <xref:System.Diagnostics.Process.StandardOutput%2A> ed è quindi necessario leggere dal flusso anche in questo caso, è necessario usare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per riprendere le operazioni di lettura asincrone. Non seguire <xref:System.Diagnostics.Process.CancelOutputRead%2A> con una chiamata a sincroni i metodi di lettura <xref:System.Diagnostics.Process.StandardOutput%2A> , ad esempio <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviato il `nmake` gli argomenti di comando con utente specificati. I flussi di errore e di output vengono letti in modo asincrono; le righe di testo raccolti vengono visualizzate nella console, nonché scritte in un file di log. Se l'output del comando supera un numero di righe specificato, vengono annullate le operazioni di lettura asincrone.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> non è abilitato per le operazioni di lettura asincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate a questo componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.Close%2A> metodo fa in modo che il processo di arresto in attesa di uscita se era in attesa, chiude l'handle del processo e Cancella le proprietà specifiche del processo. <xref:System.Diagnostics.Process.Close%2A> non chiudere i lettori di output, input e di errore standard e i writer nel caso in cui viene fatto riferimento esternamente.  
  
> [!NOTE]
>  Il metodo <xref:System.Diagnostics.Process.Dispose%2A> chiama <xref:System.Diagnostics.Process.Close%2A>. Posizionare il <xref:System.Diagnostics.Process> dell'oggetto un `using` blocco Elimina le risorse senza la necessità di chiamare <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Recupera quindi l'utilizzo della memoria fisica del processo associato a intervalli di 2 secondi per un massimo di 10 secondi. L'esempio rileva se il processo viene chiuso prima di 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude un processo che dispone di un'interfaccia utente inviando un messaggio di chiusura alla corrispondente finestra principale.</summary>
        <returns>
          <see langword="true" /> se il messaggio di chiusura è stato inviato correttamente, <see langword="false" /> se il processo associato non dispone di una finestra principale o se la finestra principale è disabilitata (ad esempio, se è attualmente visualizzata una finestra modale).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un processo è in esecuzione, il ciclo di messaggi è in uno stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata a <xref:System.Diagnostics.Process.CloseMainWindow%2A> invia una richiesta di chiusura della finestra principale, che, in un'applicazione ben formata, consente di chiudere le finestre figlio e revoca dei cicli di messaggi in esecuzione per l'applicazione. La richiesta di terminazione del processo chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> non forza la chiusura dell'applicazione. L'applicazione può richiedere per la verifica dell'utente prima di uscire può rifiutare la chiusura. Per forzare la chiusura dell'applicazione, usare il <xref:System.Diagnostics.Process.Kill%2A> (metodo). Il comportamento di <xref:System.Diagnostics.Process.CloseMainWindow%2A> è identico a quello di un utente la chiusura di finestra principale di un'applicazione usando il menu di sistema. Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone l'applicazione per uscire immediatamente.  
  
 I dati modificati dal processo o le risorse allocate per il processo possono essere perse se si chiama <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoca una chiusura anomala di processo e deve essere utilizzato solo quando necessario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Abilita una chiusura normale del processo e chiude tutte le finestre, è preferibile per le applicazioni con un'interfaccia. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> ha esito negativo, è possibile usare <xref:System.Diagnostics.Process.Kill%2A> per terminare il processo. <xref:System.Diagnostics.Process.Kill%2A> è l'unico modo per terminare i processi che non dispongono di interfacce grafiche.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo per i processi in esecuzione nel computer locale. È non deve generare i processi nei computer remoti per uscire. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Recupera quindi l'utilizzo della memoria fisica del processo associato a intervalli di 2 secondi per un massimo di 10 secondi. L'esempio rileva se il processo viene chiuso prima di 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Processo già terminato.  
  
oppure 
Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia tutte le risorse usate dal processo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la generazione dell'evento <see cref="E:System.Diagnostics.Process.Exited" /> quando il processo viene terminato.</summary>
        <value>
          <see langword="true" /> se l'evento <see cref="E:System.Diagnostics.Process.Exited" /> dovrà essere generato quando il processo associato viene terminato (mediante un'uscita o una chiamata al metodo <see cref="M:System.Diagnostics.Process.Kill" />); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />. Si noti che il <see cref="E:System.Diagnostics.Process.Exited" /> evento viene generato anche se il valore di <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> viene <see langword="false" /> quando il processo viene chiuso durante o prima che l'utente esegue un <see cref="P:System.Diagnostics.Process.HasExited" /> controllare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà indica se il componente deve ricevere notifica quando il sistema operativo ha arrestato un processo. Il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà viene utilizzata l'elaborazione asincrona per notificare all'applicazione che un processo è stato terminato. Per forzare l'applicazione in modo sincrono attendere un evento di uscita (che interrompe l'elaborazione dell'applicazione fino a quando non si è verificato l'evento di uscita), usare il <xref:System.Diagnostics.Process.WaitForExit%2A> (metodo).

> [!NOTE]
> Se si usa Visual Studio e fare doppio clic su un <xref:System.Diagnostics.Process> componente nel progetto, un <xref:System.Diagnostics.Process.Exited> delegato dell'evento e il gestore eventi vengono generati automaticamente. Set di codice aggiuntivo di <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà `false`. È necessario modificare questa proprietà su `true` per il gestore dell'evento da eseguire quando viene chiuso il processo associato.

Se il componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valore è `true`, o quando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> viene `false` e un <xref:System.Diagnostics.Process.HasExited%2A> controllo viene richiamato dal componente, il componente può accedere alle informazioni amministrative per il processo associato, che rimane archiviati dal sistema operativo. Tali informazioni includono il <xref:System.Diagnostics.Process.ExitTime%2A> e il <xref:System.Diagnostics.Process.ExitCode%2A>.

Dopo aver terminato il processo associato, il <xref:System.Diagnostics.Process.Handle%2A> del componente non punta più a una risorsa di processo esistente. Al contrario, può solo essere utilizzato per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema operativo è a conoscenza che non esistono handle a processi terminati che non sono stati rilasciati dai <xref:System.Diagnostics.Process> componenti, in modo che mantiene le <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria.

È previsto un costo associato la visione per un processo venga terminato. Se <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> viene `true`, il <xref:System.Diagnostics.Process.Exited> evento viene generato quando termina il processo associato. Le procedure per la <xref:System.Diagnostics.Process.Exited> evento eseguito all'ora corrente.

In alcuni casi, l'applicazione avvia un processo ma non richiede la notifica della chiusura. Ad esempio, l'applicazione può avviare Blocco note per consentire all'utente di eseguire la modifica del testo senza effettuare alcun altro uso dell'applicazione Blocco note. È possibile scegliere evitare la notifica quando il processo viene terminato perché non è rilevante per la continuità operativa dell'applicazione. L'impostazione <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> a `false` possono salvare le risorse di sistema.

## Examples  
Esempio di codice seguente crea un processo che consente di stampare un file. Imposta il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà per fare in modo che il processo generi il <xref:System.Diagnostics.Process.Exited> eventi alla chiusura. Il <xref:System.Diagnostics.Process.Exited> gestore dell'evento Visualizza le informazioni sul processo.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta un componente <see cref="T:System.Diagnostics.Process" /> nello stato che gli permette di interagire con i processi del sistema operativo eseguiti in modalità speciale attivando la proprietà nativa <see langword="SeDebugPrivilege" /> sul thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni processi di sistema operativo eseguito in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non sia stato chiamato <xref:System.Diagnostics.Process.EnterDebugMode%2A> sul componente. Chiamare <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando non è più necessario l'accesso a questi processi eseguiti in modalità speciale.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione scrive nel proprio flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica che il processo associato ha scritto nel proprio flusso <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 L'evento si verifica solo durante le operazioni di lettura asincrone sul <xref:System.Diagnostics.Process.StandardError%2A>. Per avviare operazioni di lettura asincrona, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardError%2A> flusso di un <xref:System.Diagnostics.Process>, aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.ErrorDataReceived> evento, quindi chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Successivamente, il <xref:System.Diagnostics.Process.ErrorDataReceived> segnali di evento ogni volta che il processo scrive una riga in reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> streaming, fino a quando il processo viene chiuso o chiama <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit> metodo per assicurarsi che il buffer di output è stato scaricato. Si noti che se si specifica un timeout utilizzando il <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload viene *non* assicurarsi che il buffer di output è stato scaricato.
  
   
  
## Examples  
 L'esempio seguente usa il `net view` comando per elencare le risorse di rete disponibili in un computer remoto. L'utente fornisce il nome del computer di destinazione come argomento della riga di comando. L'utente può fornire anche un nome di file per l'output di errore. L'esempio raccoglie l'output del comando net, attende il completamento del processo e quindi scrive l'output risultante nella console. Se l'utente fornisce il file di errore facoltativo, vengono scritti gli errori nel file.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore specificato dal processo associato quando è stato terminato.</summary>
        <value>Codice specificato dal processo associato quando è stato terminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Diagnostics.Process.ExitCode%2A> per ottenere lo stato restituito il processo di sistema quando è stato terminato. È possibile usare il codice di uscita molto, analogamente a un numero intero restituito da una `main()` procedure.  
  
 Il <xref:System.Diagnostics.Process.ExitCode%2A> valore per un processo riflette la convenzione specifica implementata dallo sviluppatore dell'applicazione per tale processo. Se si usa il valore di codice di uscita per prendere decisioni nel codice, assicurarsi di conoscere la convenzione di codice di uscita usata dal processo di applicazione.  
  
 Gli sviluppatori in genere indicano l'esito positivo da una <xref:System.Diagnostics.Process.ExitCode%2A> pari a zero e definiscono come errori da valori diversi da zero che il metodo chiamante può usare per identificare la causa di una chiusura processo anomalo. Non è necessario seguire queste linee guida, ma sono la convenzione.  
  
 Se si prova a ottenere il <xref:System.Diagnostics.Process.ExitCode%2A> prima che il processo è terminato, il tentativo di genera un'eccezione. Esaminare il <xref:System.Diagnostics.Process.HasExited%2A> proprietà prima di tutto per verificare se è stato terminato il processo associato.  
  
> [!NOTE]
>  Quando l'output standard è stato reindirizzato per gestori eventi asincroni, è possibile che l'elaborazione di output non deve avere completato quando <xref:System.Diagnostics.Process.HasExited%2A> restituisce `true`. Per assicurarsi che gestione asincrona degli eventi è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro prima di archiviare <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 È possibile usare la <xref:System.Diagnostics.Process.CloseMainWindow%2A> o il <xref:System.Diagnostics.Process.Kill%2A> metodo a causa di un processo venga terminato.  
  
 Esistono due modi per visualizzare una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. La notifica sincrona si basa sulla chiamata di <xref:System.Diagnostics.Process.WaitForExit%2A> metodo sospendere l'elaborazione dell'applicazione fino a quando non viene chiuso il componente associato. Notifica asincrona si basa sul <xref:System.Diagnostics.Process.Exited> evento. Quando si utilizza la notifica asincrona <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve essere impostata su `true` per il <xref:System.Diagnostics.Process> componente per ricevere una notifica che il processo è terminato.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non è terminato.  
  
oppure 
Il processo <see cref="P:System.Diagnostics.Process.Handle" /> non è valido.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ExitCode" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine di un processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.Exited> evento indica che il processo associato è stato chiuso. Questo evento indica che il processo di terminazione (interrotto) o è stato chiuso. Questo evento può verificarsi solo se il valore della <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> è di proprietà `true`.  
  
 Esistono due modi per visualizzare una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. La notifica sincrona si intende chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per bloccare il thread corrente fino alla chiusura del processo. Notifica asincrona Usa le <xref:System.Diagnostics.Process.Exited> evento, che consente al thread chiamante di continuare l'esecuzione nel frattempo. Nel secondo caso <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve essere impostata su `true` per l'applicazione chiamante riceva l'evento di chiusura.  
  
 Quando il sistema operativo viene arrestato un processo, notifica a tutti gli altri processi che hanno registrato i gestori dell'evento di chiusura. A questo punto, l'handle del processo che semplicemente è stato chiuso può essere utilizzato per accedere a alcune proprietà, ad esempio <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.HasExited%2A> che il sistema operativo gestisce fino a quando non rilascia completamente tale handle.  
  
> [!NOTE]
>  Anche se si dispone di un handle a un processo è ancora terminato, non è possibile chiamare <xref:System.Diagnostics.Process.Start%2A> per ristabilire la connessione allo stesso processo. La chiamata <xref:System.Diagnostics.Process.Start%2A> automaticamente rilascia il processo associato e si connette a un processo con lo stesso file, ma un innovativo <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Per altre informazioni sull'uso del <xref:System.Diagnostics.Process.Exited> eventi nelle applicazioni Windows Forms, vedere il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente crea un processo che consente di stampare un file. Genera il <xref:System.Diagnostics.Process.Exited> eventi quando il processo viene terminato perché il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà è stata impostata durante il processo è stato creato. Il <xref:System.Diagnostics.Process.Exited> gestore dell'evento Visualizza le informazioni sul processo.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui il processo associato è stato terminato.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che indica il momento in cui il processo associato è stato terminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non è stato terminato il processo, il tentativo di recuperare il <xref:System.Diagnostics.Process.ExitTime%2A> proprietà genera un'eccezione. Uso <xref:System.Diagnostics.Process.HasExited%2A> prima di ottenere il <xref:System.Diagnostics.Process.ExitTime%2A> proprietà per determinare se è stato terminato il processo associato.  
  
   
  
## Examples  
 Esempio di codice seguente crea un processo che consente di stampare un file. Il processo genera il <xref:System.Diagnostics.Process.Exited> evento alla chiusura e il gestore eventi visualizza la <xref:System.Diagnostics.Process.ExitTime%2A> proprietà e altri elaborare le informazioni.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ExitTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un nuovo componente <see cref="T:System.Diagnostics.Process" /> e lo associa al processo attivo.</summary>
        <returns>Nuovo componente <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo che sta eseguendo l'applicazione chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> dell'istanza e lo si associa alla risorsa di processo nel computer locale.  
  
 Come l'analogo <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A> metodi <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associa una risorsa esistente a un nuovo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> e lo associa alla risorsa di processo esistente specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Identificatore univoco nel sistema di una risorsa di processo.</param>
        <summary>Restituisce un nuovo componente <see cref="T:System.Diagnostics.Process" />, dato l'identificatore di un processo nel computer locale.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> associato alla risorsa locale del processo identificata dal parametro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> componente e associarlo a una risorsa di processo nel computer locale. La risorsa di processo deve esistere già nel computer, in quanto <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> non crea una risorsa di sistema, ma piuttosto generati dall'applicazione associa una risorsa <xref:System.Diagnostics.Process> componente. Un processo <xref:System.Diagnostics.Process.Id%2A> può essere recuperato solo per un processo attualmente in esecuzione nel computer. Dopo che il processo viene terminato, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> genera un'eccezione se viene passato un identificatore scaduto.  
  
 Su un particolare computer, l'identificatore di un processo è univoco. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione di una determinata applicazione, usare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se nel computer che esegue l'applicazione specificata, sono presenti più processi <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> restituisce una matrice contenente tutti i processi associati. È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L'identificatore di processo può essere visualizzato nei `Processes` Pannello di Gestione attività Windows. Il `PID` colonna viene visualizzato l'identificatore di processo assegnato a un processo.  
  
 Il `processId` parametro è un <xref:System.Int32> (un intero 32 bit con segno), anche se l'API di Windows sottostante utilizza un `DWORD` (intero senza segno a 32 bit) per l'API simili. Questo avviene per motivi cronologici.
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo specificato dal parametro <paramref name="processId" /> non è in esecuzione. L'identificatore potrebbe essere scaduto.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato da questo oggetto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Identificatore univoco nel sistema di una risorsa di processo.</param>
        <param name="machineName">Nome di un computer della rete.</param>
        <summary>Restituisce un nuovo componente <see cref="T:System.Diagnostics.Process" />, dato un identificatore di processo e il nome di un computer sulla rete.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> associato a una risorsa di processo remota identificata dal parametro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> componente e associarlo a una risorsa di processo in un computer remoto sulla rete. La risorsa di processo deve esistere già nel computer specificato, in quanto <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> non crea una risorsa di sistema, ma piuttosto generati dall'applicazione associa una risorsa <xref:System.Diagnostics.Process> componente. Un processo <xref:System.Diagnostics.Process.Id%2A> può essere recuperato solo per un processo attualmente in esecuzione nel computer. Dopo che il processo viene terminato, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> genera un'eccezione se viene passato un identificatore scaduto.  
  
 Su un particolare computer, l'identificatore di un processo è univoco. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione di una determinata applicazione, usare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se nel computer che esegue l'applicazione specificata, sono presenti più processi <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> restituisce una matrice contenente tutti i processi associati. È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L'identificatore di processo può essere visualizzato nei `Processes` Pannello di Gestione attività Windows. Il `PID` colonna viene visualizzato l'identificatore di processo assegnato a un processo.  
  
 Se non si specifica un `machineName`, viene utilizzato il computer locale. In alternativa, è possibile specificare il computer locale tramite l'impostazione `machineName` sul valore "." o su una stringa vuota ("").  
  
 Il `processId` parametro è un <xref:System.Int32> (un intero 32 bit con segno), anche se l'API di Windows sottostante utilizza un `DWORD` (intero senza segno a 32 bit) per l'API simili. Questo avviene per motivi cronologici.   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo specificato dal parametro <paramref name="processId" /> non è in esecuzione. L'identificatore potrebbe essere scaduto.  
  
oppure 
La sintassi del parametro <paramref name="machineName" /> non è valida. Il nome potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato da questo oggetto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa alle risorse di processo esistenti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> per ciascuna risorsa di processo del computer locale.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta tutte le risorse di processo in esecuzione sul computer locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo nel computer locale. Le risorse di processo devono esistere già nel computer locale, in quanto <xref:System.Diagnostics.Process.GetProcesses%2A> non crea le risorse di sistema, ma piuttosto associa le risorse con generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Poiché il sistema operativo stesso è in esecuzione i processi in background, questa matrice non è mai vuota.  
  
 Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero usando il <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> (metodo). <xref:System.Diagnostics.Process.GetProcessById%2A> Crea un <xref:System.Diagnostics.Process> componente associato con il processo identificato nel sistema dall'identificatore di processo che viene passato al metodo. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crea una matrice di <xref:System.Diagnostics.Process> componenti la cui risorse di processo associato che condividono il file eseguibile passa al metodo.  
  
> [!NOTE]
>  Più servizi di Windows possono essere caricati nella stessa istanza del processo Host del servizio (svchost.exe). GetProcesses non identifica i singoli servizi; per tali informazioni, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Computer da cui leggere l'elenco di processi.</param>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> per ciascuna risorsa di processo nel computer specificato.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta tutte le risorse di processo in esecuzione sul computer specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo del computer (in genere remoto) specificato. Le risorse di processo devono esistere già nel computer locale, in quanto <xref:System.Diagnostics.Process.GetProcesses%2A> non crea le risorse di sistema, ma piuttosto associa le risorse con generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Poiché il sistema operativo stesso è in esecuzione i processi in background, questa matrice non è mai vuota.  
  
 Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero usando il <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> (metodo). <xref:System.Diagnostics.Process.GetProcessById%2A> Crea un <xref:System.Diagnostics.Process> componente associato con il processo identificato nel sistema dall'identificatore di processo che viene passato al metodo. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crea una matrice di <xref:System.Diagnostics.Process> componenti la cui risorse di processo associato che condividono il file eseguibile passa al metodo.  
  
 Questo overload del metodo di <xref:System.Diagnostics.Process.GetProcesses%2A> metodo viene in genere utilizzato per recuperare l'elenco delle risorse di processo in esecuzione in un computer remoto sulla rete, ma è possibile specificare il computer locale mediante il passaggio ".".  
  
> [!NOTE]
>  Più servizi di Windows possono essere caricati nella stessa istanza del processo Host del servizio (svchost.exe). GetProcesses non identifica i singoli servizi; per tali informazioni, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è valida. Potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma del sistema operativo non supporta questa operazione in computer remoti.</exception>
        <exception cref="T:System.InvalidOperationException">Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un problema durante l'accesso a un'API di sistema sottostante.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa alle risorse di processo esistenti che condividono il nome di processo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nome descrittivo del processo.</param>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa a tutte le risorse di processo nel computer locale che condividono il nome di processo specificato.</summary>
        <returns>Una matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta le risorse di processo che eseguono l'applicazione o il file specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer locale. Le risorse di processo devono esistere già nel computer, in quanto <xref:System.Diagnostics.Process.GetProcessesByName%2A> non crea le risorse di sistema, ma piuttosto li associa generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Oggetto `processName` possono essere specificati per un file eseguibile che non è attualmente in esecuzione nel computer locale, in modo che la matrice restituita dal metodo può essere vuota.  
  
 Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l'estensione .exe o il percorso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> è utile per ottenere e modificare tutti i processi associati con lo stesso file eseguibile. Ad esempio, è possibile passare un nome del file eseguibile come il `processName` parametro, per poter arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 Anche se un processo <xref:System.Diagnostics.Process.Id%2A> è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale possono essere in esecuzione l'applicazione specificata dal `processName` parametro. Pertanto <xref:System.Diagnostics.Process.GetProcessById%2A> restituisce al massimo un processo ma <xref:System.Diagnostics.Process.GetProcessesByName%2A> restituisce una matrice contenente tutti i processi associati. Se è necessario modificare il processo tramite chiamate API standard, è possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo il recupero di una matrice di <xref:System.Diagnostics.Process> componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nome descrittivo del processo.</param>
        <param name="machineName">Nome di un computer della rete.</param>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa a tutte le risorse di processo in un computer remoto che condividono il nome di processo specificato.</summary>
        <returns>Una matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta le risorse di processo che eseguono l'applicazione o il file specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer specificato. Le risorse di processo devono esistere già nel computer, in quanto <xref:System.Diagnostics.Process.GetProcessesByName%2A> non crea le risorse di sistema, ma piuttosto li associa generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Oggetto `processName` possono essere specificati per un file eseguibile che non è attualmente in esecuzione nel computer locale, in modo che la matrice restituita dal metodo può essere vuota.  
  
 Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l'estensione .exe o il percorso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> è utile per ottenere e modificare tutti i processi associati con lo stesso file eseguibile. Ad esempio, è possibile passare un nome del file eseguibile come il `processName` parametro, per poter arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 Anche se un processo <xref:System.Diagnostics.Process.Id%2A> è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale possono essere in esecuzione l'applicazione specificata dal `processName` parametro. Pertanto <xref:System.Diagnostics.Process.GetProcessById%2A> restituisce al massimo un processo ma <xref:System.Diagnostics.Process.GetProcessesByName%2A> restituisce una matrice contenente tutti i processi associati. Se è necessario modificare il processo tramite chiamate API standard, è possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo il recupero di una matrice di <xref:System.Diagnostics.Process> componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.  
  
 È possibile utilizzare questo overload per ottenere i processi nel computer locale, nonché in un computer remoto. Usare "." per specificare il computer locale. Esiste un altro overload che usa il computer locale per impostazione predefinita.  
  
 È possibile accedere a processi in remoto computer solo per visualizzare le informazioni sui processi, ad esempio le statistiche. È possibile chiudere, terminare (usando <xref:System.Diagnostics.Process.Kill%2A>), o avviare i processi nel computer remoto.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico nel computer locale. Viene quindi recuperato informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è valida. Potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma del sistema operativo non supporta questa operazione in computer remoti.</exception>
        <exception cref="T:System.InvalidOperationException">Il tentativo di connessione a <paramref name="machineName" /> non è riuscito.

oppure 
Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un problema durante l'accesso a un'API di sistema sottostante.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo del processo associato.</summary>
        <value>Handle che il sistema operativo ha assegnato al processo associato quando è stato avviato. Il sistema usa questo handle per tenere traccia degli attributi del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può ottenere un handle a un processo che può essere utilizzato come parametro per molte funzioni di controllo e informazioni sul processo. È possibile usare questo handle per inizializzare un <xref:System.Threading.WaitHandle> o per chiamare i metodi nativi con platform invoke.  
  
 Questo handle di processo è privato a un'applicazione, in altre parole, non è possibile condividere gli handle di processo. Un processo è anche disponibile un processo <xref:System.Diagnostics.Process.Id%2A> che, a differenza di <xref:System.Diagnostics.Process.Handle%2A>, sia univoco e, di conseguenza, valida in tutto il sistema.  
  
 Solo i processi avviati tramite una chiamata a <xref:System.Diagnostics.Process.Start%2A> impostare la <xref:System.Diagnostics.Process.Handle%2A> proprietà dell'oggetto corrispondente <xref:System.Diagnostics.Process> istanze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato o è terminato. Non è possibile leggere l'oggetto <see cref="P:System.Diagnostics.Process.Handle" /> perché a questa istanza di <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.  
  
oppure 
L'istanza di <see cref="T:System.Diagnostics.Process" /> è stata collegata a un processo in esecuzione ma non si hanno le autorizzazioni necessarie per ottenere un handle con diritti di accesso completi.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Handle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di handle aperti dal processo.</summary>
        <value>Numero di handle del sistema operativo aperti dal processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli handle forniscono un modo per un processo fare riferimento agli oggetti. Un processo può ottenere l'handle di file, risorse, le code di messaggi e molti altri oggetti di sistema operativo. Il sistema operativo recupera la memoria associata al processo solo quando il numero di handle è zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il processo associato è stato terminato.</summary>
        <value>
          <see langword="true" /> se il processo del sistema operativo cui fa riferimento il componente <see cref="T:System.Diagnostics.Process" /> è stato terminato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valore pari `true` per <xref:System.Diagnostics.Process.HasExited%2A> indica che il processo associato è stato terminato normalmente o in modo anomalo. È possibile richiedere o forzare il processo venga terminato chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Se un handle aperto per il processo, il sistema operativo rilascia la memoria del processo durante il processo è stato terminato, ma conserva le informazioni amministrative relative al processo, ad esempio l'handle, codice di uscita e fase di uscita. Per ottenere queste informazioni, è possibile usare la <xref:System.Diagnostics.Process.ExitCode%2A> e <xref:System.Diagnostics.Process.ExitTime%2A> proprietà. Queste proprietà vengono popolate automaticamente per i processi avviati da questo componente. Le informazioni amministrative viene rilasciate quando tutti i <xref:System.Diagnostics.Process> componenti associati con il processo di sistema vengono eliminati definitivamente e conservano gli handle non è più il processo terminato.  
  
 Indipendentemente dal codice possibile terminare un processo. Se è stato avviato il processo di utilizzo di questo componente, il sistema aggiorna il valore di <xref:System.Diagnostics.Process.HasExited%2A> automaticamente, anche se il processo associato viene terminato in modo indipendente.  
  
> [!NOTE]
>  Quando l'output standard è stato reindirizzato per gestori eventi asincroni, è possibile che l'elaborazione di output verrà non completati quando questa proprietà restituisce `true`. Per assicurarsi che gestione asincrona degli eventi è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro prima di archiviare <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Recupera quindi l'utilizzo della memoria fisica del processo associato a intervalli di 2 secondi per un massimo di 10 secondi. L'esempio rileva se il processo viene chiuso prima di 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun processo è associato all'oggetto.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare il codice di uscita del processo.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l’identificatore univoco per il processo associato.</summary>
        <value>Identificatore univoco generato dal sistema relativo al processo cui questa istanza di <see cref="T:System.Diagnostics.Process" /> fa riferimento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il processo <xref:System.Diagnostics.Process.Id%2A> non è valido se il processo associato non è in esecuzione. Pertanto, è necessario assicurarsi che il processo è in esecuzione prima di tentare di recuperare il <xref:System.Diagnostics.Process.Id%2A> proprietà. Finché non termina il processo, l'identificatore di processo identifica in modo univoco il processo in tutto il sistema.  
  
 È possibile connettersi a un processo è in esecuzione in un computer locale o remoto in una nuova <xref:System.Diagnostics.Process> istanza passando l'identificatore di processo per il <xref:System.Diagnostics.Process.GetProcessById%2A> (metodo). <xref:System.Diagnostics.Process.GetProcessById%2A> è un `static` metodo che crea un nuovo componente e imposta la <xref:System.Diagnostics.Process.Id%2A> proprietà del nuovo <xref:System.Diagnostics.Process> istanza automaticamente.  
  
 Gli identificatori di processo possono essere riutilizzati dal sistema. Il <xref:System.Diagnostics.Process.Id%2A> valore della proprietà è univoco solo mentre è in esecuzione il processo associato. Una volta terminato il processo, il sistema può riutilizzare la <xref:System.Diagnostics.Process.Id%2A> valore della proprietà per un processo non correlato.  
  
 Poiché l'identificatore è univoco nel sistema, è possibile passarlo agli altri thread come alternativa a passare un <xref:System.Diagnostics.Process> istanza. Questa azione può salvare le risorse di sistema ma garantisce che il processo venga identificato correttamente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere il <xref:System.Diagnostics.Process.Id%2A> per tutte le istanze di un'applicazione in esecuzione. Il codice crea una nuova istanza del blocco note, vengono elencate tutte le istanze del blocco note e quindi consente all'utente di immettere il <xref:System.Diagnostics.Process.Id%2A> numero per rimuovere un'istanza specifica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.Process.Id" /> del processo non è stata impostata.  
  
oppure 
A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta immediatamente il processo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Forza un'interruzione del processo, mentre <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo le richieste una terminazione. Quando è in esecuzione un processo con un'interfaccia grafica, il ciclo di messaggi è in uno stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata a <xref:System.Diagnostics.Process.CloseMainWindow%2A> invia una richiesta di chiusura della finestra principale, che, in un'applicazione ben formata, consente di chiudere le finestre figlio e revoca dei cicli di messaggi in esecuzione per l'applicazione. La richiesta di terminazione del processo chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> non forza la chiusura dell'applicazione. L'applicazione può richiedere per la verifica dell'utente prima di uscire può rifiutare la chiusura. Per forzare la chiusura dell'applicazione, usare il <xref:System.Diagnostics.Process.Kill%2A> (metodo). Il comportamento di <xref:System.Diagnostics.Process.CloseMainWindow%2A> è identico a quello di un utente la chiusura di finestra principale di un'applicazione usando il menu di sistema. Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone l'applicazione per uscire immediatamente.  
  
> [!NOTE]
>  Il <xref:System.Diagnostics.Process.Kill%2A> metodo viene eseguito in modo asincrono. Dopo la chiamata di <xref:System.Diagnostics.Process.Kill%2A> metodo, chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per attendere il processo di uscita o verificare il <xref:System.Diagnostics.Process.HasExited%2A> proprietà per determinare se il processo è terminato.  
  
 I dati modificati dal processo o le risorse allocate per il processo possono essere perse se si chiama <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoca una chiusura anomala di processo e deve essere usato solo quando necessario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Abilita una chiusura normale del processo e chiude tutte le finestre, è preferibile per le applicazioni con un'interfaccia. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> ha esito negativo, è possibile usare <xref:System.Diagnostics.Process.Kill%2A> per terminare il processo. <xref:System.Diagnostics.Process.Kill%2A> è l'unico modo per terminare i processi che non dispongono di interfacce grafiche.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo per i processi in esecuzione nel computer locale. È non deve generare i processi nei computer remoti per uscire. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti.  
  
> [!NOTE]
>  Se la chiamata per il <xref:System.Diagnostics.Process.Kill%2A> metodo viene eseguito durante il processo è in fase di chiusura, un <xref:System.ComponentModel.Win32Exception> generata per accesso negato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile terminare il processo associato.  
  
oppure 
Il processo verrà terminato.  
  
oppure 
Il processo associato è un eseguibile Win16.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.Kill" /> per un processo in esecuzione in un computer remoto. Il metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Processo già terminato.  
  
oppure 
A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fa uscire un componente <see cref="T:System.Diagnostics.Process" /> dallo stato che permette di interagire con i processi del sistema operativo eseguiti in modalità speciale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni processi di sistema operativo eseguito in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non sia stato chiamato <xref:System.Diagnostics.Process.EnterDebugMode%2A> sul componente. Chiamare <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando non è più necessario l'accesso a questi processi eseguiti in modalità speciale.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del computer sul quale è in esecuzione il processo associato.</summary>
        <value>Nome del computer sul quale è in esecuzione il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile visualizzare i dati statistici e le informazioni sui processi in esecuzione nel computer remoto, ma è possono chiamare <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, o <xref:System.Diagnostics.Process.Kill%2A> nei computer remoti.  
  
> [!NOTE]
>  Quando il processo associato è in esecuzione nel computer locale, questa proprietà restituisce un punto (".") per il nome del computer. È consigliabile usare il <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà da ottenere il nome del computer corretti.  
  
   
  
## Examples  
 Per usare l'esempio seguente è necessario innanzitutto avviare almeno un'istanza del blocco note in un computer remoto. L'esempio richiede il nome del computer remoto in cui è in esecuzione, il blocco note e quindi Visualizza la rispettiva <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, e <xref:System.Diagnostics.Process.MachineName%2A> proprietà per ogni istanza.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo principale del processo associato.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.ProcessModule" /> usato per avviare il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modulo di processo rappresenta file DLL o .exe che viene caricato in un processo specifico. Il <xref:System.Diagnostics.Process.MainModule%2A> proprietà consente di visualizzare informazioni sull'eseguibile usato per avviare il processo, inclusi il nome del modulo, nome file e informazioni sul modulo di memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainModule" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un processo a 32 bit sta provando ad accedere ai moduli di un processo a 64 bit.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
oppure 
Il processo è stato terminato.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle della finestra principale del processo associato.</summary>
        <value>Handle generato dal sistema della finestra principale del processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La finestra principale è la finestra aperta dal processo che ha attualmente lo stato attivo (il <xref:System.Windows.Forms.Form.TopLevel%2A> modulo). È necessario usare il <xref:System.Diagnostics.Process.Refresh%2A> per aggiornare il <xref:System.Diagnostics.Process> oggetto per cui ottenere l'handle della finestra principale corrente, se è stata modificata. In generale, poiché viene memorizzato nella cache l'handle di finestra, usare <xref:System.Diagnostics.Process.Refresh%2A> in anticipo per garantire che è possibile recuperare l'handle corrente.  
  
 È possibile ottenere il <xref:System.Diagnostics.Process.MainWindowHandle%2A> proprietà solo per i processi in esecuzione nel computer locale. Il <xref:System.Diagnostics.Process.MainWindowHandle%2A> proprietà è un valore che identifica in modo univoco la finestra che viene associata al processo.  
  
 Un processo ha una finestra principale associata solo se il processo ha un'interfaccia grafica. Se il processo associato non dispone di una finestra principale, il <xref:System.Diagnostics.Process.MainWindowHandle%2A> valore è uguale a zero. Anche il valore è zero per i processi che sono stati nascosti, vale a dire a processi non sono visibili nella barra degli strumenti. Ciò può verificarsi per i processi che vengono visualizzati come icone nell'area di notifica, all'estrema destra della barra delle applicazioni.  
  
 Se è stato appena avviato un processo e si vuole usare il relativo handle di finestra principale, è consigliabile usare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodo per consentire il processo completare l'avvio, assicurando che sia stato creato l'handle della finestra principale. In caso contrario, verrà generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> non è definito perché il processo è terminato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la didascalia della finestra principale del processo.</summary>
        <value>Titolo della finestra principale del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un processo ha una finestra principale associata solo se il processo ha un'interfaccia grafica. Se il processo associato non dispone di una finestra principale (in modo che <xref:System.Diagnostics.Process.MainWindowHandle%2A> è uguale a zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> è una stringa vuota (""). Se è stato appena avviato un processo e si desidera utilizzare il titolo della finestra principale, è consigliabile usare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodo per consentire il processo completare l'avvio, assicurando che sia stato creato l'handle della finestra principale. In caso contrario, il sistema genererà un'eccezione.  
  
> [!NOTE]
>  La finestra principale è la finestra che attualmente ha lo stato attivo; Si noti che questo potrebbe non essere la finestra principale per il processo. È necessario usare il <xref:System.Diagnostics.Process.Refresh%2A> per aggiornare il <xref:System.Diagnostics.Process> oggetto per cui ottenere l'handle della finestra principale corrente, se è stata modificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note e recupera la didascalia della finestra principale del processo.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> non è definita perché il processo è terminato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima del working set, in byte, consentita per il processo associato.</summary>
        <value>Dimensione massima del working set consentita in memoria per il processo, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dall'applicazione, incluse le pagine presenti nei file con estensione dll e file DLL di sistema. Working set dimensioni aumentano, aumenta la richiesta di memoria.  
  
 Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria pari alla dimensione minima del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai più le dimensioni massime.  
  
 Il sistema imposta il valore predefinito del working set. È possibile modificare tali dimensioni usando il <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membri. Tuttavia, l'impostazione di questi valori non garantisce che la memoria saranno riservato o residenti.  
  
> [!NOTE]
>  Quando si aumenta la dimensione del working set di un processo, si accettano quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del minimo o massimo working set è eccessiva, poiché possono peggiorare le prestazioni del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione minima del working set non è valida. Deve essere maggiore o uguale alla dimensione minima del working set.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sul working set dalla risorsa di processo associata.  
  
oppure 
L'identificatore di processo o l'handle di processo è zero perché il processo non è stato avviato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
oppure 
Il processo è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione minima del working set, in byte, consentita per il processo associato.</summary>
        <value>Dimensione minima del working set richiesta in memoria per il processo, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dall'applicazione, incluse le pagine presenti nei file con estensione dll e file DLL di sistema. Working set dimensioni aumentano, aumenta la richiesta di memoria.  
  
 Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria pari alla dimensione minima del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai più le dimensioni massime.  
  
 Il sistema imposta il valore predefinito del working set. È possibile modificare tali dimensioni usando il <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membri. Tuttavia, l'impostazione di questi valori non garantisce che la memoria saranno riservato o residenti.  
  
> [!NOTE]
>  Quando si aumenta la dimensione del working set di un processo, si accettano quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del minimo o massimo working set è eccessiva, poiché possono peggiorare le prestazioni del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione minima del working set non è valida. Deve essere minore di o uguale alla dimensione massima del working set.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sul working set dalla risorsa di processo associata.  
  
oppure 
L'identificatore di processo o l'handle di processo è zero perché il processo non è stato avviato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
oppure 
Il processo è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i moduli che sono stati caricati dal processo associato.</summary>
        <value>Matrice di tipo <see cref="T:System.Diagnostics.ProcessModule" /> che rappresenta i moduli caricati dal processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modulo di processo rappresenta file DLL o .exe che viene caricato in un processo specifico. Oggetto <xref:System.Diagnostics.ProcessModule> istanza consente di visualizzare informazioni su un modulo, inclusi il nome del modulo, nome file e informazioni sul modulo di memoria.  
  
 Un processo può caricare più moduli in memoria. Ad esempio, file .exe che caricano altri file DLL dispongono di più moduli.  
  
 Dopo aver avviato il processo, la raccolta è vuota finché il sistema ha caricato il processo. Se il processo dispone di una finestra principale, è possibile chiamare <xref:System.Diagnostics.Process.WaitForInputIdle%2A> prima di recuperare questa proprietà per assicurarsi che l'insieme è non vuoto quando si ottiene l'elenco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Modules" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Modules" /> per il processo di sistema o il processo inattivo. Questi processi non contengono moduli.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal sistema per il processo associato che non può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria di sistema, in byte, allocata per il processo associato che non può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema non di paging usata dal processo, in byte. È suddiviso tra i pool di paging e memoria di sistema è la memoria fisica utilizzata dal sistema operativo. Le allocazioni di memoria non di paging rimangono nella memoria di sistema e non vengono inviate al file di paging della memoria virtuale.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte del Pool non di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera l'evento <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> è il metodo API che genera il <xref:System.Diagnostics.Process.Exited> evento. La chiamata <xref:System.Diagnostics.Process.OnExited%2A> fa sì che il <xref:System.Diagnostics.Process.Exited> evento possa verificarsi ed è l'unico modo per generare l'evento utilizzando il <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> viene usata principalmente quando le classi derivate dal componente.  
  
 Come alternativa alla <xref:System.Diagnostics.Process.OnExited%2A>, è possibile scrivere il proprio gestore dell'evento. Creare il proprio delegato del gestore eventi e il proprio metodo di gestione degli eventi.  
  
> [!NOTE]
>  Se si usa l'ambiente di Visual Studio, un delegato del gestore eventi (AddOnExited) e un metodo di gestione degli eventi (Process1_Exited) vengono create automaticamente quando si trascina un <xref:System.Diagnostics.Process> componente in un form e fare doppio clic sull'icona. Il codice creato per l'esecuzione quando il <xref:System.Diagnostics.Process.Exited> viene immesso nella procedura Process1_Exited si verifica. Non è necessaria creare il <xref:System.Diagnostics.Process.OnExited%2A> membro, perché viene implementata automaticamente.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Process.OnExited%2A> metodo in una classe derivata.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione scrive nel proprio flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.OutputDataReceived> evento indica che l'oggetto associato <xref:System.Diagnostics.Process> ha scritto una riga, terminare con un carattere di nuova riga, nel proprio flusso <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 L'evento è abilitato durante operazioni di lettura asincrona sul <xref:System.Diagnostics.Process.StandardOutput%2A>. Per avviare operazioni di lettura asincrona, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso di un <xref:System.Diagnostics.Process>, aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.OutputDataReceived> evento, quindi chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Successivamente, il <xref:System.Diagnostics.Process.OutputDataReceived> segnali di evento ogni volta che il processo scrive una riga in reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> streaming, fino a quando il processo viene chiuso o chiama <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per assicurarsi che il buffer di output è stato scaricato.  
  
   
  
## Examples  
 L'esempio seguente illustra come eseguire operazioni di lettura asincrona sul reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso dei `ipconfig` comando.  
  
 Nell'esempio viene creato un delegato per il `OutputHandler` gestore dell'evento e la associa il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore eventi riceve le righe di testo da reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, formatta il testo e salvarlo in una stringa di output che viene visualizzata in un secondo momento nella finestra della console di esempio.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria nel file di paging della memoria virtuale usata dal processo, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio degli indirizzi virtuale per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni della memoria usata dal sistema operativo per il processo, usare il <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> proprietà.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **byte File di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione, il blocco note e quindi recupera e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal sistema per il processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria di sistema, in byte, allocata per il processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema paginabile usata dal processo, in byte. È suddiviso tra i pool di paging e memoria di sistema è la memoria fisica utilizzata dal sistema operativo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni della memoria dell'applicazione usata dal processo, usare il <xref:System.Diagnostics.Process.PagedMemorySize64%2A> proprietà.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **byte del Pool di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria, in byte, nel file di paging della memoria virtuale usata dal processo associato.</summary>
        <value>Quantità massima di memoria, in byte, allocata dal processo associato che potrebbe essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria, in byte, nel file di paging della memoria virtuale usata dal processo associato.</summary>
        <value>Quantità massima di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito dal valore di questa proprietà rappresenta la dimensione massima di memoria nel file di paging della memoria virtuale usata dal processo dall'avvio, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio degli indirizzi virtuale per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **picco di byte di pagine File** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria virtuale in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria virtuale, in byte, che il processo associato ha richiesto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria virtuale in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria virtuale, in byte, allocata per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione massima di memoria virtuale usata dal processo di avvio che, in byte. Il sistema operativo viene eseguito il mapping lo spazio degli indirizzi virtuale per ogni processo alle pagine caricate nella memoria fisica, o alle pagine archiviate nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **picco di byte virtuali** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni di picco del working set per il processo associato in byte.</summary>
        <value>Quantità massima di memoria fisica che il processo associato ha richiesto in una sola volta in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria fisica in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria fisica, in byte, allocata per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione massima di utilizzo di set di memoria usata dal processo dall'avvio, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, incluse le istruzioni da moduli di processo e le librerie di sistema.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **max Working Set** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la priorità del processo associato deve essere incrementata temporaneamente dal sistema operativo quando la finestra principale è attiva.</summary>
        <value>
          <see langword="true" /> se va eseguito l'incremento dinamico della priorità del processo uscito dallo stato di attesa; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un thread viene eseguito in un processo per cui la classe di priorità è uno dei valori di enumerazione dynamic priorità (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), il sistema aumenta temporaneamente la priorità del thread quando si esce da uno stato di attesa. Questa azione impedisce ad altri processi di interrompere l'elaborazione del thread corrente. Il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> impostazione influisce su tutti i thread esistenti e tutti i thread creati successivamente dal processo. Per ripristinare il comportamento normale, impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> proprietà `false`.  
  
> [!NOTE]
>  Aumento eccessivo della priorità può sottrarre risorse essenziali del sistema operativo e le funzioni di rete, causando problemi con le altre attività del sistema operativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sull'aumento della priorità dalla risorsa di processo associata.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.  
  
oppure 
L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la categoria di priorità globale per il processo associato.</summary>
        <value>Categoria di priorità del processo associato, dalla quale viene calcolata la proprietà <see cref="P:System.Diagnostics.Process.BasePriority" /> del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe di priorità del processo include una gamma di livelli di priorità di thread. Thread con priorità diverse che sono in esecuzione nel processo di esecuzione rispetto alla classe di priorità del processo. Win32 Usa quattro classi di priorità con sette livelli di priorità di base per ogni classe. Queste classi di priorità del processo vengono acquisite nel <xref:System.Diagnostics.ProcessPriorityClass> enumerazione, che consente di imposta la priorità del processo <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. In base al tempo trascorso o altri degli incrementi, il livello di priorità di base possono essere modificati dal sistema operativo quando è necessario attivare prima degli altri per l'accesso al processore di un processo. Inoltre, è possibile impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> per aumentare temporaneamente il livello di priorità di thread che sono state intraprese dallo stato di attesa. La priorità viene reimpostata quando il processo restituisce lo stato di attesa.  
  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà consente di visualizzare la priorità iniziale che viene assegnata a un processo. Tuttavia, poiché si tratta di sola lettura, è possibile usare il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà per impostare la priorità di un processo. Per modificare la priorità, usare il <xref:System.Diagnostics.Process.PriorityClass%2A> proprietà, che ottiene o imposta la categoria di priorità globale per il processo.  
  
 La classe di priorità non è possibile visualizzare tramite Monitor di sistema. La tabella seguente illustra la relazione tra il <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> valori.  
  
|BasePriority|Classe di priorità|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile impostare o recuperare le informazioni sulla priorità del processo dalla risorsa di processo associata.  
  
oppure 
L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> è stata impostata su <see langword="AboveNormal" /> o <see langword="BelowNormal" /> quando si usa Windows 98 o Windows Millennium Edition (Windows Me). Queste piattaforme non supportano tali valori per la classe di priorità.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La classe di priorità non può essere impostata perché non usa un valore valido, come definito nell'enumerazione <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria privata, in byte, allocata per il processo associato.</summary>
        <value>Numero di byte allocati dal processo associato che non possono essere condivisi con altri processi.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria privata, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata per il processo associato che non può essere condivisa con altri processi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria usata dal processo, in byte, che non possono essere condivisi con altri processi.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **byte privati** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo privilegiato del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processore nell'eseguire il codice all'interno del nucleo centrale del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del processo.</summary>
        <value>Nome usato dal sistema per identificare il processo rispetto all'utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.ProcessName%2A> proprietà contiene un nome del file eseguibile, ad esempio Outlook, che non include l'estensione .exe o il percorso. È utile per ottenere e modificare tutti i processi associati con lo stesso file eseguibile.  
  
> [!NOTE]
>  Sul [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemi operativi, il <xref:System.Diagnostics.Process.ProcessName%2A> proprietà può essere troncata e 15 caratteri se non è possibile ottenere le informazioni sul modulo di processo.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando un nome di file eseguibile, per recuperare una matrice che contiene ogni istanza in esecuzione nel computer specificato. È possibile usare questa matrice, ad esempio, per arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un identificatore oppure nessun processo è associato a <see cref="T:System.Diagnostics.Process" />.  
  
oppure 
Il processo associato è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Il processo non si trova in questo computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i processori nei quali è pianificata l'esecuzione dei thread di questo processo.</summary>
        <value>Maschera di bit che rappresenta i processori con cui è possibile eseguire i thread del processo associato. Il valore predefinito dipende dal numero di processori presenti nel computer. Il valore predefinito è 2 <sup>n</sup> -1, dove n è il numero di processori.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 e versioni successive, un thread in un processo può eseguire la migrazione da un processore, riempiendo la cache del processore a ogni migrazione. Con carichi di lavoro di sistema eccessivi, specificando il processore che deve essere eseguito un thread specifico può migliorare le prestazioni riducendo il numero di volte in cui che la cache del processore viene ricaricata. L'associazione tra un processore e un thread viene chiamato l'affinità processori.  
  
 Ogni processore viene rappresentato sotto forma di bit. Bit 0 è il processore uno, bit 1 è il processore due e così via. Se si imposta un bit sul valore 1, il processore corrispondente viene selezionato per l'assegnazione di thread. Quando si imposta la <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valore su zero, il sistema operativo pianificazione del set di algoritmi affinità del thread. Quando il <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valore è impostato su qualsiasi valore diverso da zero, il valore viene interpretato come maschera di bit che specifica i processori sono selezionabili.  
  
 Nella tabella seguente mostra una selezione di <xref:System.Diagnostics.Process.ProcessorAffinity%2A> i valori per un sistema con otto processori.  
  
|Maschera di bit|Valore binario|Processori idonei|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 e 2|  
|0x0007|00000000 00000111|1, 2 e 3|  
|0x0009|00000000 00001001|1 e 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 e 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile impostare o recuperare le informazioni di <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> dalla risorsa del processo associato.  
  
oppure 
L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
oppure 
Il processo è stato terminato.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina le informazioni relative al processo associato memorizzate nella cache all'interno del componente del processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver <xref:System.Diagnostics.Process.Refresh%2A> viene chiamato, la prima richiesta per informazioni su ogni proprietà fa sì che il componente di elaborazione ottenere un nuovo valore dal processo associato.  
  
 Quando un <xref:System.Diagnostics.Process> è associato a una risorsa di processo, i valori delle proprietà del componente di <xref:System.Diagnostics.Process> immediatamente vengono popolati in base allo stato del processo associato. Se le informazioni relative al processo associato viene successivamente modificato, tali modifiche non vengono riflesse nel <xref:System.Diagnostics.Process> valori memorizzati nella cache del componente. Il <xref:System.Diagnostics.Process> componente è uno snapshot della risorsa di processo al momento sono associate. Per visualizzare i valori correnti per il processo associato, chiamare il <xref:System.Diagnostics.Process.Refresh%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Recupera quindi l'utilizzo della memoria fisica del processo associato a intervalli di 2 secondi per un massimo di 10 secondi. L'esempio rileva se il processo viene chiuso prima di 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'interfaccia utente del processo sta rispondendo.</summary>
        <value>
          <see langword="true" /> se l'interfaccia utente del processo associato sta rispondendo al sistema; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un processo con un'interfaccia utente, il <xref:System.Diagnostics.Process.Responding%2A> proprietà contatta l'interfaccia utente per determinare se il processo risponde all'input dell'utente. Se l'interfaccia non risponde immediatamente, il <xref:System.Diagnostics.Process.Responding%2A> restituisce proprietà `false`. Utilizzare questa proprietà per determinare se l'interfaccia del processo associato ha smesso di rispondere.  
  
 Se il processo non ha un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, questa proprietà restituisce `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Responding" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo di questo processo.</summary>
        <value>Handle nativo di questo processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'handle è disponibile solo se il componente chiamante ha avviato il processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore della sessione di Servizi terminal per il processo associato.</summary>
        <value>Identificatore della sessione di Servizi terminal per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.SessionId%2A> proprietà identifica la sessione in cui è attualmente in esecuzione l'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">A questo processo non è associata alcuna sessione.</exception>
        <exception cref="T:System.InvalidOperationException">A questo identificatore di sessione non è associato alcun processo.  
  
oppure 
Il processo associato non si trova in questo computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La proprietà <see cref="P:System.Diagnostics.Process.SessionId" /> non è supportata in Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per leggere l'output di errore dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamReader" /> che può essere usato per leggere il flusso di errore standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel relativo flusso errore standard, che sia in genere visualizzato nella console. Mediante il reindirizzamento di <xref:System.Diagnostics.Process.StandardError%2A> flusso, è possibile modificare o eliminare l'output di errore di un processo. Ad esempio, è possibile filtrare il testo, formattarla in modo diverso o scrivere l'output in un file di registro designato sia la console.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardError%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> al `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> a `true`. In caso contrario, la lettura dal <xref:System.Diagnostics.Process.StandardError%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output di errori del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardError%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e torna immediatamente al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona la <xref:System.Diagnostics.Process.StandardError%2A> flusso e il processo figlio la scrittura in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso di reindirizzamento di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzata, dipende dal padre. Il processo figlio resta in attesa durante la successiva operazione di scrittura fino a quando l'elemento padre legge dal flusso completo o chiude il flusso. La condizione di deadlock quando il chiamante e il processo figlio di attesa tra loro per completare un'operazione e non può continuare. È possibile evitare i deadlock valutando le dipendenze tra il chiamante e il processo figlio.  
  
 Il codice c# seguente, ad esempio, Mostra come leggere da un flusso reindirizzato e attendere il chiusura del processo figlio.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardError.ReadToEnd` prima di `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima di `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire reindirizzato. Il processo padre verrebbe attendere in modo indefinito la terminazione del processo figlio. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 Si verifica un problema simile quando si legge tutto il testo da flussi di errore e output standard. Il codice c# seguente, ad esempio, esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura su di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una condizione di deadlock dei risultati, se il processo padre chiama `p.StandardOutput.ReadToEnd` seguita da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire il flusso di errore. Il processo padre viene attesa indefinita per il chiusura del processo figlio relativa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile usare operazioni di lettura asincrona per evitare queste dipendenze e i deadlock potenziale. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggere l'output di ogni flusso in un thread separato.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura sincrone e asincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> nel <xref:System.Diagnostics.Process.StandardError%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modi diversi. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 L'esempio seguente usa il `net use` comando insieme a un utente ha fornito l'argomento per eseguire il mapping di una risorsa di rete. Quindi legge il flusso di errore standard del comando net e lo scrive nella console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> non è stato definito per il reindirizzamento; assicurarsi che <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> sia impostato su <see langword="true" /> e che <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sia impostato su <see langword="false" />.  
  
\- oppure - 
Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> è stato aperto per operazioni di lettura asincrona con <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per scrivere l'input dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamWriter" /> che può essere usato per scrivere il flusso di input standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.Process> può leggere il testo di input dal rispettivo flusso di input standard, in genere la tastiera. Mediante il reindirizzamento di <xref:System.Diagnostics.Process.StandardInput%2A> flusso, è possibile specificare a livello di codice l'input. Invece di usare gli input da tastiera, ad esempio, è possibile fornire il testo dal contenuto di un file specificato o l'output da un'altra applicazione.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardInput%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> al `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> a `true`. In caso contrario, la scrittura di <xref:System.Diagnostics.Process.StandardInput%2A> stream genera un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente illustra come reindirizzare il <xref:System.Diagnostics.Process.StandardInput%2A> flusso di un processo. Nell'esempio viene avviato il `sort` con input reindirizzato. Quindi chiede all'utente per il testo e lo passa al `sort` processo mediante il flusso <xref:System.Diagnostics.Process.StandardInput%2A> flusso. Il `sort` i risultati vengono visualizzati all'utente della console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardInput" /> non è stato definito perché la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> è impostata su <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per leggere l'output dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamReader" /> che può essere usato per leggere il flusso di output standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel relativo flusso standard, che sia in genere visualizzato nella console. Mediante il reindirizzamento di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, è possibile modificare o eliminare l'output di un processo. Ad esempio, è possibile filtrare il testo, formattarla in modo diverso o scrivere l'output in un file di registro designato sia la console.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardOutput%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> al `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> a `true`. In caso contrario, la lettura dal <xref:System.Diagnostics.Process.StandardOutput%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e torna immediatamente al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona la <xref:System.Diagnostics.Process.StandardOutput%2A> flusso e il processo figlio la scrittura in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso di reindirizzamento di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzata, dipende dal padre. Il processo figlio resta in attesa durante la successiva operazione di scrittura fino a quando l'elemento padre legge dal flusso completo o chiude il flusso. La condizione di deadlock quando il chiamante e il processo figlio di attesa tra loro per completare un'operazione e non può continuare. È possibile evitare i deadlock valutando le dipendenze tra il chiamante e il processo figlio.  
  
 Il codice c# seguente, ad esempio, Mostra come leggere da un flusso reindirizzato e attendere il chiusura del processo figlio.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardOutput.ReadToEnd` prima di `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima di `p.StandardOutput.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire reindirizzato. Il processo padre verrebbe attendere in modo indefinito la terminazione del processo figlio. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 Si verifica un problema simile quando si legge tutto il testo da flussi di errore e output standard. Il codice c# seguente, ad esempio, esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura su di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una condizione di deadlock dei risultati, se il processo padre chiama `p.StandardOutput.ReadToEnd` seguita da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire il flusso di errore. Il processo padre viene attesa indefinita per il chiusura del processo figlio relativa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile usare operazioni di lettura asincrona per evitare queste dipendenze e i deadlock potenziale. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggere l'output di ogni flusso in un thread separato.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura sincrone e asincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità asincrona o sincrona, tutte le successive lettura operazioni su tale flusso devono essere la stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modi diversi. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguito il comando ipconfig.exe e reindirizza l'output standard alla finestra della console di esempio.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> non è stato definito per il reindirizzamento; assicurarsi che <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> sia impostato su <see langword="true" /> e che <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sia impostato su <see langword="false" />.  
  
\- oppure - 
Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> è stato aperto per operazioni di lettura asincrona con <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia una risorsa di processo e la associa a un componente <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia (o riutilizza) la risorsa di processo specificata dalla proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> di questo componente <see cref="T:System.Diagnostics.Process" /> e la associa al componente.</summary>
        <returns>
          <see langword="true" /> se viene avviata una risorsa di processo, <see langword="false" /> se non viene avviata alcuna risorsa di processo nuova (ad esempio, se è stato riutilizzato un processo esistente).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo e associarlo a corrente <xref:System.Diagnostics.Process> componente. Il valore restituito `true` indica che è stata avviata una nuova risorsa di processo. Se la risorsa di processo specificato dal <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà è già in esecuzione nel computer, viene avviata alcuna risorsa di elaborazione aggiuntivi. Al contrario, il processo in esecuzione risorse viene riutilizzato e `false` viene restituito.  
  
 È possibile avviare un'applicazione ClickOnce, specificando la posizione da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce, specificando il percorso di installazione sul disco rigido.  
  
> [!NOTE]
>  Se si usa Visual Studio, questo overload del metodo di <xref:System.Diagnostics.Process.Start%2A> metodo è quello che viene inserito il codice dopo avere trascinato un <xref:System.Diagnostics.Process> componente nella finestra di progettazione. Usare la `Properties` finestra per espandere il `StartInfo` categoria e scrivere il valore appropriato nel `FileName` proprietà. Le modifiche verranno visualizzate nella finestra del form `InitializeComponent` procedure.  
  
 Questo overload del metodo <xref:System.Diagnostics.Process.Start%2A> non è un `static` (metodo). È necessario chiamarlo da un'istanza di <xref:System.Diagnostics.Process> classe. Prima di chiamare <xref:System.Diagnostics.Process.Start%2A>, è necessario innanzitutto specificare <xref:System.Diagnostics.Process.StartInfo%2A> informazioni sulle proprietà di questo <xref:System.Diagnostics.Process> istanza, perché tale informazione viene utilizzata per determinare la risorsa di processo da avviare.  
  
 Gli altri overload del <xref:System.Diagnostics.Process.Start%2A> metodo sono `static` membri. Non è necessaria creare un'istanza di <xref:System.Diagnostics.Process> componente prima di chiamare l'overload del metodo. In alternativa, è possibile chiamare <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> classe stesso e un nuovo <xref:System.Diagnostics.Process> se è stato avviato il processo di creazione del componente. In alternativa, `null` viene restituito se è stato riutilizzato un processo. La risorsa di processo viene associata automaticamente la nuova <xref:System.Diagnostics.Process> restituito dal componente di <xref:System.Diagnostics.Process.Start%2A> (metodo).  
  
 Il <xref:System.Diagnostics.Process.StartInfo%2A> membri possono essere utilizzati per riprodurre la funzionalità del `Run` finestra di dialogo di Windows `Start` menu. Tutto ciò che possono essere digitati nella riga di comando può essere avviata impostando i valori appropriati nel <xref:System.Diagnostics.Process.StartInfo%2A> proprietà. Gli unici <xref:System.Diagnostics.Process.StartInfo%2A> è di proprietà che deve essere impostata la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non deve essere un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione che viene installata nel sistema. Ad esempio, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà può avere un'estensione di file con estensione txt se si sono associati file di testo con un editor, ad esempio Blocco note, o se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word può avere un'estensione di file con estensione doc.  
  
 Nella riga di comando, è possibile specificare le azioni da intraprendere per determinati tipi di file. Ad esempio, è possibile stampare documenti o modificare i file di testo. Specificare queste azioni usando il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> membro del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà. Per altri tipi di file, è possibile specificare argomenti della riga di comando quando si avvia il file dal `Run` nella finestra di dialogo. Ad esempio, è possibile passare un URL come argomento, se si specifica il browser come il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Questi argomenti possono essere specificati nel <xref:System.Diagnostics.Process.StartInfo%2A> della proprietà <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membro.  
  
 Se si dispone di una variabile di percorso dichiarata nel sistema di uso delle virgolette, è necessario qualificare completamente tale percorso durante l'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e aggiungerlo utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` quando il riavvio.  
  
> [!NOTE]
>  Codice di controllo pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si usa il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o controllo server, il nuovo processo viene eseguito nel server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto del browser client e non ha accesso al desktop dell'utente.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment in thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true` nel componente di elaborazione <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` (metodo). In caso contrario, un thread gestito può essere un `unknown` sullo stato o inserire nel `MTA` lo stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non viene esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 L'esempio seguente usa un'istanza di <xref:System.Diagnostics.Process> classe avvii un processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è stato specificato alcun nome file nella proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> del componente <see cref="T:System.Diagnostics.Process" />.
-oppure- Il membro <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> della proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> è <see langword="true" /> mentre <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato nei sistemi operativi senza supporto della shell, ad esempio Nano Server (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Oggetto <see cref="T:System.Diagnostics.ProcessStartInfo" /> che contiene le informazioni usate per avviare il processo, tra cui il nome file e gli eventuali argomenti della riga di comando.</param>
        <summary>Avvia la risorsa di processo specificata dal parametro contenente le informazioni di avvio del processo (ad esempio, il nome file del processo da avviare) e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando un <xref:System.Diagnostics.ProcessStartInfo> istanza. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non viene avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza dover prima creare un nuovo <xref:System.Diagnostics.Process> istanza. Utilizza questo overload con un <xref:System.Diagnostics.ProcessStartInfo> parametro è un'alternativa ai passaggi di creazione di un nuovo espliciti <xref:System.Diagnostics.Process> istanza, l'impostazione relativa <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e chiamare il metodo <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Usando un <xref:System.Diagnostics.ProcessStartInfo> di istanze come il parametro consente di chiamare <xref:System.Diagnostics.Process.Start%2A> con il massimo controllo su ciò che viene passato nella chiamata per avviare il processo. Se è necessario passare solo un nome file o un nome di file e gli argomenti, non è necessario creare un nuovo <xref:System.Diagnostics.ProcessStartInfo> dell'istanza, anche se è delle opzioni. Gli unici <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> è di proprietà che deve essere impostata la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non è necessario rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione che viene installata nel sistema. Ad esempio, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà può avere un'estensione di file con estensione txt se si sono associati file di testo con un editor, ad esempio Blocco note, o se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word può avere un'estensione di file con estensione doc.  
  
 È possibile avviare un'applicazione ClickOnce, specificando la posizione da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce, specificando il percorso di installazione sul disco rigido.  
  
 Se il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> proprietà delle <xref:System.Diagnostics.Process.StartInfo%2A> istanza sono impostate, non gestito `CreateProcessWithLogonW` funzione viene chiamata, che avvia il processo di una nuova finestra, anche se la <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> valore della proprietà è `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> valore della proprietà è <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Se il <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> proprietà è `null`, il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> proprietà deve essere in formato UPN *utente*@*DNS_domain_name*.   
  
 A differenza di altri overload, eseguire l'overload del <xref:System.Diagnostics.Process.Start%2A> senza parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> dell'istanza, le informazioni di avvio specificato (incluso il nome del file) e si vuole avviare una risorsa di processo e associarlo a esistenti <xref:System.Diagnostics.Process> istanza. Usare uno dei `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consentono di specificare le informazioni di inizio per la risorsa di processo usando un <xref:System.Diagnostics.ProcessStartInfo> istanza.  
  
 Se si dispone di una variabile di percorso dichiarata nel sistema di uso delle virgolette, è necessario qualificare completamente tale percorso durante l'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e aggiungerlo utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` quando il riavvio.  
  
> [!NOTE]
>  Codice di controllo pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si usa il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o controllo server, il nuovo processo viene eseguito nel server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto del browser client e non ha accesso al desktop dell'utente.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment in thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true` nel `startInfo` parametro, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` (metodo). In caso contrario, un thread gestito può essere un `unknown` sullo stato o inserire nel `MTA` lo stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non viene esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Innanzitutto, nell'esempio seguente genera un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine o siti specifici. Infine viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 Per ulteriori esempi di altri utilizzi di questo metodo, vedere le singole proprietà del <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è stato specificato alcun nome file nella proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parametro <paramref name="startInfo" />.  
  
oppure 
La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parametro <paramref name="startInfo" /> è <see langword="true" /> e anche la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="true" />.  
  
oppure 
La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parametro <paramref name="startInfo" /> è <see langword="true" /> e la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> non è <see langword="null" /> o vuota oppure la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="startInfo" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato nella proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parametro <paramref name="startInfo" /> non è stato trovato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
oppure 
La somma della lunghezza degli argomenti e della lunghezza del percorso completo del processo supera i 2080 caratteri. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato nei sistemi operativi senza supporto della shell, ad esempio Nano Server (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un documento o di un file di applicazione da eseguire nel processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un documento o un file di applicazione e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando il nome del file. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non viene avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza dover prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload è un'alternativa ai passaggi espliciti di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 È possibile avviare un'applicazione ClickOnce mediante l'impostazione di `fileName` parametro nel percorso (ad esempio, un indirizzo Web) da cui è stato installato l'applicazione. Avviare un'applicazione ClickOnce, specificando il percorso di installazione sul disco rigido.  
  
 Avvio di un processo specificandone il nome file è simile a digitare le informazioni contenute nel `Run` finestra di dialogo di Windows `Start` menu. Pertanto, il nome del file non necessari rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il nome del file può avere un'estensione di file con estensione txt se si sono associati file di testo con un editor, ad esempio Blocco note, oppure se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word può avere un file con estensione doc. Allo stesso modo, nello stesso modo in cui il `Run` finestra di dialogo può accettare un nome del file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad".  
  
 Questo overload non consente argomenti della riga di comando per il processo. Se è necessario specificare uno o più argomenti della riga di comando per il processo, usare il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> o <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overload.  
  
 A differenza di altri overload, eseguire l'overload del <xref:System.Diagnostics.Process.Start%2A> senza parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> dell'istanza, le informazioni di avvio specificato (incluso il nome del file) e si vuole avviare una risorsa di processo e associarlo a esistenti <xref:System.Diagnostics.Process> istanza. Usare uno dei `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consentono di specificare il nome del file della risorsa di processo da avviare.  
  
 Se si dispone di una variabile di percorso dichiarata nel sistema di uso delle virgolette, è necessario qualificare completamente tale percorso durante l'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e aggiungerlo utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` quando il riavvio.  
  
> [!NOTE]
>  Codice di controllo pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si usa il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o controllo server, il nuovo processo viene eseguito nel server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto del browser client e non ha accesso al desktop dell'utente.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment in thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true` nel componente di elaborazione <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` (metodo). In caso contrario, un thread gestito può essere un `unknown` sullo stato o inserire nel `MTA` lo stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non viene esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Innanzitutto, nell'esempio seguente genera un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine o siti specifici. Infine viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variabile di ambiente PATH include una stringa che contiene virgolette.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="arguments">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione e un insieme di argomenti della riga di comando e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando il nome del file e gli argomenti della riga di comando. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non viene avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza dover prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload è un'alternativa ai passaggi di creazione di un nuovo espliciti <xref:System.Diagnostics.Process> istanza, l'impostazione il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> i membri del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Avvio di un processo specificando il nome del file e gli argomenti è simile a digitare il nome file e gli argomenti della riga di comando in di `Run` finestra di dialogo di Windows `Start` menu. Pertanto, il nome del file non necessari rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il nome del file può avere un'estensione di file con estensione txt se si sono associati file di testo con un editor, ad esempio Blocco note, oppure se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word può avere un file con estensione doc. Allo stesso modo, nello stesso modo in cui il `Run` finestra di dialogo può accettare un nome del file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, il `arguments` parametro potrebbe rappresentare un file su cui intervenire, ad esempio file di testo in `Notepad.exe myfile.txt`. Se il `fileName` parametro rappresenta un file di comando (cmd), il `arguments` parametro deve includere un "`/c`"o"`/k`" argomento per specificare se la finestra di comando viene chiusa o rimane dopo il completamento.  
  
 A differenza di altri overload, eseguire l'overload del <xref:System.Diagnostics.Process.Start%2A> senza parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> dell'istanza, le informazioni di avvio specificato (incluso il nome del file) e si vuole avviare una risorsa di processo e associarlo a esistenti <xref:System.Diagnostics.Process> istanza. Usare uno dei `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consentono di specificare il nome del file della risorsa di processo per avviare e gli argomenti della riga di comando da passare.  
  
 Se si dispone di una variabile di percorso dichiarata nel sistema di uso delle virgolette, è necessario qualificare completamente tale percorso durante l'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e aggiungerlo utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` quando il riavvio.  
  
> [!NOTE]
>  Codice di controllo pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si usa il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o controllo server, il nuovo processo viene eseguito nel server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto del browser client e non ha accesso al desktop dell'utente.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
 Questo caso, è necessaria una nota sugli stati di apartment in thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true` nel componente di elaborazione <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` (metodo). In caso contrario, un thread gestito può essere un `unknown` sullo stato o inserire nel `MTA` lo stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non viene esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Innanzitutto, nell'esempio seguente genera un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine o siti specifici. Infine viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="fileName" /> o il parametro <paramref name="arguments" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
oppure 
La somma della lunghezza degli argomenti e della lunghezza del percorso completo del processo supera i 2080 caratteri. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variabile di ambiente PATH include una stringa che contiene virgolette.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="userName">Nome utente da usare all'avvio del processo.</param>
        <param name="password">Classe <see cref="T:System.Security.SecureString" /> contenente la password da usare all'avvio del processo.</param>
        <param name="domain">Dominio da usare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione, un nome utente, una password e un dominio e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).  
  
> [!NOTE]
>  Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete utilizzando un identificatore di risorsa uniforme (URI), non una lettera di unità collegate.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non viene avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza dover prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload è un'alternativa ai passaggi di creazione di un nuovo espliciti <xref:System.Diagnostics.Process> istanza, l'impostazione il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Allo stesso modo, nello stesso modo in cui il **eseguiti** nella finestra di dialogo può accettare un nome del file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, il `arguments` parametro potrebbe rappresentare un file su cui intervenire, ad esempio file di testo in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A> gli overload che hanno `userName`, `password`, e `domain` parametri.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare questo overload per avviare un file eseguibile e viene inoltre la generazione di un <xref:System.ComponentModel.Win32Exception> quando viene effettuato un tentativo di avviare un'applicazione associata a un file eseguibile.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun nome file specificato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato in Linux o macOS (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="arguments">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <param name="userName">Nome utente da usare all'avvio del processo.</param>
        <param name="password">Classe <see cref="T:System.Security.SecureString" /> contenente la password da usare all'avvio del processo.</param>
        <param name="domain">Dominio da usare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione e un insieme di argomenti della riga di comando, un nome utente, una password e un dominio, e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, gli argomenti della riga di comando, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).  
  
> [!NOTE]
>  Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete utilizzando un identificatore di risorsa uniforme (URI), non una lettera di unità collegate.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non viene avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza dover prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload è un'alternativa ai passaggi di creazione di un nuovo espliciti <xref:System.Diagnostics.Process> istanza, l'impostazione il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Allo stesso modo, nello stesso modo in cui il **eseguiti** nella finestra di dialogo può accettare un nome del file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, il `arguments` parametro potrebbe rappresentare un file su cui intervenire, ad esempio file di testo in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A> gli overload che hanno `userName`, `password`, e `domain` parametri.  
  
 Ogni volta che utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudi processi che utilizzano <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile controllare se un processo è già stato chiuso con relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun nome file specificato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
oppure 
La somma della lunghezza degli argomenti e della lunghezza del percorso completo al file associato supera 2080. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato in Linux o macOS (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le proprietà da passare al metodo <see cref="M:System.Diagnostics.Process.Start" /> del componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.ProcessStartInfo" /> che rappresenta i dati con i quali avviare il processo. Tra gli argomenti sono compresi il nome del file eseguibile o il documento usato per avviare il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> rappresenta il set di parametri da usare per avviare un processo. Quando <xref:System.Diagnostics.Process.Start%2A> viene chiamato, il <xref:System.Diagnostics.Process.StartInfo%2A> viene usato per specificare il processo di avvio. Il solo caso di necessità <xref:System.Diagnostics.Process.StartInfo%2A> membro da impostare è il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Avvio di un processo specificando il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà è simile a digitare le informazioni contenute nel **eseguire** finestra di dialogo di Windows **avviare** menu. Pertanto, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non è necessario rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> possono avere estensione txt se si sono associati file di testo con un editor, ad esempio Blocco note, oppure se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word può avere un file con estensione doc. Allo stesso modo, nello stesso modo in cui il **eseguiti** nella finestra di dialogo può accettare un nome del file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà su "Notepad.exe" o "Notepad".  
  
 È possibile avviare un'applicazione ClickOnce mediante l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà nel percorso (ad esempio, un indirizzo Web) da cui è stato installato l'applicazione. Avviare un'applicazione ClickOnce, specificando il percorso di installazione sul disco rigido.  
  
 Se il nome del file implica un file eseguibile, ad esempio un file con estensione doc, è possibile includere un verbo che specifica l'azione da eseguire sul file. Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> a "Print" per un file che terminano con l'estensione di file con estensione doc. Il nome del file specificato nella <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non è necessario avere un'estensione, se si immette manualmente un valore per il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà. Tuttavia, se si usa il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà per determinare i verbi sono disponibili, è necessario includere l'estensione.  
  
 È possibile modificare i parametri specificati nel <xref:System.Diagnostics.Process.StartInfo%2A> proprietà fino all'ora che si chiama il <xref:System.Diagnostics.Process.Start%2A> metodo sul processo. Dopo avere avviato il processo, la modifica di <xref:System.Diagnostics.Process.StartInfo%2A> valori non influisce o riavviare il processo associato. Se si chiama il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> metodo con il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> non gestita, le proprietà impostate `CreateProcessWithLogonW` funzione viene chiamata, che avvia il processo di una nuova finestra, anche se la <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> valore della proprietà è `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> valore della proprietà è <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Se non è stata usata la <xref:System.Diagnostics.Process.Start%2A> metodo per avviare un processo, il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà non riflette i parametri utilizzati per avviare il processo. Ad esempio, se si usa <xref:System.Diagnostics.Process.GetProcesses%2A> per ottenere una matrice di processi in esecuzione nel computer, il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà di ciascuno <xref:System.Diagnostics.Process> non contiene il nome del file originale o argomenti utilizzati per avviare il processo.  
  
 Quando viene avviato il processo, il nome del file è il file che popola la (sola lettura) <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Se si desidera recuperare il file eseguibile che è associato il processo dopo aver avviato il processo, usare il <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Se si desidera impostare il file eseguibile di un <xref:System.Diagnostics.Process> dell'istanza per cui non è stato avviato un processo associato, usare il <xref:System.Diagnostics.Process.StartInfo%2A> della proprietà <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Poiché i membri del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà sono gli argomenti passati al <xref:System.Diagnostics.Process.Start%2A> metodo di un processo, la modifica il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà dopo aver avviato il processo associato non verrà reimpostato il <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Queste proprietà vengono usate solo per inizializzare il processo associato.  
  
   
  
## Examples  
 Nell'esempio seguente consente di popolare un <xref:System.Diagnostics.Process.StartInfo%2A> con il file da eseguire, l'azione eseguita su di esso e se è necessario Visualizza un'interfaccia utente. Per altri esempi, vedere le pagine di riferimento per le proprietà del <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore che specifica la proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> è <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui è stato avviato il processo associato.</summary>
        <value>Oggetto che indica il momento in cui è stato avviato il processo. Viene generata un eccezione se il processo non è in esecuzione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.StartTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è stato terminato.  
  
oppure 
Il processo non è stato avviato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore nella chiamata alla funzione di Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore dell'evento generate in seguito a un evento di terminazione di un processo.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usato per effettuare il marshalling delle chiamate del gestore dell'evento generate in seguito a un evento <see cref="E:System.Diagnostics.Process.Exited" /> del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> viene `null`, i metodi che gestiscono il <xref:System.Diagnostics.Process.Exited> eventi vengono chiamati su un thread dal pool di thread di sistema. Per altre informazioni sui pool di thread di sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando la <xref:System.Diagnostics.Process.Exited> evento è gestito da un componente visivo di Windows Form, ad esempio un <xref:System.Windows.Forms.Button>, accedere al componente tramite il pool di thread di sistema potrebbero non funzionare o potrebbe generare un'eccezione. Evitare questo problema impostando <xref:System.Diagnostics.Process.SynchronizingObject%2A> a un componente di Windows Form, in modo che i metodi che gestiscono il <xref:System.Diagnostics.Process.Exited> eventi da chiamare sullo stesso thread in cui è stato creato il componente.  
  
 Se il <xref:System.Diagnostics.Process> viene usata all'interno [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in una finestra di progettazione Windows Form <xref:System.Diagnostics.Process.SynchronizingObject%2A> viene impostato automaticamente al controllo che contiene il <xref:System.Diagnostics.Process>. Ad esempio, se si inserisce un <xref:System.Diagnostics.Process> in una finestra di progettazione per `Form1` (che eredita dalla classe <xref:System.Windows.Forms.Form>) il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà di <xref:System.Diagnostics.Process> è impostato per l'istanza di `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In genere, questa proprietà viene impostata quando il componente si trova all'interno di un controllo o form, in quanto tali componenti vengono associati a un thread specifico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gruppo di thread in esecuzione nel processo associato.</summary>
        <value>Matrice di tipo <see cref="T:System.Diagnostics.ProcessThread" /> che rappresenta i thread del sistema operativo attualmente in esecuzione nel processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread esegue codice in un processo. Ogni processo viene avviato con un singolo thread, il thread principale. Qualsiasi thread può creare thread aggiuntivi. Thread all'interno di un processo di condividere lo spazio degli indirizzi del processo.  
  
 Usare <xref:System.Diagnostics.ProcessThread> per ottenere tutti i thread associati al processo corrente. Il thread primario non necessariamente in corrispondenza dell'indice da zero nella matrice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Il processo non ha un oggetto <see cref="P:System.Diagnostics.Process.Id" /> o non sono presenti processi associati all'istanza di <see cref="T:System.Diagnostics.Process" />.  
  
oppure 
Il processo associato è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il nome del processo in una stringa, combinandola al tipo di componente padre, se disponibile.</summary>
        <returns>Proprietà <see cref="P:System.Diagnostics.Process.ProcessName" />, combinata con il valore restituito <see cref="M:System.Object.ToString" /> del componente base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> non è supportato in Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo totale del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processo associato nell'utilizzo della CPU. Questo valore è la somma delle proprietà <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> e <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo utente del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processo associato nell'esecuzione del codice all'interno della parte di applicazione del processo (non all'interno del nucleo centrale del sistema operativo).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la dimensione in byte della memoria virtuale del processo.</summary>
        <value>Quantità di memoria virtuale, in byte, che il processo associato ha richiesto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria virtuale, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria virtuale, in byte, allocata per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria virtuale usata dal processo, in byte. Il sistema operativo viene eseguito il mapping lo spazio degli indirizzi virtuale per ogni processo alle pagine caricate nella memoria fisica, o alle pagine archiviate nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **byte virtuali** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta l'intervallo di tempo in base al quale attendere che il processo associato venga terminato e blocca il thread corrente di esecuzione fino alla scadenza di tale intervallo o al termine del processo. Per evitare di bloccare il thread corrente, usare l'evento <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Per esempi di codice, vedere le pagine di riferimento alle proprietà <see cref="P:System.Diagnostics.Process.StandardError" /> e <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> di attendere in modo indefinito la terminazione del processo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> Consente di attendere finché non termina il processo associato al thread corrente.  Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, usare l'evento <xref:System.Diagnostics.Process.Exited>.  
  
 Questo metodo indica il <xref:System.Diagnostics.Process> componente attenderà una quantità infinita di tempo per i processo e gestori eventi uscire. Ciò può provocare un'applicazione di rispondere. Ad esempio, se si chiama <xref:System.Diagnostics.Process.CloseMainWindow%2A> per un processo con un'interfaccia utente, la richiesta al sistema operativo per terminare il processo associato potrebbe non essere gestita se il processo viene scritto per il ciclo di messaggi non digitano mai.  
  
> [!NOTE]
>  Nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versioni precedenti, il <xref:System.Diagnostics.Process.WaitForExit> overload in attesa per <xref:System.Int32.MaxValue> millisecondi (circa 24 giorni), non per un periodo illimitato. Inoltre, le versioni precedenti non si attende che i gestori eventi per l'uscita se la versione completa <xref:System.Int32.MaxValue> è stata raggiunta l'ora.  
  
 Questo overload garantisce che tutte le elaborazioni sono stata completata, inclusa la gestione degli eventi asincroni per l'output standard reindirizzato. È necessario utilizzare questo overload dopo una chiamata al <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload quando l'output standard è stato reindirizzato per gestori eventi asincroni.  
  
 Quando un processo associato viene chiuso (ovvero, quando viene arrestata dal sistema operativo mediante una terminazione normale o anomala), il sistema archivia le informazioni amministrative relative al processo e restituisce il componente che ha chiamato <xref:System.Diagnostics.Process.WaitForExit>. Il <xref:System.Diagnostics.Process> componente può quindi accedere alle informazioni, che include le <xref:System.Diagnostics.Process.ExitTime%2A>, usando il <xref:System.Diagnostics.Process.Handle%2A> al processo terminato.  
  
 Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A> proprietà del componente non punta più a una risorsa di processo esistente. Al contrario, l'handle è utilizzabile solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle da processi terminati che non sono stati rilasciati dal <xref:System.Diagnostics.Process> componenti, in modo che mantiene le <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria fino al <xref:System.Diagnostics.Process> componente specificamente libera le risorse. Per questo motivo, ogni volta che si chiama <xref:System.Diagnostics.Process.Start%2A> per un <xref:System.Diagnostics.Process> dell'istanza, chiamare <xref:System.Diagnostics.Process.Close%2A> quando il processo associato ha terminato e non è più necessario le informazioni amministrative su di esso. <xref:System.Diagnostics.Process.Close%2A> libera la memoria allocata per il processo è ancora terminato.  
  
   
  
## Examples  
 Vedere la sezione Osservazioni del <xref:System.Diagnostics.Process.StandardError%2A> pagina di riferimento di proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile accedere all'impostazione di attesa.</exception>
        <exception cref="T:System.SystemException">Non è stato impostato alcun <see cref="P:System.Diagnostics.Process.Id" /> di processo e non è presente alcun <see cref="P:System.Diagnostics.Process.Handle" /> da cui è possibile determinare la proprietà <see cref="P:System.Diagnostics.Process.Id" />.  
  
oppure 
A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.  
  
oppure 
Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.WaitForExit" /> per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Quantità di tempo, espressa in millisecondi, in base alla quale viene attesa la terminazione del processo associato. Il valore massimo è il valore integer a 32 bit più alto possibile, che rappresenta l'infinito per il sistema operativo.</param>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> di attendere per il numero specificato di millisecondi che il processo venga terminato.</summary>
        <returns>
          <see langword="true" /> se il processo associato è stato terminato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Consente di attendere finché non termina il processo associato al thread corrente. Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, usare l'evento <xref:System.Diagnostics.Process.Exited>.  
  
 Questo metodo indica il <xref:System.Diagnostics.Process> componente attendere un periodo di tempo per l'uscita del processo finito. Se il processo associato viene chiuso entro la fine dell'intervallo perché la richiesta di terminazione è stata negata, `false` viene restituito alla routine chiamante. È possibile specificare <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per `milliseconds`, e <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> si comportano allo stesso come il <xref:System.Diagnostics.Process.WaitForExit> rapporto di overload. Se si passa 0 (zero) per il metodo, viene restituito `true` solo se il processo è già stato terminato; in caso contrario, restituisce immediatamente `false`.  
  
> [!NOTE]
>  Nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versioni precedenti, se `milliseconds` era -1, il <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload in attesa per <xref:System.Int32.MaxValue> millisecondi (circa 24 giorni), non per un periodo illimitato.  
  
 Quando l'output standard è stato reindirizzato per gestori eventi asincroni, è possibile che l'elaborazione di output verrà non completati quando questo metodo viene restituito. Per assicurarsi che gestione asincrona degli eventi è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro dopo avere ricevuto un `true` da questo overload. Per assicurarsi che il <xref:System.Diagnostics.Process.Exited> evento viene gestito in modo corretto nelle applicazioni Windows Form, impostare il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà.  
  
 Quando un processo associato viene chiuso (viene chiusa dal sistema operativo tramite una terminazione normale o anomala), il sistema archivia le informazioni amministrative relative al processo e restituisce il componente che ha chiamato <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Il <xref:System.Diagnostics.Process> componente può quindi accedere alle informazioni, che include le <xref:System.Diagnostics.Process.ExitTime%2A>, usando il <xref:System.Diagnostics.Process.Handle%2A> al processo terminato.  
  
 Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A> proprietà del componente non punta più a una risorsa di processo esistente. Al contrario, l'handle è utilizzabile solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle da processi terminati che non sono stati rilasciati dal <xref:System.Diagnostics.Process> componenti, in modo che mantiene le <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria fino al <xref:System.Diagnostics.Process> componente specificamente libera le risorse. Per questo motivo, ogni volta che si chiama <xref:System.Diagnostics.Process.Start%2A> per un <xref:System.Diagnostics.Process> dell'istanza, chiamare <xref:System.Diagnostics.Process.Close%2A> quando il processo associato ha terminato e non è più necessario le informazioni amministrative su di esso. <xref:System.Diagnostics.Process.Close%2A> libera la memoria allocata per il processo è ancora terminato.  
  
   
  
## Examples  
 Vedere l'esempio di codice per il <xref:System.Diagnostics.Process.ExitCode%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile accedere all'impostazione di attesa.</exception>
        <exception cref="T:System.SystemException">Non è stato impostato alcun <see cref="P:System.Diagnostics.Process.Id" /> di processo e non è presente alcun <see cref="P:System.Diagnostics.Process.Handle" /> da cui è possibile determinare la proprietà <see cref="P:System.Diagnostics.Process.Id" />.  
  
oppure 
A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.  
  
oppure 
Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà che il processo associato entri in uno stato inattivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà in modo indefinito che il processo associato entri in uno stato inattivo. Questo overload viene applicato soltanto ai processi dotati di interfaccia utente e, quindi, di un ciclo di messaggi.</summary>
        <returns>
          <see langword="true" /> se il processo associato ha raggiunto uno stato inattivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Diagnostics.Process.WaitForInputIdle> per forzare l'elaborazione dell'applicazione in attesa fino a quando non ha restituito il ciclo di messaggi nello stato inattivo. Quando un processo con un'interfaccia utente è in esecuzione, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Il processo restituisce quindi il ciclo di messaggi. Un processo viene definito in uno stato di inattività quando è in attesa dei messaggi all'interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l'applicazione deve attendere che un processo completare la creazione relativa finestra principale prima che l'applicazione comunica con tale finestra.  
  
 Se un processo non dispone di un ciclo di messaggi <xref:System.Diagnostics.Process.WaitForInputIdle> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Diagnostics.Process.WaitForInputIdle> overload indica il <xref:System.Diagnostics.Process> componente per un'attesa indefinita per il processo di diventare inattiva nel ciclo di messaggi. Questa istruzione può causare un'applicazione di rispondere. Ad esempio, se il processo viene scritto per sempre il messaggio uscire immediatamente dal ciclo, come illustrato nel frammento di codice `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un'interfaccia grafica.  
  
oppure 
Si è verificato un errore sconosciuto. Il processo non è riuscito a passare a uno stato di inattività.  
  
oppure 
Processo già terminato.  
  
oppure 
Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Valore pari a 1 per <see cref="F:System.Int32.MaxValue" /> che specifica la quantità di tempo, espressa in millisecondi, in base alla quale viene atteso che il processo associato diventi inattivo. Un valore pari a 0 specifica una restituzione immediata, mentre un valore pari a -1 specifica un'attesa infinita.</param>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà per un numero specificato di millisecondi che il processo associato entri in uno stato inattivo. Questo overload viene applicato soltanto ai processi dotati di interfaccia utente e, quindi, di un ciclo di messaggi.</summary>
        <returns>
          <see langword="true" /> se il processo associato ha raggiunto uno stato inattivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> per forzare l'elaborazione dell'applicazione in attesa fino a quando non ha restituito il ciclo di messaggi nello stato inattivo. Quando un processo con un'interfaccia utente è in esecuzione, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Il processo restituisce quindi il ciclo di messaggi. Un processo viene definito in uno stato di inattività quando è in attesa dei messaggi all'interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l'applicazione deve attendere che un processo completare la creazione relativa finestra principale prima che l'applicazione comunica con tale finestra.  
  
 Se un processo non dispone di un ciclo di messaggi <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload indica il <xref:System.Diagnostics.Process> componente attendere un periodo di tempo per il processo di diventare inattiva nel ciclo di messaggi finito. Se il processo associato non è diventata inattivo entro la fine dell'intervallo poiché il ciclo sta ancora elaborando i messaggi, `false` viene restituito alla routine chiamante.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un'interfaccia grafica.  
  
oppure 
Si è verificato un errore sconosciuto. Il processo non è riuscito a passare a uno stato di inattività.  
  
oppure 
Processo già terminato.  
  
oppure 
Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'utilizzo di memoria fisica del processo associato, espresso in byte.</summary>
        <value>Quantità totale di memoria fisica usata dal processo associato, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente dell'utilizzo di set di memoria usata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e consente di visualizzare il codice di uscita del processo.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria fisica, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria fisica, in byte, allocata per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente dell'utilizzo di set di memoria usata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibile per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibile per un'applicazione di usare senza generare un errore di pagina.  
  
 Il working set include i dati sia condivisi che privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, incluse le istruzioni in moduli di processo e le librerie di sistema.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente per la **Working Set** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. L'esempio recupera quindi e consente di visualizzare varie proprietà del processo associato. Nell'esempio viene rilevato durante il processo viene chiuso e visualizza le statistiche di memoria codice e picco relativa uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>