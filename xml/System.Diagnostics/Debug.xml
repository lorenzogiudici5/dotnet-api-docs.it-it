<Type Name="Debug" FullName="System.Diagnostics.Debug">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fcf465491257980e042b06fb8c34d629c1463d98" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36675482" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Debug" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Debug extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debug" />
  <TypeSignature Language="VB.NET" Value="Public Class Debug" />
  <TypeSignature Language="C++ CLI" Value="public ref class Debug abstract sealed" />
  <TypeSignature Language="F#" Value="type Debug = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides a set of methods and properties that help debug your code.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si utilizzano i metodi nel <xref:System.Diagnostics.Debug> classe per stampare le informazioni di debug e controllare la logica con asserzioni, è possibile rendere il codice più affidabile senza conseguenze per le dimensioni delle prestazioni e il codice del prodotto di spedizione.  
  
 Questa classe fornisce metodi per visualizzare un <xref:System.Diagnostics.Debug.Assert%2A> della finestra di dialogo e di generare un'asserzione che avrà sempre esito negativo. Questa classe fornisce metodi di scrittura nelle variazioni seguenti: <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A> e <xref:System.Diagnostics.Debug.WriteLineIf%2A>.  
  
 Il <xref:System.Diagnostics.BooleanSwitch> e <xref:System.Diagnostics.TraceSwitch> classi consentono di controllare in modo dinamico l'output di traccia. È possibile modificare i valori di queste opzioni senza ricompilare l'applicazione. Per informazioni sull'utilizzo del file di configurazione per impostare un'opzione, vedere la <xref:System.Diagnostics.Switch> classe e il [opzioni di traccia](~/docs/framework/debug-trace-profile/trace-switches.md) argomento.  
  
 È possibile personalizzare la destinazione dell'output di tracciatura aggiungendo <xref:System.Diagnostics.TraceListener> istanze a o la rimozione di istanze dal <xref:System.Diagnostics.Debug.Listeners%2A> insieme. Il <xref:System.Diagnostics.Debug.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e il <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a due classi viene aggiunto il listener a entrambi. Per impostazione predefinita, il <xref:System.Diagnostics.DefaultTraceListener> classe genera l'output di traccia.  
  
> [!NOTE]
>  Aggiunta di un listener di traccia per il <xref:System.Diagnostics.Debug.Listeners%2A> raccolta può causare un'eccezione generata durante la traccia, se non è disponibile una risorsa utilizzata dal listener di traccia. Le condizioni e l'eccezione generata dipendono il listener di traccia e non può essere enumerate in questo argomento. Può essere utile effettuare le chiamate al <xref:System.Diagnostics.Debug> metodi `try` / `catch` blocchi per rilevare e gestire eventuali eccezioni dal listener di traccia.  
  
 È possibile modificare il livello di rientro utilizzando il <xref:System.Diagnostics.Debug.Indent%2A> metodo o la <xref:System.Diagnostics.Debug.IndentLevel%2A> proprietà. Per modificare la spaziatura del rientro, utilizzare il <xref:System.Diagnostics.Debug.IndentSize%2A> proprietà. È possibile specificare se scaricare automaticamente il buffer di output dopo ogni operazione di scrittura impostando il <xref:System.Diagnostics.Debug.AutoFlush%2A> proprietà `true`.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 Il <xref:System.Diagnostics.ConditionalAttribute> attributo viene applicato ai metodi di <xref:System.Diagnostics.Debug>. I compilatori che supportano <xref:System.Diagnostics.ConditionalAttribute> ignorano le chiamate a questi metodi solo se "DEBUG" è stato definito come simbolo di compilazione condizionale. Fare riferimento alla documentazione del compilatore per determinare se <xref:System.Diagnostics.ConditionalAttribute> è supportata e la sintassi per la definizione di un simbolo di compilazione condizionale.  
  
> [!NOTE]
> Nei progetti di Visual Studio c# e Visual Basic, per impostazione predefinita, il simbolo di compilazione condizionale "DEBUG" è definito per le compilazioni di debug e il simbolo "TRACE" è definito per entrambe build di debug e rilascio. Per informazioni su come disabilitare questo comportamento, vedere la documentazione di Visual Studio. Per informazioni sul debug condizionale in Visual C++, vedere [classe Debug (C + c++ /CLI)](/cpp/dotnet/debug-class-cpp-cli).
  
 Per definire il simbolo di compilazione condizionale "DEBUG" in c#, aggiungere il `/d:DEBUG` opzione alla riga di comando del compilatore quando si compila il codice tramite la riga di comando o aggiungere `#define DEBUG` nella parte superiore del file. In Visual Basic, aggiungere il `/d:DEBUG=True` opzione alla riga di comando del compilatore o aggiungere `#Const DEBUG=True` al file.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Diagnostics.Debug> per indicare l'inizio e fine dell'esecuzione del programma. Nell'esempio viene usato anche <xref:System.Diagnostics.Debug.Indent%2A> e <xref:System.Diagnostics.Debug.Unindent%2A> per distinguere l'output di traccia.  
  
 [!code-cpp[Classic Debug Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug Example/CS/source.cs#1)]
 [!code-vb[Classic Debug Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Trace" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Checks for a condition; if the condition is <see langword="false" />, outputs messages and displays a message box that shows the call stack.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Debug.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, a failure message is not sent and the message box is not displayed.</param>
        <summary>Checks for a condition; if the condition is <see langword="false" />, displays a message box that shows the call stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
> [!IMPORTANT]
>  Il `Assert` metodi non sono disponibili per [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] app.  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, viene inviato un messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] le app non supportano le finestre di dialogo modale, pertanto funzionano in modalità interfaccia utente e la modalità interfaccia utente non. Il messaggio viene scritto attiva listener di traccia in modalità di debug, o nessun messaggio viene scritto in modalità di rilascio.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un indice per una matrice, esegue un'azione per impostare il valore dell'indice e quindi chiama <xref:System.Diagnostics.Debug.Assert%2A> per confermare che il valore di indice è valido. Se non è valido, <xref:System.Diagnostics.Debug.Assert%2A> restituisce lo stack di chiamate.  
  
 [!code-cpp[Classic Debug.Assert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Debug.Assert (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the specified message is not sent and the message box is not displayed.</param>
        <param name="message">The message to send to the <see cref="P:System.Diagnostics.Trace.Listeners" /> collection.</param>
        <summary>Checks for a condition; if the condition is <see langword="false" />, outputs a specified message and displays a message box that shows the call stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%2A> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se il `type` parametro è valido. Se `type` viene `null`, <xref:System.Diagnostics.Trace.Assert%2A> genera un messaggio.  
  
 [!code-cpp[Classic Debug.Assert1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string * string -&gt; unit" Usage="System.Diagnostics.Debug.Assert (condition, message, detailMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the specified messages are not sent and the message box is not displayed.</param>
        <param name="message">The message to send to the <see cref="P:System.Diagnostics.Trace.Listeners" /> collection.</param>
        <param name="detailMessage">The detailed message to send to the <see cref="P:System.Diagnostics.Trace.Listeners" /> collection.</param>
        <summary>Checks for a condition; if the condition is <see langword="false" />, outputs two specified messages and displays a message box that shows the call stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato e un messaggio dettagliato dal <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se il `type` parametro è valido. Se `type` viene `null`, <xref:System.Diagnostics.Trace.Assert%2A> vengono generati due messaggi.  
  
 [!code-cpp[Classic Debug.Assert2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessageFormat, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessageFormat, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessageFormat As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessageFormat, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string * string * obj[] -&gt; unit" Usage="System.Diagnostics.Debug.Assert (condition, message, detailMessageFormat, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessageFormat" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the specified messages are not sent and the message box is not displayed.</param>
        <param name="message">The message to send to the <see cref="P:System.Diagnostics.Trace.Listeners" /> collection.</param>
        <param name="detailMessageFormat">The composite format string to send to the <see cref="P:System.Diagnostics.Trace.Listeners" /> collection. This message contains text intermixed with zero or more format items, which correspond to objects in the <c>args</c> array.</param>
        <param name="args">An object array that contains zero or more objects to format.</param>
        <summary>Checks for a condition; if the condition is <see langword="false" />, outputs two messages (simple and formatted) and displays a message box that shows the call stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare la rappresentazione in una stringa. La stringa risultante viene inviata al <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, il <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> viene chiamato e il `detailMessageFormat` stringa e `args` matrice vengono passati come parametri. <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> quindi invia il messaggio di testo specificato e il messaggio di testo formattato per la <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio è dipendente se è presente il <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="System.Diagnostics.Debug.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether <see cref="M:System.Diagnostics.Debug.Flush" /> should be called on the <see cref="P:System.Diagnostics.Debug.Listeners" /> after every write.</summary>
        <value>
          <see langword="true" /> se il metodo <see cref="M:System.Diagnostics.Debug.Flush" /> viene chiamato sulla proprietà <see cref="P:System.Diagnostics.Debug.Listeners" /> dopo ogni operazione di scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito è `false`.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. L'impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è anche possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Close" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Close();" />
      <MemberSignature Language="F#" Value="static member Close : unit -&gt; unit" Usage="System.Diagnostics.Debug.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flushes the output buffer and then calls the <see langword="Close" /> method on each of the <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando l'output viene inserito in un file, ad esempio per il <xref:System.Diagnostics.TextWriterTraceListener>.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. L'impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.StreamWriter> chiamato `myOutputWriter` per scrivere in un file denominato `TestFile.txt`. Nell'esempio viene creato il writer di testo, file e flusso, scritta una sola riga di testo nel file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Emits an error message.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Fail : string -&gt; unit" Usage="System.Diagnostics.Debug.Fail message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to emit.</param>
        <summary>Emits the specified error message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito prevede che il <xref:System.Diagnostics.DefaultTraceListener> genera il messaggio in una finestra di messaggio quando l'applicazione è in esecuzione in modalità interfaccia utente e di ottenere il <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio è dipendente se è presente il <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Debug.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Debug.Fail Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#1)]  
  
 È anche possibile usare il <xref:System.Diagnostics.Debug.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Debug.Fail Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberSignature Language="F#" Value="static member Fail : string * string -&gt; unit" Usage="System.Diagnostics.Debug.Fail (message, detailMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to emit.</param>
        <param name="detailMessage">A detailed message to emit.</param>
        <summary>Emits an error message and a detailed error message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito prevede che il <xref:System.Diagnostics.DefaultTraceListener> genera il messaggio in una finestra di messaggio quando l'applicazione è in esecuzione in modalità interfaccia utente e di ottenere il <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio è dipendente se è presente il <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Debug.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Debug.Fail1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#1)]  
  
 È anche possibile usare il <xref:System.Diagnostics.Debug.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Debug.Fail1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Flush();" />
      <MemberSignature Language="F#" Value="static member Flush : unit -&gt; unit" Usage="System.Diagnostics.Debug.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flushes the output buffer and causes buffered data to write to the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. L'impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.FileStream> chiamato `myFileStream` per scrivere in un file denominato `TestFile.txt`. Nell'esempio viene creato il flusso, apre il file eventualmente esistente o ne crea uno nuovo, scrivere una sola riga di testo nel file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Indent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Indent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Indent();" />
      <MemberSignature Language="F#" Value="static member Indent : unit -&gt; unit" Usage="System.Diagnostics.Debug.Indent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Increases the current <see cref="P:System.Diagnostics.Debug.IndentLevel" /> by one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Unindent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentLevel { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IndentLevel : int with get, set" Usage="System.Diagnostics.Debug.IndentLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the indent level.</summary>
        <value>Livello di rientro. Il valore predefinito è 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Debug.IndentLevel%2A> proprietà rappresenta il numero di volte in cui il rientro di dimensioni <xref:System.Diagnostics.Debug.IndentSize%2A> viene applicato.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IndentSize : int with get, set" Usage="System.Diagnostics.Debug.IndentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of spaces in an indent.</summary>
        <value>Numero di spazi in un rientro. Il valore predefinito è quattro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.TextWriterTraceListener> questo numero viene interpretato come "spazi". Un <xref:System.Diagnostics.EventLogTraceListener> ignora questo valore.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è anche possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.Listeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Listeners As TraceListenerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::TraceListenerCollection ^ Listeners { System::Diagnostics::TraceListenerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Listeners : System.Diagnostics.TraceListenerCollection" Usage="System.Diagnostics.Debug.Listeners" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of listeners that is monitoring the debug output.</summary>
        <value>Un <see cref="T:System.Diagnostics.TraceListenerCollection" /> che rappresenta una raccolta di tipo <see cref="T:System.Diagnostics.TraceListener" /> che consente di monitorare l'output di debug.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I listener producono output formattato dall'output di debug. Per impostazione predefinita, la raccolta contiene un'istanza di <xref:System.Diagnostics.DefaultTraceListener> classe. Per rimuovere il listener predefinito, chiamare il <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> metodo e passare l'istanza del <xref:System.Diagnostics.DefaultTraceListener>. Per reindirizzare l'output alla finestra della console, aggiungere un'istanza di <xref:System.Diagnostics.ConsoleTraceListener>. Per reindirizzare l'output in un file o flusso, aggiungere un'istanza di <xref:System.Diagnostics.TextWriterTraceListener>.  
  
> [!NOTE]
>  Il <xref:System.Diagnostics.Debug.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e il <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a due classi viene aggiunto il listener a entrambi.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TextWriterTraceListener> che output allo schermo della console. Il codice aggiunge quindi il nuovo listener per il <xref:System.Diagnostics.Debug.Listeners%2A>.  
  
 [!code-cpp[Classic Debug.Listeners Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Listeners Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Listeners Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Print">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes a message followed by a line terminator to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Print : string -&gt; unit" Usage="System.Diagnostics.Debug.Print message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">The message to write.</param>
        <summary>Writes a message followed by a line terminator to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il terminatore di riga predefinito è un ritorno a capo seguito da un avanzamento riga. Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Print : string * obj[] -&gt; unit" Usage="System.Diagnostics.Debug.Print (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A composite format string that contains text intermixed with zero or more format items, which correspond to objects in the <c>args</c> array.</param>
        <param name="args">An object array containing zero or more objects to format.</param>
        <summary>Writes a formatted string followed by a line terminator to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare la rappresentazione in una stringa. Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  -or-  The number that indicates an argument to format is less than zero, or greater than or equal to the number of specified objects to format.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Unindent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unindent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unindent();" />
      <MemberSignature Language="F#" Value="static member Unindent : unit -&gt; unit" Usage="System.Diagnostics.Debug.Unindent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decreases the current <see cref="P:System.Diagnostics.Debug.IndentLevel" /> by one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Indent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information about the debug to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Diagnostics.Debug.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Writes the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Diagnostics.Debug.Write message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to write.</param>
        <summary>Writes a message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member Write : obj * string -&gt; unit" Usage="System.Diagnostics.Debug.Write (value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilizzare il `category` parametro al gruppo di messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member Write : string * string -&gt; unit" Usage="System.Diagnostics.Debug.Write (message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to write.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilizzare il `category` parametro al gruppo di messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information about the debug to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * obj -&gt; unit" Usage="System.Diagnostics.Debug.WriteIf (condition, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the value is written to the trace listeners in the collection.</param>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Writes the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versioni successive, l'esempio restituisce il nome del parametro del valore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito un messaggio sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteIf (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the message is written to the trace listeners in the collection.</param>
        <param name="message">A message to write.</param>
        <summary>Writes a message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * obj * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteIf (condition, value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the category name and value are written to the trace listeners in the collection.</param>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il nome del `myObject` e il `category` per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * string * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteIf (condition, message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the category name and message are written to the trace listeners in the collection.</param>
        <param name="message">A message to write.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information about the debug to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Diagnostics.Debug.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Writes the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il nome dell'oggetto nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLine message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to write.</param>
        <summary>Writes a message followed by a line terminator to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLine (value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Diagnostics.Debug.WriteLine (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A composite format string that contains text intermixed with zero or more format items, which correspond to objects in the <c>args</c> array.</param>
        <param name="args">An object array that contains zero or more objects to format.</param>
        <summary>Writes a formatted message followed by a line terminator to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare la rappresentazione in una stringa.  
  
 La parola chiave nella sintassi per questo metodo implica che la matrice di oggetti può essere un valore singolo. L'eccezione è il <xref:System.String> oggetto. Overload esplicite hanno la precedenza, pertanto un `arg` impostazione di una singola stringa predefinita sarà il <xref:System.Diagnostics.Debug.WriteLine%28System.String%2CSystem.String%29?displayProperty=nameWithType> rapporto di overload.  
  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLine (message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message to write.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e il `category` sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information about the debug to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * obj -&gt; unit" Usage="System.Diagnostics.Debug.WriteLineIf (condition, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the value is written to the trace listeners in the collection.</param>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Writes the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il nome dell'oggetto nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLineIf (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the message is written to the trace listeners in the collection.</param>
        <param name="message">A message to write.</param>
        <summary>Writes a message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * obj * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLineIf (condition, value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">The conditional expression to evaluate. If the condition is <see langword="true" />, the category name and value are written to the trace listeners in the collection.</param>
        <param name="value">An object whose name is sent to the <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and the value of the object's <see cref="M:System.Object.ToString" /> method to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * string * string -&gt; unit" Usage="System.Diagnostics.Debug.WriteLineIf (condition, message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> to cause a message to be written; otherwise, <see langword="false" />.</param>
        <param name="message">A message to write.</param>
        <param name="category">A category name used to organize the output.</param>
        <summary>Writes a category name and message to the trace listeners in the <see cref="P:System.Diagnostics.Debug.Listeners" /> collection if a condition is <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e il `category` sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  Primo esempio: ' ' csharp if(mySwitch.TraceError) debug. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' Secondo esempio: ' ' csharp debug. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
  </Members>
</Type>