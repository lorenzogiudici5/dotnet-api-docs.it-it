<Type Name="Debug" FullName="System.Diagnostics.Debug">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1f2f5cb8de12cc67dfb0178935452c56a2348ef" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061115" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Debug" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Debug extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debug" />
  <TypeSignature Language="VB.NET" Value="Public Class Debug" />
  <TypeSignature Language="C++ CLI" Value="public ref class Debug abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un set di metodi e proprietà che consentono di eseguire il debug del codice.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si utilizzano i metodi nel <xref:System.Diagnostics.Debug> classe per stampare le informazioni di debug e controllare la logica con asserzioni, è possibile rendere il codice più affidabile senza conseguenze per le dimensioni delle prestazioni e il codice del prodotto shipping.  
  
 Questa classe fornisce metodi per visualizzare un <xref:System.Diagnostics.Debug.Assert%2A> nella finestra di dialogo e la generazione di un'asserzione che avrà sempre esito negativo. Questa classe fornisce metodi di scrittura nelle seguenti variazioni: <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A> e <xref:System.Diagnostics.Debug.WriteLineIf%2A>.  
  
 Il <xref:System.Diagnostics.BooleanSwitch> e <xref:System.Diagnostics.TraceSwitch> classi consentono di controllare dinamicamente l'output di traccia. È possibile modificare i valori di queste opzioni senza ricompilare l'applicazione. Per informazioni sull'utilizzo del file di configurazione per impostare un'opzione, vedere il <xref:System.Diagnostics.Switch> classe e [opzioni di traccia](~/docs/framework/debug-trace-profile/trace-switches.md) argomento.  
  
 È possibile personalizzare la destinazione dell'output di tracciatura aggiungendo <xref:System.Diagnostics.TraceListener> istanze a o la rimozione di istanze di <xref:System.Diagnostics.Debug.Listeners%2A> insieme. Il <xref:System.Diagnostics.Debug.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a una classe viene aggiunto il listener a entrambi. Per impostazione predefinita, la <xref:System.Diagnostics.DefaultTraceListener> classe genera l'output di traccia.  
  
> [!NOTE]
>  Aggiunta di un listener di traccia di <xref:System.Diagnostics.Debug.Listeners%2A> raccolta può causare un'eccezione generata durante la traccia, se una risorsa utilizzata dal listener di traccia non è disponibile. Le condizioni e l'eccezione generata dipendono dal listener di traccia e non può essere enumerate in questo argomento. Può essere utile effettuare le chiamate per il <xref:System.Diagnostics.Debug> metodi `try` / `catch` blocchi per rilevare e gestire tutte le eccezioni dai listener di traccia.  
  
 È possibile modificare il livello di rientro utilizzando il <xref:System.Diagnostics.Debug.Indent%2A> metodo o <xref:System.Diagnostics.Debug.IndentLevel%2A> proprietà. Per modificare la spaziatura del rientro, utilizzare il <xref:System.Diagnostics.Debug.IndentSize%2A> proprietà. È possibile specificare se scaricare automaticamente il buffer di output dopo ogni scrittura impostando il <xref:System.Diagnostics.Debug.AutoFlush%2A> proprietà `true`.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 Il <xref:System.Diagnostics.ConditionalAttribute> attributo viene applicato ai metodi di <xref:System.Diagnostics.Debug>. I compilatori che supportano <xref:System.Diagnostics.ConditionalAttribute> ignorano le chiamate a questi metodi, a meno che non "DEBUG" è definito come simbolo di compilazione condizionale. Fare riferimento alla documentazione di un compilatore per determinare se <xref:System.Diagnostics.ConditionalAttribute> è supportata e la sintassi per definire un simbolo di compilazione condizionale.  
  
> [!NOTE]
> Nei progetti di Visual Studio c# e Visual Basic, per impostazione predefinita, il simbolo di compilazione condizionale "DEBUG" è definito per le compilazioni di debug e il simbolo "TRACE" è definito per entrambe build di debug e rilascio. Per informazioni su come disabilitare questo comportamento, vedere la documentazione di Visual Studio. Per informazioni sul debug condizionale in Visual C++, vedere [classe Debug (C + + CLI)](/cpp/dotnet/debug-class-cpp-cli).
  
 Per definire il simbolo di compilazione condizionale "DEBUG" in c#, aggiungere il `/d:DEBUG` opzione alla riga di comando del compilatore quando si compila il codice tramite la riga di comando o aggiungere `#define DEBUG` all'inizio del file. In Visual Basic, aggiungere il `/d:DEBUG=True` opzione alla riga di comando del compilatore o aggiungere `#Const DEBUG=True` al file.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Diagnostics.Debug> per indicare l'inizio e alla fine dell'esecuzione del programma. Nell'esempio viene inoltre utilizzato <xref:System.Diagnostics.Debug.Indent%2A> e <xref:System.Diagnostics.Debug.Unindent%2A> per distinguere l'output di traccia.  
  
 [!code-cpp[Classic Debug Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug Example/CS/source.cs#1)]
 [!code-vb[Classic Debug Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Trace" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, vengono generati messaggi e viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio di errore non viene inviato e la finestra di messaggio non viene visualizzata.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per ulteriori informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
> [!IMPORTANT]
>  Il `Assert` metodi non sono disponibili per [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] app.  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, viene inviato un messaggio di errore per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic su di **Abort** pulsante chiude l'applicazione. Fare clic su **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Fare clic su **ignora** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applicazioni non supportano le finestre di dialogo modale, in modo identico in modalità interfaccia utente e la modalità interfaccia utente non funzionano. Il messaggio viene scritto per il listener di traccia attivi in modalità di debug, o nessun messaggio viene scritto in modalità di rilascio.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio di asserzione o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un indice per una matrice, esegue un'azione per impostare il valore dell'indice e quindi chiama <xref:System.Diagnostics.Debug.Assert%2A> per confermare che il valore di indice è valido. Se non è valido, <xref:System.Diagnostics.Debug.Assert%2A> restituisce lo stack di chiamate.  
  
 [!code-cpp[Classic Debug.Assert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio specificato non viene inviato e la finestra di messaggio non viene visualizzata.</param>
        <param name="message">Messaggio da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, genera un messaggio specificato e visualizza una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per ulteriori informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%2A> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic su di **Abort** pulsante chiude l'applicazione. Fare clic su **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Fare clic su **ignora** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio di asserzione o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se il `type` parametro è valido. Se `type` è `null`, <xref:System.Diagnostics.Trace.Assert%2A> genera un messaggio.  
  
 [!code-cpp[Classic Debug.Assert1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, i messaggi specificati non vengono inviati e la finestra di messaggio non viene visualizzata.</param>
        <param name="message">Messaggio da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessage">Messaggio dettagliato da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, vengono generati due messaggi specificati e viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per ulteriori informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato e un messaggio dettagliato dal <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic su di **Abort** pulsante chiude l'applicazione. Fare clic su **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Fare clic su **ignora** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio di asserzione o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se il `type` parametro è valido. Se `type` è `null`, <xref:System.Diagnostics.Trace.Assert%2A> vengono generati due messaggi.  
  
 [!code-cpp[Classic Debug.Assert2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Assert2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Assert2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessageFormat, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessageFormat, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessageFormat As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessageFormat, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessageFormat" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, i messaggi specificati non vengono inviati e la finestra di messaggio non viene visualizzata.</param>
        <param name="message">Messaggio da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessageFormat">Stringa di formato composito da inviare alla raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />. Questo messaggio contiene testo combinato con zero o più elementi di formato, che corrispondono a oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, vengono generati due messaggi (semplice e formattato) e viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione in una stringa. La stringa risultante viene inviata al <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
 Per impostazione predefinita, il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Per ulteriori informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Debug.Assert%2A> valuta la condizione. Se il risultato è `false`, <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metodo viene chiamato e `detailMessageFormat` stringa e `args` matrice vengono passati come parametri. <xref:System.Diagnostics.Debug.Assert%28System.Boolean%2CSystem.String%2CSystem.String%2CSystem.Object%5B%5D%29> quindi invia il messaggio di testo specificato e il messaggio di testo formattato per la <xref:System.Diagnostics.Debug.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità di interfaccia utente, viene visualizzata una finestra di messaggio che indica lo stack di chiamate con i numeri di file e riga. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic su di **Abort** pulsante chiude l'applicazione. Fare clic su **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Fare clic su **ignora** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio di asserzione o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <assert assertuienabled="true" logfilename="c:\\myFile.log" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se chiamare il metodo <see cref="M:System.Diagnostics.Debug.Flush" /> sulla proprietà <see cref="P:System.Diagnostics.Debug.Listeners" /> dopo ogni operazione di scrittura.</summary>
        <value>
          <see langword="true" /> se il metodo <see cref="M:System.Diagnostics.Debug.Flush" /> viene chiamato sulla proprietà <see cref="P:System.Diagnostics.Debug.Listeners" /> dopo ogni operazione di scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito è `false`.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. Impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è anche possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Close" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Svuota il buffer dell'output e quindi chiama il metodo <see langword="Close" /> per ogni <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando l'output viene inserito in un file, ad esempio per il <xref:System.Diagnostics.TextWriterTraceListener>.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. Impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.StreamWriter> chiamato `myOutputWriter` per scrivere in un file denominato `TestFile.txt`. L'esempio crea il writer di testo, un flusso e file, scrive una riga di testo al file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Genera un messaggio di errore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da generare.</param>
        <summary>Genera il messaggio di errore specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito prevede che il <xref:System.Diagnostics.DefaultTraceListener> genera il messaggio in una finestra di messaggio quando l'applicazione è in esecuzione in modalità interfaccia utente e di ottenere il <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Debug.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Debug.Fail Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#1)]  
  
 È inoltre possibile utilizzare il <xref:System.Diagnostics.Debug.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Debug.Fail Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da generare.</param>
        <param name="detailMessage">Messaggio dettagliato da generare.</param>
        <summary>Genera un messaggio di errore e un messaggio di errore dettagliato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito prevede che il <xref:System.Diagnostics.DefaultTraceListener> genera il messaggio in una finestra di messaggio quando l'applicazione è in esecuzione in modalità interfaccia utente e di ottenere il <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), o chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> sul (metodo)<xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Debug.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Debug.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Debug.Fail1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Fail1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Fail1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#1)]  
  
 È inoltre possibile utilizzare il <xref:System.Diagnostics.Debug.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Debug.Fail1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Debug.Fail1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Debug.Fail1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Svuota il buffer di output e determina la scrittura dei dati del buffer nell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non chiama in modo esplicito <xref:System.Diagnostics.Debug.Flush%2A> o <xref:System.Diagnostics.Debug.Close%2A>. Impostazione <xref:System.Diagnostics.Debug.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.FileStream> chiamato `myFileStream` per scrivere in un file denominato `TestFile.txt`. Nell'esempio viene creato il flusso, apre il file se esistente o crearne una nuova, scrivere una riga di testo nel file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Debug.Close Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Close Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Indent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Indent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Indent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Incrementa la proprietà <see cref="P:System.Diagnostics.Debug.IndentLevel" /> corrente di uno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Unindent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentLevel { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il livello di rientro.</summary>
        <value>Livello di rientro. Il valore predefinito è 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Debug.IndentLevel%2A> proprietà rappresenta il numero di volte in cui il rientro di dimensioni <xref:System.Diagnostics.Debug.IndentSize%2A> viene applicato.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.IndentSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di spazi in un rientro.</summary>
        <value>Numero di spazi in un rientro. Il valore predefinito è quattro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.TextWriterTraceListener> questo numero viene interpretato come spazi. Un <xref:System.Diagnostics.EventLogTraceListener> ignora questo valore.  
  
 Per impostare il <xref:System.Diagnostics.Debug.AutoFlush%2A> e <xref:System.Diagnostics.Debug.IndentSize%2A> per <xref:System.Diagnostics.Debug>, è anche possibile modificare il file di configurazione corrispondente al nome dell'applicazione. Il file di configurazione deve essere formattato come illustrato nell'esempio seguente.  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="true" indentsize="7" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debug.Listeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Listeners As TraceListenerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::TraceListenerCollection ^ Listeners { System::Diagnostics::TraceListenerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di listener che esegue il monitoraggio dell'output di debug.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.TraceListenerCollection" /> che rappresenta un insieme di tipo <see cref="T:System.Diagnostics.TraceListener" /> che esegue il monitoraggio dell'output di debug.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I listener producono output formattato dall'output di debug. Per impostazione predefinita, la raccolta contiene un'istanza di <xref:System.Diagnostics.DefaultTraceListener> classe. Per rimuovere il listener predefinito, chiamare il <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> (metodo) e passare l'istanza del <xref:System.Diagnostics.DefaultTraceListener>. Per reindirizzare l'output alla finestra della console, aggiungere un'istanza di <xref:System.Diagnostics.ConsoleTraceListener>. Per reindirizzare l'output di un file o flusso, aggiungere un'istanza di <xref:System.Diagnostics.TextWriterTraceListener>.  
  
> [!NOTE]
>  Il <xref:System.Diagnostics.Debug.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a una classe viene aggiunto il listener a entrambi.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TextWriterTraceListener> che genera nella finestra della console. Il codice aggiunge quindi il nuovo listener per il <xref:System.Diagnostics.Debug.Listeners%2A>.  
  
 [!code-cpp[Classic Debug.Listeners Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Listeners Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Listeners Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Valore richiesta <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Print">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un messaggio seguito da un terminatore di riga nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da inserire.</param>
        <summary>Scrive un messaggio seguito da un terminatore di riga nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il terminatore di riga predefinito è un ritorno a capo seguito da un avanzamento riga. Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Print(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Print (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato composito che contiene testo combinato con zero o più elementi di formato, che corrispondono agli oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Scrive una stringa formattata seguita da un terminatore di riga nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione in una stringa. Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
 oppure  
  
 Il numero che indica un argomento da formattare è minore di zero oppure maggiore o uguale al numero di oggetti specificati da formattare.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Unindent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unindent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unindent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riduce l'oggetto <see cref="P:System.Diagnostics.Debug.IndentLevel" /> corrente di uno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente imposta il livello di rientro e trasmette i messaggi di debug.  
  
 [!code-cpp[Classic Debug.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Debug.Indent" />
        <altmember cref="P:System.Diagnostics.Debug.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Debug.IndentSize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sul debug nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilizzare il `category` parametro al gruppo di messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.Write(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Utilizzare il `category` parametro al gruppo di messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sul debug nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il valore viene scritto nei listener di traccia nell'insieme.</param>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versioni successive, l'esempio restituisce il nome del parametro del valore per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, viene generato un messaggio sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio viene scritto nei listener di traccia nell'insieme.</param>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio ai listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il nome della categoria e il valore vengono scritti nei listener di traccia nell'insieme.</param>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Verbose`, viene generato il nome del `myObject` e `category` per il <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il nome della categoria e il messaggio vengono scritti nei listener di traccia nell'insieme.</param>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.Write("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sul debug nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, viene generato il nome dell'oggetto nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio seguito da un terminatore di riga nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato composito che contiene testo combinato con zero o più elementi di formato, che corrispondono agli oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Scrive un messaggio formattato seguito da un terminatore di riga nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza il di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione in una stringa.  
  
 La parola chiave nella sintassi per questo metodo implica che la matrice di oggetti può essere un valore singolo. L'eccezione è il <xref:System.String> oggetto. Overload esplicite hanno la precedenza, quindi un `arg` impostazione di una singola stringa predefinita sarà la <xref:System.Diagnostics.Debug.WriteLine%28System.String%2CSystem.String%29?displayProperty=nameWithType> rapporto di overload.  
  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e `category` sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLine2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLine2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sul debug nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il valore viene scritto nei listener di traccia nell'insieme.</param>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, viene generato il nome dell'oggetto nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio viene scritto nei listener di traccia nell'insieme.</param>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio ai listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il nome della categoria e il valore vengono scritti nei listener di traccia nell'insieme.</param>
        <param name="value">Oggetto il cui nome viene inviato ai <see cref="P:System.Diagnostics.Debug.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Debug.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere utilizzato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A?displayProperty=nameWithType> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, viene generato il primo messaggio di errore di <xref:System.Diagnostics.Debug.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Debug.Listeners%2A> insieme, vedere la <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostato su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e `category` sulla stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Debug.WriteLineIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Debug.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione utilizzando <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando viene disattivata, l'analisi perché se <c>mySwitch. TraceError</c> restituisce <see langword="false" />, non è necessario chiamare <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Debug.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e non viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  
  
 Primo esempio:  
  
```csharp  
if(mySwitch.TraceError)   
    Debug.WriteLine("aNumber = " + aNumber + " out of range");  
```  
  
 Secondo esempio:  
  
```csharp  
Debug.WriteLineIf(mySwitch.TraceError, "aNumber = " + aNumber + " out of range");  
```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConsoleTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
  </Members>
</Type>