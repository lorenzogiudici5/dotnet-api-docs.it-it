<Type Name="Trace" FullName="System.Diagnostics.Trace">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e42fd94386357117b180964fe8e0ea782e8fcab0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36674304" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Trace" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Trace extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Trace" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Trace" />
  <TypeSignature Language="C++ CLI" Value="public ref class Trace sealed" />
  <TypeSignature Language="F#" Value="type Trace = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Viene fornita una serie di metodi e proprietà per la tracciatura dell'esecuzione del codice. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare le proprietà e metodi di <xref:System.Diagnostics.Trace> classe alla versione strumento compila. Strumentazione consente di monitorare l'integrità dell'applicazione in esecuzione nelle impostazioni reale. Traccia consente di isolare i problemi e risolverli senza interferire con un sistema in esecuzione.  
  
 Questa classe fornisce metodi per visualizzare un <xref:System.Diagnostics.Trace.Assert%2A> della finestra di dialogo e di generare un'asserzione che verrà sempre <xref:System.Diagnostics.Trace.Fail%2A>. Questa classe fornisce metodi di scrittura nelle variazioni seguenti: <xref:System.Diagnostics.Trace.Write%2A>, <xref:System.Diagnostics.Trace.WriteLine%2A>, <xref:System.Diagnostics.Trace.WriteIf%2A>, e <xref:System.Diagnostics.Trace.WriteLineIf%2A>.  
  
 Il <xref:System.Diagnostics.BooleanSwitch> e <xref:System.Diagnostics.TraceSwitch> classi consentono di controllare in modo dinamico l'output di traccia. È possibile modificare i valori di queste opzioni senza ricompilare l'applicazione. Per informazioni sull'utilizzo del file di configurazione per impostare un'opzione, vedere la <xref:System.Diagnostics.Switch> classe e il [procedura: creare, inizializzare e configurare opzioni di traccia](~/docs/framework/debug-trace-profile/how-to-create-initialize-and-configure-trace-switches.md) argomento.  
  
 È possibile personalizzare la destinazione dell'output di tracciatura aggiungendo <xref:System.Diagnostics.TraceListener> istanze a o la rimozione di istanze dal <xref:System.Diagnostics.Trace.Listeners%2A> insieme. Il <xref:System.Diagnostics.Trace.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e il <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a due classi viene aggiunto il listener a entrambi. Per impostazione predefinita, l'output di traccia viene generato usando il <xref:System.Diagnostics.DefaultTraceListener> classe.  
  
> [!NOTE]
>  Aggiunta di un listener di traccia per il <xref:System.Diagnostics.Trace.Listeners%2A> raccolta può causare un'eccezione generata durante la traccia, se non è disponibile una risorsa utilizzata dal listener di traccia. Le condizioni e l'eccezione generata dipendono il listener di traccia e non può essere enumerate in questo argomento. Può essere utile effettuare le chiamate al <xref:System.Diagnostics.Trace> metodi `try` / `catch` blocchi per rilevare e gestire eventuali eccezioni dal listener di traccia.  
  
> [!NOTE]
>  Se si aggiungono i listener di traccia al codice parzialmente attendibile, si otterrà un'eccezione <xref:System.Security.SecurityException>, perché l'aggiunta dei listener di traccia richiede l'autorizzazione <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>. Per tracciare il codice parzialmente attendibile in esecuzione in una sandbox di Visual Studio, non aggiungere i listener di traccia. Tuttavia è possibile visualizzare il <xref:System.Diagnostics.Trace> e <xref:System.Diagnostics.Debug> i messaggi nella **Output** finestra.  
  
 Il <xref:System.Diagnostics.Trace> classe fornisce proprietà per ottenere o impostare il livello delle <xref:System.Diagnostics.Trace.Indent%2A>, la <xref:System.Diagnostics.Trace.IndentSize%2A>e se si desidera <xref:System.Diagnostics.Trace.AutoFlush%2A> dopo ogni operazione di scrittura.  
  
 Per impostare il <xref:System.Diagnostics.Trace.AutoFlush%2A> e <xref:System.Diagnostics.Trace.IndentSize%2A> per <xref:System.Diagnostics.Trace>, è possibile modificare il file di configurazione che corrisponde al nome dell'applicazione. Il file di configurazione deve essere formattato come nell'esempio seguente:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 Il <xref:System.Diagnostics.ConditionalAttribute> attributo viene applicato ai metodi di <xref:System.Diagnostics.Trace>. I compilatori che supportano <xref:System.Diagnostics.ConditionalAttribute> ignorano le chiamate a questi metodi solo se "TRACE" è stata definita come simbolo di compilazione condizionale. Fare riferimento alla documentazione del compilatore per determinare se <xref:System.Diagnostics.ConditionalAttribute> è supportata e la sintassi per la definizione di un simbolo di compilazione condizionale.  
  
> [!NOTE]
>  Nei progetti di Visual Studio, il simbolo di compilazione condizionale "DEBUG" è per impostazione predefinita definito per le compilazioni di debug, mentre il simbolo "TRACE" è definito sia per le compilazioni di debug che di rilascio. Per informazioni su come disabilitare questo comportamento, vedere la documentazione di Visual Studio.  
  
 Per definire il simbolo di compilazione condizionale "DEBUG" in C#, aggiungere l'opzione `/d:TRACE` alla riga di comando del compilatore durante la compilazione del codice mediante una riga di comando oppure aggiungere `#define TRACE` all'inizio del file. In Visual Basic, aggiungere il `/d:TRACE=True` opzione alla riga di comando del compilatore o aggiungere `#Const TRACE=True` al file.  
  
 <xref:System.Diagnostics.ConditionalAttribute> non è supportato dal compilatore C++. Per fornire una funzionalità equivalente, è necessario racchiudere le chiamate ai metodi della <xref:System.Diagnostics.Trace> in un `#if defined(TRACE) ... #endif` bloccare, quindi aggiungere il `/DTRACE` opzione alla riga di comando del compilatore o aggiungere `#define TRACE` al file.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Diagnostics.Trace> per indicare l'inizio e fine dell'esecuzione del programma. Nell'esempio viene inoltre utilizzata la <xref:System.Diagnostics.Trace.Indent%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.Trace.Unindent%2A?displayProperty=nameWithType> metodi per distinguere l'output di traccia. Per un esempio più esaustivo dell'utilizzo del <xref:System.Diagnostics.Trace>, vedere [procedura: aggiungere istruzioni di traccia al codice dell'applicazione](~/docs/framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md).  
  
 [!code-cpp[Classic Trace Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace Example/CS/source.cs#1)]
 [!code-vb[Classic Trace Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Diagnostics.Debug" />
    <altmember cref="T:System.Diagnostics.Switch" />
    <altmember cref="T:System.Diagnostics.BooleanSwitch" />
    <altmember cref="T:System.Diagnostics.TraceSwitch" />
    <altmember cref="T:System.Diagnostics.TraceListener" />
    <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
    <altmember cref="T:System.Diagnostics.EventLogTraceListener" />
    <altmember cref="T:System.Diagnostics.TraceListenerCollection" />
    <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, vengono generati messaggi e viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Trace.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio di errore non viene inviato e la finestra di messaggio non viene visualizzata.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Trace.Assert%28System.Boolean%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Trace.Assert%28System.Boolean%29> valuta la condizione. Se il risultato è `false`, viene inviato un messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità interfaccia utente, viene visualizzata una finestra di messaggio che mostra lo stack di chiamate con numeri di riga e file. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un indice per una matrice. Viene quindi eseguita un'azione che imposta il valore dell'indice. Successivamente il codice chiama <xref:System.Diagnostics.Trace.Assert%2A> per verificare l'indice valore è valido. Se non è valido, il <xref:System.Diagnostics.Trace.Assert%2A> restituisce lo stack di chiamate.  
  
 [!code-cpp[Classic Trace.Assert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Trace.Assert (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, il messaggio specificato non viene inviato e la finestra di messaggio non viene visualizzata.</param>
        <param name="message">Messaggio da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, genera un messaggio specificato e visualizza una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%29> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità interfaccia utente, viene visualizzata una finestra di messaggio che mostra lo stack di chiamate con numeri di riga e file. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L'esempio seguente viene controllato per verificare che il `type` parametro è valido. Se il `type` passato viene `null`, il <xref:System.Diagnostics.Trace.Assert%2A> genera un messaggio.  
  
 [!code-cpp[Classic Trace.Assert1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Assert(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ message, System::String ^ detailMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string * string -&gt; unit" Usage="System.Diagnostics.Trace.Assert (condition, message, detailMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Espressione condizionale da valutare. Se la condizione è <see langword="true" />, i messaggi specificati non vengono inviati e la finestra di messaggio non viene visualizzata.</param>
        <param name="message">Messaggio da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="detailMessage">Messaggio dettagliato da inviare alla raccolta di <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Controlla una condizione. Se la condizione è <see langword="false" />, vengono generati due messaggi specificati e viene visualizzata una finestra di messaggio contenente lo stack di chiamate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> metodo se si desidera eseguire asserzioni in versione Compila. Il <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> metodo funziona solo nelle build di debug. Per altre informazioni, vedere [asserzioni nel codice gestito](/visualstudio/debugger/assertions-in-managed-code).  
  
 In genere, il <xref:System.Diagnostics.Trace.Assert%28System.Boolean%2CSystem.String%2CSystem.String%29> metodo viene utilizzato per identificare errori logici durante lo sviluppo di programmi. <xref:System.Diagnostics.Trace.Assert%2A> valuta la condizione. Se il risultato è `false`, invia il messaggio di diagnostica specificato e un messaggio dettagliato dal <xref:System.Diagnostics.Trace.Listeners%2A> insieme. È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> , o la rimozione di uno, il <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
 Quando l'applicazione viene eseguita in modalità interfaccia utente, viene visualizzata una finestra di messaggio che mostra lo stack di chiamate con numeri di riga e file. La finestra di messaggio contiene tre pulsanti: **Abort**, **ripetere**, e **ignora**. Fare clic sui **Abort** pulsante consente di terminare l'applicazione. Facendo clic **ripetere** invia il codice nel debugger se l'applicazione è in esecuzione in un debugger o consente di aprire un debugger in caso contrario. Facendo clic **Ignore** continua con l'istruzione successiva nel codice.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio dipende dalla presenza del <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile modificare il comportamento del <xref:System.Diagnostics.DefaultTraceListener> nel file di configurazione che corrisponde al nome dell'applicazione. In questo file, è possibile abilitare e disabilitare la finestra di messaggio assert o impostare il <xref:System.Diagnostics.DefaultTraceListener.LogFileName%2A?displayProperty=nameWithType> proprietà. Il file di configurazione deve essere formattato come segue:  
  
```  
<configuration>  
  <system.diagnostics>  
    <switches>  
      <add name="mySwitch" value="4"/>  
    </switches>  
    <trace autoflush="false" indentsize="4"/>  
    <assert assertuienabled="true" logfilename=".\TraceLog.txt"/>  
  </system.diagnostics>  
</configuration>  
```  
  
   
  
## Examples  
 L'esempio seguente viene controllato per verificare che il `type` parametro è valido. Se il `type` passato viene `null`, il <xref:System.Diagnostics.Trace.Assert%2A> genera un messaggio.  
  
 [!code-cpp[Classic Trace.Assert2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Assert2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Assert2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Assert2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public static bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="System.Diagnostics.Trace.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se chiamare il metodo <see cref="M:System.Diagnostics.Trace.Flush" /> sulla proprietà <see cref="P:System.Diagnostics.Trace.Listeners" /> dopo ogni operazione di scrittura.</summary>
        <value>
          <see langword="true" /> se il metodo <see cref="M:System.Diagnostics.Trace.Flush" /> viene chiamato sulla proprietà <see cref="P:System.Diagnostics.Trace.Listeners" /> dopo ogni operazione di scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito è `false`.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Trace.Flush%2A> o <xref:System.Diagnostics.Trace.Close%2A>. L'impostazione <xref:System.Diagnostics.Trace.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
 Per impostare il <xref:System.Diagnostics.Trace.AutoFlush%2A> e <xref:System.Diagnostics.Trace.IndentSize%2A> per <xref:System.Diagnostics.Trace>, è anche possibile modificare il file di configurazione che corrisponde al nome dell'applicazione. Il file di configurazione deve essere formattato come nell'esempio seguente:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public static void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Close" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Close();" />
      <MemberSignature Language="F#" Value="static member Close : unit -&gt; unit" Usage="System.Diagnostics.Trace.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scarica il buffer di output, quindi chiude l'oggetto <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo quando l'output viene inserito in un file, ad esempio per il <xref:System.Diagnostics.TextWriterTraceListener>.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Trace.Flush%2A> o <xref:System.Diagnostics.Trace.Close%2A>. L'impostazione <xref:System.Diagnostics.Trace.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.StreamWriter> chiamato `myOutputWriter` per scrivere in un file denominato `TestFile.txt`. Nell'esempio viene creato il writer di file, il flusso e testo, scritta una sola riga di testo nel file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Trace.Flush Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Flush Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Flush Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Flush Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationManager">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.CorrelationManager CorrelationManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.CorrelationManager CorrelationManager" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.CorrelationManager" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrelationManager As CorrelationManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::CorrelationManager ^ CorrelationManager { System::Diagnostics::CorrelationManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationManager : System.Diagnostics.CorrelationManager" Usage="System.Diagnostics.Trace.CorrelationManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CorrelationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gestore di correlazioni per il thread per la traccia.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.CorrelationManager" /> associato al thread per la traccia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si tratta di una proprietà avanzata che la maggior parte delle applicazioni non dovrebbero essere occasione da utilizzare.  
  
 Il <xref:System.Diagnostics.CorrelationManager> classe fornisce i metodi utilizzati per archiviare un'identità di operazione logica in un contesto di associazione di thread e contrassegnare automaticamente ogni evento di traccia generata dal thread con l'identità memorizzata.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.CorrelationManager" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Fail">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Genera un messaggio di errore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Fail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Fail : string -&gt; unit" Usage="System.Diagnostics.Trace.Fail message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da generare.</param>
        <summary>Genera il messaggio di errore specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito per il listener di traccia predefinito consiste nell'output il `message` parametro a una finestra di messaggio quando l'applicazione viene eseguita in modalità interfaccia utente e la <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio è dipendente se è presente il <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> a o rimuovendo uno dal <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Trace.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Trace.Fail Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Fail Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Fail Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail Example/VB/source.vb#1)]  
  
 È anche possibile usare il <xref:System.Diagnostics.Trace.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Trace.Fail Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Trace.Fail Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail Example/CS/source.cs#2)]
 [!code-vb[Classic Trace.Fail Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public static void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberSignature Language="F#" Value="static member Fail : string * string -&gt; unit" Usage="System.Diagnostics.Trace.Fail (message, detailMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da generare.</param>
        <param name="detailMessage">Messaggio dettagliato da generare.</param>
        <summary>Genera un messaggio di errore e un messaggio di errore dettagliato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È il comportamento predefinito per il listener di traccia predefinito per l'output il `message` parametro e il `detailedMessage` parametro a una finestra di messaggio quando l'applicazione viene eseguita in modalità interfaccia utente e la <xref:System.Diagnostics.TraceListener> istanze il <xref:System.Diagnostics.Trace.Listeners%2A> raccolta .  
  
> [!NOTE]
>  La visualizzazione della finestra di messaggio è dipendente se è presente il <xref:System.Diagnostics.DefaultTraceListener>. Se il <xref:System.Diagnostics.DefaultTraceListener> non si trova nel <xref:System.Diagnostics.Trace.Listeners%2A> insieme, la finestra di messaggio non viene visualizzata. Il <xref:System.Diagnostics.DefaultTraceListener> può essere rimossa mediante il [ &lt;deselezionare&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/clear-element-for-listeners-for-trace.md), il [ &lt;rimuovere&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/remove-element-for-listeners-for-trace.md), oppure chiamando il <xref:System.Diagnostics.TraceListenerCollection.Clear%2A> metodo sul <xref:System.Diagnostics.Trace.Listeners%2A> proprietà (`System.Diagnostics.Trace.Listeners.Clear()`).  
  
 È possibile personalizzare questo comportamento aggiungendo un <xref:System.Diagnostics.TraceListener> a o rimuovendo uno dal <xref:System.Diagnostics.Trace.Listeners%2A> insieme.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Diagnostics.Trace.Fail%2A> metodo per stampare un messaggio durante la gestione delle eccezioni.  
  
 [!code-cpp[Classic Trace.Fail1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Fail1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Fail1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/VB/source.vb#1)]  
  
 È anche possibile usare il <xref:System.Diagnostics.Trace.Fail%2A> metodo in un'istruzione switch.  
  
 [!code-cpp[Classic Trace.Fail1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Trace.Fail1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/CS/source.cs#2)]
 [!code-vb[Classic Trace.Fail1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Fail1 Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public static void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Flush();" />
      <MemberSignature Language="F#" Value="static member Flush : unit -&gt; unit" Usage="System.Diagnostics.Trace.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Svuota il buffer di output e determina la scrittura dei dati del buffer in <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.Diagnostics.Trace.Flush%2A> o <xref:System.Diagnostics.Trace.Close%2A>. L'impostazione <xref:System.Diagnostics.Trace.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TextWriterTraceListener> denominato `myTextListener`. `myTextListener` Usa un <xref:System.IO.StreamWriter> chiamato `myOutputWriter` per scrivere in un file denominato `TestFile.txt`. Nell'esempio viene creato il writer di file, il flusso e testo, scritta una sola riga di testo nel file e quindi scarica e chiude l'output.  
  
 [!code-cpp[Classic Trace.Flush Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Flush Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Flush Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Flush Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Flush Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public static void Indent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Indent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Indent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Indent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Indent();" />
      <MemberSignature Language="F#" Value="static member Indent : unit -&gt; unit" Usage="System.Diagnostics.Trace.Indent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Incrementa la proprietà <see cref="P:System.Diagnostics.Trace.IndentLevel" /> corrente di uno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Di seguito viene incrementato e decrementato il livello di rientro e trasmette i messaggi di traccia.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Trace.Unindent" />
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="IndentLevel">
      <MemberSignature Language="C#" Value="public static int IndentLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.IndentLevel" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentLevel { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IndentLevel : int with get, set" Usage="System.Diagnostics.Trace.IndentLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il livello di rientro.</summary>
        <value>Livello di rientro. Il valore predefinito è zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Trace.IndentLevel%2A> proprietà rappresenta il numero di volte in cui il rientro di dimensioni <xref:System.Diagnostics.Trace.IndentSize%2A> viene applicato. Questa proprietà viene archiviata in base al singolo thread/richiesta.  
  
   
  
## Examples  
 Di seguito viene incrementato e decrementato il livello di rientro e trasmette i messaggi di traccia.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IndentSize">
      <MemberSignature Language="C#" Value="public static int IndentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 IndentSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.IndentSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property IndentSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int IndentSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IndentSize : int with get, set" Usage="System.Diagnostics.Trace.IndentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di spazi in un rientro.</summary>
        <value>Numero di spazi in un rientro. Il valore predefinito è quattro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.TextWriterTraceListener> questo numero viene interpretato come "spazi". Un <xref:System.Diagnostics.EventLogTraceListener> ignora questo valore.  
  
 Questa proprietà viene archiviata in base al singolo thread/richiesta.  
  
 Per impostare il <xref:System.Diagnostics.Trace.AutoFlush%2A> e <xref:System.Diagnostics.Trace.IndentSize%2A> per <xref:System.Diagnostics.Trace>, è anche possibile modificare il file di configurazione che corrisponde al nome dell'applicazione. Il file di configurazione deve essere formattato come nell'esempio seguente:  
  
```xml  
<configuration>  
  <system.diagnostics>  
    <trace autoflush="false" indentsize="3" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Listeners">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.TraceListenerCollection Listeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Diagnostics.TraceListenerCollection Listeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.Listeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Listeners As TraceListenerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Diagnostics::TraceListenerCollection ^ Listeners { System::Diagnostics::TraceListenerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Listeners : System.Diagnostics.TraceListenerCollection" Usage="System.Diagnostics.Trace.Listeners" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceListenerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di listener che esegue il monitoraggio dell'output di traccia.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.TraceListenerCollection" /> che rappresenta una raccolta di tipo <see cref="T:System.Diagnostics.TraceListener" /> che esegue il monitoraggio dell'output di traccia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I listener producono output formattato dall'output di traccia. Per impostazione predefinita, la raccolta contiene un'istanza di <xref:System.Diagnostics.DefaultTraceListener> classe. Se si desidera rimuovere il listener predefinito, chiamare il <xref:System.Diagnostics.TraceListenerCollection.Remove%2A> metodo e passare l'istanza del <xref:System.Diagnostics.DefaultTraceListener>. Per reindirizzare l'output alla finestra della console, aggiungere un'istanza di <xref:System.Diagnostics.ConsoleTraceListener> classe.  
  
> [!NOTE]
>  Il <xref:System.Diagnostics.Trace.Listeners%2A> insieme è condiviso da entrambi i <xref:System.Diagnostics.Debug> e il <xref:System.Diagnostics.Trace> classi; aggiunta di un listener di traccia a due classi viene aggiunto il listener a entrambi.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Diagnostics.ConsoleTraceListener> che output allo schermo della console. Il codice aggiunge quindi il nuovo listener per il <xref:System.Diagnostics.Trace.Listeners%2A>.  
  
 [!code-cpp[Classic Trace.Listeners Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Listeners Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Listeners Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Listeners Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh();" />
      <MemberSignature Language="F#" Value="static member Refresh : unit -&gt; unit" Usage="System.Diagnostics.Trace.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna i dati configurazione di traccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati di configurazione di traccia acquisiti quando l'applicazione viene avviata. Se i dati di configurazione viene modificati dopo l'applicazione viene avviata, chiamare il <xref:System.Diagnostics.Trace.Refresh%2A> metodo per aggiornare i dati di configurazione di traccia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceError">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sull'errore nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceError">
      <MemberSignature Language="C#" Value="public static void TraceError (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceError(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceError(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceError (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceError(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member TraceError : string -&gt; unit" Usage="System.Diagnostics.Trace.TraceError message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio informativo da inserire.</param>
        <summary>Scrive un messaggio di errore nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando il messaggio specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceError%2A> chiama il `TraceEvent` metodo per ogni listener di traccia, con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Error>, passando il messaggio informativo come stringa del messaggio.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceError">
      <MemberSignature Language="C#" Value="public static void TraceError (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceError(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceError(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceError (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceError(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member TraceError : string * obj[] -&gt; unit" Usage="System.Diagnostics.Trace.TraceError (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato che contiene zero o più elementi di formato, corrispondenti a oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice <see langword="object" /> che contiene zero o più oggetti da formattare.</param>
        <summary>Scrive un messaggio di errore nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando la matrice di oggetti e le informazioni di formattazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceError%2A> chiama il `TraceEvent` metodi nei listener di traccia con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Error>, passando il contenuto del messaggio come matrice di oggetti con le informazioni di formattazione. Vedere la <xref:System.String.Format%2A> metodo per ulteriori informazioni sul `format` e `args` parametri.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceInformation">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un messaggio informativo nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceInformation">
      <MemberSignature Language="C#" Value="public static void TraceInformation (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceInformation(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceInformation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceInformation (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceInformation(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member TraceInformation : string -&gt; unit" Usage="System.Diagnostics.Trace.TraceInformation message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio informativo da inserire.</param>
        <summary>Scrive un messaggio informativo nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando il messaggio specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceInformation%2A> chiama il `TraceEvent` metodo per ogni listener di traccia, con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Information>, passando il messaggio informativo come stringa del messaggio.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceInformation">
      <MemberSignature Language="C#" Value="public static void TraceInformation (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceInformation(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceInformation(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceInformation (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceInformation(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member TraceInformation : string * obj[] -&gt; unit" Usage="System.Diagnostics.Trace.TraceInformation (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato che contiene zero o più elementi di formato, corrispondenti a oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice <see langword="object" /> che contiene zero o più oggetti da formattare.</param>
        <summary>Scrive un messaggio informativo nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando la matrice di oggetti e le informazioni di formattazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceInformation%2A> chiama il `TraceEvent` metodi nei listener di traccia con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Information>, passando il contenuto del messaggio come matrice di oggetti con le informazioni di formattazione. Vedere la <xref:System.String.Format%2A> metodo per ulteriori informazioni sul `format` e `args` parametri.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceWarning">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sull'avviso nei listener di traccia nell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceWarning">
      <MemberSignature Language="C#" Value="public static void TraceWarning (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceWarning(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceWarning(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceWarning (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceWarning(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member TraceWarning : string -&gt; unit" Usage="System.Diagnostics.Trace.TraceWarning message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio informativo da inserire.</param>
        <summary>Scrive un messaggio di avviso nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando il messaggio specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceWarning%2A> chiama il `TraceEvent` metodo per ogni listener di traccia con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Warning>, passando il messaggio informativo come stringa del messaggio.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="TraceWarning">
      <MemberSignature Language="C#" Value="public static void TraceWarning (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TraceWarning(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.TraceWarning(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TraceWarning (format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TraceWarning(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member TraceWarning : string * obj[] -&gt; unit" Usage="System.Diagnostics.Trace.TraceWarning (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato che contiene zero o più elementi di formato, corrispondenti a oggetti nella matrice <c>args</c>.</param>
        <param name="args">Matrice <see langword="object" /> che contiene zero o più oggetti da formattare.</param>
        <summary>Scrive un messaggio di avviso nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> usando la matrice di oggetti e le informazioni di formattazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Trace.TraceWarning%2A> chiama il `TraceEvent` metodi nei listener di traccia con il tipo di evento di traccia <xref:System.Diagnostics.TraceEventType.Warning>, passando il contenuto del messaggio come matrice di oggetti con le informazioni di formattazione. Vedere la <xref:System.String.Format%2A> metodo per ulteriori informazioni sul `format` e `args` parametri.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Unindent">
      <MemberSignature Language="C#" Value="public static void Unindent ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unindent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Unindent" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unindent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unindent();" />
      <MemberSignature Language="F#" Value="static member Unindent : unit -&gt; unit" Usage="System.Diagnostics.Trace.Unindent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riduce l'oggetto <see cref="P:System.Diagnostics.Trace.IndentLevel" /> corrente di uno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Di seguito viene incrementato e decrementato il livello di rientro e trasmette i messaggi di traccia.  
  
 [!code-cpp[Classic Trace.IndentLevel Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.IndentLevel Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.IndentLevel Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.IndentLevel Example/VB/source.vb#1)]  
  
 Questo esempio produce il seguente output:  
  
```  
  
List of errors:  
     Error 1: File not found  
     Error 2: Directory not found  
End of list of errors  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Trace.Indent" />
        <altmember cref="P:System.Diagnostics.Trace.IndentLevel" />
        <altmember cref="P:System.Diagnostics.Trace.IndentSize" />
      </Docs>
    </Member>
    <Member MemberName="UseGlobalLock">
      <MemberSignature Language="C#" Value="public static bool UseGlobalLock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseGlobalLock" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Trace.UseGlobalLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseGlobalLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseGlobalLock { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseGlobalLock : bool with get, set" Usage="System.Diagnostics.Trace.UseGlobalLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se deve essere usato il blocco globale.</summary>
        <value>
          <see langword="true" /> se il blocco globale deve essere usato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il blocco globale viene sempre utilizzato se il listener di traccia non è thread-safe, indipendentemente dal valore di <xref:System.Diagnostics.Trace.UseGlobalLock%2A>. Il <xref:System.Diagnostics.TraceListener.IsThreadSafe%2A> proprietà viene utilizzata per determinare se il listener è thread-safe. Il blocco globale non viene usato solo se il valore di <xref:System.Diagnostics.Trace.UseGlobalLock%2A> viene `false` e il valore di <xref:System.Diagnostics.TraceListener.IsThreadSafe%2A> è `true`. Il comportamento predefinito consiste nell'utilizzare il blocco globale.  
  
 Per impostare il <xref:System.Diagnostics.Trace.UseGlobalLock%2A> per <xref:System.Diagnostics.Trace>, è anche possibile modificare il file di configurazione che corrisponde al nome dell'applicazione. Il file di configurazione deve essere formattato come nell'esempio seguente:  
  
```  
<configuration>  
  <system.diagnostics>  
    <trace useGlobalLock="false" />  
  </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con codice non gestito. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumerazione associata:  <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sulla traccia nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Diagnostics.Trace.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
> [!NOTE]
>  ASP.NET fornisce funzionalità di traccia personalizzate per le pagine Web. Per scrivere i messaggi di traccia nelle pagine ASP.NET, usare il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà.  
  
 Per impostazione predefinita, nel codice associato a una pagina Web ASP.NET, l'istruzione `Trace.Write("...")` è una chiamata ai <xref:System.Web.TraceContext.Write%2A> metodo il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà. Usare la <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe nelle pagine Web, è necessario includere lo spazio dei nomi, ad esempio, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Error` o versioni successive, l'esempio restituisce il nome del `value` parametro per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito un messaggio sulla stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.Write1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Diagnostics.Trace.Write message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
> [!NOTE]
>  ASP.NET fornisce funzionalità di traccia personalizzate per le pagine Web. Per scrivere i messaggi di traccia nelle pagine ASP.NET, usare il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà.  
  
 Per impostazione predefinita, nel codice associato a una pagina Web ASP.NET, l'istruzione `Trace.Write("...")` è una chiamata ai <xref:System.Web.TraceContext.Write%2A> metodo il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà. Usare la <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe nelle pagine Web, è necessario includere lo spazio dei nomi, ad esempio, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Un terminatore di riga segue il secondo messaggio.  
  
 [!code-cpp[Classic Trace.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member Write : obj * string -&gt; unit" Usage="System.Diagnostics.Trace.Write (value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Un nome dell'oggetto <see cref="T:System.Object" /> viene inviato all'oggetto <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
> [!NOTE]
>  ASP.NET fornisce funzionalità di traccia personalizzate per le pagine Web. Per scrivere i messaggi di traccia nelle pagine ASP.NET, usare il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà.  
  
 Per impostazione predefinita, nel codice associato a una pagina Web ASP.NET, l'istruzione `Trace.Write("...")` è una chiamata ai <xref:System.Web.TraceContext.Write%2A> metodo il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà. Usare la <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe nelle pagine Web, è necessario includere lo spazio dei nomi, ad esempio, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il nome del `myObject` e il `category` per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.Write3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.Write(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member Write : string * string -&gt; unit" Usage="System.Diagnostics.Trace.Write (message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
> [!NOTE]
>  ASP.NET fornisce funzionalità di traccia personalizzate per le pagine Web. Per scrivere i messaggi di traccia nelle pagine ASP.NET, usare il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà.  
  
 Per impostazione predefinita, nel codice associato a una pagina Web ASP.NET, l'istruzione `Trace.Write("...")` è una chiamata ai <xref:System.Web.TraceContext.Write%2A> metodo il <xref:System.Web.UI.Page.Trace%2A?displayProperty=nameWithType> proprietà. Usare la <xref:System.Diagnostics.Trace?displayProperty=nameWithType> classe nelle pagine Web, è necessario includere lo spazio dei nomi, ad esempio, `System.Diagnostics.Trace.Write("...")`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.Write2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sulla traccia nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * obj -&gt; unit" Usage="System.Diagnostics.Trace.WriteIf (condition, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versioni successive, l'esempio restituisce il nome del parametro del valore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito un messaggio sulla stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteIf (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio ai listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * obj * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteIf (condition, value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata sul <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il nome del `myObject` e il `category` per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteIf">
      <MemberSignature Language="C#" Value="public static void WriteIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteIf : bool * string * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteIf (condition, message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.Write%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Verbose`, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Error` o superiore, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.Write(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. Write ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sulla traccia nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Diagnostics.Trace.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il nome dell'oggetto nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLine1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLine message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.Write Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.Write Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.Write Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.Write Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.Write Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLine (value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLine3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLine (message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e il `category` sulla stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLine2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLine2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLine2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLine2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineIf">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni sulla traccia nei listener di traccia dell'insieme <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * obj -&gt; unit" Usage="System.Diagnostics.Trace.WriteLineIf (condition, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <summary>Scrive il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il nome dell'oggetto nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLineIf (condition, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="message">Messaggio da scrivere.</param>
        <summary>Scrive un messaggio ai listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteIf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteIf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteIf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteIf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, object value, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, object value, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, value As Object, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::Object ^ value, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * obj * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLineIf (condition, value, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="value">Oggetto <see cref="T:System.Object" /> il cui nome viene inviato a <see cref="P:System.Diagnostics.Trace.Listeners" />.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e il valore del metodo <see cref="M:System.Object.ToString" /> dell'oggetto nei listener di traccia nella raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore nella stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteLineIf">
      <MemberSignature Language="C#" Value="public static void WriteLineIf (bool condition, string message, string category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLineIf(bool condition, string message, string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLineIf (condition As Boolean, message As String, category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLineIf(bool condition, System::String ^ message, System::String ^ category);" />
      <MemberSignature Language="F#" Value="static member WriteLineIf : bool * string * string -&gt; unit" Usage="System.Diagnostics.Trace.WriteLineIf (condition, message, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.TraceSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("TRACE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <see langword="true" /> per fare in modo che venga scritto un messaggio; in caso contrario, <see langword="false" />.</param>
        <param name="message">Messaggio da scrivere.</param>
        <param name="category">Nome di categoria usato per organizzare l'output.</param>
        <summary>Scrive un nome di categoria e un messaggio nei listener di traccia della raccolta <see cref="P:System.Diagnostics.Trace.Listeners" /> se una condizione è <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, l'output viene scritto in un'istanza di <xref:System.Diagnostics.DefaultTraceListener>.  
  
 Il `category` parametro può essere usato per raggruppare i messaggi di output.  
  
 Questo metodo chiama il <xref:System.Diagnostics.TraceListener.WriteLine%2A> metodo del listener di traccia.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Diagnostics.TraceSwitch> denominato `generalSwitch`. Questa opzione è impostata all'esterno di esempio di codice.  
  
 Se l'opzione è impostata il <xref:System.Diagnostics.TraceLevel> `Error` o versione successiva, nell'esempio viene restituito il primo messaggio di errore per il <xref:System.Diagnostics.Trace.Listeners%2A>. Per informazioni sull'aggiunta di un listener per il <xref:System.Diagnostics.Trace.Listeners%2A> insieme, vedere il <xref:System.Diagnostics.TraceListenerCollection> classe.  
  
 Quindi, se il <xref:System.Diagnostics.TraceLevel> è impostata su `Verbose`, nell'esempio viene restituito il secondo messaggio di errore e il `category` sulla stessa riga del primo messaggio. Il secondo messaggio è seguito da un terminatore di riga.  
  
 [!code-cpp[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/CS/source.cs#1)]
 [!code-vb[Classic Trace.WriteLineIf2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Trace.WriteLineIf2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile ridurre al minimo la riduzione delle prestazioni di strumentazione dell'applicazione tramite <see langword="If...Then" /> istruzioni anziché <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" /> istruzioni. I seguenti due esempi di codice inviare lo stesso messaggio di debug. Tuttavia, il primo esempio è molto più veloce quando la traccia è disattivata, perché se <c>mySwitch. TraceError</c> restituisca <see langword="false" /> non è necessario chiamare <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)" />. Nel secondo esempio viene chiamato sempre <see cref="M:System.Diagnostics.Trace.WriteLineIf(System.Boolean,System.String)" />, anche quando <c>mySwitch. TraceError</c> è <see langword="false" /> e viene prodotto alcun output di traccia. Ciò può comportare inutile esecuzione di codice arbitrariamente complesso.  * * Primo esempio * * ' ' if(mySwitch.TraceError) Trace. WriteLine ("un numero =" + un numero + "compreso nell'intervallo"); ' ' * * Secondo esempio * * ' ' Trace. WriteLineIf (mySwitch. TraceError, "un numero =" + un numero + "compreso nell'intervallo"); ```</para>
        </block>
        <altmember cref="T:System.Diagnostics.Debug" />
        <altmember cref="T:System.Diagnostics.Trace" />
        <altmember cref="T:System.Diagnostics.BooleanSwitch" />
        <altmember cref="T:System.Diagnostics.TraceSwitch" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:System.Diagnostics.DefaultTraceListener" />
        <altmember cref="T:System.Diagnostics.ConditionalAttribute" />
      </Docs>
    </Member>
  </Members>
</Type>