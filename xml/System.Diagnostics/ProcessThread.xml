<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cbfbcc77256bd34443df230f42cc12dddc55633e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399675" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un thread di processo del sistema operativo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Diagnostics.ProcessThread> per ottenere informazioni su un thread attualmente in esecuzione nel sistema. In questo modo, ad esempio, si consente al monitoraggio delle prestazioni del thread.  
  
> [!IMPORTANT]
>  Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Un thread è un percorso di esecuzione tramite un programma. È la più piccola unità di esecuzione in Win32. È costituito da uno stack, lo stato di registri della CPU e una voce nell'elenco di esecuzione dell'utilità di pianificazione del sistema.  
  
 Un processo è costituito da uno o più thread e il codice, dati e altre risorse di un programma in memoria. Risorse programma tipici sono file aperti, semafori e memoria allocata in modo dinamico. Ogni risorsa di un processo è condiviso da tutti i thread del processo.  
  
 Un programma viene eseguito quando l'utilità di pianificazione di sistema offre il controllo dell'esecuzione di uno dei thread del programma. L'utilità di pianificazione determina quali thread deve essere eseguito e quando. Un thread con priorità inferiore che si debba attendere thread con priorità superiore completare le attività. Nei computer multiprocessore, l'utilità di pianificazione può spostare singoli thread a processori diversi, pertanto il bilanciamento del carico della CPU.  
  
 Ogni processo viene avviato con un singolo thread, è noto come il thread principale. Qualsiasi thread può creare thread aggiuntivi. Tutti i thread all'interno di un processo di condividono lo spazio degli indirizzi del processo.  
  
 Il thread principale non è necessariamente contenuto nel primo indice nella raccolta.  
  
> [!NOTE]
>  A partire da .NET Framework versione 2.0, è stata eliminata la possibilità di dati del contatore prestazioni di riferimento in altri computer per la maggior parte dei metodi di .NET Framework e delle proprietà. Questa modifica è stata apportata per migliorare le prestazioni e per consentire a utenti non amministratori di utilizzare la <xref:System.Diagnostics.ProcessThread> classe. Di conseguenza, alcune applicazioni che non generavano eccezioni nelle versioni precedenti di .NET Framework a questo punto è possibile che venga visualizzato un <xref:System.NotSupportedException>. I metodi e le proprietà interessate sono troppo numerosi da essere elencati in questa pagina, ma le informazioni sull'eccezione è stato aggiunto per gli argomenti di membri interessati.  
  
 Il thread di un processo vengono eseguiti singolarmente e non sono consapevoli di altra a meno che non si renderle visibili tra loro. Thread che condividono risorse comuni, tuttavia, deve coordinare il proprio lavoro tramite i semafori o un altro metodo di comunicazione interprocesso.  
  
 Per ottenere una raccolta di tutti i <xref:System.Diagnostics.ProcessThread> gli oggetti associati al processo corrente, il <xref:System.Diagnostics.Process.Threads%2A> proprietà del <xref:System.Diagnostics.Process> istanza.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la priorità base del thread.</summary>
        <value>La priorità base del thread, calcolata dal sistema operativo combinando la classe di priorità del processo con il livello di priorità del thread associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessThread.BasePriority%2A> rappresenta la priorità iniziale del thread di processo. È possibile visualizzare informazioni sulla priorità base attraverso contatore di Base di priorità del Monitor di sistema.  
  
 Il sistema operativo calcola la priorità base di un thread combinando l'intervallo di livelli di priorità del thread con la classe di priorità del processo. È possibile impostare il processo <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> uno dei valori di proprietà di <xref:System.Diagnostics.ProcessPriorityClass> enumerazione, che sono <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. È possibile impostare il thread <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> proprietà a un intervallo di valori che delimita le priorità di base del thread. Win32 utilizza quattro classi di priorità con sette livelli di priorità di base per ogni classe.  
  
 La priorità del thread corrente potrebbe deviare dalla priorità di base. Ad esempio, è possibile modificare il sistema operativo di <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> proprietà in base al tempo trascorso o altri quando un processo deve essere incrementi per l'accesso al processore. Inoltre, è possibile impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> proprietà per impedire al sistema di aumentare temporaneamente la priorità di un thread ogni volta che il processo viene eseguito dallo stato di attesa. La priorità viene reimpostata quando il processo ritorna allo stato di attesa.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la priorità corrente del thread.</summary>
        <value>La priorità corrente del thread, che potrebbe essere diversa da quella di base a seconda del modo in cui il sistema operativo pianifica il thread. La priorità può essere temporaneamente aumentata per un thread attivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La priorità del thread corrente potrebbe deviare dalla priorità di base. Ad esempio, è possibile modificare il sistema operativo di <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> proprietà in base al tempo trascorso o altri, quando un processo deve essere incrementi per l'accesso al processore. Inoltre, è possibile impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> proprietà per impedire al sistema di aumentare temporaneamente la priorità di un thread ogni volta che il processo viene eseguito dallo stato di attesa. La priorità viene reimpostata quando il processo ritorna allo stato di attesa.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore univoco del thread.</summary>
        <value>L'identificatore univoco associato a uno specifico thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo riutilizza i numeri di identificazione di thread, che identificano i thread solo durante la relativa durata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta il processore preferenziale su cui eseguire questo thread.</summary>
        <value>Il processore preferenziale del thread, utilizzato quando il sistema pianifica i thread, per determinare il processore su cui eseguirlo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> valore è in base zero.  In altre parole, per impostare l'affinità di thread per il primo processore, impostare la proprietà su zero.  
  
 Il sistema pianifica thread sui rispettivi processori preferenziali, laddove possibile.  
  
 Un thread di processo è possibile eseguire la migrazione da un processore, con ogni migrazione il ricaricamento di cache del processore. Specifica di un processore di un thread di migliorare le prestazioni con carichi elevati del sistema, riducendo il numero di volte in cui che la cache del processore viene ricaricata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> proprietà per un'istanza del blocco note al primo processore.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Il sistema non è stato in grado di impostare l'avvio del thread sul processore specificato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il sistema operativo deve incrementare temporaneamente la priorità del thread associato ogni volta che la finestra principale del processo del thread diventa attiva.</summary>
        <value>
          <see langword="true" /> per incrementare la priorità del thread quando l'utente interagisce con l'interfaccia del processo; in caso contrario, <see langword="false" /> . Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> è `true`, il sistema incrementa temporaneamente la priorità del thread quando il processo associato viene eseguito dallo stato di attesa. Questa azione impedisce ad altri processi di interrompere l'elaborazione del thread corrente. Il <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> impostazione influisce su tutti i thread esistenti, nonché qualsiasi thread successivamente creato dal processo. Per ripristinare il funzionamento normale, impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> proprietà `false`.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> ha effetto solo quando il thread è in esecuzione in un processo che ha un <xref:System.Diagnostics.Process.PriorityClass%2A> impostato su uno dei valori di enumerazione priorità dinamica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  Aumento eccessivo della priorità può sottrarre risorse essenziali del sistema operativo e di rete. Ciò potrebbe causare problemi con le altre attività del sistema operativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare le informazioni sull'incremento di priorità.  
  
 oppure  
  
 Non è possibile impostare le informazioni sull'incremento di priorità.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il livello di priorità del thread.</summary>
        <value>Uno dei valori di <see cref="T:System.Diagnostics.ThreadPriorityLevel" />, che specifica un intervallo nel quale rientra la priorità del thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il livello di priorità non è un singolo valore, ma piuttosto un intervallo di valori. Il sistema operativo calcola la priorità del thread base tramite il processo <xref:System.Diagnostics.Process.PriorityClass%2A> per scegliere un valore dall'intervallo specificato nella <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare le informazioni sul livello di priorità del thread.  
  
 oppure  
  
 Non è possibile impostare il livello di priorità del thread.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'intervallo di tempo che il thread ha impiegato nell'esecuzione del codice all'interno del nucleo centrale del sistema operativo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica l'intervallo di tempo impiegato dal thread nell'esecuzione del codice all'interno del nucleo centrale del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Usa i meccanismi di protezione diversi e alla radice di tutti è la distinzione tra modalità utente e privilegiata. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corrisponde alla quantità di tempo impiegato per l'applicazione è in esecuzione in modalità privilegiata all'interno del sistema operativo. Il <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> proprietà indica la quantità di tempo che l'applicazione richiesta per l'esecuzione di codice in modalità utente, all'esterno del sistema.  
  
 Modalità utente limita l'applicazione in due modi principali. In primo luogo, l'applicazione non può accedere direttamente le periferiche, ma è necessario chiamare invece il nucleo centrale del sistema operativo per ottenere o impostare i dati delle periferiche. Il sistema operativo può quindi garantire che un'applicazione non comporta l'eliminazione delle periferiche dati necessari da un altro. In secondo luogo, l'applicazione non è possibile leggere o modificare i dati che gestisce il sistema operativo stesso. Questa restrizione impedisce alle applicazioni di base di danneggiare inavvertitamente o intenzionalmente. Se il sistema operativo per eseguire un'operazione, necessari per l'applicazione chiama una delle routine del sistema. Molte di queste passano alla modalità privilegiata, eseguire l'operazione e ritornano in modalità utente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare l'intervallo di tempo del thread.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta il processore sul quale può essere eseguito il thread associato.</summary>
        <value>Un oggetto <see cref="T:System.IntPtr" /> che punta a un insieme di bit, ciascuno dei quali rappresenta un processore sul quale può essere eseguito il thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'affinità del processore di un thread è il set di processori che dispone di una relazione. In altre parole, i documenti che possono essere pianificato per l'esecuzione.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> rappresenta ogni processore sotto forma di bit. Bit 0 rappresenta il processore uno, il bit 1 processore due e così via. Nella tabella seguente viene illustrato un subset di possibili <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> per un sistema a quattro processori.  
  
|Valore della proprietà (in esadecimale)|Processori validi|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 o 2|  
|0x0004|3|  
|0x0005|1 o 3|  
|0x0007|1, 2 o 3|  
|0x000F|1, 2, 3 o 4|  
  
 È inoltre possibile specificare il singolo processore preferito per un thread impostando il <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> proprietà. Un thread di processo è possibile eseguire la migrazione da un processore, con ogni migrazione il ricaricamento di cache del processore. Specifica di un processore di un thread di migliorare le prestazioni con carichi elevati del sistema, riducendo il numero di volte in cui che la cache del processore viene ricaricata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> proprietà per un'istanza del blocco note al primo processore.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile impostare l'affinità dei processori.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta il processore ideale di questo thread a indicare che non è presente un singolo processore ideale. In altre parole, ogni altro processore può essere ideale.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile reimpostare il processore ideale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'indirizzo di memoria della funzione chiamata dal sistema operativo per l'avvio di questo thread.</summary>
        <value>L'indirizzo iniziale del thread, che punta alla funzione definita dall'applicazione eseguita dal thread.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni processo viene avviato con un singolo thread, è noto come il thread principale. Qualsiasi thread può creare thread aggiuntivi.  
  
 Un processo ha uno spazio degli indirizzi virtuali, codice eseguibile, dati, handle dell'oggetto, le variabili di ambiente, una priorità base e minima e massima del working set. Tutti i thread di un processo di condividono le risorse di sistema e spazio di indirizzi virtuali. Inoltre, ogni thread gestisce i gestori di eccezioni, una priorità di pianificazione e un set di strutture in cui verrà salvata nel contesto del thread, mentre il thread è in attesa di essere pianificati. Nel contesto del thread include l'insieme di registri del computer, lo stack del kernel, un blocco di ambiente del thread e uno stack utente nello spazio degli indirizzi del processo del thread.  
  
 Ogni thread di Windows effettivamente inizia l'esecuzione in una funzione di sistema, non la funzione fornita dall'applicazione. L'indirizzo iniziale per il thread principale è, di conseguenza, lo stesso (come rappresenta l'indirizzo della funzione di sistema) per ogni processo di Windows nel sistema. Tuttavia, il <xref:System.Diagnostics.ProcessThread.StartAddress%2A> proprietà consente di ottenere l'indirizzo iniziale di funzione specifica per l'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui il sistema operativo ha iniziato il thread.</summary>
        <value>Un oggetto <see cref="T:System.DateTime" /> che rappresenta l'ora di sistema al momento dell'avvio del thread da parte del sistema operativo.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare l'intervallo di tempo del thread.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo stato corrente di questo thread.</summary>
        <value>Un oggetto <see cref="T:System.Diagnostics.ThreadState" /> che indica lo stato del thread, ad esempio in esecuzione, in attesa o completato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessThread.WaitReason%2A> valore della proprietà è valida solo quando il <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valore <xref:System.Diagnostics.ThreadState.Wait>. Di conseguenza, verificare il <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valore prima di ottenere il <xref:System.Diagnostics.ProcessThread.WaitReason%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità totale di tempo impiegata da questo thread nell'utilizzo del processore.</summary>
        <value>Un oggetto <see cref="T:System.TimeSpan" /> che indica la quantità di tempo in base alla quale il thread ha avuto il controllo del processore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> proprietà indica la quantità totale di tempo che il sistema ha eseguito il thread dallo stato di attesa e assegnare priorità in qualsiasi processore. In un sistema multiprocessore, questo valore comprende tempo impiegato per ogni processore, se il thread usato più di un processore.  
  
 Il <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> proprietà è la somma del <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> e <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare l'intervallo di tempo del thread.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di tempo che il thread associato ha impiegato nell'esecuzione del codice all'interno dell'applicazione.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal thread nell'esecuzione del codice all'interno dell'applicazione, rispetto all'esecuzione all'interno del nucleo centrale del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT utilizza meccanismi di protezione diversi e alla radice di tutti è la distinzione tra modalità utente e privilegiata. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> corrisponde alla quantità di tempo impiegato per l'applicazione è in esecuzione in modalità utente, di fuori del sistema operativo. Il <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corrisponde alla quantità di tempo che l'applicazione richiesta per l'esecuzione di codice in modalità privilegiata, all'interno del sistema.  
  
 Modalità utente limita l'applicazione in due modi principali. In primo luogo, l'applicazione non può accedere direttamente le periferiche, ma è necessario chiamare invece il nucleo centrale del sistema operativo per ottenere o impostare i dati delle periferiche. Il sistema operativo può quindi garantire che un'applicazione non comporta l'eliminazione delle periferiche dati necessari da un altro. In secondo luogo, l'applicazione non è possibile leggere o modificare i dati che gestisce il sistema operativo stesso. Questa restrizione impedisce alle applicazioni di base di danneggiare inavvertitamente o intenzionalmente. Se il sistema operativo per eseguire un'operazione, necessari per l'applicazione chiama una delle routine del sistema. Molte di queste passano alla modalità privilegiata, eseguire l'operazione e ritornano in modalità utente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile recuperare l'intervallo di tempo del thread.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il motivo per cui il thread è in attesa.</summary>
        <value>Un oggetto <see cref="T:System.Diagnostics.ThreadWaitReason" /> che rappresenta il motivo per il quale il thread è nello stato di attesa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessThread.WaitReason%2A> proprietà è valida solo quando il <xref:System.Diagnostics.ProcessThread.ThreadState%2A> è <xref:System.Diagnostics.ThreadState.Wait>. Di conseguenza, verificare il <xref:System.Diagnostics.ProcessThread.ThreadState%2A> valore prima di ottenere il <xref:System.Diagnostics.ProcessThread.WaitReason%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il thread non è nello stato di attesa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Il processo è eseguito su un computer remoto.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>