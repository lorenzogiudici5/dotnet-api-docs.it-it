<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9d100a5bf53ebda6b29682bac284d4cbf695a7fd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620425" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un controllo che fornisce una barra di scorrimento con un oggetto <see cref="T:System.Windows.Controls.Primitives.Thumb" /> scorrevole la cui posizione corrisponde a un valore.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La figura seguente mostra un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo.  
  
 ![Illustrazione di ScrollBar](~/add/media/scrollbar-illustration.JPG "illustrazione di Scrollbar")  
  
 Il <xref:System.Windows.Controls.Primitives.ScrollBar> controllo contiene un <xref:System.Windows.Controls.Primitives.Track> controllo. Il <xref:System.Windows.Controls.Primitives.Track> controllo costituito da un <xref:System.Windows.Controls.Primitives.Thumb> controllo e due <xref:System.Windows.Controls.Primitives.RepeatButton> controlli. È possibile aumentare e ridurre il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> proprietà del <xref:System.Windows.Controls.Primitives.ScrollBar> controllo premendo il <xref:System.Windows.Controls.Primitives.RepeatButton> controlla o spostando il <xref:System.Windows.Controls.Primitives.Thumb>. L'intervallo predefinito di valori per il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> proprietà è compreso tra 0 e 1. Il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> rappresenta la distanza lineare del <xref:System.Windows.Controls.Primitives.Thumb> tra gli endpoint del <xref:System.Windows.Controls.Primitives.ScrollBar>. È possibile modificare l'intervallo di valori predefinito impostando il <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> e <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> proprietà. Il <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> proprietà determina se il <xref:System.Windows.Controls.Primitives.ScrollBar> viene visualizzato orizzontalmente o verticalmente, ed è necessario definire questa proprietà per il <xref:System.Windows.Controls.Primitives.ScrollBar> controllo venga visualizzato.  
  
 Il <xref:System.Windows.Controls.Primitives.Track> in un <xref:System.Windows.Controls.Primitives.ScrollBar> è orientato in modo che i valori aumentano dall'alto verso il basso per un oggetto verticale <xref:System.Windows.Controls.Primitives.ScrollBar> o da sinistra a destra per un oggetto orizzontale <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Il <xref:System.Windows.Controls.Primitives.Track> proprietà nella tabella seguente sono illustrate le destinazioni di associazione per il corrispondente <xref:System.Windows.Controls.Primitives.ScrollBar> proprietà quando il <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> proprietà non è definita in modo esplicito. Se si definisce in modo esplicito il <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> proprietà, l'associazione non viene eseguito.  
  
|Proprietà <xref:System.Windows.Controls.Primitives.Track>|Proprietà <xref:System.Windows.Controls.Primitives.ScrollBar>|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 È possibile accedere il <xref:System.Windows.Controls.Primitives.Track> controllo di un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo utilizzando il <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> proprietà.  
  
 Per visualizzare <xref:System.Windows.UIElement> contenuto all'interno di una casella con barre di scorrimento, utilizzare il <xref:System.Windows.Controls.ScrollViewer> controllo.  
  
## <a name="customizing-the-scrollbar-control"></a>Personalizzazione del controllo barra di scorrimento  
 Per applicare le stesse impostazioni di proprietà a più <xref:System.Windows.Controls.Primitives.ScrollBar> controlli, utilizzare il <xref:System.Windows.FrameworkElement.Style%2A> proprietà. È possibile modificare il valore predefinito <xref:System.Windows.Controls.ControlTemplate> per fornire al controllo un aspetto univoco. Per ulteriori informazioni sulla creazione di un <xref:System.Windows.Controls.ControlTemplate>, vedere [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Per visualizzare le parti e stati specifici di <xref:System.Windows.Controls.Primitives.ScrollBar>, vedere [stili e modelli ScrollBar](~/docs/framework/wpf/controls/scrollbar-styles-and-templates.md).  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione.  Per ulteriori informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  L'impostazione di una proprietà visiva può avere effetto solo se tale proprietà è sia presente nel <xref:System.Windows.Controls.Primitives.ScrollBar> controllo del modello predefinito e viene impostata tramite una. È possibile trovare un elenco di proprietà visive nella sezione "Modifica la struttura Visual di un controllo" [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un oggetto orizzontale <xref:System.Windows.Controls.Primitives.ScrollBar> che dispone di un intervallo di valori compreso tra 0 e 100.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che notifica a <see cref="T:System.Windows.Controls.ScrollViewer" /> che l'utente sta trascinando <see cref="T:System.Windows.Controls.Primitives.Thumb" /> dell'oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> orizzontale sul valore fornito in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'utente trascina il cursore di un <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> chiamate <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> per il <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand>. Se <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituisce `true`, <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il comando.  Se <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituisce `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand>.  
  
 Il <xref:System.Windows.Controls.ScrollViewer> utilizza questo comando per abilitare lo scorrimento posticipato. Quando <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> è `true` e l'utente trascina il <xref:System.Windows.Controls.Primitives.Thumb> del <xref:System.Windows.Controls.Primitives.ScrollBar>, il contenuto del <xref:System.Windows.Controls.ScrollViewer> rimane invariato fino a quando l'utente rilascia il <xref:System.Windows.Controls.Primitives.Thumb>. Se è abilitato lo scorrimento posticipato, il <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> per un oggetto orizzontale <xref:System.Windows.Controls.Primitives.ScrollBar> quando l'utente trascina il <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che notifica a <see cref="T:System.Windows.Controls.ScrollViewer" /> che l'utente sta trascinando l'oggetto <see cref="T:System.Windows.Controls.Primitives.Thumb" /> dell'oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale sul valore fornito in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'utente trascina il cursore di un <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> chiamate <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> per il <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand>. Se <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituisce `true`, <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il comando.  Se <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituisce `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand>.  
  
 Il <xref:System.Windows.Controls.ScrollViewer> utilizza questo comando per abilitare lo scorrimento posticipato. Quando <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> è `true` e l'utente trascina il <xref:System.Windows.Controls.Primitives.Thumb> del <xref:System.Windows.Controls.Primitives.ScrollBar>, il contenuto del <xref:System.Windows.Controls.ScrollViewer> rimane invariato fino a quando l'utente rilascia il <xref:System.Windows.Controls.Primitives.Thumb>. Se è abilitato lo scorrimento posticipato, il <xref:System.Windows.Controls.Primitives.ScrollBar> esegue il <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> per un oggetto verticale <xref:System.Windows.Controls.Primitives.ScrollBar> quando l'utente trascina il <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> è abilitata.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> è abilitato in un oggetto <see cref="T:System.Windows.Controls.ScrollViewer" /> e la dimensione del contenuto è maggiore dell'area di visualizzazione, in caso contrario <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione imposta <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> a `true` solo se il <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> valore il <xref:System.Windows.Controls.Primitives.ScrollBar> è maggiore del <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> valore e <xref:System.Windows.Controls.Primitives.ScrollBar> è abilitata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di poco nella direzione verticale di valore crescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il tasto freccia giù.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.LineDownCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di poco nella direzione orizzontale di valore decrescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando riduce la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme sinistra <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.LineLeftCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di poco nella direzione orizzontale di valore crescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il diritto <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.LineRightCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di poco nella direzione verticale di valore decrescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando consente di ridurre il <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il tasto freccia su.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.LineUpCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea la struttura ad albero visuale per <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione imposta inoltre il <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> proprietà per il <xref:System.Windows.Controls.Primitives.Track> definito nel <xref:System.Windows.Controls.Primitives.ScrollBar> modello.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione delle classi per l'evento <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> che viene generato quando l'oggetto <see cref="T:System.Windows.Controls.ContextMenu" /> di un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> viene chiuso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Controls.ContextMenu> di un <xref:System.Windows.Controls.Primitives.ScrollBar> fornisce opzioni per la modifica di <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> del <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione delle classi per l'evento <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> che viene generato quando l'oggetto <see cref="T:System.Windows.Controls.ContextMenu" /> di un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> viene aperto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Controls.ContextMenu> di un <xref:System.Windows.Controls.Primitives.ScrollBar> fornisce opzioni per la modifica di <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> del <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> per questo controllo <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> per il controllo <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifica di questa implementazione il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> del <xref:System.Windows.Controls.Primitives.ScrollBar> alla posizione del <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> evento che si verifica quando l'utente preme il tasto MAIUSC. L'evento viene gestito mediante l'impostazione <xref:System.Windows.RoutedEventArgs.Handled%2A> nei dati dell'evento `e` a `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione salva la posizione di clic del mouse in modo che il <xref:System.Windows.Controls.Primitives.ScrollBar> può scorrere in tale posizione in risposta a un <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand>.  
  
   
  
## Examples  
 Oggetto <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> si verifica quando l'utente seleziona **scorrimento qui** dal menu visualizzato quando l'utente preme il pulsante destro del mouse su di <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> viene visualizzato in orizzontale o in verticale.</summary>
        <value>Valore dell'enumerazione <see cref="T:System.Windows.Controls.Orientation" /> che stabilisce se il controllo <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> viene visualizzato in orizzontale o in verticale. Il valore predefinito è <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> proprietà per un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo.  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di molto nella direzione verticale di valore crescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il tasto PGGIÙ.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.PageDownCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di molto nella direzione orizzontale di valore decrescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando riduce la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il pulsante della è a sinistra della pagina di <xref:System.Windows.Controls.Primitives.Thumb>. Nella figura seguente mostra i pulsanti di pagina in un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Le diverse parti di una barra di scorrimento](~/add/media/scrollbarpagebutton.png "le diverse parti di una barra di scorrimento")  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.PageLeftCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di molto nella direzione orizzontale di valore crescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il pulsante della a destra della pagina di <xref:System.Windows.Controls.Primitives.Thumb>. Nella figura seguente mostra i pulsanti di pagina in un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Le diverse parti di una barra di scorrimento](~/add/media/scrollbarpagebutton.png "le diverse parti di una barra di scorrimento")  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.PageRightCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> di molto nella direzione verticale di valore decrescente del relativo oggetto <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando consente di ridurre il <xref:System.Windows.Controls.Primitives.Track.Value%2A> del <xref:System.Windows.Controls.Primitives.Track> nel <xref:System.Windows.Controls.Primitives.ScrollBar> dal valore della <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> proprietà.  
  
 Questo comando si verifica quando l'utente preme il tasto PGSU.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *oggetto* *proprietà*`="`**ScrollBar. PageUpCommand**`"/>`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come specificare il <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> in un oggetto personalizzato <xref:System.Windows.Controls.Primitives.ScrollBar> modello di stile.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato una o più volte mentre il contenuto scorre in un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> quando l'utente sposta <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> tramite il mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento si verifica in genere più volte quando l'utente modifica il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> del <xref:System.Windows.Controls.Primitives.ScrollBar> trascinando il <xref:System.Windows.Controls.Primitives.Track.Thumb%2A>. Non sono previsti limiti al numero di volte in cui questo evento viene generato come il <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> posizione viene trascinata.  
  
 Questo evento non viene generato quando il <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> del <xref:System.Windows.Controls.Primitives.ScrollBar> controllo viene modificato nel codice.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Strategia di routing|Bubbling|  
|delegato|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come assegnare un gestore eventi per il <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll> evento da un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo e come definire il gestore dell'evento nel codice.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica l'evento indirizzato <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al punto in cui viene fatto clic con il mouse per aprire l'oggetto <see cref="T:System.Windows.Controls.ContextMenu" /> in <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando si verifica quando l'utente seleziona **scorrimento qui** dal <xref:System.Windows.Controls.ContextMenu> opzioni. Il <xref:System.Windows.Controls.ContextMenu> del <xref:System.Windows.Controls.Primitives.ScrollBar> viene visualizzata quando l'utente posiziona il puntatore del mouse sul <xref:System.Windows.Controls.Primitives.ScrollBar> e preme il pulsante destro del mouse. Questo menu contiene opzioni per lo scorrimento di <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Questo comando è per un <xref:System.Windows.Controls.Primitives.ScrollBar> che fa parte di un <xref:System.Windows.Controls.ScrollViewer> controllare e viene eseguita tramite il <xref:System.Windows.Controls.ScrollViewer>.  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="` **ScrollBar.ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di fare scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sul valore <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un oggetto verticale <xref:System.Windows.Controls.Primitives.ScrollBar>, questo movimento si verifica quando l'utente preme i tasti CTRL + fine.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToBottomCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere il contenuto verso l'angolo inferiore destro di un controllo <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando viene utilizzato solo con un <xref:System.Windows.Controls.ScrollViewer> controllo.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere il contenuto verso l'angolo superiore sinistro di un controllo <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando viene utilizzato solo con un <xref:System.Windows.Controls.ScrollViewer> controllo.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToHomeCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> orizzontale in un oggetto <see cref="T:System.Windows.Controls.ScrollViewer" /> sul valore fornito in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando viene utilizzato solo con un <xref:System.Windows.Controls.ScrollViewer> controllo.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToHorizontalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di fare scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sul valore <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" /> per un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> orizzontale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando si verifica quando l'utente preme i tasti CTRL + HOME per un oggetto orizzontale <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="` **ScrollBar.ScrollToLeftEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di fare scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sul valore <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> per un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> orizzontale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando si verifica quando l'utente preme i tasti CTRL + fine per il controllo orizzontale <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="` **ScrollBar.ScrollToRightEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di fare scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> sul valore <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> per un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un oggetto verticale <xref:System.Windows.Controls.Primitives.ScrollBar>, questo movimento si verifica quando l'utente preme i tasti CTRL + HOME.  
  
 Quando si implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> come parte di un <xref:System.Windows.Controls.ScrollViewer> (controllo), il <xref:System.Windows.Controls.ScrollViewer> esegue questo comando.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToTopCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando che consente di far scorrere un oggetto <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale in un oggetto <see cref="T:System.Windows.Controls.ScrollViewer" /> sul valore fornito in <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando viene utilizzato solo con un <xref:System.Windows.Controls.ScrollViewer> controllo.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 `<` *object* *property*`="`**ScrollBar.ScrollToVerticalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Windows.Controls.Primitives.Track" /> per un controllo <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Primitives.Track" /> utilizzato con un controllo <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modello di stile tipico per un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo include un <xref:System.Windows.Controls.Primitives.Track> controllo circondato su entrambi i lati da due <xref:System.Windows.Controls.Button> controlli.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come accedere il <xref:System.Windows.Controls.Primitives.Track> controllo usato con un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo.  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta la quantità del contenuto scorrevole attualmente visualizzato.</summary>
        <value>Quantità di contenuto scorrevole attualmente visibile. Il valore predefinito è 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le unità utilizzate per <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> sono le stesse che vengono utilizzati per descrivere la lunghezza del contenuto. Alcuni esempi includono le righe di testo o pagine di testo.  
  
 Il valore della <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> proprietà viene utilizzata per calcolare la dimensione del <xref:System.Windows.Controls.Primitives.Thumb> controllo che viene visualizzato come indicatore di valore scorrevole in un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo. Il <xref:System.Windows.Controls.Primitives.Thumb> dimensioni del controllo rappresentano la quantità di un <xref:System.Windows.Controls.ScrollViewer> il contenuto del controllo è visibile.  Se al 25% di un <xref:System.Windows.Controls.ScrollViewer> il contenuto del controllo è visibile, il <xref:System.Windows.Controls.Primitives.Thumb> occupa il 25% della traccia nel <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 È possibile decidere quale unità <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> utilizza.  Quando si imposta questa proprietà, assicurarsi che il <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A>, e <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> proprietà utilizzano le stesse unità.  
  
 La figura seguente mostra come <xref:System.Windows.Controls.Primitives.Thumb> dimensioni corrispondenti alla quantità di contenuto che è visibile.  
  
 ![La lunghezza del percorso e una barra di scorrimento](~/add/media/scrollbarthumbsize.png "la lunghezza del percorso e una barra di scorrimento")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> su un <xref:System.Windows.Controls.Primitives.ScrollBar> controllo.  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>