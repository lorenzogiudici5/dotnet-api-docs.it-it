<Type Name="ButtonBase" FullName="System.Windows.Controls.Primitives.ButtonBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ec69f99ec8992aba0cba7b25892e354471c7bab7" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39939627" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Controls.ContentControl, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ButtonBase extends System.Windows.Controls.ContentControl implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ButtonBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ButtonBase&#xA;Inherits ContentControl&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class ButtonBase abstract : System::Windows::Controls::ContentControl, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type ButtonBase = class&#xA;    inherit ContentControl&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Button)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta la classe base per tutti i controlli <see cref="T:System.Windows.Controls.Button" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestire le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento a cui rispondere quando l'utente sceglie un <xref:System.Windows.Controls.Primitives.ButtonBase>. L'utente può generare il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventi usando un' <xref:System.Windows.Controls.AccessText> o premendo INVIO o barra spaziatrice mentre il controllo ha lo stato attivo.  Quando l'utente preme la barra spaziatrice, il set di controllo <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> a `true` e acquisisce il puntatore del mouse.  Di conseguenza, il controllo genera gli eventi del mouse, ad esempio <xref:System.Windows.UIElement.MouseEnter> e <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Si noti che l'utilizzo di <xref:System.Windows.Controls.AccessText> o invio non viene modificato <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o acquisire il mouse, ma in cui generare il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 Il <xref:System.Windows.Controls.Primitives.ButtonBase> imposta la <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> proprietà associata `true`.  
  
 Il metodo <xref:System.Windows.Controls.Primitives.ButtonBase> imposta la proprietà <xref:System.Windows.UIElement.IsInputMethodEnabled%2A> su `false`.  
  
 Oggetto <xref:System.Windows.Controls.Primitives.ButtonBase> è un <xref:System.Windows.Controls.ContentControl>, il che significa che può contenere un singolo oggetto di qualsiasi tipo (ad esempio, una stringa, un'immagine o un pannello). Per altre informazioni, vedere la classe <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ButtonBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ButtonBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.RoutedEventHandler " Usage="member this.Click : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene fatto clic su un oggetto <see cref="T:System.Windows.Controls.Button" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utente può generare il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventi usando un' <xref:System.Windows.Controls.AccessText> o premendo INVIO o barra spaziatrice mentre il controllo ha lo stato attivo.  Quando l'utente preme la barra spaziatrice, il set di controllo <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> a `true` e acquisisce il puntatore del mouse.  Di conseguenza, il controllo genera gli eventi del mouse, ad esempio <xref:System.Windows.UIElement.MouseEnter> e <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Si noti che l'utilizzo di <xref:System.Windows.Controls.AccessText> o invio non viene modificato <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o acquisire il mouse, ma in cui generare il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 Il <xref:System.Windows.Controls.Primitives.ButtonBase> contrassegni la <xref:System.Windows.UIElement.MouseLeftButtonDown> evento come gestito nel <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> (metodo) e genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Di conseguenza, il <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> evento non verrà mai verificarsi per un controllo che eredita da <xref:System.Windows.Controls.Primitives.ButtonBase>. In alternativa, associare un gestore eventi per il <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> eventi oppure chiamare <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` impostato su `true`.  
  
<a name="routedEventInfo_Click"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickEvent>|  
|Strategia di routing|Bubbling|  
|delegato|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Nell'esempio seguente mostra tre pulsanti che rispondono al clic del mouse in tre modi diversi.  
  
-   Al passaggio del mouse - il primo pulsante Cambia colore quando l'utente passa con il mouse sopra il pulsante  
  
-   Premere - il secondo pulsante richiede che venga premuto il puntatore del mouse mentre il puntatore del mouse si trova sul pulsante.  
  
-   Versione - il terzo non reimposta il colore di sfondo dei pulsanti fino a quando il puntatore del mouse viene premuto e rilasciato nel pulsante.  
  
 [!code-xaml[ClickModes_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml#1)]  
  
 [!code-csharp[ClickModes_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ClickModes_snip#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClickModes_snip/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica l'evento indirizzato <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento corrisponde a un clic del pulsante sinistro del mouse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ClickMode ClickMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ClickMode ClickMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ClickMode As ClickMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ClickMode ClickMode { System::Windows::Controls::ClickMode get(); void set(System::Windows::Controls::ClickMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClickMode : System.Windows.Controls.ClickMode with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ClickMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica quando viene generato l'evento <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />.</summary>
        <value>Quando viene generato l'evento <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />. Il valore predefinito è <see cref="F:System.Windows.Controls.ClickMode.Release" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ClickMode"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClickModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClickModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClickModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta il comando da richiamare in seguito alla pressione del pulsante.</summary>
        <value>Comando da richiamare quando viene premuto questo pulsante. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene utilizzata per associare un comando con un'istanza particolare pulsante.  
  
 Nelle [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], questa proprietà è impostata in genere come un valore del comando statico da una delle librerie di comandi esistenti, ad esempio <xref:System.Windows.Input.ApplicationCommands> o <xref:System.Windows.Input.NavigationCommands>. Per informazioni dettagliate, vedere [Cenni preliminari](~/docs/framework/wpf/advanced/commanding-overview.md) o <xref:System.Windows.Input.ICommand>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object Command="commandName"/>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *commandName*  
 Il comando da richiamare quando viene premuto questo pulsante.  
  
<a name="dependencyPropertyInfo_Command"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il parametro da passare alla proprietà <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />.</summary>
        <value>Parametro da passare alla proprietà <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maggior parte dei comandi esistenti da librerie di comando non usano un parametro del comando. Dei comandi che utilizzano un parametro del comando, la maggior parte di questi elementi accettano un parametro con un valore di tipo primitivo, ad esempio un numero intero o una stringa. Tuttavia, è possibile creare un comando personalizzato che preveda un tipo non primitivo come parametro di comando. Per un comando personalizzato in questo caso, l'impostazione <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> nel codice potrebbe richiedere un'istanza di oggetto nuovo o esistente. Impostazione <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> nel markup potrebbe richiedere la sintassi degli elementi proprietà, in cui l'elemento oggetto compilata la sintassi è un nuovo elemento del tipo previsto dal comando. In alternativa, l'impostazione nel markup potrebbe richiedere un riferimento tramite un'estensione di markup per un oggetto esistente (in genere questi riferimenti vengono eseguiti con [estensione di Markup Binding](~/docs/framework/wpf/advanced/binding-markup-extension.md) o [estensione di Markup StaticResource ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)).  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object CommandParameter="commandParameter" />  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *commandParameter*  
 Valore dello stesso tipo di comando specificato nel <xref:System.Windows.Controls.Primitives.ButtonBase.Command%2A> si aspetta di proprietà. Se si usa un comando di libreria esistente del comando, vedere la documentazione di tale libreria di comandi per [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] le informazioni sull'utilizzo, incluso il tipo di <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> prevede che il comando. Se si usa un comando personalizzato, vedere la sezione Osservazioni.  
  
<a name="dependencyPropertyInfo_CommandParameter"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" /> indirizzata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta l'elemento su cui eseguire il comando specificato.</summary>
        <value>Elemento sul quale generare un comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> proprietà non può essere usata per definire un <xref:System.Windows.UIElement>. Il <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> proprietà fornisce un riferimento a un elemento che è già definito nell'applicazione.  
  
<a name="xamlAttributeUsage_Target"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<ButtonBase CommandTarget="{Binding ElementName= elementName }"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *elementName*  
 Il nome del <xref:System.Windows.IInputElement> che riceve il comando.  
  
<a name="dependencyPropertyInfo_CommandTarget"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore della proprietà <see cref="P:System.Windows.ContentElement.IsEnabled" />.</summary>
        <value>
          <see langword="true" /> se il controllo è abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si sceglie di eseguire l'override di questa implementazione, verificare che si chiama il metodo di base.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressed">
      <MemberSignature Language="C#" Value="public bool IsPressed { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPressed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPressed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsPressed {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPressed : bool with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un oggetto <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> è attualmente attivato.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> è attivato, in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> è lo stato di un pulsante che indica il pulsante sinistro del mouse o tramite il pulsante viene premuta barra spaziatrice. Quando <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> è `true`, il controllo acquisisce il mouse.  Di conseguenza, il controllo genera gli eventi del mouse, ad esempio <xref:System.Windows.UIElement.MouseEnter> e <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Si noti che l'utilizzo di <xref:System.Windows.Controls.AccessText> o invio non viene modificato <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o acquisire il mouse, ma genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 A partire da .NET Framework versione 3.0 Service Pack 1, <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> dispone di un setter protetto. Per usare questa funzionalità, l'applicazione deve essere destinata a .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
<a name="dependencyPropertyInfo_IsPressed"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> proprietà in uno stile di trigger.  
  
 [!code-xaml[BtnColor#9](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnColor/CSharp/Pane1.xaml#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsPressedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsPressedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsPressedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsPressedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsPressedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected override void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="buttonBase.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.Input.AccessKeyManager.AccessKeyPressed" />.</param>
        <summary>Risponde quando viene chiamata la proprietà <see cref="P:System.Windows.Controls.AccessText.AccessKey" /> per questo controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Windows.Input.AccessKeyEventArgs.IsMultiple%2A> è `true`, questo metodo chiama l'implementazione di base, che fornisce lo stato attivo in questo controllo.  In caso contrario, questo metodo genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick();" />
      <MemberSignature Language="F#" Value="abstract member OnClick : unit -&gt; unit&#xA;override this.OnClick : unit -&gt; unit" Usage="buttonBase.OnClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera l'evento <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" /> indirizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento chiamando <xref:System.Windows.UIElement.RaiseEvent%2A>. Per altre informazioni, vedere [Cenni preliminari sugli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsPressedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsPressedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsPressedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsPressedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsPressedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="buttonBase.OnIsPressedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Viene chiamato quando viene modificata la proprietà <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.KeyDown" /> che viene generato quando l'utente preme un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questa implementazione la <xref:System.Windows.UIElement.KeyDown> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> non è impostata su <xref:System.Windows.Controls.ClickMode.Hover> e uno dei casi seguenti sono vere:  
  
-   L'utente preme la barra spaziatrice.  
  
-   L'utente preme INVIO e <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> è `true` per questo controllo.  
  
 In tutti gli altri casi, questa implementazione non modifica lo stato gestito (il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà) del <xref:System.Windows.UIElement.KeyDown> i dati dell'evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.UIElement.KeyUp" />.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.KeyUp" /> che viene generato quando l'utente rilascia un tasto mentre il controllo ha lo stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione contrassegna le <xref:System.Windows.UIElement.KeyUp> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando l'utente rilascia la barra spaziatrice. In caso contrario, questa implementazione non modifica lo stato gestito (il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà) del <xref:System.Windows.UIElement.KeyUp> i dati dell'evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="buttonBase.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.IInputElement.LostKeyboardFocus" />.</param>
        <summary>Chiamato quando un elemento perde lo stato attivo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.LostMouseCapture" /> che viene generato quando il controllo non riceve più messaggi di eventi mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione non modifica lo stato gestito (il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà) del <xref:System.Windows.UIElement.LostMouseCapture> i dati dell'evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.Input.Mouse.MouseEnter" />.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" /> che viene generato quando il mouse viene posizionato sul controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> è impostata su <xref:System.Windows.Controls.ClickMode.Hover>, in questa implementazione il <xref:System.Windows.UIElement.MouseEnter> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` e genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento <see cref="E:System.Windows.Input.Mouse.MouseLeave" />.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.MouseLeave" /> che viene generato quando il mouse viene spostato all'esterno di un elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questa implementazione la <xref:System.Windows.UIElement.MouseLeave> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> è impostato su <xref:System.Windows.Controls.ClickMode.Hover>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> che viene generato quando viene premuto il pulsante sinistro del mouse mentre il puntatore del mouse si trova nel controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione contrassegna le <xref:System.Windows.UIElement.MouseLeftButtonDown> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> non è impostata su <xref:System.Windows.Controls.ClickMode.Hover>. Per rispondere al <xref:System.Windows.UIElement.MouseLeftButtonDown> evento, associare un gestore eventi per il <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> evento oppure chiamare <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` impostato su `true`.  
  
 Quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> è impostata su <xref:System.Windows.Controls.ClickMode.Press>, questo metodo genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> che viene generato quando viene rilasciato il pulsante sinistro del mouse mentre il puntatore del mouse si trova nel controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione contrassegna le <xref:System.Windows.UIElement.MouseLeftButtonUp> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> non è impostata su <xref:System.Windows.Controls.ClickMode.Hover>. Per rispondere al <xref:System.Windows.UIElement.MouseLeftButtonUp> evento, associare un gestore eventi per il <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> evento oppure chiamare <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` impostato su `true`.  
  
 Quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> è impostata su <xref:System.Windows.Controls.ClickMode.Release> viene <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> viene `true`, questo metodo genera il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento.</param>
        <summary>Fornisce la gestione della classe per l'evento indirizzato <see cref="E:System.Windows.UIElement.MouseMove" /> che viene generato quando il puntatore del mouse viene spostato mentre si trova su questo elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In questa implementazione la <xref:System.Windows.UIElement.MouseMove> evento come gestito impostando il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà dei dati dell'evento per `true` quando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> non è impostata su <xref:System.Windows.Controls.ClickMode.Hover> e <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> è `true`. Per rispondere al <xref:System.Windows.UIElement.MouseMove> evento, associare un gestore eventi per il <xref:System.Windows.ContentElement.PreviewMouseMove> evento oppure chiamare <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` impostato su `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che le classi di base gestisce l'evento con un gestore della classe, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="buttonBase.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Specifica le modifiche apportate alla dimensione.</param>
        <summary>Chiamato quando viene modificata la dimensione sottoposta a rendering di un controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esegue l'override di <xref:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged%2A> metodo del <xref:System.Windows.UIElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>