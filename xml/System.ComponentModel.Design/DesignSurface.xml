<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9043a02e4ef99359f1cf161142f09f0e89e203d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36707602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type DesignSurface = class&#xA;    interface IDisposable&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Presents a user interface for designing components.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface> classe implementa quello che l'utente visualizza come una finestra di progettazione. <xref:System.ComponentModel.Design.DesignSurface> è che l'interfaccia utente, l'utente modifica le modifiche alle funzionalità in fase di progettazione. <xref:System.ComponentModel.Design.DesignSurface> fornisce una superficie di progettazione completamente indipendente.  
  
 Il <xref:System.ComponentModel.Design.DesignSurface> classe può essere usata come una finestra di progettazione autonomo o può essere associata il <xref:System.ComponentModel.Design.DesignSurfaceManager> classe per fornire un'implementazione comune per un'applicazione che ospita più <xref:System.ComponentModel.Design.DesignSurface> oggetti.  
  
 Il <xref:System.ComponentModel.Design.DesignSurface> può essere usata da sola o l'utente può derivare una nuova classe e ottimizzare il comportamento.  
  
 Il <xref:System.ComponentModel.Design.DesignSurface> classe fornisce automaticamente i diversi servizi in fase di progettazione. Il <xref:System.ComponentModel.Design.DesignSurface> classe aggiunge tutti i relativi servizi nel relativo costruttore. La maggior parte di questi servizi può essere sostituita dal sostituirli in protetto <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> proprietà. Per sostituire un servizio, eseguire l'override del costruttore, chiamare il metodo base e apportare le modifiche tramite il metodo protetto <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> proprietà. Tutti i servizi che vengono aggiunte al contenitore del servizio e che implementano <xref:System.IDisposable> vengono eliminati quando si elimina l'area di progettazione. Il set predefinito di sostituibili servizi che la <xref:System.ComponentModel.Design.DesignSurface> classe fornisce illustrato nella tabella seguente.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Consente agli oggetti che non fanno parte della raccolta di componenti del contenitore per fornire i propri provider di estensione.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Utilizzato da <xref:System.ComponentModel.TypeDescriptor> per ottenere un elenco dei provider di estensione. Con questo servizio, provider di estensione possano in tempo reale all'esterno del contenitore.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Fornisce gli hook della finestra di progettazione dei metadati. Si tratta dell'interfaccia principale per il filtro di metadati.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Consente di selezionare i componenti nella finestra di progettazione.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Fornisce un modo per ottenere un nome per gli oggetti, anche quando tali oggetti non sono definiti nel sito.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Offre l'area di progettazione se stesso come un servizio.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Fornisce una classe base per il recupero e impostazione dei valori di opzione per una finestra di progettazione.|  
  
 Nella tabella seguente vengono mostrati i servizi non sostituibili forniti per impostazione predefinita.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Genera eventi quando vengono apportate modifiche ai componenti.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Controlla l'accesso a tipi, servizi e transazioni. Interfaccia principale per le finestre di progettazione.|  
|<xref:System.ComponentModel.IContainer>|Proprietario del set di componenti che sono in fase di progettazione. Ogni finestra di progettazione presenta un <xref:System.ComponentModel.IContainer> che possiede i componenti.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Deriva da <xref:System.IServiceProvider> e fornisce un modo per aggiungere e rimuovere servizi dalla finestra di progettazione.|  
  
 Oltre a questi servizi, il <xref:System.ComponentModel.Design.DesignSurface> classe fornisce anche un unico servizio che è disponibile tramite un sito del componente. Questo servizio è univoco per ogni componente. Nella tabella seguente vengono mostrati i servizi che non possono essere sostituiti.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Un dizionario generico di coppie chiave/valore che può essere utilizzato per archiviare i dati arbitrari su un componente.|  
|<xref:System.ComponentModel.INestedContainer>|Un contenitore che consente a un componente aggiungere altri componenti figlio nella finestra di progettazione. Questi componenti faranno parte dell'area di progettazione, ma non partecipa alla serializzazione. Ciò è utile quando si desidera progettare un controllo che è in grado di esporre un'area di se stesso in una finestra di progettazione, ma non si desidera l'area deve far parte di serializzazione.|  
  
 Oltre a <xref:System.ComponentModel.ISite>, il sito implementa anche le interfacce seguenti.  
  
> [!CAUTION]
>  Verificare l'esistenza di tali interfacce, anziché utilizzare indiscriminatamente il cast, poiché altre implementazioni del sito potrebbero non essere implementate.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Fornisce un modo per ottenere il contenitore dei servizi specifici. Ad esempio, <xref:System.ComponentModel.Design.IDictionaryService> è un servizio specifico. Con questo servizio, è possibile aggiungere servizi specifiche del sito aggiuntivi.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">per l'accesso completo alle risorse di sistema. Valori richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Stato associato:</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.DesignSurface" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.DesignSurface" /> class.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface parentProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">The parent service provider, or <see langword="null" /> if there is no parent used to resolve services.</param>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.DesignSurface" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando `parentProvide` è presente, finestre di progettazione contenute all'interno dell'area possono recuperare i servizi dall'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface rootComponentType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">The type of root component to create.</param>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.DesignSurface" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si usa il <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> costruttore, viene creato un semplice caricatore della finestra di progettazione che, a sua volta, viene creato un componente del tipo specificato e quindi termina il processo di caricamento. Questo è un modo semplice per creare una finestra di progettazione, presupponendo che tutti venga eseguito il salvataggio dello stato esternamente. Internamente, viene chiamato <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> e passa il tipo di componente radice.  
  
> [!NOTE]
>  Il <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> overload non è influenzato <xref:System.Windows.Forms.Design.DesignerOptions>. Il <xref:System.Windows.Forms.Design.DesignerOptions> deve essere nel contenitore dei servizi prima che venga caricata nell'area di progettazione. Se è necessario accedere al <xref:System.Windows.Forms.Design.DesignerOptions>, chiamare il costruttore vuoto, aggiungere il <xref:System.Windows.Forms.Design.DesignerOptions> per il <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> e chiamare <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> con `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider * Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface (parentProvider, rootComponentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">The parent service provider, or <see langword="null" /> if there is no parent used to resolve services.</param>
        <param name="rootComponentType">The type of root component to create.</param>
        <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Design.DesignSurface" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzando il <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> costruttore crea un caricatore della finestra di progettazione semplice che crea un componente del tipo specificato e quindi termina il processo di caricamento. Questo è un modo semplice per creare una finestra di progettazione, presupponendo che tutti venga eseguito il salvataggio dello stato esternamente. Internamente, viene chiamato <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> e passa il tipo di componente radice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins the loading process.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.ComponentModel.Design.Serialization.DesignerLoader -&gt; unit" Usage="designSurface.BeginLoad loader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">The designer loader to use for loading the designer.</param>
        <summary>Begins the loading process with the given designer loader.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il caricamento della finestra di progettazione può essere asincrono, pertanto il caricamento può proseguire dopo la restituzione della chiamata. Collegare un gestore eventi per il <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventi per ricevere una notifica al completamento del caricamento area di progettazione.  
  
 Dopo aver <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> viene chiamato, è possibile ottenere subito la visualizzazione della finestra di progettazione, perché i caricatori della finestra di progettazione devono fornire almeno il componente radice quando si caricano in modo asincrono.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="loader" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Type -&gt; unit" Usage="designSurface.BeginLoad rootComponentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">The type of component to create in design mode.</param>
        <summary>Begins the loading process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si `rootComponentType` viene specificato, un caricatore della finestra di progettazione predefinita che crea semplicemente un'istanza di `rootComponentType` verrà utilizzato. Il caricamento della finestra di progettazione può essere asincrono, pertanto il caricamento può proseguire dopo la restituzione della chiamata. Collegare un gestore eventi per il <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventi per ricevere una notifica al completamento del caricamento area di progettazione.  
  
 Dopo aver <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> viene chiamato, è possibile ottenere subito la visualizzazione della finestra di progettazione, perché i caricatori della finestra di progettazione devono fornire almeno il componente radice quando si caricano in modo asincrono.  
  
> [!NOTE]
>  Il <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> metodo crea un'istanza del tipo di componente e consente di inizializzare una finestra di progettazione per questa istanza. Il <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento viene generato prima questo metodo restituisce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentContainer : System.ComponentModel.IContainer" Usage="System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.ComponentModel.IContainer" /> implementation within the design surface.</summary>
        <value>Il <see cref="T:System.ComponentModel.IContainer" /> implementazione nell'area di progettazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> proprietà contiene tutti gli oggetti che sono attualmente in modalità progettazione. Quando i componenti vengono aggiunti a <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, finestra di progettazione, se presente, viene caricato. Il componente è definito in un sito che fornisce accesso completo all'area di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="abstract member CreateComponent : Type -&gt; System.ComponentModel.IComponent&#xA;override this.CreateComponent : Type -&gt; System.ComponentModel.IComponent" Usage="designSurface.CreateComponent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">The type of component to create.</param>
        <summary>Creates an instance of a component.</summary>
        <returns>The newly created component.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> viene chiamato dall'area di progettazione <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> metodo per creare un'istanza di un componente. Il componente deve essere creato e aggiunto al contenitore pubblico nell'area di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberSignature Language="F#" Value="abstract member CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner&#xA;override this.CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner" Usage="designSurface.CreateDesigner (component, rootDesigner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">The component for which the designer should be created.</param>
        <param name="rootDesigner">
          <see langword="true" /> to create a root designer; <see langword="false" /> to create a normal designer.</param>
        <summary>Creates a designer when a component is added to the container.</summary>
        <returns>An instance of the requested designer, or <see langword="null" /> if no matching designer could be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> viene chiamato dall'area di progettazione <xref:System.ComponentModel.IContainer> quando un componente viene aggiunto al contenitore. Questo metodo crea una finestra di progettazione, ma non inizializzata. Quando viene restituito, la finestra di progettazione viene inizializzato dal contenitore.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> creare due diversi tipi di finestre di progettazione: radice normali finestre di progettazione e finestre di progettazione. Una finestra di progettazione radice è una finestra di progettazione per il componente radice nell'area di progettazione, che, per definizione, è il primo componente aggiunto al contenitore. RootDesigner differiscono dalle normali finestre di progettazione sono responsabili per l'interfaccia utente presentato all'utente finale. Finestre di progettazione radice è in genere accordarsi con il resto delle finestre di progettazione in una superficie di progettazione per fornire questa interfaccia.  
  
 L'implementazione predefinita di questo metodo delega al <xref:System.ComponentModel.TypeDescriptor>, passando <xref:System.ComponentModel.Design.IRootDesigner> come tipo di finestra di progettazione per le finestre di progettazione radice, o <xref:System.ComponentModel.Design.IDesigner> per i progettisti normale. È possibile eseguire l'override di questo metodo per richiedere un tipo specifico di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type -&gt; obj&#xA;override this.CreateInstance : Type -&gt; obj" Usage="designSurface.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type to create.</param>
        <summary>Creates an instance of the given type.</summary>
        <returns>The newly created object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `type` è un <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> Cerca un costruttore di tipo <xref:System.ComponentModel.IContainer> prima, seguita da un costruttore vuoto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a container suitable for nesting controls or components.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer owningComponent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">The component that manages the nested container.</param>
        <summary>Creates a container suitable for nesting controls or components.</summary>
        <returns>The nested container.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aggiunta di un componente a un contenitore annidato crea relativa finestra di progettazione e lo rende idoneo per tutti i servizi disponibili nell'area di progettazione. I componenti aggiunti ai contenitori nidificati non partecipano alla serializzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent * string -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer (owningComponent, containerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">The component that manages the nested container.</param>
        <param name="containerName">An additional name for the nested container.</param>
        <summary>Creates a container suitable for nesting controls or components.</summary>
        <returns>The nested container.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aggiunta di un componente a un contenitore annidato crea relativa finestra di progettazione e lo rende idoneo per tutti i servizi disponibili nell'area di progettazione. I componenti aggiunti ai contenitori nidificati non partecipano alla serializzazione.  
  
 È possibile fornire un nome aggiuntivo per il <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> metodo passando un valore in `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="designSurface.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metodo segue lo standard <xref:System.IDisposable> pattern. Chiamare questo metodo elimina l'area di progettazione. La versione protetta di questo metodo viene `virtual` e segue il normale <xref:System.IDisposable> pattern.  
  
> [!NOTE]
>  Poiché <xref:System.ComponentModel.Design.DesignSurface> non dispone di qualsiasi codice nativo per la pulizia non ha un finalizzatore che chiama <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Se è necessario chiamare <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, è necessario aggiungere manualmente un finalizzatore.  
  
 Chiamare il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> dopo aver terminato di utilizzare l'oggetto <xref:System.ComponentModel.Design.DesignSurface>. Il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> lascia l'oggetto <xref:System.ComponentModel.Design.DesignSurface> in una condizione di inutilizzabilità. Dopo la chiamata <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, è necessario rilasciare tutti i riferimenti per il <xref:System.ComponentModel.Design.DesignSurface> consentire al garbage collector di recuperare la memoria che il <xref:System.ComponentModel.Design.DesignSurface> occupata. Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> prima di rilasciare l'ultimo riferimento a <xref:System.ComponentModel.Design.DesignSurface>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.ComponentModel.Design.DesignSurface> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="designSurface.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the resources used by the <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose> metodo segue lo standard <xref:System.IDisposable> pattern. Chiamare questo metodo elimina l'area di progettazione. La versione protetta di questo metodo viene `virtual` e segue il normale <xref:System.IDisposable> pattern.  
  
> [!NOTE]
>  Poiché <xref:System.ComponentModel.Design.DesignSurface> non dispone di qualsiasi codice nativo per la pulizia non ha un finalizzatore che chiama <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Se è necessario chiamare <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, è necessario aggiungere manualmente un finalizzatore.  
  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` metodo e il <xref:System.Object.Finalize%2A> metodo. `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Quando il `disposing` parametro è true, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.ComponentModel.Design.DesignSurface> riferimenti. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per ulteriori informazioni <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito e [override del metodo Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the design surface is disposed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'area viene eliminata solo quando il pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metodo su <xref:System.ComponentModel.Design.DesignSurface> viene chiamato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtelLoading : bool with get, set" Usage="System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the **Design-time Error List** is loading.</summary>
        <value>
          <see langword="true" /> Se il * * fase di progettazione errore elenco * * il caricamento; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="designSurface.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializes changes to the design surface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> metodo può essere chiamato per eseguire il push delle modifiche apportate all'area di progettazione nel serializzatore. Ciò garantisce che l'area di progettazione e lo stato serializzato siano sincronizzati. L'implementazione effettiva di questo metodo viene inoltrato al caricatore della finestra di progettazione associato all'area di progettazione. Il caricatore della finestra di progettazione è possibile scegliere di rinviare le modifiche fino <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> viene chiamato, o è possibile scegliere di mantenere i dati serializzati aggiornato con tutte le modifiche dell'utente. Il <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> metodo assicura che, indipendentemente dal modello il caricatore della finestra di progettazione da usare, lo stato serializzato è sincronizzato con l'area di progettazione effettiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberSignature Language="F#" Value="member this.Flushed : EventHandler " Usage="member this.Flushed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a call is made to the <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> method of <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il caricatore della finestra di progettazione viene scaricato prima di tutto e quindi il <xref:System.ComponentModel.Design.DesignSurface.Flushed> evento viene generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designSurface.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">The type of service to retrieve.</param>
        <summary>Gets a service from the service container.</summary>
        <returns>An object that implements, or is a derived class of, <paramref name="serviceType" />, or <see langword="null" /> if the service does not exist in the service container.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> che consente di recuperare un servizio nel contenitore di servizi dell'area di progettazione. Inoltre, questo inoltrerà a qualsiasi provider di servizi che è stato assegnato all'area di progettazione in fase di costruzione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the design surface is currently loaded.</summary>
        <value>
          <see langword="true" /> Se l'area di progettazione è attualmente caricato; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " Usage="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the designer load has completed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento viene generato per carichi di esito positivo, nonché quelli non riusciti. Se il codice in questo gestore eventi genera un'eccezione, la finestra di progettazione viene scaricato.  
  
 Il <xref:System.ComponentModel.Design.LoadedEventArgs> oggetto può essere utilizzato per determinare se il caricamento è stato completato e, inoltre, fornisce un elenco di errori che si sono verificati durante il caricamento.  
  
> [!NOTE]
>  Condizione che il sistema di serializzazione è in grado di tollerare errori per la riuscita dei caricamenti, possono verificarsi errori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadErrors : System.Collections.ICollection" Usage="System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection of loading errors or a void collection.</summary>
        <value>Oggetto <see cref="T:System.Collections.ICollection" /> degli errori di caricamento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberSignature Language="F#" Value="member this.Loading : EventHandler " Usage="member this.Loading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the designer is about to be loaded.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit&#xA;override this.OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit" Usage="designSurface.OnLoaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoading : EventArgs -&gt; unit&#xA;override this.OnLoading : EventArgs -&gt; unit" Usage="designSurface.OnLoading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloaded : EventArgs -&gt; unit&#xA;override this.OnUnloaded : EventArgs -&gt; unit" Usage="designSurface.OnUnloaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloading : EventArgs -&gt; unit&#xA;override this.OnUnloading : EventArgs -&gt; unit" Usage="designSurface.OnUnloading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnViewActivate : EventArgs -&gt; unit&#xA;override this.OnViewActivate : EventArgs -&gt; unit" Usage="designSurface.OnViewActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceContainer : System.ComponentModel.Design.ServiceContainer" Usage="System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service container.</summary>
        <value>Il contenitore del servizio che fornisce tutti i servizi per finestre di progettazione contenute all'interno dell'area di progettazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In fase di costruzione, <xref:System.ComponentModel.Design.DesignSurface> aggiunge servizi predefiniti nel contenitore del servizio. È possibile lasciare i servizi predefiniti nello stato attuale, oppure è possibile rimuoverli e sostituirli con valori personalizzati. I servizi predefiniti sono tutti creati su richiesta, pertanto non è senza perdita di prestazioni per l'aggiunta in fase di costruzione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : EventHandler " Usage="member this.Unloaded : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a designer has finished unloading.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : EventHandler " Usage="member this.Unloading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a designer is about to unload.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene scaricata una finestra di progettazione, viene eliminato l'intero stato per tale finestra di progettazione, inclusa la visualizzazione della finestra di progettazione. La vista deve essere priva in questo momento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.View : obj" Usage="System.ComponentModel.Design.DesignSurface.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the view for the root designer.</summary>
        <value>La visualizzazione della finestra di progettazione radice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> metodo deve essere chiamato prima di avviare il processo di caricamento. È possibile restituire una visualizzazione prima che il caricatore della finestra di progettazione ha terminato di caricare la finestra di progettazione radice, che fornisce la visualizzazione, è il primo oggetto creato dal caricatore della finestra di progettazione. Se una vista è disponibile, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> genera un'eccezione.  
  
 Il concetto di una tecnologia di visualizzazione è obsoleto. Tuttavia, rimane nelle interfacce per le finestre di progettazione radice per la compatibilità con le versioni precedenti. L'utilizzo è nascosto da chiunque ne usi <xref:System.ComponentModel.Design.DesignSurface> oggetti. Il <xref:System.ComponentModel.Design.DesignSurface.View%2A> proprietà nasconde le tecnologie di visualizzazione restituendo le tecnologie supportate alla finestra di progettazione radice.  
  
   
  
## Examples  
 Esempio di codice seguente come <xref:System.ComponentModel.Design.DesignSurface.View%2A> nasconde le tecnologie di visualizzazione.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The design surface is not loading, the designer loader has not yet created a root designer, or the design surface finished the load, but failed. More information may available in the <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">The designer loaded, but it does not offer a view compatible with this design surface.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> attached to the <see cref="T:System.ComponentModel.Design.DesignSurface" /> has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberSignature Language="F#" Value="member this.ViewActivated : EventHandler " Usage="member this.ViewActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> method has been called on <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si prevede di supportare il <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> metodo, il gestore dell'evento debba attivare la finestra per questa area di progettazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>