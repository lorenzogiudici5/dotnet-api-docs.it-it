<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3aa7493e17750216c5342b1ee5e784080710e3a2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370465" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un'interfaccia utente per la progettazione dei componenti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ComponentModel.Design.DesignSurface> classe implementa quello che l'utente visualizza come una finestra di progettazione. <xref:System.ComponentModel.Design.DesignSurface> è che l'interfaccia utente, l'utente modifica le modifiche alle funzionalità in fase di progettazione. <xref:System.ComponentModel.Design.DesignSurface> fornisce una superficie di progettazione completamente indipendente.  
  
 Il <xref:System.ComponentModel.Design.DesignSurface> classe può essere utilizzata come una finestra di progettazione autonomo o può essere associato il <xref:System.ComponentModel.Design.DesignSurfaceManager> classe per fornire un'implementazione comune per un'applicazione che ospita più <xref:System.ComponentModel.Design.DesignSurface> oggetti.  
  
 La <xref:System.ComponentModel.Design.DesignSurface> classe può essere utilizzata da sola o l'utente può derivare una nuova classe e ottimizzare il comportamento.  
  
 La <xref:System.ComponentModel.Design.DesignSurface> classe fornisce automaticamente i diversi servizi in fase di progettazione. La <xref:System.ComponentModel.Design.DesignSurface> classe aggiunge tutti i relativi servizi nel relativo costruttore. La maggior parte di questi servizi può essere sostituita e sostituiti protetto <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> proprietà. Per sostituire un servizio, eseguire l'override del costruttore, chiamare il metodo base e apportare le modifiche tramite il metodo protetto <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> proprietà. Tutti i servizi che vengono aggiunte al contenitore del servizio e che implementano <xref:System.IDisposable> vengono eliminati quando si elimina l'area di progettazione. Il set predefinito di sostituibili servizi a cui la <xref:System.ComponentModel.Design.DesignSurface> classe fornisce è illustrato nella tabella seguente.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Gli oggetti che non fanno parte dell'insieme di componenti del contenitore per fornire i propri provider di estensione.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Utilizzato da <xref:System.ComponentModel.TypeDescriptor> per ottenere un elenco dei provider di estensione. Con questo servizio, provider di estensione possono risiedere di fuori del contenitore.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Fornisce gli hook dei metadati della finestra di progettazione. Si tratta dell'interfaccia principale per il filtro di metadati.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Consente di selezionare i componenti nella finestra di progettazione.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Fornisce un modo per ottenere un nome per gli oggetti, anche quando tali oggetti non sono definiti nel sito.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Offre l'area di progettazione se stesso come un servizio.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Fornisce una classe di base per ottenere e impostare i valori delle opzioni per una finestra di progettazione.|  
  
 La tabella seguente illustra i servizi non sostituibili forniti per impostazione predefinita.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Genera eventi quando vengono apportate modifiche ai componenti.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Controlla l'accesso a tipi, servizi e transazioni. Interfaccia principale per le finestre di progettazione.|  
|<xref:System.ComponentModel.IContainer>|Proprietario del set di componenti che sono in fase di progettazione. Ogni finestra di progettazione è un <xref:System.ComponentModel.IContainer> che possiede i componenti.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Deriva da <xref:System.IServiceProvider> e fornisce un modo per aggiungere e rimuovere servizi dalla finestra di progettazione.|  
  
 Oltre a questi servizi, la <xref:System.ComponentModel.Design.DesignSurface> classe fornisce anche un unico servizio che è disponibile tramite un sito del componente. Questo servizio è univoco per ogni componente. Nella tabella seguente vengono mostrati i servizi che non possono essere sostituiti.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Un dizionario generico di coppie chiave/valore che può essere utilizzato per archiviare i dati arbitrari su un componente.|  
|<xref:System.ComponentModel.INestedContainer>|Un contenitore che consente a un componente aggiungere altri componenti figlio nella finestra di progettazione. Questi componenti faranno parte dell'area di progettazione, ma non partecipa alla serializzazione. Ciò è utile quando si desidera progettare un controllo che è in grado di esporre un'area di se stesso in una finestra di progettazione, ma non si desidera l'area deve far parte di serializzazione.|  
  
 Oltre a <xref:System.ComponentModel.ISite>, anche nel sito vengono implementate le interfacce seguenti.  
  
> [!CAUTION]
>  Verificare l'esistenza di queste interfacce, anziché utilizzare indiscriminatamente il cast, poiché altre implementazioni del sito potrebbero non essere implementate.  
  
|Service|Descrizione|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Fornisce un modo per ottenere il contenitore di servizi specifici del sito. Ad esempio, <xref:System.ComponentModel.Design.IDictionaryService> è un servizio specifico. Con questo servizio, è possibile aggiungere altri servizi specifici.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">per l'accesso completo alle risorse di sistema. Valori richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Stato associato:</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Il provider di servizi padre oppure il valore <see langword="null" /> se non viene utilizzato alcun padre per risolvere i servizi.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando `parentProvide` è presente, finestre di progettazione contenute all'interno dell'area possono recuperare i servizi dall'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Tipo di componente radice da creare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza il <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> costruttore, viene creato un semplice caricatore della finestra di progettazione che, a sua volta, viene creato un componente del tipo specificato e quindi termina il processo di caricamento. Questo è un modo semplice per creare una finestra di progettazione, si presuppone che tutti venga eseguito il salvataggio dello stato esternamente. Internamente, viene chiamato <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> e passa il tipo di componente radice.  
  
> [!NOTE]
>  Il <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> overload non è interessata da <xref:System.Windows.Forms.Design.DesignerOptions>. Il <xref:System.Windows.Forms.Design.DesignerOptions> deve essere nel contenitore dei servizi prima che venga caricata nell'area di progettazione. Se è necessario accedere a <xref:System.Windows.Forms.Design.DesignerOptions>, chiamare il costruttore vuoto, aggiungere il <xref:System.Windows.Forms.Design.DesignerOptions> per il <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> e chiamare <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> con `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Il provider di servizi padre oppure il valore <see langword="null" /> se non viene utilizzato alcun padre per risolvere i servizi.</param>
        <param name="rootComponentType">Tipo di componente radice da creare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzo di <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> costruttore crea un caricatore della finestra di progettazione semplice che crea un componente del tipo specificato e quindi termina il processo di caricamento. Questo è un modo semplice per creare una finestra di progettazione, si presuppone che tutti venga eseguito il salvataggio dello stato esternamente. Internamente, viene chiamato <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> e passa il tipo di componente radice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia il processo di caricamento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">Caricatore da utilizzare per il caricamento della finestra di progettazione.</param>
        <summary>Avvia il processo di caricamento con il caricatore della finestra di progettazione indicato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il caricamento della finestra di progettazione può essere asincrono, pertanto il caricamento può proseguire dopo la restituzione della chiamata. Collegare un gestore eventi per il <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventi per ricevere una notifica al completamento del caricamento nell'area di progettazione.  
  
 Dopo aver <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> viene chiamato, è possibile ottenere subito la visualizzazione della finestra di progettazione, perché i caricatori della finestra di progettazione devono fornire almeno il componente principale durante il caricamento asincrono.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="loader" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Tipo di componente da creare in modalità di progettazione.</param>
        <summary>Avvia il processo di caricamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando `rootComponentType` viene specificato un caricatore della finestra di progettazione predefinito che crea semplicemente un'istanza di `rootComponentType` verrà utilizzato. Il caricamento della finestra di progettazione può essere asincrono, pertanto il caricamento può proseguire dopo la restituzione della chiamata. Collegare un gestore eventi per il <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventi per ricevere una notifica al completamento del caricamento nell'area di progettazione.  
  
 Dopo aver <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> viene chiamato, è possibile ottenere subito la visualizzazione della finestra di progettazione, perché i caricatori della finestra di progettazione devono fornire almeno il componente principale durante il caricamento asincrono.  
  
> [!NOTE]
>  Il <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> metodo crea un'istanza del tipo di componente e consente di inizializzare una finestra di progettazione per questa istanza. Il <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento viene generato prima questo metodo restituisce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponentType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'implementazione dell'interfaccia <see cref="T:System.ComponentModel.IContainer" /> all'interno dell'area di progettazione.</summary>
        <value>Implementazione dell'interfaccia <see cref="T:System.ComponentModel.IContainer" /> all'interno dell'area di progettazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> proprietà contiene tutti gli oggetti che sono attualmente in modalità progettazione. Quando i componenti vengono aggiunti a <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, finestra di progettazione, se presente, viene caricato. Il componente è definito in un sito che fornisce accesso completo all'area di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Tipo di componente da creare.</param>
        <summary>Crea un'istanza di un componente.</summary>
        <returns>Componente appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> metodo viene chiamato dall'area di progettazione <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> metodo per creare un'istanza di un componente. Il componente deve essere creato e aggiunto al contenitore pubblico nell'area di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente per il quale creare la finestra di progettazione.</param>
        <param name="rootDesigner">
          <see langword="true" /> per creare una finestra di progettazione radice; <see langword="false" /> per creare una finestra di progettazione normale.</param>
        <summary>Crea una finestra di progettazione quando un componente viene aggiunto al contenitore.</summary>
        <returns>Istanza della finestra di progettazione richiesta oppure <see langword="null" /> se non è possibile individuare la finestra di progettazione corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> metodo viene chiamato dall'area di progettazione <xref:System.ComponentModel.IContainer> quando un componente viene aggiunto al contenitore. Questo metodo crea una finestra di progettazione, ma non inizializzata. Quando viene restituito, la finestra di progettazione viene inizializzata dal contenitore.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> creare due tipi diversi di finestre di progettazione: radice e normale. Una finestra di progettazione radice è una finestra di progettazione per il componente radice nell'area di progettazione, la cui definizione è il primo componente aggiunto al contenitore. Finestre di progettazione radice differiscono dalle normali finestre di progettazione sono responsabili per l'interfaccia utente presentato all'utente finale. Finestre di progettazione radice sono generalmente coordinate con il resto delle finestre di progettazione nell'area di progettazione per fornire questa interfaccia.  
  
 L'implementazione predefinita di questo metodo delega al <xref:System.ComponentModel.TypeDescriptor>, passando <xref:System.ComponentModel.Design.IRootDesigner> come tipo di finestra di progettazione per le finestre di progettazione radice, o <xref:System.ComponentModel.Design.IDesigner> per le normali finestre di progettazione. È possibile eseguire l'override di questo metodo per richiedere un tipo specifico di progettazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo da creare.</param>
        <summary>Crea un'istanza del tipo indicato.</summary>
        <returns>Oggetto appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `type` è un <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> Cerca un costruttore di tipo <xref:System.ComponentModel.IContainer> prima, seguita da un costruttore vuoto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un contenitore adatto per i controlli o i componenti di annidamento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Componente che gestisce il contenitore annidato.</param>
        <summary>Crea un contenitore adatto per i controlli o i componenti di annidamento.</summary>
        <returns>Contenitore annidato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aggiunta di un componente a un contenitore annidato crea la finestra di progettazione e lo rende idoneo per tutti i servizi disponibili nell'area di progettazione. I componenti aggiunti ai contenitori nidificati non partecipano alla serializzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Componente che gestisce il contenitore annidato.</param>
        <param name="containerName">Nome aggiuntivo del contenitore annidato.</param>
        <summary>Crea un contenitore adatto per i controlli o i componenti di annidamento.</summary>
        <returns>Contenitore annidato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aggiunta di un componente a un contenitore annidato crea la finestra di progettazione e lo rende idoneo per tutti i servizi disponibili nell'area di progettazione. I componenti aggiunti ai contenitori nidificati non partecipano alla serializzazione.  
  
 È possibile fornire un nome aggiuntivo per il <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> metodo passando un valore in `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metodo segue lo standard <xref:System.IDisposable> modello. Chiamare questo metodo elimina l'area di progettazione. La versione protetta di questo metodo è `virtual` e segue il normale <xref:System.IDisposable> modello.  
  
> [!NOTE]
>  Poiché <xref:System.ComponentModel.Design.DesignSurface> non dispone di alcun codice nativo per la pulizia non ha un finalizzatore che chiama <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Se è necessario chiamare <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, è necessario aggiungere manualmente un finalizzatore.  
  
 Chiamare il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> dopo aver terminato di utilizzare l'oggetto <xref:System.ComponentModel.Design.DesignSurface>. Il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> lascia l'oggetto <xref:System.ComponentModel.Design.DesignSurface> in una condizione di inutilizzabilità. Dopo la chiamata <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, è necessario rilasciare tutti i riferimenti al <xref:System.ComponentModel.Design.DesignSurface> in modo che il garbage collector può recuperare la memoria che di <xref:System.ComponentModel.Design.DesignSurface> occupata. Per ulteriori informazioni, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> prima di rilasciare l'ultimo riferimento a <xref:System.ComponentModel.Design.DesignSurface>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.ComponentModel.Design.DesignSurface> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse usate da <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose> metodo segue lo standard <xref:System.IDisposable> modello. Chiamare questo metodo elimina l'area di progettazione. La versione protetta di questo metodo è `virtual` e segue il normale <xref:System.IDisposable> modello.  
  
> [!NOTE]
>  Poiché <xref:System.ComponentModel.Design.DesignSurface> non dispone di alcun codice nativo per la pulizia non ha un finalizzatore che chiama <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Se è necessario chiamare <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, è necessario aggiungere manualmente un finalizzatore.  
  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` (metodo) e <xref:System.Object.Finalize%2A> metodo. `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Quando il `disposing` parametro è true, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.ComponentModel.Design.DesignSurface> riferimenti. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [si esegue l'override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato quando viene eliminata l'area di progettazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'area viene eliminata solo quando il pubblico <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metodo <xref:System.ComponentModel.Design.DesignSurface> viene chiamato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se **Design-time Error List** viene caricato.</summary>
        <value>
          <see langword="true" /> Se il **elenco errori in fase di progettazione** il caricamento; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializza le modifiche apportate all'area di progettazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> metodo può essere chiamato per eseguire il push delle modifiche apportate all'area di progettazione nel serializzatore. Questo assicura che l'area di progettazione e lo stato serializzato sono sincronizzate. L'implementazione effettiva di questo metodo viene inoltrato al caricatore della finestra di progettazione associato all'area di progettazione. Il caricatore della finestra di progettazione può scegliere di rinviare le modifiche fino a quando <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> viene chiamato, oppure mantenere aggiornati i dati serializzati con tutte le modifiche dell'utente. Il <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> metodo assicura che, indipendentemente dal modello di caricatore della finestra di progettazione da usare, lo stato serializzato è sincronizzato con l'area di progettazione effettiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato quando viene eseguita una chiamata al metodo <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> dell'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il caricatore della finestra di progettazione viene scaricato prima, quindi il <xref:System.ComponentModel.Design.DesignSurface.Flushed> viene generato l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Tipo di servizio da recuperare.</param>
        <summary>Ottiene un servizio dal contenitore dei servizi.</summary>
        <returns>Oggetto che implementa o rappresenta una classe derivata dell'oggetto <paramref name="serviceType" />, oppure <see langword="null" /> se nel contenitore il servizio è inesistente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> che consente di recuperare un servizio nel contenitore dei servizi dell'area di progettazione. Inoltre, questo verrà inoltrare a qualsiasi provider di servizi che sono stati specificati per l'area di progettazione in fase di costruzione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'area di progettazione è in fase di caricamento.</summary>
        <value>
          <see langword="true" /> se l'area di progettazione è in fase di caricamento; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato al termine del caricamento della finestra di progettazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento viene generato per il caricamento ha esito positivo, nonché quelli. Se il codice in questo gestore eventi genera un'eccezione, la finestra di progettazione viene scaricato.  
  
 Il <xref:System.ComponentModel.Design.LoadedEventArgs> oggetto può essere utilizzato per determinare se il caricamento è stato completato e, inoltre, fornisce un elenco di errori che si è verificato durante il caricamento.  
  
> [!NOTE]
>  Possono verificarsi errori per la riuscita dei caricamenti, a condizione che il sistema di serializzazione è in grado di tollerare errori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un insieme di errori di caricamento o un insieme vuoto.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> degli errori di caricamento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato quando si sta per caricare la finestra di progettazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contenitore dei servizi.</summary>
        <value>Contenitore dei servizi che fornisce tutti i servizi alle finestre nell'area di progettazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In fase di costruzione, <xref:System.ComponentModel.Design.DesignSurface> aggiunge servizi predefiniti nel contenitore del servizio. È possibile lasciare i servizi predefiniti nello stato attuale, o è possibile rimuoverli e sostituirli con valori personalizzati. I servizi predefiniti sono tutti creati su richiesta, pertanto non è senza perdita di prestazioni per l'aggiunta in fase di costruzione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato al termine dello scaricamento della finestra di progettazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato quando la finestra di progettazione è in fase di scaricamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene scaricata una finestra di progettazione, viene eliminato l'intero stato per tale finestra di progettazione, inclusa la visualizzazione della finestra di progettazione. La vista deve essere priva in questo momento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la visualizzazione per la finestra di progettazione radice.</summary>
        <value>Visualizzazione per la finestra di progettazione radice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> metodo deve essere chiamato prima di avviare il processo di caricamento. È possibile restituire una visualizzazione finché il caricatore della finestra di progettazione non viene completata durante il caricamento perché la finestra di progettazione radice, che fornisce la visualizzazione, è il primo oggetto creato dal caricatore della finestra di progettazione. Se una vista è disponibile, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> genera un'eccezione.  
  
 Il concetto di una tecnologia di visualizzazione è obsoleto. Tuttavia, rimane nelle interfacce per le finestre di progettazione radice per la compatibilità con le versioni precedenti. L'utilizzo è nascosto da chiunque utilizzi <xref:System.ComponentModel.Design.DesignSurface> oggetti. Il <xref:System.ComponentModel.Design.DesignSurface.View%2A> proprietà nasconde le tecnologie di visualizzazione restituendo le tecnologie supportate alla finestra di progettazione radice.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come <xref:System.ComponentModel.Design.DesignSurface.View%2A> nasconde le tecnologie di visualizzazione.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'area di progettazione non viene caricata, il caricatore della finestra di progettazione non ha ancora creato la finestra di progettazione radice o il caricamento dell'area di progettazione è terminato con esito negativo. Ulteriori informazioni sono disponibili nella documentazione relativa alla proprietà <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">La finestra di progettazione è stata caricata ma non dispone di una visualizzazione compatibile con questa area di progettazione.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" /> collegata all'oggetto <see cref="T:System.ComponentModel.Design.DesignSurface" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Generato quando viene chiamato il metodo <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> nell'interfaccia <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si desidera supportare la <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> metodo, il gestore eventi deve attivare la finestra per questa area di progettazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>