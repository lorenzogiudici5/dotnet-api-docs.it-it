<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="965dfec69322c17517b9ac618c8ada59a4c5e4b8" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48754409" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Aggiunge un livello di buffer per operazioni di lettura e scrittura in un altro flusso. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un buffer è un blocco di byte nella memoria utilizzata per memorizzare i dati, riducendo il numero di chiamate al sistema operativo. Buffer di migliorare la lettura e scrittura delle prestazioni. Un buffer è utilizzabile per la lettura o scrittura, ma mai entrambe contemporaneamente. Il <xref:System.IO.BufferedStream.Read%2A> e <xref:System.IO.BufferedStream.Write%2A> metodi di `BufferedStream` gestiscono automaticamente il buffer.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 `BufferedStream` può essere composta da determinati tipi di flussi. Fornisce le implementazioni per leggere e scrivere byte un'origine dati o nell'archivio sottostante. Uso <xref:System.IO.BinaryReader> e <xref:System.IO.BinaryWriter> per la lettura e scrittura di altri tipi di dati. `BufferedStream` è progettato per impedire al buffer di rallentamento delle operazioni di input e output quando il buffer non è necessaria. Se è sempre leggere e scrivere per dimensioni superiori a dimensioni del buffer interno, quindi `BufferedStream` potrebbe anche non allocare il buffer interno. `BufferedStream` anche memorizza nel buffer di operazioni di lettura e scrittura in un buffer condiviso. Si presuppone che sarà quasi sempre possibile eseguire una serie di operazioni di lettura o scrittura, ma raramente possono essere di due di essi.  
  
   
  
## Examples  
 Gli esempi di codice seguenti illustrano come usare il `BufferedStream` classe tramite la `NetworkStream` classe per migliorare le prestazioni di determinate operazioni dei / o. Avviare il server in un computer remoto prima di avviare il client. Specificare il nome del computer remoto come argomento della riga di comando all'avvio del client. Variare la `dataArraySize` e `streamBufferSize` costanti per visualizzare il relativo effetto sulle prestazioni.  
  
 Il primo esempio viene illustrato il codice eseguito sul client e il secondo esempio viene illustrato il codice che viene eseguito nel server.  
  
 **Esempio 1: Codice eseguito sul client**  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 **Esempio 2: Codice che viene eseguito nel server**  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.BufferedStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.BufferedStream" /> con una dimensione predefinita del buffer di 4096 byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un buffer di lettura/scrittura condivisa viene allocato la prima volta un `BufferedStream` oggetto viene inizializzato con questo costruttore. Il buffer condiviso non viene usato se tutte le letture e scritture sono maggiori o uguali a `bufferSize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso corrente.</param>
        <param name="bufferSize">Dimensioni del buffer, in byte.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.BufferedStream" /> con la dimensione specificata del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un buffer di lettura/scrittura condivisa viene allocato la prima volta un `BufferedStream` oggetto viene inizializzato con questo costruttore. Il buffer condiviso non viene usato se tutte le letture e scritture sono maggiori o uguali a `bufferSize`.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è negativo.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui leggere i dati.</param>
        <param name="offset">Offset di byte in <c>buffer</c> in corrispondenza del quale iniziare a scrivere i dati letti dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la lettura è completa.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di lettura asincrona da altre richieste.</param>
        <summary>Inizia un'operazione di lettura asincrona. (In alternativa, si consideri l'uso di <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Oggetto che rappresenta la lettura asincrona, che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> deve essere chiamato una sola volta per ogni chiamata a <xref:System.IO.BufferedStream.BeginRead%2A>. Riesce a terminare un processo di lettura prima di iniziare la lettura di un altro può causare comportamenti indesiderati, ad esempio deadlock.  
  
> [!NOTE]
>  Usare il <xref:System.IO.BufferedStream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
 <xref:System.IO.BufferedStream.EndRead%2A> deve essere chiamato con questo <xref:System.IAsyncResult> per scoprire quanti byte sono stati letti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è tentato di eseguire la lettura asincrona oltre la fine del flusso.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza del buffer meno <paramref name="offset" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta l'operazione di lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer contenente i dati da scrivere nel flusso corrente.</param>
        <param name="offset">Offset di byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso corrente.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <param name="callback">Metodo da chiamare quando l'operazione di scrittura asincrona viene completata.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di scrittura asincrona da altre richieste.</param>
        <summary>Inizia un'operazione di scrittura asincrona. (In alternativa, si consideri l'uso di <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Oggetto che rappresenta la scrittura asincrona che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> deve essere chiamato una sola volta per ogni <xref:System.IAsyncResult> da <xref:System.IO.BufferedStream.BeginWrite%2A>. <xref:System.IO.BufferedStream.EndWrite%2A> blocca fino a quando non è stata completata l'operazione dei / o.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="buffer" /> meno <paramref name="offset" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la lettura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la lettura; <see langword="false" /> se il flusso è chiuso o è stato aperto con accesso in sola scrittura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la lettura, le chiamate al <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>e la `Peek` metodi della <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, e <xref:System.IO.TextReader> generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la ricerca.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la ricerca; <see langword="false" /> se il flusso è chiuso o è stato creato da un handle del sistema operativo, ad esempio un pipe o un output di console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la ricerca, le chiamate a <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, e <xref:System.IO.BufferedStream.Seek%2A> generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la scrittura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la scrittura; <see langword="false" /> se il flusso è chiuso o è stato aperto con accesso in sola lettura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la scrittura, una chiamata a <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, o <xref:System.IO.BufferedStream.WriteByte%2A> genera un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Riferimento alla richiesta asincrona in sospeso da attendere.</param>
        <summary>Attende il completamento dell'operazione di lettura asincrona in sospeso. (In alternativa, si consideri l'uso di <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Numero di byte letti dal flusso, tra 0 (zero) e il numero di byte richiesto. I flussi restituiscono solo 0 solo alla fine del flusso; in caso contrario, è necessario che effettuino un blocco fino a quando sia disponibile almeno 1 byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 <xref:System.IO.BufferedStream.EndRead%2A> deve essere chiamato con questo <xref:System.IAsyncResult> per scoprire quanti byte sono stati letti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.IAsyncResult" /> non è stato creato chiamando <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> in questa classe.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">La richiesta asincrona in sospeso.</param>
        <summary>Termina un'operazione di scrittura asincrona, rimanendo bloccato fino al completamento dell'operazione di I/O. (In alternativa, si consideri l'uso di <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, e <xref:System.IO.BufferedStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 <xref:System.IO.BufferedStream.EndWrite%2A> deve essere chiamato una sola volta per ogni chiamata a <xref:System.IO.BufferedStream.BeginRead%2A>. Riesce a terminare un processo di lettura prima di iniziare un'altra operazione di lettura può causare deadlock o altri comportamenti indesiderati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.IAsyncResult" /> non è stato creato chiamando <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> in questa classe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di cancellare i dati di tutti i buffer del flusso e la scrittura dei dati memorizzati nel buffer nella periferica sottostante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non chiama in modo esplicito `Flush` o <xref:System.IO.Stream.Close%2A>.  
  
 Se si usa la <xref:System.IO.BufferedStream.%23ctor%2A> costruttore, quindi specificare le dimensioni del buffer durante la creazione di `BufferedStream` dell'oggetto, il contenuto viene scaricato quando raggiunge la dimensione del buffer. Ad esempio, codice, ad esempio `BufferedStream bs = new BufferedStream(bs, 5)` Scarica il contenuto quando le dimensioni del buffer raggiungono 5 byte.  
  
 Tutti i metodi di lettura e scrittura di `BufferedStream` gestiscono automaticamente il buffer, in modo che non è necessario richiamare `Flush` quando si passa alternativamente tra lettura e scrittura.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.IO.IOException">L'origine dati o il repository non è aperto.</exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Cancella in modo asincrono i dati di tutti i buffer del flusso, determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scaricamento asincrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza del flusso in byte.</summary>
        <value>Lunghezza del flusso in byte.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Il flusso sottostante è <see langword="null" /> o è chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la posizione all'interno del flusso corrente.</summary>
        <value>Posizione all'interno del flusso corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `get` richiama funzione di accesso <xref:System.IO.BufferedStream.Seek%2A> per ottenere la posizione corrente all'interno del flusso sottostante e quindi modifica tale valore in base alla posizione corrente all'interno del buffer.  
  
 Il `set` copia i dati scritti in precedenza per il buffer nel flusso sottostante e quindi richiama <xref:System.IO.BufferedStream.Seek%2A>.  
  
 La ricerca in un punto qualsiasi oltre la lunghezza del flusso è supportata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore passato a <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, quale la chiusura del flusso.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Buffer in cui verranno copiati i byte.</param>
        <param name="offset">Offset dei byte nel buffer da cui iniziare la lettura dei byte.</param>
        <param name="count">Numero di byte da leggere.</param>
        <summary>Copia i byte dal flusso correntemente memorizzato nel buffer in una matrice.</summary>
        <returns>Numero complessivo di byte letti nel parametro <paramref name="array" />. Può essere minore del numero di byte richiesti se tale quantità di byte non è disponibile o 0 se è stata raggiunta la fine del flusso prima della lettura dei dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Read` metodo restituirà 0 solo se viene raggiunta la fine del flusso. In tutti gli altri casi, `Read` legge sempre almeno un byte dal flusso prima della restituzione. Per definizione, se non sono disponibili dati dal flusso al momento della chiamata a `Read`, il `Read` metodo restituisce 0 (raggiunta la fine del flusso viene automaticamente). Un'implementazione è gratuita restituire un minor numero di byte rispetto a quella richiesta, anche se non è stata raggiunta la fine del flusso.  
  
 Usare <xref:System.IO.BinaryReader> per la lettura dei tipi di dati primitivi.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="array" /> meno <paramref name="offset" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Il flusso non è aperto o è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> da cui iniziare la scrittura dei dati dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte letti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile creare un token di annullamento tramite la creazione di un'istanza del <xref:System.Threading.CancellationTokenSource> classi e passando il <xref:System.Threading.CancellationTokenSource.Token%2A> proprietà come il `cancellationToken` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge un byte dal flusso sottostante e restituisce il cast di byte su un parametro <see langword="int" /> o restituisce -1 se la lettura viene eseguita a partire dalla fine del flusso.</summary>
        <returns>Cast di byte su un parametro <see langword="int" /> o -1 se la lettura viene eseguita a partire dalla fine del flusso.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, quale la chiusura del flusso.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita su <see langword="Stream" /> crea una nuova matrice a byte singolo e quindi chiama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Si tratta formalmente corretto, è poco efficiente. Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'allocazione di una matrice aggiuntivi in ogni chiamata.</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Offset dei byte rispetto a <c>origin</c>.</param>
        <param name="origin">Valore del tipo <see cref="T:System.IO.SeekOrigin" /> che indica il punto di riferimento dal quale ottenere la nuova posizione.</param>
        <summary>Imposta la posizione all'interno del flusso corrente memorizzato nel buffer.</summary>
        <returns>Nuova posizione all'interno del flusso corrente memorizzato nel buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `offset` è negativo, la nuova posizione precederà quella specificata da `origin` in base al numero di byte specificato da `offset`. Se `offset` è 0, la nuova posizione sarà quella specificata da `origin`. Se `offset` è positivo, la nuova posizione seguirà quella specificata da `origin` in base al numero di byte specificato da `offset`.  
  
 Quando un <xref:System.IO.BufferedStream> oggetto è il flusso di base per un <xref:System.IO.StreamReader> dell'oggetto, chiamare il <xref:System.IO.BufferedStream.Seek%2A> metodo può causare la posizione del flusso in cui non è più corrisponda alla posizione del buffer interno nel lettore. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo se assolutamente necessario.  
  
 La ricerca in un punto qualsiasi oltre la lunghezza del flusso è supportata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Il flusso non è aperto o è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Intero che indica la lunghezza desiderata in byte del flusso corrente memorizzato nel buffer.</param>
        <summary>Imposta la lunghezza del flusso memorizzato nel buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il buffer viene scaricato prima di impostare la lunghezza di nell'origine dati sottostante o nell'archivio. Se il valore specificato è minore della lunghezza corrente del flusso memorizzato nel buffer, viene troncato nel flusso memorizzato nel buffer. Se il valore specificato è maggiore della lunghezza corrente del flusso memorizzato nel buffer, viene espanso nel flusso memorizzato nel buffer. Se il flusso memorizzato nel buffer viene espanso, il contenuto del flusso memorizzato nel buffer tra la vecchia e nuova lunghezze non definito.  
  
 `SetLength` Scarica tutte le scritture memorizzato nel buffer se necessario.  
  
 Un flusso deve supportare la scrittura e per la ricerca `SetLength` a funzionare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Il flusso non è aperto o è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta né la scrittura né la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice di byte da cui copiare i byte di <c>count</c> nel flusso corrente memorizzato nel buffer.</param>
        <param name="offset">Offset nel buffer da cui avviare la copia dei byte nel flusso corrente memorizzato nel buffer.</param>
        <param name="count">Numero di byte da scrivere nel flusso corrente memorizzato nel buffer.</param>
        <summary>Copia i byte nel flusso memorizzato nel buffer e sposta la posizione corrente, all'interno del flusso memorizzato nel buffer, in base al numero di byte scritto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.BufferedStream> classe.  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="array" /> meno <paramref name="offset" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Il flusso è chiuso o <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer da cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte scritti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scrittura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile creare un token di annullamento tramite la creazione di un'istanza del <xref:System.Threading.CancellationTokenSource> classi e passando il <xref:System.Threading.CancellationTokenSource.Token%2A> proprietà come il `cancellationToken` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di scrittura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte da scrivere nel flusso.</param>
        <summary>Scrive un byte nella posizione corrente all'interno del flusso memorizzato nel buffer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
  </Members>
</Type>