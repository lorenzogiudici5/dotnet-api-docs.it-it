<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="431f9e174b49e9b4691e3d8cf2409fcf68f1c7e3" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48744542" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <TypeSignature Language="F#" Value="type File = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce i metodi statici per creare, copiare, eliminare, spostare e aprire un singolo file, nonché supportare la creazione di oggetti <see cref="T:System.IO.FileStream" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la classe <xref:System.IO.File> per le operazioni tipiche, quali copia, spostamento, ridenominazione, creazione, apertura, eliminazione e aggiunta a un singolo file alla volta. È anche possibile usare la <xref:System.IO.File> classe per ottenere e impostare gli attributi di file o <xref:System.DateTime> informazioni relative alla creazione, accesso e la scrittura di un file. Se si desidera eseguire operazioni su più file, vedere <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> o <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Molte del <xref:System.IO.File> metodi restituiscono altri tipi dei / o quando si crea o aprire i file. È possibile utilizzare questi altri tipi per gestire ulteriormente un file. Per altre informazioni, vedere specifici <xref:System.IO.File> i membri, ad esempio <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, o <xref:System.IO.File.Create%2A>.  
  
 Poiché tutti i <xref:System.IO.File> metodi sono statici, potrebbe risultare più efficiente usare un' <xref:System.IO.File> metodo anziché un corrispondente <xref:System.IO.FileInfo> metodo di istanza se si desidera eseguire solo un'azione. Tutti i <xref:System.IO.File> metodi richiedono il percorso del file che si sta modificando.  
  
 I metodi statici del <xref:System.IO.File> classe eseguire controlli di sicurezza su tutti i metodi. Se si intende riutilizzare un oggetto più volte, è consigliabile usare il metodo di istanza corrispondente di <xref:System.IO.FileInfo> invece, poiché la sicurezza del controllo non sarà sempre essere necessarie.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura per i nuovi file viene concesso a tutti gli utenti.  
  
 Nella tabella seguente descrive le enumerazioni che consentono di personalizzare il comportamento di vari <xref:System.IO.File> metodi.  
  
|Enumerazione|Descrizione|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Specifica l'accesso in lettura e scrittura in un file.|  
|<xref:System.IO.FileShare>|Specifica il livello di accesso consentito per un file che è già in uso.|  
|<xref:System.IO.FileMode>|Specifica se venga mantenuto o sovrascrivere il contenuto di un file esistente e il fatto che le richieste per creare un file esistente generano un'eccezione.|  
  
> [!NOTE]
>  I membri che accettano un percorso come una stringa di input, che il percorso deve essere nel formato corretto o viene generata un'eccezione. Ad esempio, se un percorso completo, ma inizia con uno spazio, il percorso non viene ritagliato in metodi della classe. Di conseguenza, il percorso sia valido e viene generata un'eccezione. Analogamente, un percorso o una combinazione di percorsi non può essere completamente qualificata due volte. Ad esempio, "c:\windows c:\temp" genera anche un'eccezione nella maggior parte dei casi. Assicurarsi che i percorsi siano in formato corretto quando si usano i metodi che accettano una stringa di percorso.  
  
 Nei membri che accettano un percorso, il percorso può fare riferimento a un file o solo una directory. Il percorso specificato può anche fare riferimento a un percorso relativo o un percorso Universal Naming Convention (UNC) per un nome di server e la condivisione. Ad esempio, le condizioni seguenti sono percorsi accettabili:  
  
-   "c:\\\MyDir\\\MyFile.txt" in c# o "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "c:\\\MyDir" in c# o "c:\MyDir" in Visual Basic.  
  
-   "MyDir\\\MySubdir" in c# o "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" nel linguaggio c#, o "\\\MyServer\MyShare" in Visual Basic.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.IO.File> classe per verificare se esiste un file, e a seconda del risultato, creare un nuovo file e scrivere, o aprire il file esistente e leggere da essa. Prima di eseguire il codice, creare un `c:\temp` cartella.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge righe a un file e quindi lo chiude.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">File in cui aggiungere righe. Se il file non esiste già, verrà creato.</param>
        <param name="contents">Righe da aggiungere al file.</param>
        <summary>Aggiunge righe a un file e quindi lo chiude. Se il file specificato non esiste, questo metodo ne crea uno, scrive la riga specificata e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo crea il file se non esiste, ma non crea nuove directory. Pertanto, il valore della `path` parametro deve contenere le directory esistenti.  
  
   
  
## Examples  
 Nell'esempio seguente scrive le righe selezionate da un file di dati di esempio in un file e quindi vengono aggiunte altre righe. La directory denominata `temp` nell'unità C deve essere presente per l'esempio completato correttamente.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio, la directory non esiste o si trova su un'unità non connessa).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione di scrittura nel file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File in cui aggiungere righe. Se il file non esiste già, verrà creato.</param>
        <param name="contents">Righe da aggiungere al file.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <summary>Aggiunge righe a un file, usando una codifica specificata e quindi lo chiude. Se il file specificato non esiste, questo metodo ne crea uno, scrive la riga specificata e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo crea il file se non esiste, ma non crea nuove directory. Pertanto, il valore della `path` parametro deve contenere le directory esistenti.  
  
 È possibile utilizzare questo metodo per creare un file che contiene gli elementi seguenti:  
  
-   I risultati di una [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) eseguire una query sulle righe di un file, come ottenuta utilizzando il <xref:System.IO.File.ReadLines%2A> (metodo).  
  
-   Il contenuto di una raccolta che implementa un <xref:System.Collections.Generic.IEnumerable%601> delle stringhe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio, la directory non esiste o si trova su un'unità non connessa).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge la stringa specificata al file, creando il file nel caso in cui non esista.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File a cui aggiungere la stringa specificata.</param>
        <param name="contents">Stringa da aggiungere al file.</param>
        <summary>Apre un file, aggiunge la stringa specificata e quindi lo chiude. Se il file non esiste, questo metodo ne crea uno, scrive la stringa specificata e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data una stringa e un percorso di file, questo metodo apre il file specificato, aggiunge la stringa alla fine del file e quindi lo chiude. L'handle di file è garantito per essere chiuso da questo metodo, anche se le eccezioni vengono generate.  
  
 Il metodo crea il file se non esiste, ma non crea nuove directory. Pertanto, il valore della `path` parametro deve contenere le directory esistenti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.AppendAllText%2A> metodo per aggiungere testo aggiuntivo alla fine di un file. In questo esempio viene creato un file se non esiste già e a cui viene aggiunto il testo. Tuttavia, la directory denominata `temp` nell'unità C deve essere presente per l'esempio completato correttamente.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio la directory non esiste o si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File a cui aggiungere la stringa specificata.</param>
        <param name="contents">Stringa da aggiungere al file.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <summary>Accoda la stringa specificata al file, creando il file nel caso in cui non esista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data una stringa e un percorso di file, questo metodo apre il file specificato, aggiunge la stringa alla fine del file usando la codifica specificata e quindi lo chiude. L'handle di file è garantito per essere chiuso da questo metodo, anche se le eccezioni vengono generate.  
  
 Il metodo crea il file se non esiste, ma non crea nuove directory. Pertanto, il valore della `path` parametro deve contenere le directory esistenti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.AppendAllText%2A> metodo per aggiungere testo aggiuntivo alla fine di un file. In questo esempio viene creato un file se non esiste già e a cui viene aggiunto il testo. Tuttavia, la directory denominata `temp` nell'unità C deve essere presente per l'esempio completato correttamente.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio la directory non esiste o si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member AppendText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.AppendText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file al quale aggiungere testo.</param>
        <summary>Crea un oggetto <see cref="T:System.IO.StreamWriter" /> che aggiunge testo con codifica UTF-8 a un file esistente o a un nuovo file se quello specificato non esiste.</summary>
        <returns>Writer di flusso che aggiunge testo con codifica UTF-8 al file specificato o a un nuovo file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> overload del costruttore. Se il file specificato da `path` non esiste, crearla. Se il file esiste, le operazioni di scrittura di <xref:System.IO.StreamWriter> aggiungere testo al file. Thread aggiuntivi sono autorizzati a leggere il file mentre è aperto.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Il `path` parametro non distinzione maiuscole/minuscole.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente aggiunge il testo in un file. Il metodo crea un nuovo file se il file non esiste. Tuttavia, la directory denominata `temp` nell'unità C deve essere presente per l'esempio completato correttamente.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio la directory non esiste o si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accodamento al file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un file esistente in un nuovo file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destFileName">Nome del file di destinazione. Non può essere una directory o un file esistente.</param>
        <summary>Copia un file esistente in un nuovo file. Non è consentito sovrascrivere un file con lo stesso nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> overload del metodo con il `overwrite` parametro impostato su `false`.  
  
 Il `sourceFileName` e `destFileName` i parametri possono specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere il <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> (metodo). Questo metodo non supporta caratteri jolly nei parametri.  
  
 Gli attributi del file originale vengono mantenuti in file copiato.  
  
   
  
## Examples  
 Nell'esempio seguente copia file cartella di backup c:\archives\2008. Usa i due overload del <xref:System.IO.File.Copy%2A> metodo come indicato di seguito:  
  
-   Utilizza in primo luogo il <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> overload del metodo per copiare i file di testo (txt). Il codice dimostra che questo overload non consente la sovrascrittura dei file che sono già stati copiati.  
  
-   Usa quindi il <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo per copiare immagini (file con estensione jpg). Il codice dimostra che questo overload consente di sovrascrivere i file che sono già stati copiati.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
oppure 
 <paramref name="sourceFileName" /> o <paramref name="destFileName" /> specifica una directory.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato in <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="sourceFileName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">L'oggetto <paramref name="destFileName" /> esiste.  
  
oppure 
Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal <paramref name="sourceFileName" /> e la scrittura in <paramref name="destFileName" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string * bool -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destFileName">Nome del file di destinazione. Non può essere una directory.</param>
        <param name="overwrite">
          <see langword="true" /> se il file di destinazione può essere sovrascritto; in caso contrario, <see langword="false" />.</param>
        <summary>Copia un file esistente in un nuovo file. È consentito sovrascrivere un file con lo stesso nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceFileName` e `destFileName` i parametri possono specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Questo metodo non supporta caratteri jolly nei parametri.  
  
 Gli attributi del file originale vengono mantenuti in file copiato.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente copia file cartella di backup c:\archives\2008. Usa i due overload del <xref:System.IO.File.Copy%2A> metodo come indicato di seguito:  
  
-   Utilizza in primo luogo il <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> overload del metodo per copiare i file di testo (txt). Il codice dimostra che questo overload non consente la sovrascrittura dei file che sono già stati copiati.  
  
 Usa quindi il <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo per copiare immagini (file con estensione jpg). Il codice dimostra che questo overload consente di sovrascrivere i file che sono già stati copiati.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="destFileName" /> è di sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
oppure 
 <paramref name="sourceFileName" /> o <paramref name="destFileName" /> specifica una directory.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato in <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'oggetto <paramref name="sourceFileName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> esiste e <paramref name="overwrite" /> è <see langword="false" />.  
  
oppure 
Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal <paramref name="sourceFileName" /> e la scrittura in <paramref name="destFileName" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un file nel percorso specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.IO.FileStream" Usage="System.IO.File.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso e nome del file da creare.</param>
        <summary>Crea o sovrascrive un file nel percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> che fornisce l'accesso in lettura/scrittura al file specificato in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileStream> oggetto creato da questo metodo è un valore predefinito <xref:System.IO.FileShare> pari a <xref:System.IO.FileShare.None>; nessun altro processo o codice può accedere al file creato fino a quando non viene chiuso l'handle di file originale.  
  
 Questo metodo equivale al <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> overload del metodo usando le dimensioni del buffer predefinite.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se il file specificato non esiste, crearla; Se esiste e non è di sola lettura, il contenuto viene sovrascritto.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura per i nuovi file viene concesso a tutti gli utenti. Il file viene aperto con accesso in lettura/scrittura e deve essere chiuso prima di poter essere aperto da un'altra applicazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente crea un file nel percorso specificato, scrive alcune informazioni nel file e legge dal file.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="path" /> specifica un file di sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la creazione del file.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberSignature Language="F#" Value="static member Create : string * int -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Nome del file.</param>
        <param name="bufferSize">Numero di byte memorizzati nel buffer per letture e scritture nel file.</param>
        <summary>Crea o sovrascrive il file specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> con le dimensioni del buffer specificate che fornisce l'accesso in lettura/scrittura al file specificato in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileStream> oggetto creato da questo metodo è un valore predefinito <xref:System.IO.FileShare> pari a <xref:System.IO.FileShare.None>; nessun altro processo o codice può accedere al file creato fino a quando non viene chiuso l'handle di file originale.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Questo metodo equivale al <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> overload del costruttore. Se il file specificato non esiste, crearla; Se esiste e non è di sola lettura, il contenuto viene sovrascritto.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura per i nuovi file viene concesso a tutti gli utenti. Il file viene aperto con accesso in lettura/scrittura e deve essere chiuso prima di poter essere aperto da un'altra applicazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente crea un file con le dimensioni del buffer specificate.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="path" /> specifica un file di sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la creazione del file.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Nome del file.</param>
        <param name="bufferSize">Numero di byte memorizzati nel buffer per letture e scritture nel file.</param>
        <param name="options">Uno dei valori di <see cref="T:System.IO.FileOptions" /> che descrive come creare o sovrascrivere il file.</param>
        <summary>Crea o sovrascrive il file indicato, specificando le dimensioni del buffer e un valore <see cref="T:System.IO.FileOptions" /> che descrive come creare o sovrascrivere il file.</summary>
        <returns>Nuovo file con le dimensioni del buffer specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Questo metodo equivale al <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> overload del costruttore. Se il file specificato non esiste, crearla; Se esiste e non è di sola lettura, il contenuto viene sovrascritto.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura per i nuovi file viene concesso a tutti gli utenti. Il file viene aperto con accesso in lettura/scrittura e deve essere chiuso prima di poter essere aperto da un'altra applicazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="path" /> specifica un file di sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la creazione del file.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Nome del file.</param>
        <param name="bufferSize">Numero di byte memorizzati nel buffer per letture e scritture nel file.</param>
        <param name="options">Uno dei valori di <see cref="T:System.IO.FileOptions" /> che descrive come creare o sovrascrivere il file.</param>
        <param name="fileSecurity">Uno dei valori di <see cref="T:System.Security.AccessControl.FileSecurity" /> che determina il controllo di accesso e la sicurezza di controllo del file.</param>
        <summary>Crea o sovrascrive il file specificato con le dimensione del buffer, le opzioni e la sicurezza del file specificati.</summary>
        <returns>Nuovo file con dimensioni del buffer, opzioni e sicurezza del file specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Questo metodo equivale al <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> overload del costruttore. Se il file specificato non esiste, crearla; Se esiste e non è di sola lettura, il contenuto viene sovrascritto.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura per i nuovi file viene concesso a tutti gli utenti. Il file viene aperto con accesso in lettura/scrittura e deve essere chiuso prima di poter essere aperto da un'altra applicazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="path" /> specifica un file di sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante la creazione del file.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.CreateText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la scrittura.</param>
        <summary>Crea o apre un file per la scrittura di testo con codifica UTF-8. Se il file esiste, il relativo contenuto verrà sovrascritto.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamWriter" /> che scrive nel file specificato usando la codifica UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> overload del costruttore con il `append` parametro impostato su `false`. Se il file specificato da `path` non esiste, crearla. Se il file esiste, il relativo contenuto viene sovrascritti. Thread aggiuntivi sono autorizzati a leggere il file mentre è aperto.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente crea un file per lettura e scrittura di testo.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Decrypt : string -&gt; unit" Usage="System.IO.File.Decrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso che descrive il file da decrittografare.</param>
        <summary>Decrittografa un file crittografato dall'account corrente usando il metodo <see cref="M:System.IO.File.Encrypt(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Decrypt%2A> metodo consente di decrittografare un file che era stato crittografato mediante il <xref:System.IO.File.Encrypt%2A> (metodo).  Il <xref:System.IO.File.Decrypt%2A> metodo in grado di decrittografare solo i file che sono stati crittografati con l'account utente corrente.  
  
 Il <xref:System.IO.File.Decrypt%2A> metodo richiede l'accesso esclusivo al file da decrittografare e genererà un'eccezione se un altro processo sta utilizzando il file. Se il file non è crittografato, <xref:System.IO.File.Decrypt%2A> restituirà un valore diverso da zero, che indica l'esito positivo.  
  
 Entrambi i <xref:System.IO.File.Encrypt%2A> (metodo) e il <xref:System.IO.File.Decrypt%2A> metodo usare il provider del servizio di crittografia (CSP) installato nel computer e le chiavi di crittografia di file del processo di chiamata al metodo.  
  
 Il file system corrente deve essere formattato come NTFS e il sistema operativo corrente deve essere Windows NT o versione successiva.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.Encrypt%2A> metodo e il <xref:System.IO.File.Decrypt%2A> metodo per crittografare e decrittografare un file. Il file deve esistere affinché l'esempio funzioni.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">È stata specificata un'unità non valida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file descritto dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file. Ad esempio, il file crittografato è già aperto.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Windows NT o versioni successive.</exception>
        <exception cref="T:System.NotSupportedException">Il file system non è NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro <paramref name="path" /> specifica una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.File.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nome del file da eliminare. Non è supportato l'uso di caratteri jolly.</param>
        <summary>Elimina il file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specificare un nome di file con alcuna informazione sul percorso relativo o assoluto per il `path` parametro. I caratteri jolly non possono essere inclusi. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se il file da eliminare non esiste, viene generata alcuna eccezione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente copia i gruppi di file nella cartella backup c:\archives\2008. e quindi vengono eliminate dalla cartella di origine.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Il file specificato è in uso.  
  
oppure 
È presente un handle aperto sul file e il sistema operativo è Windows XP o versioni precedenti. Questo handle aperto può derivare dall'enumerazione di directory e file. Per altre informazioni, vedere [Procedura: enumerare directory e file](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
Il file è un file eseguibile in uso.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
 <paramref name="path" /> ha specificato un file in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per eliminare il file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Encrypt : string -&gt; unit" Usage="System.IO.File.Encrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso che descrive il file da crittografare.</param>
        <summary>Crittografa un file in modo che possa essere decrittografato solamente dall'account che lo ha crittografato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Encrypt%2A> metodo consente di crittografare un file in modo che possa essere decrittografato solo l'account usato per chiamare questo metodo. Usare la <xref:System.IO.File.Decrypt%2A> metodo per decrittografare un file crittografato con la <xref:System.IO.File.Encrypt%2A> (metodo).  
  
 Il <xref:System.IO.File.Encrypt%2A> metodo richiede l'accesso esclusivo al file crittografato e avrà esito negativo se un altro processo sta utilizzando il file.  
  
 Entrambi i <xref:System.IO.File.Encrypt%2A> (metodo) e il <xref:System.IO.File.Decrypt%2A> metodo usare il provider del servizio di crittografia (CSP) installato nel computer e le chiavi di crittografia di file del processo di chiamata al metodo.  
  
 Questo metodo non è disponibile in tutte le versioni di Windows. Non è ad esempio, disponibile nelle edizioni Home.  
  
 Il file system corrente deve essere formattato come NTFS.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.Encrypt%2A> metodo e il <xref:System.IO.File.Decrypt%2A> metodo per crittografare e decrittografare un file. Il file deve esistere affinché l'esempio funzioni.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">È stata specificata un'unità non valida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file descritto dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Windows NT o versioni successive.</exception>
        <exception cref="T:System.NotSupportedException">Il file system non è NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro <paramref name="path" /> specifica una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere e scrivere il file descritto dal <paramref name="path" /> parametro. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.File.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da controllare.</param>
        <summary>Determina se il file specificato esiste.</summary>
        <returns>
          <see langword="true" /> se il chiamante dispone delle autorizzazioni richieste e se <paramref name="path" /> contiene il nome di un file esistente; altrimenti, <see langword="false" />. Questo metodo restituisce anche <see langword="false" /> se <paramref name="path" /> è <see langword="null" />, un percorso non valido o una stringa di lunghezza zero. Se il chiamante non dispone di autorizzazioni sufficienti per leggere il file specificato, non viene generata alcuna eccezione e il metodo restituisce <see langword="false" /> a prescindere dall'esistenza di <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Exists%2A> metodo non deve essere usato per la convalida del percorso, questo metodo verifica semplicemente se il file specificato in `path` esiste. Il passaggio di un percorso non valido per <xref:System.IO.File.Exists%2A> restituisce `false`. Per verificare se il percorso contiene caratteri non validi, è possibile chiamare il <xref:System.IO.Path.GetInvalidPathChars%2A> metodo per recuperare i caratteri non validi per il file system. È anche possibile creare un'espressione regolare per verificare se il percorso sia valido per l'ambiente. Per esempi di percorsi accettabili, vedere <xref:System.IO.File>.  
  
 Per verificare se è presente una directory, vedere <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Tenere presente che un altro processo può potenzialmente eseguire un'operazione con il file tra l'ora si chiama il <xref:System.IO.File.Exists%2A> metodo ed eseguire un'altra operazione sul file, ad esempio <xref:System.IO.File.Delete%2A>.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se `path` descrive una directory, questo metodo restituisce `false`. Gli spazi finali vengono rimossi dal `path` parametro prima di determinare se il file esiste.  
  
 Il <xref:System.IO.File.Exists%2A> restituzione del metodo `false` se si verifica un errore durante il tentativo di determinare se il file specificato esiste. Ciò può verificarsi nelle situazioni che generano eccezioni, ad esempio passando un nome di file con caratteri non validi o troppi caratteri, un disco mancante o non superato o se il chiamante non dispone dell'autorizzazione per leggere il file.  
  
   
  
## Examples  
 Nell'esempio seguente determina se esiste un file.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) di un file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.FileInfo.GetAccessControl%2A> metodi per recuperare l'accesso controllano le voci dell'elenco (ACL) di un file specificato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso al file contenente un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che descrive le informazioni relative all'elenco di controllo di accesso (ACL) del file.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) di un file specificato.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula le regole di controllo di accesso del file descritto dal parametro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.File.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per un file.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono dei diritti ad azioni specifiche per il file specificato. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In ambienti di NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> vengono concesse all'utente se l'utente ha <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> diritti alla cartella padre. Per negare <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Nega <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sulla directory padre.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.GetAccessControl%2A> e il <xref:System.IO.File.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso di controllo voce di elenco (ACL) da un file.  È necessario specificare un utente valido o un account di gruppo per eseguire questo esempio.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Il file non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro <paramref name="path" /> specifica una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere l'elenco di controllo di accesso. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Percorso al file contenente un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che descrive le informazioni relative all'elenco di controllo di accesso (ACL) del file.</param>
        <param name="includeSections">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlSections" /> che specifica il tipo di informazioni relative all'elenco di controllo di accesso (ACL) da ricevere.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula il tipo specificato di voci dell'elenco di controllo di accesso (ACL) per un file specificato.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula le regole di controllo di accesso del file descritto dal parametro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.File.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per un file.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono dei diritti ad azioni specifiche per il file specificato. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In ambienti di NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> vengono concesse all'utente se l'utente ha <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> diritti alla cartella padre. Per negare <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Nega <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sulla directory padre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Il file non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro <paramref name="path" /> specifica una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione leggere l'elenco di controllo di accesso. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : string -&gt; System.IO.FileAttributes" Usage="System.IO.File.GetAttributes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.IO.FileAttributes" /> del file nel percorso.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileAttributes" /> del file nel percorso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il `GetAttributes` e `SetAttributes` metodi applicando le `Archive` e `Hidden` attributi in un file.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è vuoto, contiene solo spazi o contiene caratteri non validi.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> rappresenta un file e non è valido, ad esempio in quanto si trova su un'unità non connessa o è impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> rappresenta una directory e non è valida, ad esempio in quanto si trova su un'unità non connessa o è impossibile trovare la directory.</exception>
        <exception cref="T:System.IO.IOException">Il file è usato da un altro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dei file. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.File.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di creazione.</param>
        <summary>Restituisce la data e l'ora di creazione del file o della directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora di creazione del file o della directory specificata. Questo valore è espresso nell'ora locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC), aggiornata all'ora locale.  
  
 Unità NTFS possono memorizzare nella cache di informazioni su un file, ad esempio ora di creazione di file, per un breve periodo di tempo. Di conseguenza, potrebbe essere necessario impostare in modo esplicito l'ora di creazione di un file se si intende sovrascrivere o sostituire un file esistente.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di creazione.</param>
        <summary>Restituisce la data e l'ora di creazione, nell'ora UTC (Universal Coordinated Time), del file o della directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora di creazione del file o della directory specificata. Questo valore è espresso nell'ora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC).  
  
 Unità NTFS possono memorizzare nella cache di informazioni su un file, ad esempio ora di creazione di file, per un breve periodo di tempo. Di conseguenza, potrebbe essere necessario impostare in modo esplicito l'ora di creazione di un file se si intende sovrascrivere o sostituire un file esistente.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.IO.File.GetCreationTimeUtc%2A> (metodo).  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di accesso.</param>
        <summary>Restituisce la data e l'ora dell'ultimo accesso al file o alla directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora dell'ultimo accesso al file o alla directory specificata. Questo valore è espresso nell'ora locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC), aggiornata all'ora locale.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di accesso.</param>
        <summary>Restituisce la data e l'ora, nell'ora UTC (Universal Coordinated Time), dell'ultimo accesso al file o alla directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora dell'ultimo accesso al file o alla directory specificata. Questo valore è espresso nell'ora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC).  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di scrittura.</param>
        <summary>Restituisce la data e l'ora dell'ultima scrittura nel file o nella directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora dell'ultima scrittura nel file o nella directory specificata. Questo valore è espresso nell'ora locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo. Ogni sistema operativo gestisce l'ora dell'ultima scrittura in base alle regole specifiche. Per migliorare le prestazioni, un sistema operativo potrebbe non impostato l'ultimo valore di ora di scrittura per l'ora esatta dell'ultima operazione di scrittura, ma potrebbe impostato invece su un'approssimazione molto vicina.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC), aggiornata all'ora locale.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni sulla data e l'ora di scrittura.</param>
        <summary>Restituisce la data e l'ora, nell'ora UTC (Universal Coordinated Time), dell'ultima scrittura nel file o nella directory specificata.</summary>
        <returns>Struttura <see cref="T:System.DateTime" /> impostata sulla data e l'ora dell'ultima scrittura nel file o nella directory specificata. Questo valore è espresso nell'ora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questo metodo può restituire un valore inaccurato, perché Usa funzioni native i cui valori potrebbero non essere aggiornati in modo continuo dal sistema operativo. Ogni sistema operativo gestisce l'ora dell'ultima scrittura in base alle regole specifiche. Per migliorare le prestazioni, un sistema operativo potrebbe non impostato l'ultimo valore di ora di scrittura per l'ora esatta dell'ultima operazione di scrittura, ma potrebbe impostato invece su un'approssimazione molto vicina.  
  
 Se il file descritto nel `path` parametro non esiste, questo metodo restituisce 12 mezzanotte del 1 gennaio 1601 D.C. (C.E.) Coordinated Universal Time (UTC).  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nome del file da spostare. Può includere un percorso relativo o assoluto.</param>
        <param name="destFileName">Nuovo percorso e nome del file.</param>
        <summary>Sposta il file specificato in un nuovo percorso, consentendo di specificare per esso un nuovo nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona su volumi di disco e non genera un'eccezione se l'origine e destinazione sono uguali. Si noti che se si tenta di sostituire un file spostando un file con lo stesso nome in tale directory, otterrai un <xref:System.IO.IOException>. È possibile utilizzare il metodo di spostamento per sovrascrivere un file esistente.  
  
 Il `sourceFileName` e `destFileName` argomenti possono includere le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se si prova a spostare un file in volumi di dischi e tale file è in uso, il file viene copiato nella destinazione, ma non viene eliminato dall'origine.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente sposta un file.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Il file di destinazione esiste già.  
  
oppure 
 Il parametro <paramref name="sourceFileName" /> non è stato trovato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti in <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato in <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido (ad esempio, si trova su un'unità non connessa).</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="sourceFileName" /> o <paramref name="destFileName" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal <paramref name="sourceFileName" /> e la scrittura in <paramref name="destFileName" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre <see cref="T:System.IO.FileStream" /> nel percorso specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire.</param>
        <param name="mode">Valore <see cref="T:System.IO.FileMode" /> che specifica se verrà creato un file qualora non ne esista già uno e determina se mantenere o sovrascrivere il contenuto dei file esistenti.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.FileStream" /> nel percorso specificato con accesso in lettura/scrittura e senza condivisione.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> aperto nella modalità e nel percorso specificati, con accesso in lettura/scrittura e non condiviso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente crea un file temporaneo e vi scrive del testo. Nell'esempio viene quindi aperto il file, usando T:System.IO.FileMode.Open; vale a dire, se il file non esiste già, sarebbe non crearla.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Create" /> e il file specificato è un file nascosto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> ha specificato un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura nel file specificato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire.</param>
        <param name="mode">Valore <see cref="T:System.IO.FileMode" /> che specifica se verrà creato un file qualora non ne esista già uno e determina se mantenere o sovrascrivere il contenuto dei file esistenti.</param>
        <param name="access">Valore <see cref="T:System.IO.FileAccess" /> che specifica le operazioni eseguibili sul file.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.FileStream" /> nel percorso specificato, con la modalità e l'accesso indicati e senza condivisione.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> non condiviso che consente di accedere al file specificato, con la modalità e l'accesso indicati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene aperto un file con accesso in sola lettura.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
oppure 
 <paramref name="access" /> ha specificato <see langword="Read" /> e <paramref name="mode" /> ha specificato <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" />, oppure <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> ha specificato un file che è in sola lettura e <paramref name="access" /> non è <see langword="Read" />.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Create" /> e il file specificato è un file nascosto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> o <paramref name="access" /> ha specificato un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura nel file specificato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire.</param>
        <param name="mode">Valore <see cref="T:System.IO.FileMode" /> che specifica se verrà creato un file qualora non ne esista già uno e determina se mantenere o sovrascrivere il contenuto dei file esistenti.</param>
        <param name="access">Valore <see cref="T:System.IO.FileAccess" /> che specifica le operazioni eseguibili sul file.</param>
        <param name="share">Valore <see cref="T:System.IO.FileShare" /> che specifica il tipo di accesso al file di cui dispongono altri thread.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.FileStream" /> nel percorso specificato, con la modalità indicata con accesso in lettura, scrittura o lettura/scrittura e l'opzione di condivisione indicata.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> nel percorso specificato, con la modalità indicata con accesso in lettura, scrittura o lettura/scrittura e l'opzione di condivisione indicata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene aperto un file con accesso in lettura e la condivisione di file non consentiti.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
oppure 
 <paramref name="access" /> ha specificato <see langword="Read" /> e <paramref name="mode" /> ha specificato <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" />, oppure <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> ha specificato un file che è in sola lettura e <paramref name="access" /> non è <see langword="Read" />.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Create" /> e il file specificato è un file nascosto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> o <paramref name="access" /> o <paramref name="share" /> ha specificato un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura nel file specificato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenRead : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenRead path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <summary>Apre un file esistente per la lettura.</summary>
        <returns>Oggetto<see cref="T:System.IO.FileStream" /> di sola lettura nel percorso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> overload del costruttore con un <xref:System.IO.FileMode> pari a <xref:System.IO.FileMode.Open>, una <xref:System.IO.FileAccess> pari a <xref:System.IO.FileAccess.Read> e una <xref:System.IO.FileShare> pari a <xref:System.IO.FileShare.Read>.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene aperto un file per la lettura.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenText : string -&gt; System.IO.StreamReader" Usage="System.IO.File.OpenText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <summary>Apre un file di testo esistente con codifica UTF-8 per la lettura.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamReader" /> nel percorso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.StreamReader.%23ctor%28System.String%29> overload del costruttore.  
  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene aperto un file di testo per la lettura.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenWrite : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenWrite path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la scrittura.</param>
        <summary>Apre un file esistente o crea un nuovo file per la scrittura.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileStream" /> non condiviso nel percorso specificato con accesso a <see cref="F:System.IO.FileAccess.Write" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> overload del costruttore con la modalità file impostata su <xref:System.IO.FileMode.OpenOrCreate>, l'accesso è impostato <xref:System.IO.FileAccess.Write>e la modalità di condivisione impostata su <xref:System.IO.FileShare.None>.  
  
 Il <xref:System.IO.File.OpenWrite%2A> metodo apre un file se già esiste per il percorso del file, o crea un nuovo file se non esiste. Per un file esistente, tale metodo non aggiunge il nuovo testo al testo esistente. Al contrario, i caratteri esistenti vengono sovrascritti con i caratteri di nuova. Se si sovrascrive una stringa più lunga (ad esempio "This is a un test del metodo OpenWrite") con una stringa più breve (ad esempio, "seconda esecuzione"), il file conterrà una combinazione delle stringhe ("secondo runtest del metodo OpenWrite").  
  
 Il `path` parametro può specificare un percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, usare il <xref:System.IO.Directory.GetCurrentDirectory%2A> (metodo).  
  
 L'oggetto restituito <xref:System.IO.FileStream> non supporta la lettura. Per aprire un file per la lettura e scrittura, utilizzare <xref:System.IO.File.Open%2A>.

 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene aperto un file per lettura e scrittura.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.  
  
oppure 
 <paramref name="path" /> ha specificato un file o una directory in sola lettura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="System.IO.File.ReadAllBytes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <summary>Apre un file binario, ne legge il contenuto in una matrice di byte e lo chiude.</summary>
        <returns>Matrice di byte con il contenuto del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dato un percorso di file, questo metodo consente di aprire il file, legge il contenuto del file in una matrice di byte e quindi lo chiude.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllBytesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="System.IO.File.ReadAllBytesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un file di testo, ne legge tutte le righe in una matrice di stringhe e quindi lo chiude.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string -&gt; string[]" Usage="System.IO.File.ReadAllLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <summary>Apre un file di testo, ne legge tutte le righe e quindi lo chiude.</summary>
        <returns>Matrice di stringhe contenente tutte le righe del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di aprire un file, legge ogni riga del file, quindi aggiunge ogni riga come elemento di una matrice di stringhe. Quindi chiude il file. Feed di una riga è definito come una sequenza di caratteri seguita da un ritorno a capo ('\r'), un avanzamento riga ('\n') o un ritorno a capo seguito immediatamente da una riga. La stringa risultante non contiene il ritorno a capo e/o l'avanzamento riga.  
  
 Questo metodo prova a rilevare automaticamente la codifica di un file basato sulla presenza dei byte order mark. Formati di codifica UTF-8 e UTF-32 (big-endian e little-endian) può essere rilevato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.ReadAllLines%2A> metodo per visualizzare il contenuto di un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string * System.Text.Encoding -&gt; string[]" Usage="System.IO.File.ReadAllLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <param name="encoding">Codifica applicata al contenuto del file.</param>
        <summary>Apre un file, ne legge tutte le righe con la codifica specificata e quindi lo chiude.</summary>
        <returns>Matrice di stringhe contenente tutte le righe del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di aprire un file, legge ogni riga del file e quindi aggiunge ogni riga come elemento di una matrice di stringhe. Quindi chiude il file. Feed di una riga è definito come una sequenza di caratteri seguita da un ritorno a capo ('\r'), un avanzamento riga ('\n') o un ritorno a capo seguito immediatamente da una riga. La stringa risultante non contiene il ritorno a capo e/o l'avanzamento riga.  
  
 Questo metodo prova a rilevare automaticamente la codifica di un file basato sulla presenza dei byte order mark. Formati di codifica UTF-8 e UTF-32 (big-endian e little-endian) può essere rilevato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.ReadAllLines%2A> metodo per visualizzare il contenuto di un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un file di testo, ne legge tutte le righe in una stringa e quindi lo chiude.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="System.IO.File.ReadAllText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <summary>Apre un file di testo, ne legge tutte le righe e quindi lo chiude.</summary>
        <returns>Stringa che contiene tutte le righe del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di aprire un file, legge ogni riga del file e quindi aggiunge ogni riga come elemento di una stringa. Quindi chiude il file. Feed di una riga è definito come una sequenza di caratteri seguita da un ritorno a capo ('\r'), un avanzamento riga ('\n') o un ritorno a capo seguito immediatamente da una riga. La stringa risultante non contiene il ritorno a capo e/o l'avanzamento riga.  
  
 Questo metodo prova a rilevare automaticamente la codifica di un file basato sulla presenza dei byte order mark. Formati di codifica UTF-8 e UTF-32 (big-endian e little-endian) può essere rilevato.  
  
 Usare il <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> overload del metodo durante la lettura dei file che possono contenere testo importato, perché non è stata riconosciuta caratteri non vengano letti correttamente.  
  
 L'handle di file è garantito per essere chiuso da questo metodo, anche se le eccezioni vengono generate.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.ReadAllText%2A> metodo per visualizzare il contenuto di un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="System.IO.File.ReadAllText (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File da aprire per la lettura.</param>
        <param name="encoding">Codifica applicata al contenuto del file.</param>
        <summary>Apre un file, ne legge tutte le righe con la codifica specificata e quindi lo chiude.</summary>
        <returns>Stringa che contiene tutte le righe del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di aprire un file, legge ogni riga del file e quindi aggiunge ogni riga come elemento di una stringa. Quindi chiude il file. Feed di una riga è definito come una sequenza di caratteri seguita da un ritorno a capo ('\r'), un avanzamento riga ('\n') o un ritorno a capo seguito immediatamente da una riga. La stringa risultante non contiene il ritorno a capo e/o l'avanzamento riga.  
  
 Questo metodo prova a rilevare automaticamente la codifica di un file basato sulla presenza dei byte order mark. Formati di codifica UTF-8 e UTF-32 (big-endian e little-endian) può essere rilevato.  
  
 L'handle di file è garantito per essere chiuso da questo metodo, anche se le eccezioni vengono generate.  
  
 Per usare le impostazioni di codifica in base alla configurazione per il sistema operativo, specificare il <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> proprietà per il `encoding` parametro.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.ReadAllText%2A> metodo per visualizzare il contenuto di un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato in <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge le righe di un file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File da leggere.</param>
        <summary>Legge le righe di un file.</summary>
        <returns>Tutte le righe del file o le righe sono il risultato di una query.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> metodi differiscono nel modo seguente: quando si usa <xref:System.IO.File.ReadLines%2A>, è possibile avviare l'enumerazione dell'insieme di stringhe prima che venga restituito l'intero insieme, quando si usa <xref:System.IO.File.ReadAllLines%2A>, è necessario attendere per l'intera matrice di stringhe restituito prima che sia possibile accedere alla matrice. Pertanto, quando si lavora con file di dimensioni molto grandi, <xref:System.IO.File.ReadLines%2A> può risultare più efficiente.  
  
 È possibile usare il <xref:System.IO.File.ReadLines%2A> metodo per eseguire le operazioni seguenti:  
  
-   Seguire [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) le query su un file per ottenere un set filtrato di righe.  
  
-   Scrivere l'insieme di righe restituito in un file con il <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> metodo, o li aggiunge a un file esistente con il <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> (metodo).  
  
-   Creare un'istanza popolata immediatamente una raccolta che accetta un <xref:System.Collections.Generic.IEnumerable%601> raccolta di stringhe per il relativo costruttore, ad esempio un <xref:System.Collections.Generic.IList%601> o un <xref:System.Collections.Generic.Queue%601>.  
  
 Questo metodo Usa <xref:System.Text.Encoding.UTF8%2A> per il valore di codifica.  
  
   
  
## Examples  
 L'esempio seguente legge le righe di un file per trovare le righe che contengono stringhe specificate.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 L'esempio seguente usa il <xref:System.IO.File.ReadLines%2A> metodo in una query LINQ che enumera tutte le directory per i file con estensione txt, legge ogni riga del file e viene visualizzata la riga se contiene la stringa "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string * System.Text.Encoding -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File da leggere.</param>
        <param name="encoding">Codifica applicata al contenuto del file.</param>
        <summary>Legge le righe di un file con una codifica specificata.</summary>
        <returns>Tutte le righe del file o le righe sono il risultato di una query.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per specificare una codifica da utilizzare per leggere il file.  
  
 Il <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> metodi differiscono nel modo seguente: quando si usa <xref:System.IO.File.ReadLines%2A>, è possibile avviare l'enumerazione dell'insieme di stringhe prima che venga restituita l'intera raccolta. Quando si usa <xref:System.IO.File.ReadAllLines%2A>, è necessario attendere che l'intera matrice di stringhe restituito prima che sia possibile accedere alla matrice. Pertanto, quando si lavora con file di dimensioni molto grandi, <xref:System.IO.File.ReadLines%2A> può risultare più efficiente.  
  
 È possibile usare il <xref:System.IO.File.ReadLines%2A> metodo per eseguire le operazioni seguenti:  
  
-   Seguire [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) le query su un file per ottenere un set filtrato di righe.  
  
-   Scrivere l'insieme di righe restituito in un file con il <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> metodo, o li aggiunge a un file esistente con il <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> (metodo).  
  
-   Creare un'istanza popolata immediatamente una raccolta che accetta un <xref:System.Collections.Generic.IEnumerable%601> raccolta di stringhe per il relativo costruttore, ad esempio un <xref:System.Collections.Generic.IList%601> o un <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato dal parametro <paramref name="path" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sostituisce il contenuto di un file specificato con il contenuto di un altro file, eliminando il file originale e creando una copia di backup del file sostituito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Replace%2A> metodi sostituiscono il contenuto di un file specificato con il contenuto di un altro file.  È anche possibile creare un backup del file che è stato sostituito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nome del file che sostituisce il file specificato da <c>destinationFileName</c>.</param>
        <param name="destinationFileName">Nome del file da sostituire.</param>
        <param name="destinationBackupFileName">Nome del file di backup.</param>
        <summary>Sostituisce il contenuto di un file specificato con il contenuto di un altro file, eliminando il file originale e creando una copia di backup del file sostituito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Replace%2A> metodo sostituisce il contenuto di un file specificato con il contenuto di un altro file.  Viene anche creato un backup del file che è stato sostituito.  
  
 Se il `sourceFileName` e `destinationFileName` sono in volumi diversi, questo metodo genererà un'eccezione. Se il `destinationBackupFileName` è in un volume diverso dal file di origine, il file di backup verrà eliminato.  
  
 Passare `null` per il `destinationBackupFileName` parametro se non si desidera creare un backup del file da sostituire.  

 Se il `destinationBackupFileName` già esistente verrà sovrascritto con il contenuto del `destinationFileName` file.
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.Replace%2A> metodo per sostituire un file con un altro file e creare un backup del file sostituito.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato del percorso descritto dal parametro <paramref name="destinationFileName" /> non era valido.  
  
oppure 
Il formato del percorso descritto dal parametro <paramref name="destinationBackupFileName" /> non era valido.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="destinationFileName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">È stata specificata un'unità non valida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file descritto dall'oggetto <see cref="T:System.IO.FileInfo" /> corrente non è stato trovato.  
  
oppure 
Il file descritto dal parametro <paramref name="destinationBackupFileName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.  
  
\- oppure - 
I parametri <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> specificano lo stesso file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo è Windows 98 Second Edition o versioni precedenti e il file system non è NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="sourceFileName" /> o <paramref name="destinationFileName" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro di origine o di destinazione specifica una directory anziché un file.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione di scrittura al file descritto dal <paramref name="destinationBackupFileName" /> parametro se ne è stato specificato. Azione di sicurezza: richiesta. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * bool -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nome del file che sostituisce il file specificato da <c>destinationFileName</c>.</param>
        <param name="destinationFileName">Nome del file da sostituire.</param>
        <param name="destinationBackupFileName">Nome del file di backup.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> per ignorare gli errori di unione (ad esempio gli attributi e gli elenchi di controllo di accesso (ACL)) dal file sostituito al file di sostituzione; in caso contrario, <see langword="false" />.</param>
        <summary>Sostituisce il contenuto di un file specificato con il contenuto di un altro file, eliminando il file originale, creando una copia di backup del file sostituito ed eventualmente ignorando gli errori di merge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.Replace%2A> metodo sostituisce il contenuto di un file specificato con il contenuto di un altro file.  Viene anche creato un backup del file che è stato sostituito.  
  
 Se il `sourceFileName` e `destinationFileName` sono in volumi diversi, questo metodo genererà un'eccezione. Se il `destinationBackupFileName` è in un volume diverso dal file di origine, il file di backup verrà eliminato.  
  
 Passare `null` per il `destinationBackupFileName` parametro se non si desidera creare un backup del file da sostituire.  

 Se il `destinationBackupFileName` già esistente verrà sovrascritto con il contenuto del `destinationFileName` file.
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.Replace%2A> metodo per sostituire un file con un altro file e creare un backup del file sostituito.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato del percorso descritto dal parametro <paramref name="destinationFileName" /> non era valido.  
  
oppure 
Il formato del percorso descritto dal parametro <paramref name="destinationBackupFileName" /> non era valido.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="destinationFileName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">È stata specificata un'unità non valida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file descritto dall'oggetto <see cref="T:System.IO.FileInfo" /> corrente non è stato trovato.  
  
oppure 
Il file descritto dal parametro <paramref name="destinationBackupFileName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.  
  
\- oppure - 
I parametri <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> specificano lo stesso file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo è Windows 98 Second Edition o versioni precedenti e il file system non è NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="sourceFileName" /> o <paramref name="destinationFileName" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro di origine o di destinazione specifica una directory anziché un file.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione di scrittura al file descritto dal <paramref name="destinationBackupFileName" /> parametro se ne è stato specificato. Azione di sicurezza: richiesta. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.FileSecurity -&gt; unit" Usage="System.IO.File.SetAccessControl (path, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">File in cui aggiungere o rimuovere le voci dell'elenco di controllo di accesso (ACL).</param>
        <param name="fileSecurity">Oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che descrive una voce ACL da applicare al file descritto dal parametro <c>percorso</c>.</param>
        <summary>Applica le voci dell'elenco di controllo di accesso (ACL) descritte da un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> nel file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.File.SetAccessControl%2A> metodo si applica a voci di elenco (ACL) di controllo di accesso a un file che rappresenta l'elenco ACL non ereditato.  
  
> [!CAUTION]
>  L'elenco ACL specificato per il `fileSecurity` parametro sostituisce l'ACL esistente per il file. Per aggiungere le autorizzazioni per un nuovo utente, usare il <xref:System.IO.File.GetAccessControl%2A> metodo per ottenere l'ACL esistente, modificarlo e quindi usare <xref:System.IO.File.SetAccessControl%2A> applicarlo nuovamente al file.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono dei diritti ad azioni specifiche per il file specificato. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Il <xref:System.IO.File.SetAccessControl%2A> metodo persiste solo <xref:System.Security.AccessControl.FileSecurity> gli oggetti che sono stati modificati dopo la creazione di oggetti.  Se un <xref:System.Security.AccessControl.FileSecurity> oggetto non è stato modificato, non essere mantenuto in un file.  Non è pertanto possibile recuperare un <xref:System.Security.AccessControl.FileSecurity> dell'oggetto da un file e riapplicare lo stesso oggetto in un altro file.  
  
 Per copiare le informazioni di ACL da un file a un altro:  
  
1.  Usare la <xref:System.IO.File.GetAccessControl%2A> metodo per recuperare il <xref:System.Security.AccessControl.FileSecurity> oggetto dal file di origine.  
  
2.  Creare un nuovo <xref:System.Security.AccessControl.FileSecurity> oggetto per il file di destinazione.  
  
3.  Usare la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> oppure <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo dell'origine <xref:System.Security.AccessControl.FileSecurity> oggetto per recuperare le informazioni di ACL.  
  
4.  Usare la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oppure <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodo per copiare le informazioni recuperate nel passaggio 3 nella destinazione <xref:System.Security.AccessControl.FileSecurity> oggetto.  
  
5.  Impostare la destinazione <xref:System.Security.AccessControl.FileSecurity> oggetto per il file di destinazione usando il <xref:System.IO.File.SetAccessControl%2A> (metodo).  
  
 In ambienti di NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> vengono concesse all'utente se l'utente ha <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> diritti alla cartella padre. Per negare <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Nega <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sulla directory padre.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso di controllo voce di elenco (ACL) da un file.  È necessario specificare un utente valido o un account di gruppo per eseguire questo esempio.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Il file non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il parametro <paramref name="path" /> specifica una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="fileSecurity" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione accedere al file. Azione di sicurezza: richiesta. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberSignature Language="F#" Value="static member SetAttributes : string * System.IO.FileAttributes -&gt; unit" Usage="System.IO.File.SetAttributes (path, fileAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file.</param>
        <param name="fileAttributes">Combinazione bit per bit dei valori di enumerazione.</param>
        <summary>Imposta l'enumerazione <see cref="T:System.IO.FileAttributes" /> del file nel percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Alcuni attributi del file, ad esempio <xref:System.IO.FileAttributes.Hidden> e <xref:System.IO.FileAttributes.ReadOnly>, possono essere combinati. Altri attributi, ad esempio <xref:System.IO.FileAttributes.Normal>, deve essere usato da solo.  
  
 Non è possibile modificare lo stato di compressione di un <xref:System.IO.File> utilizzando il <xref:System.IO.File.SetAttributes%2A> (metodo).  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il `GetAttributes` e `SetAttributes` metodi applicando le `Archive` e `Hidden` attributi in un file.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è vuoto, contiene solo spazi vuoti, caratteri non validi, oppure l'attributo del file non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora di creazione.</param>
        <param name="creationTime">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora di creazione del <c>percorso</c>. Questo valore è espresso nell'ora locale.</param>
        <summary>Imposta la data e l'ora di creazione del file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unità NTFS possono memorizzare nella cache file meta-info, come ora di creazione di file, per un breve periodo di tempo. Di conseguenza, potrebbe essere necessario impostare in modo esplicito l'ora di creazione di un file se si intende sovrascrivere o sostituire un file esistente.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'esecuzione dell'operazione.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> specifica un valore al di fuori dell'intervallo di date, ore o di entrambe, consentite per l'operazione.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora di creazione.</param>
        <param name="creationTimeUtc">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora di creazione del <c>percorso</c>. Questo valore è espresso nell'ora UTC.</param>
        <summary>Imposta la data e l'ora, nell'ora UTC (Universal Coordinated Time), della creazione del file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unità NTFS possono memorizzare nella cache file meta-info, come ora di creazione di file, per un breve periodo di tempo. Di conseguenza, potrebbe essere necessario impostare in modo esplicito l'ora di creazione di un file se si intende sovrascrivere o sostituire un file esistente.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'esecuzione dell'operazione.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> specifica un valore al di fuori dell'intervallo di date, ore o di entrambe, consentite per l'operazione.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora di accesso.</param>
        <param name="lastAccessTime">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora dell'ultimo accesso del <c>percorso</c>. Questo valore è espresso nell'ora locale.</param>
        <summary>Imposta la data e l'ora dell'ultimo accesso al file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente controlla file system per il file specificato, se necessario, creare e quindi imposta e ottiene l'ora dell'ultimo accesso.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> specifica un valore esterno all'intervallo di date od ore consentite per l'operazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora di accesso.</param>
        <param name="lastAccessTimeUtc">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora dell'ultimo accesso del <c>percorso</c>. Questo valore è espresso nell'ora UTC.</param>
        <summary>Imposta la data e l'ora, nell'ora UTC (Universal Coordinated Time), dell'ultimo accesso al file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> specifica un valore esterno all'intervallo di date od ore consentite per l'operazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora.</param>
        <param name="lastWriteTime">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora dell'ultima scrittura del <c>percorso</c>. Questo valore è espresso nell'ora locale.</param>
        <summary>Imposta la data e l'ora dell'ultima scrittura nel file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente controlla file system per il file specificato, la creazione del file se necessario e quindi imposta e ottiene l'ora dell'ultima scrittura del file.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> specifica un valore esterno all'intervallo di date od ore consentite per l'operazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">File per cui impostare le informazioni sulla data e l'ora.</param>
        <param name="lastWriteTimeUtc">Oggetto <see cref="T:System.DateTime" /> contenente il valore da impostare per la data e l'ora dell'ultima scrittura del <c>percorso</c>. Questo valore è espresso nell'ora UTC.</param>
        <summary>Imposta la data e l'ora, nell'ora UTC (Universal Coordinated Time), dell'ultima scrittura nel file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `path` parametro è consentito specificare le informazioni sul percorso relativo o assoluto. Informazioni sul percorso relativo è interpretati come relativo alla directory di lavoro corrente. Per ottenere la directory di lavoro corrente, vedere <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il percorso specificato non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> specifica un valore esterno all'intervallo di date od ore consentite per l'operazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura nel file specificato. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Testo con lettura da un File</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] -&gt; unit" Usage="System.IO.File.WriteAllBytes (path, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="bytes">Byte da scrivere nel file.</param>
        <summary>Crea un nuovo file, scrive la matrice di byte specificata e quindi lo chiude. Se il file di destinazione è già esistente, viene sovrascritto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data una matrice di byte e un percorso di file, questo metodo apre il file specificato, scrive il contenuto della matrice di byte nel file e quindi lo chiude.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" /> o la matrice di byte è vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllBytesAsync : string * byte[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllBytesAsync (path, bytes, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo file, vi scrive una o più stringhe e quindi lo chiude.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Righe da scrivere nel file.</param>
        <summary>Crea un nuovo file, vi scrive una raccolta di stringhe e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento predefinito del <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> consiste nello scrivere i dati con codifica UTF-8 senza un byte order mark (BOM). Se è necessario includere un identificatore di UTF-8, ad esempio un byte order mark, all'inizio di un file, usare il <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> overload del metodo con <xref:System.Text.Encoding.UTF8%2A> codifica.  
  
 Se il file di destinazione è già esistente, viene sovrascritto.  
  
 È possibile usare questo metodo per creare il contenuto per una classe collection che accetta un <xref:System.Collections.Generic.IEnumerable%601> nel relativo costruttore, ad esempio un <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, o un <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> classe.  
  
   
  
## Examples  
 Nell'esempio seguente scrive le righe selezionate da un file di dati di esempio in un file.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Matrice di stringhe da scrivere nel file.</param>
        <summary>Crea un nuovo file, scrive la matrice di stringhe specificata e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file di destinazione è già esistente, viene sovrascritto.  
  
 Il comportamento predefinito del <xref:System.IO.File.WriteAllLines%2A> metodo consiste nella scrittura dei dati utilizzando la codifica UTF-8 senza un byte order mark (BOM). Se è necessario includere un identificatore di UTF-8, ad esempio un byte order mark, all'inizio di un file, usare il <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> overload del metodo con <xref:System.Text.Encoding.UTF8%2A> codifica.  
  
 Data una matrice di stringhe e un percorso di file, questo metodo apre il file specificato, scrive la matrice di stringhe nel file e quindi lo chiude.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.WriteAllLines%2A> metodo per scrivere testo in un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Righe da scrivere nel file.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <summary>Crea un nuovo file usando la codifica specificata, vi scrive una raccolta di stringhe e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file di destinazione è già esistente, viene sovrascritto.  
  
 È possibile utilizzare questo metodo per creare un file che contiene gli elementi seguenti:  
  
-   I risultati di una [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) eseguire una query sulle righe di un file, come ottenuta utilizzando il <xref:System.IO.File.ReadLines%2A> (metodo).  
  
-   Il contenuto di una raccolta che implementa un <xref:System.Collections.Generic.IEnumerable%601> delle stringhe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> non è valido (ad esempio si trova in un'unità non mappata).</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il parametro <paramref name="path" /> supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il parametro <paramref name="path" /> consente di specificare un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> è una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Matrice di stringhe da scrivere nel file.</param>
        <param name="encoding">Oggetto <see cref="T:System.Text.Encoding" /> che rappresenta la codifica di caratteri applicata alla matrice di stringhe.</param>
        <summary>Crea un nuovo file, vi scrive la matrice di stringhe specificata usando la codifica specificata e quindi lo chiude.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file di destinazione è già esistente, viene sovrascritto.  
  
 Data una matrice di stringhe e un percorso di file, questo metodo consente di aprire il file specificato, scrive la matrice di stringhe nel file usando la codifica specificata e quindi chiude il file.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.WriteAllLines%2A> metodo per scrivere testo in un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo file, ne scrive il contenuto e quindi lo chiude. Se il file di destinazione è già esistente, viene sovrascritto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Stringa da scrivere nel file.</param>
        <summary>Crea un nuovo file, scrive la stringa specificata e quindi lo chiude. Se il file di destinazione è già esistente, viene sovrascritto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato UTF-8 senza un Byte Order Mark (BOM) di codifica, quindi l'uso di <xref:System.Text.Encoding.GetPreamble%2A> metodo restituirà una matrice di byte vuota. Se è necessario includere un identificatore di UTF-8, ad esempio un byte order mark, all'inizio di un file, usare il <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> overload del metodo con <xref:System.Text.Encoding.UTF8%2A> codifica.  
  
 Data una stringa e un percorso di file, questo metodo apre il file specificato, scrive la stringa nel file e quindi lo chiude.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.WriteAllText%2A> metodo per scrivere testo in un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> è <see langword="null" /> o il parametro <paramref name="contents" /> è vuoto.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">File in cui scrivere.</param>
        <param name="contents">Stringa da scrivere nel file.</param>
        <param name="encoding">Codifica da applicare alla stringa.</param>
        <summary>Crea un nuovo file, scrive la stringa specificata usando la codifica specificata e quindi lo chiude. Se il file di destinazione è già esistente, viene sovrascritto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data una stringa e un percorso di file, questo metodo consente di aprire il file specificato, scrive la stringa nel file usando la codifica specificata e quindi chiude il file. L'handle di file è garantito per essere chiuso da questo metodo, anche se le eccezioni vengono generate.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.IO.File.WriteAllText%2A> metodo per scrivere testo in un file. In questo esempio viene creato un file, se non esiste già e a cui viene aggiunto il testo.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> è <see langword="null" /> o il parametro <paramref name="contents" /> è vuoto.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specifica un file di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
 <paramref name="path" /> ha specificato una directory.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.NotSupportedException">Il formato di <paramref name="path" /> non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in scrittura a un file o directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>