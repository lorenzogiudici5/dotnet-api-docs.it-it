<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="65d5283e253c2c7ea16ba664f4bae3d2f67005ec" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36560815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa un oggetto <see cref="T:System.IO.TextReader" /> che legge i caratteri da un flusso di byte in una particolare codifica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> è progettato per l'input di caratteri in una particolare codifica, mentre il <xref:System.IO.Stream> classe è progettata per byte di input e output. Utilizzare <xref:System.IO.StreamReader> per leggere le righe di informazioni da un file di testo standard.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 <xref:System.IO.StreamReader> il valore predefinito per la codifica UTF-8 se non specificato diversamente, anziché l'impostazione per la tabella codici ANSI per il sistema corrente. UTF-8 gestisce correttamente i caratteri Unicode e fornisce risultati coerenti in versioni localizzate del sistema operativo. Se si ottiene la codifica caratteri corrente usando il <xref:System.IO.StreamReader.CurrentEncoding%2A> proprietà, il valore non è affidabile fino a dopo il primo <xref:System.IO.StreamReader.Read%2A> (metodo), poiché il rilevamento automatico della codifica non viene eseguita fino alla prima chiamata a un <xref:System.IO.StreamReader.Read%2A> metodo.  
  
 Per impostazione predefinita, un <xref:System.IO.StreamReader> non è thread-safe. Vedere <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> per un wrapper thread-safe.  
  
 Il <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo leggere e scrivere il numero di caratteri specificato dal `count` parametro. Questi devono essere distinte dalle <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> e <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, che leggono e scrivono il numero di byte specificati dal `count` parametro. Utilizzare il <xref:System.IO.BufferedStream> metodi solo per la lettura e scrittura di un numero integrale di byte gli elementi della matrice.  
  
> [!NOTE]
>  Durante la lettura da un <xref:System.IO.Stream>, risulta più efficiente di utilizzare un buffer che è la stessa dimensione del buffer interno del flusso.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente usa un'istanza di <xref:System.IO.StreamReader> leggere il testo da un file. Il costruttore usato in questo esempio non è supportato per l'utilizzo in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] app.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 Nell'esempio seguente crea un <xref:System.IO.StreamReader> oggetto e chiama relativo <xref:System.IO.StreamReader.ReadAsync%2A> metodo per leggere un file in modo asincrono.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica <xref:System.Text.UTF8Encoding>, il <xref:System.IO.StreamReader.BaseStream%2A> proprietà utilizzando il `stream` parametro e le dimensioni del buffer interno a 1024 byte.  
  
 Il <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> su forniti <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> non supporta la lettura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da leggere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il nome file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso completo del file è specificato per il `path` parametro. Questo costruttore inizializza la codifica su <xref:System.Text.UTF8Encoding> e le dimensioni del buffer da 1024 byte.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il `path` parametro non è necessario essere un file archiviato su disco, può essere qualsiasi parte di un sistema che supporta l'accesso mediante i flussi.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> include una sintassi non corretta o non valida relativa al nome del file, al nome della directory o all'etichetta del volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato, con l'opzione specificata per il rilevamento dei byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica <xref:System.Text.UTF8Encoding>, il <xref:System.IO.StreamReader.BaseStream%2A> proprietà utilizzando il `stream` parametro e le dimensioni del buffer interno a 1024 byte.  
  
 Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> su forniti <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> non supporta la lettura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato, con la codifica dei caratteri specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica dei caratteri è impostata il `encoding` parametro e le dimensioni del buffer è pari a 1024 byte. Il <xref:System.IO.StreamReader> oggetto tenta di rilevare la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> su forniti <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> non supporta la lettura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da leggere.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il nome file specificato, con l'opzione specificata per il rilevamento dei byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica <xref:System.Text.UTF8Encoding>, il <xref:System.IO.StreamReader.BaseStream%2A> proprietà utilizzando il `stream` parametro e le dimensioni del buffer interno a 1024 byte.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il `path` parametro non è necessario essere un file archiviato su disco, può essere qualsiasi parte di un sistema che supporta l'accesso mediante i flussi.  
  
 Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, il <xref:System.Text.UTF8Encoding> viene utilizzato. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> include una sintassi non corretta o non valida relativa al nome del file, al nome della directory o all'etichetta del volume.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il nome file specificato, con la codifica dei caratteri specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica come specificato dal `encoding` parametro e le dimensioni del buffer interno a 1024 byte. Il <xref:System.IO.StreamReader> oggetto tenta di rilevare la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il `path` parametro non è necessario essere un file archiviato su disco, può essere qualsiasi parte di un sistema che supporta l'accesso mediante i flussi.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> include una sintassi non corretta o non valida relativa al nome del file, al nome della directory o all'etichetta del volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato, con la codifica dei caratteri e l'opzione per il rilevamento dei byte order mark specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica come specificato dal `encoding` parametro, il <xref:System.IO.StreamReader.BaseStream%2A> proprietà utilizzando il `stream` parametro e le dimensioni del buffer interno a 1024 byte.  
  
 Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> su forniti <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> non supporta la lettura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il nome file specificato, con la codifica caratteri e l'opzione per il rilevamento dei byte order mark specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica come specificato dal `encoding` parametro e le dimensioni del buffer interno a 1024 byte.  
  
 Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il `path` parametro non è necessario essere un file archiviato su disco, può essere qualsiasi parte di un sistema che supporta l'accesso mediante i flussi.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> include una sintassi non corretta o non valida relativa al nome del file, al nome della directory o all'etichetta del volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <param name="bufferSize">Dimensione minima del buffer.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato, con la codifica dei caratteri, l'opzione per il rilevamento dei byte order mark e le dimensioni del buffer specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dimensioni del buffer, in numero di caratteri a 16 bit, l'impostazione sono la `bufferSize` parametro. Se `bufferSize` è minore rispetto alla dimensione minima consentita (128 caratteri), viene utilizzata la dimensione minima consentita.  
  
 Questo costruttore consente di modificare la prima volta che vengono letti dalla codifica di <xref:System.IO.StreamReader> oggetto. Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> su forniti <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
> [!NOTE]
>  Durante la lettura da un <xref:System.IO.Stream>, risulta più efficiente di utilizzare un buffer che è la stessa dimensione del buffer interno del flusso.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è minore o uguale a zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se cercare i byte order mark all'inizio del file.</param>
        <param name="bufferSize">Dimensioni minime del buffer, in numero di caratteri a 16 bit.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il nome file specificato, con la codifica caratteri, l'opzione per il rilevamento dei byte order mark e le dimensioni del buffer specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza la codifica come specificato dal `encoding` parametro.  
  
 Questo costruttore consente di modificare la prima volta che vengono letti dalla codifica di <xref:System.IO.StreamReader> oggetto. Il `detectEncodingFromByteOrderMarks` parametro rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Le dimensioni del buffer, in numero di caratteri a 16 bit, l'impostazione sono la `bufferSize` parametro. Se `bufferSize` è minore rispetto alla dimensione minima consentita (128 caratteri), viene utilizzata la dimensione minima consentita.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il `path` parametro non è necessario essere un file archiviato su disco, può essere qualsiasi parte di un sistema che supporta l'accesso mediante i flussi.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato quanto descritto <xref:System.IO.StreamReader> costruttore.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="encoding" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> include una sintassi non corretta o non valida relativa al nome del file, al nome della directory o all'etichetta del volume.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> è minore o uguale a zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso da leggere.</param>
        <param name="encoding">Codifica dei caratteri da usare.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" /> per cercare gli indicatori per l'ordine dei byte all'inizio del file; in caso contrario, <see langword="false" />.</param>
        <param name="bufferSize">Dimensione minima del buffer.</param>
        <param name="leaveOpen">
          <see langword="true" /> per mantenere il flusso aperto dopo avere eliminato l'oggetto <see cref="T:System.IO.StreamReader" />; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.StreamReader" /> per il flusso specificato in base alla codifica caratteri, all'opzione per il rilevamento dei byte order mark e alle dimensioni del buffer specificati. Facoltativamente mantiene aperto il flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A meno che non si imposta la `leaveOpen` parametro a `true`, la <xref:System.IO.StreamReader> object chiama <xref:System.IO.Stream.Dispose> all'oggetto fornito <xref:System.IO.Stream> oggetto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> viene chiamato.  
  
 Le dimensioni del buffer, in numero di caratteri a 16 bit, l'impostazione sono la `bufferSize` parametro. Se `bufferSize` è minore rispetto alla dimensione minima consentita (128 caratteri), viene utilizzata la dimensione minima consentita.  
  
 Questo costruttore consente di modificare la prima volta che vengono letti dalla codifica di <xref:System.IO.StreamReader> oggetto. Se il `detectEncodingFromByteOrderMarks` parametro `true`, il costruttore rileva la codifica esaminando i primi tre byte del flusso. Riconosce automaticamente Unicode UTF-8, little-endian e contrassegna testo Unicode big-endian se il file inizia con l'ordine dei byte. In caso contrario, viene utilizzata la codifica fornito dall'utente. Per altre informazioni, vedere il metodo <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Durante la lettura da un <xref:System.IO.Stream>, risulta più efficiente di utilizzare un buffer che è la stessa dimensione del buffer interno del flusso.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati correttamente e potrebbe provocare un'eccezione generata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il flusso sottostante.</summary>
        <value>Flusso sottostante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per accedere al flusso sottostante. Il <xref:System.IO.StreamReader> classe input buffer dal flusso sottostante quando si chiama uno del <xref:System.IO.StreamReader.Read%2A> metodi. Se si modifica la posizione del flusso sottostante dopo la lettura dei dati nel buffer, la posizione del flusso sottostante potrebbe non corrispondere la posizione del buffer interno. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario. Il <xref:System.IO.StreamReader> costruttori che dispongono del `detectEncodingFromByteOrderMarks` parametro è possibile modificare la prima volta che vengono letti dalla codifica di <xref:System.IO.StreamReader> oggetto.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude l'oggetto <see cref="T:System.IO.StreamReader" /> e il flusso sottostante e rilascia tutte le risorse di sistema associate al lettore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> metodo.  
  
 Questa implementazione di <xref:System.IO.StreamReader.Close%2A> chiama il <xref:System.IO.StreamReader.Dispose%2A> passando un `true` valore.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito <xref:System.IO.StreamReader.Close%2A>. L'impostazione <xref:System.IO.StreamWriter.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
 Segue una chiamata a <xref:System.IO.StreamReader.Close%2A>, le operazioni sul lettore potrebbero generare eccezioni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la codifica caratteri corrente usata dall'oggetto <see cref="T:System.IO.StreamReader" /> corrente.</summary>
        <value>Codifica caratteri usata dal lettore corrente. Il valore può essere diverso dopo la prima chiamata a un metodo <see cref="Overload:System.IO.StreamReader.Read" /> di <see cref="T:System.IO.StreamReader" />, in quanto il rilevamento automatico della codifica non è completo fino alla prima chiamata a un metodo <see cref="Overload:System.IO.StreamReader.Read" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente ottiene la codifica dell'oggetto specificato <xref:System.IO.StreamReader> oggetto.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella il buffer interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo per reimpostare il buffer interno per il <xref:System.IO.StreamReader> oggetto. È necessario chiamare questo metodo solo quando la posizione del buffer interno e il <xref:System.IO.StreamReader.BaseStream%2A> non corrispondono. Queste posizioni possono diventare non corrispondenti quando si leggere i dati nel buffer e quindi Cerca una nuova posizione nel flusso sottostante. Questo metodo determina un rallentamento delle prestazioni e deve essere utilizzato solo quando strettamente necessario, ad esempio quando si desidera leggere una parte del contenuto di un <xref:System.IO.StreamReader> dell'oggetto più volte.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato uno scenario in cui il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo deve essere chiamato per sincronizzare il buffer interno e il flusso sottostante. Il file nell'esempio viene usato per illustrare la posizione ed è costituito da testo `abcdefghijklmnopqrstuvwxyz`. Chiamando <xref:System.IO.StreamReader.DiscardBufferedData%2A> dopo i dati vengono letti, l'esempio funziona come previsto. Dopo che vengono letti i primi 15 caratteri, la posizione viene reimpostata sul valore di offset pari a 2 e vengono letti tutti i caratteri rimanenti. Se si rimuove la chiamata a <xref:System.IO.StreamReader.DiscardBufferedData%2A>, nell'esempio non funziona come previsto. Vengono letti i primi 15 caratteri, ma solo la posizione del flusso sottostante viene reimpostata. Il buffer interno del <xref:System.IO.StreamReader> oggetto è ancora in base 16 caratteri. Pertanto, <xref:System.IO.StreamReader.ReadToEnd%2A> restituisce tutti i caratteri nel buffer più i caratteri nel flusso sottostante a partire dalla posizione di ripristino.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Chiude il flusso sottostante, rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.IO.StreamReader" /> e, facoltativamente, rilascia le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.IDisposable.Dispose%2A> metodo e il <xref:System.Object.Finalize%2A> metodo. <xref:System.IDisposable.Dispose%2A> richiama il metodo protetto <xref:System.IO.StreamReader.Dispose%2A> metodo con il `disposing` parametro impostato su true. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.StreamReader.Dispose%2A> con `disposing` impostato su false.  
  
 Quando il `disposing` parametro `true`, questo metodo rilascia tutte le risorse utilizzate da qualsiasi gestiti oggetti che il <xref:System.IO.StreamReader> riferimenti all'oggetto. Il metodo richiama il metodo <xref:System.IDisposable.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dispose può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una precedente chiamata a Dispose [cref,...]. Per ulteriori informazioni su come implementare <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> vedere [implementazione di un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per ulteriori informazioni <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la posizione corrente del flusso è alla fine del flusso.</summary>
        <value>
          <see langword="true" /> se la posizione corrente del flusso è alla fine del flusso; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso sottostante è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oggetto <see cref="T:System.IO.StreamReader" /> che include un flusso vuoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando vengono letti i metodi vengono richiamati per <xref:System.IO.StreamReader.Null>, viene restituito sempre zero. Quando si <xref:System.IO.StreamReader.ReadLine%2A> richiamato <xref:System.IO.StreamReader.Null>, `null` viene restituito.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il carattere successivo disponibile senza usarlo.</summary>
        <returns>Intero che rappresenta il carattere successivo da leggere oppure -1 se non sono presenti caratteri da leggere o se il flusso non supporta la ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.StreamReader.Peek%2A> metodo restituisce un valore intero per determinare se si è verificata la fine del file o un altro errore. Ciò consente a un utente verificare se il valore restituito è -1 prima di eseguire il cast a un <xref:System.Char> tipo.  
  
 Questo metodo esegue l'override del metodo <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 La posizione corrente del <xref:System.IO.StreamReader> oggetto non viene modificato da <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente legge le righe da un file fino a quando non viene raggiunta la fine del file.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge il carattere successivo o il set di caratteri successivo dal flusso di input.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge il carattere successivo dal flusso di input e fa avanzare di un carattere la posizione del carattere.</summary>
        <returns>Carattere successivo dal flusso di input rappresentato come oggetto <see cref="T:System.Int32" /> oppure -1 se non sono disponibili altri caratteri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Questo metodo restituisce un intero in modo che venga restituito -1 se è stata raggiunta la fine del flusso. Se si modifica la posizione del flusso sottostante dopo la lettura dei dati nel buffer, la posizione del flusso sottostante potrebbe non corrispondere la posizione del buffer interno. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo semplice del <xref:System.IO.StreamReader.Read%2A> metodo.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 Esempio di codice seguente viene illustrata la lettura di un singolo carattere utilizzando il <xref:System.IO.StreamReader.Read> overload del metodo, la formattazione dell'output come decimale ed esadecimale dell'intero ASCII.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index + count - 1</c>) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Indice di <c>buffer</c> in corrispondenza del quale iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere.</param>
        <summary>Legge un numero massimo specificato di caratteri dal flusso corrente e scrive i dati in un buffer, iniziando dall'indice specificato.</summary>
        <returns>Numero di caratteri letti oppure 0 se alla fine del flusso non è stato letto alcun dato. Il numero sarà minore o uguale al parametro <paramref name="count" />, a seconda che i dati siano disponibili o meno all'interno del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Questo metodo restituisce un intero in modo che venga restituito 0 se è stata raggiunta la fine del flusso.  
  
 Quando si utilizza il <xref:System.IO.StreamReader.Read%2A> (metodo), risulta più efficiente per usare un buffer che è la stessa dimensione del buffer interno del flusso, in cui il buffer interno viene impostato sulla dimensione di blocco desiderato e per leggere sempre inferiore alla dimensione di blocco. Se le dimensioni del buffer interno non specificata durante il flusso è stato costruito, le dimensioni predefinite pari a 4 KB (pari a 4.096 byte). Se si modifica la posizione del flusso sottostante dopo la lettura dei dati nel buffer, la posizione del flusso sottostante potrebbe non corrispondere la posizione del buffer interno. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario.  
  
 Questo metodo restituisce dopo che il numero di caratteri specificato dal `count` parametro vengono lette o viene raggiunta la fine del file. <xref:System.IO.TextReader.ReadBlock%2A> è una versione che causano il blocco di <xref:System.IO.StreamReader.Read%2A>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente legge cinque caratteri alla volta fino a quando non viene raggiunta la fine del file.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza del buffer meno <paramref name="index" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se viene raggiunta la fine del flusso prima che il numero di caratteri specificato venga scritto nel buffer, il metodo corrente terminerà.</param>
        <summary>Legge in modo asincrono un numero massimo specificato di caratteri dal flusso corrente e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene il numero totale di caratteri letti nel buffer. Il valore del risultato può essere minore del numero di caratteri richiesti se il numero di caratteri attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività viene completata dopo che il numero di caratteri specificato dal `count` parametro vengono lette o viene raggiunta la fine del flusso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come leggere tutti i caratteri in un file utilizzando il <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo. Verifica se ogni carattere è una lettera, cifre o spazi vuoti prima di aggiungere il carattere in un'istanza del <xref:System.Text.StringBuilder> classe.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="index" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index + count - 1</c>) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere.</param>
        <summary>Legge un numero massimo specificato di caratteri dal flusso corrente e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Numero di caratteri letti. Il numero sarà minore o uguale a <paramref name="count" />, a seconda che tutti i caratteri di input siano stati letti o meno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La posizione del flusso sottostante viene anticipata per il numero di caratteri letti nella `buffer`.  
  
 Il metodo si blocca fino a quando non `count` caratteri vengono letti o è stata raggiunta la fine del flusso. Si tratta di una versione che causano il blocco di <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza del buffer meno <paramref name="index" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.StreamReader" /> è chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se viene raggiunta la fine del flusso prima che il numero di caratteri specificato venga scritto nel buffer, il metodo restituisce un risultato.</param>
        <summary>Legge in modo asincrono un numero massimo specificato di caratteri dal flusso corrente e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene il numero totale di caratteri letti nel buffer. Il valore del risultato può essere minore del numero di caratteri richiesti se il numero di caratteri attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività non viene completata finché il numero di caratteri specificato dal `count` parametro sono di lettura o è stata raggiunta la fine del flusso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="index" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge una riga di caratteri dal flusso corrente e restituisce i dati come stringa.</summary>
        <returns>Riga successiva del flusso di input oppure <see langword="null" /> se viene raggiunta la fine del flusso di input.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una riga viene definita come una sequenza di caratteri seguiti da una riga ("\n"), un ritorno a capo ("\r"), un ritorno a capo seguito immediatamente da una riga feed o ("\r\n"). La stringa restituita non contiene il carattere di terminazione ritorno a capo o avanzamento riga. Il valore restituito è `null` se viene raggiunta la fine del flusso di input.  
  
 Questo metodo esegue l'override del metodo <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Se il metodo genera un' <xref:System.OutOfMemoryException>, la posizione del lettore nell'oggetto sottostante <xref:System.IO.Stream> oggetto viene anticipato per il numero di caratteri, il metodo è stato in grado di leggere, ma i caratteri già letti interna <xref:System.IO.StreamReader.ReadLine%2A> buffer vengono ignorati . Se si modifica la posizione del flusso sottostante dopo la lettura dei dati nel buffer, la posizione del flusso sottostante potrebbe non corrispondere la posizione del buffer interno. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente legge le righe da un file fino a quando non viene raggiunta la fine del file.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per l’allocazione di un buffer per la stringa restituita.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge una riga di caratteri in modo asincrono dal flusso corrente e restituisce i dati come stringa.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene la riga successiva del flusso oppure è <see langword="null" /> se tutti i caratteri sono stati letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come leggere la prima riga di un file utilizzando il <xref:System.IO.StreamReader.ReadLineAsync> metodo.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri nella riga successiva è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i caratteri dalla posizione corrente fino alla fine del flusso.</summary>
        <returns>Parte restante del flusso come stringa, dalla posizione corrente alla fine del flusso. Se la posizione corrente è alla fine del flusso, restituisce una stringa vuota ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> funziona meglio quando è necessario leggere tutti gli input dalla posizione corrente alla fine del flusso. Se è necessario un maggiore controllo sul numero di caratteri letti dal flusso, utilizzare il <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo, che in genere comporta un miglioramento delle prestazioni.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> si presuppone che il flusso conosca una volta raggiunta la fine. Per protocolli interattivi in cui il server invia i dati solo quando è richiesto e non chiude la connessione, <xref:System.IO.StreamReader.ReadToEnd%2A> potrebbe bloccarsi in modo indefinito poiché non raggiunge la fine e deve essere evitato.  
  
 Si noti che quando si utilizza il <xref:System.IO.StreamReader.Read%2A> (metodo), risulta più efficiente di utilizzare un buffer che è la stessa dimensione del buffer interno del flusso. Se le dimensioni del buffer non specificata durante il flusso è stato costruito, le dimensioni predefinite pari a 4 KB (pari a 4.096 byte).  
  
 Se il metodo genera un' <xref:System.OutOfMemoryException>, la posizione del lettore nell'oggetto sottostante <xref:System.IO.Stream> oggetto viene anticipato per il numero di caratteri, il metodo è stato in grado di leggere, ma i caratteri già letti interna <xref:System.IO.StreamReader.ReadLine%2A> buffer vengono ignorati . Se si modifica la posizione del flusso sottostante dopo la lettura dei dati nel buffer, la posizione del flusso sottostante potrebbe non corrispondere la posizione del buffer interno. Per reimpostare il buffer interno, chiamare il <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodo; tuttavia, questo metodo determina un rallentamento delle prestazioni e deve essere chiamato solo quando strettamente necessario.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente legge fino alla fine di un file in un'unica operazione.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per l’allocazione di un buffer per la stringa restituita.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i caratteri dalla posizione corrente fino alla fine del flusso in modo asincrono e li restituisce come singola stringa.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene una stringa con i caratteri compresi tra la posizione corrente e la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come leggere il contenuto di un file utilizzando il <xref:System.IO.StreamReader.ReadToEndAsync> metodo.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
  </Members>
</Type>