<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c2a48ad6254044761826100b2be9db53d138b868" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911272" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una visualizzazione generica di una sequenza di byte. Questa è una classe abstract.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> è la classe base astratta di tutti i flussi. Un flusso è un'astrazione di una sequenza di byte, ad esempio un file, un dispositivo di input/output, una pipe di comunicazione tra processi o un socket TCP/IP. La <xref:System.IO.Stream> classe e le relative classi derivate forniscono una visualizzazione generica di questi diversi tipi di input e output e così il programmatore dai dettagli specifici del sistema operativo e i dispositivi sottostanti.  
  
 I flussi implicano tre operazioni fondamentali:  
  
-   È possibile leggere da flussi. La lettura è il trasferimento dei dati da un flusso in una struttura di dati, ad esempio una matrice di byte.  
  
-   È possibile scrivere nei flussi. La scrittura è il trasferimento dei dati da una struttura di dati in un flusso.  
  
-   La ricerca. La ricerca fa riferimento a una query e modifica della posizione corrente all'interno di un flusso. Ricerca funzionalità dipende dal tipo di archivio di backup è un flusso. Flussi di rete, ad esempio, non includono alcun concetto unificato di una posizione corrente e pertanto in genere non supportano la ricerca.  
  
 Alcuni dei più comunemente utilizzati flussi che ereditano da <xref:System.IO.Stream> sono <xref:System.IO.FileStream>, e <xref:System.IO.MemoryStream>.  
  
 A seconda origine dati sottostante o nell'archivio, flussi potrebbero supportare solo alcune di queste funzionalità. È possibile eseguire una query le funzionalità di un flusso utilizzando il <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, e <xref:System.IO.Stream.CanSeek%2A> proprietà la <xref:System.IO.Stream> classe.  
  
 Il <xref:System.IO.Stream.Read%2A> e <xref:System.IO.Stream.Write%2A> metodi leggere e scrivere dati in una vasta gamma di formati. Per i flussi che supportano la ricerca, utilizzare il <xref:System.IO.Stream.Seek%2A> e <xref:System.IO.Stream.SetLength%2A> metodi e <xref:System.IO.Stream.Position%2A> e <xref:System.IO.Stream.Length%2A> le proprietà per eseguire una query e modificare la posizione corrente e la lunghezza di un flusso.  
  
 Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Eliminazione di un <xref:System.IO.Stream> oggetto Scarica tutti i dati memorizzati nel buffer e chiama essenzialmente la <xref:System.IO.Stream.Flush%2A> metodo. <xref:System.IO.Stream.Dispose%2A> rilascia inoltre le risorse del sistema operativo, ad esempio gli handle di file, le connessioni di rete o memoria utilizzata per qualsiasi buffer interni. La <xref:System.IO.BufferedStream> classe fornisce la funzionalità del wrapping di un flusso memorizzato nel buffer intorno a un altro flusso per migliorare la lettura e scrittura delle prestazioni.  
  
 A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.IO.Stream> classe include metodi asincroni per semplificare le operazioni asincrone. Contiene un metodo asincrono `Async` nel nome, ad esempio <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>. Questi metodi consentono di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Quando utilizzato in un [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> include due metodi di estensione: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> e <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>. Questi metodi consentono di convertire un <xref:System.IO.Stream> oggetto in un flusso di [!INCLUDE[wrt](~/includes/wrt-md.md)]. È anche possibile convertire un flusso di [!INCLUDE[wrt](~/includes/wrt-md.md)] per un <xref:System.IO.Stream> oggetto utilizzando il <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> e <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> metodi. Per ulteriori informazioni, vedere [procedura: convertire tra flussi di .NET Framework e flussi di Windows Runtime](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)  
  
 Alcune implementazioni del flusso di eseguire il buffer locale dei dati sottostanti per migliorare le prestazioni. Per questi flussi, è possibile utilizzare il <xref:System.IO.Stream.Flush%2A> o <xref:System.IO.Stream.FlushAsync%2A> metodo per cancellare tutti i buffer interni e assicurare che tutti i dati siano stati scritti nell'origine dati o il repository sottostante.  
  
 Se è necessario un flusso senza archivio di backup (noto anche come un bucket di bit), utilizzare il <xref:System.IO.Stream.Null> campo da recuperare un'istanza di un flusso che è progettato per questo scopo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare due <xref:System.IO.FileStream> oggetti da copiare in modo asincrono i file da una directory in un'altra directory. La classe <xref:System.IO.FileStream> deriva dalla classe <xref:System.IO.Stream>. Si noti che il gestore eventi <xref:System.Web.UI.WebControls.Button.Click> per il controllo <xref:System.Windows.Controls.Button> è contrassegnato con il modificatore `async` perché chiama un metodo asincrono.  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando si implementa una classe derivata di <see cref="T:System.IO.Stream" />, è necessario fornire implementazioni per le <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> metodi. I metodi asincroni <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, e <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> utilizza metodi sincroni <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> nelle rispettive implementazioni. Pertanto, le implementazioni di <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> funzioneranno correttamente con i metodi asincroni. Le implementazioni predefinite di <see cref="M:System.IO.Stream.ReadByte" /> e <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> creare una nuova matrice di byte a elemento singolo e quindi chiamare le implementazioni di <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Quando si deriva dalla <see cref="T:System.IO.Stream" />, si consiglia di eseguire l'override di questi metodi per accedere al buffer interno, se presente, per migliorare notevolmente le prestazioni. È inoltre necessario fornire le implementazioni di <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, e <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  
  
 Non eseguire l'override di <see cref="M:System.IO.Stream.Close" /> (metodo), invece, inserire tutte la <see cref="T:System.IO.Stream" /> logica di pulizia nel <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (metodo). Per ulteriori informazioni, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
    </block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> è la classe base astratta di tutti i flussi.  
  
 Alcuni dei più comunemente utilizzati flussi che ereditano da <xref:System.IO.Stream> sono <xref:System.IO.FileStream>, e <xref:System.IO.MemoryStream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui leggere i dati.</param>
        <param name="offset">Offset di byte in <c>buffer</c> in corrispondenza del quale iniziare a scrivere i dati letti dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la lettura è completa.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di lettura asincrona da altre richieste.</param>
        <summary>Inizia un'operazione di lettura asincrona. (In alternativa, si consideri l'uso di <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta la lettura asincrona, che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti è necessario usare metodi quali <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> per implementare operazioni di I/O asincrone. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, della Guida è implementare più facilmente le operazioni dei / o asincrone.  
  
 L'implementazione predefinita di `BeginRead` su un flusso di chiamate di <xref:System.IO.Stream.Read%2A> metodo in modo sincrono, vale a dire che `Read` potrebbe bloccarsi su alcuni flussi. Tuttavia, le istanze di classi, ad esempio `FileStream` e `NetworkStream` supportano completamente le operazioni asincrone, se le istanze sono state aperte in modo asincrono. Pertanto, le chiamate a `BeginRead` non verrà bloccata su tali flussi. È possibile eseguire l'override `BeginRead` (tramite delegati asincroni, ad esempio) per fornire il comportamento asincrono.  
  
 Passare il `IAsyncResult` un valore restituito per il <xref:System.IO.Stream.EndRead%2A> metodo del flusso per determinare il numero di byte letti e rilasciare le risorse di sistema operativo utilizzate per la lettura. <xref:System.IO.Stream.EndRead%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Stream.BeginRead%2A>. È possibile eseguire questa operazione utilizzando lo stesso codice che ha chiamato `BeginRead` o in un callback passato a `BeginRead`.  
  
 La posizione corrente nel flusso viene aggiornata quando la lettura o scrittura asincrona viene eseguita, non al completamento dell'operazione dei / o.  
  
 Più richieste asincrone contemporanee rendono incerto l'ordine di completamento della richiesta.  
  
 Utilizzare il <xref:System.IO.Stream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
 Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente `BeginRead`. Gli errori che si verificano durante una richiesta di lettura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e generano eccezioni quando si chiama `EndRead`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">È stato eseguito un tentativo di lettura asincrona oltre la fine del flusso o si è verificato un errore del disco.</exception>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <exception cref="T:System.NotSupportedException">L'implementazione corrente di <see langword="Stream" /> non supporta l'operazione di lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer da cui scrivere i dati.</param>
        <param name="offset">Offset di byte in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <param name="callback">Callback asincrono facoltativo, da chiamare quando la scrittura è completa.</param>
        <param name="state">Oggetto fornito dall'utente che distingue questa specifica richiesta di scrittura asincrona da altre richieste.</param>
        <summary>Inizia un'operazione di scrittura asincrona. (In alternativa, si consideri l'uso di <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</summary>
        <returns>Oggetto <see langword="IAsyncResult" /> che rappresenta la scrittura asincrona, che può essere ancora in sospeso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti è necessario usare metodi quali <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> per implementare operazioni di I/O asincrone. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, della Guida è implementare più facilmente le operazioni dei / o asincrone.  
  
 L'implementazione predefinita di `BeginWrite` su un flusso di chiamate di <xref:System.IO.Stream.Write%2A> metodo in modo sincrono, vale a dire che `Write` potrebbe bloccarsi su alcuni flussi. Tuttavia, le istanze di classi, ad esempio `FileStream` e `NetworkStream` supportano completamente le operazioni asincrone, se le istanze sono state aperte in modo asincrono. Pertanto, le chiamate a `BeginWrite` non verrà bloccata su tali flussi. È possibile eseguire l'override `BeginWrite` (tramite delegati asincroni, ad esempio) per fornire il comportamento asincrono.  
  
 Passare il `IAsyncResult` restituito dal metodo corrente per <xref:System.IO.Stream.EndWrite%2A> per garantire che la scrittura venga completata e libera le risorse in modo appropriato. <xref:System.IO.Stream.EndWrite%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Stream.BeginWrite%2A>. È possibile eseguire questa operazione utilizzando lo stesso codice che ha chiamato `BeginWrite` o in un callback passato a `BeginWrite`. Se si verifica un errore durante un'operazione di scrittura asincrona, fino a quando non essere generata un'eccezione `EndWrite` viene chiamato con il `IAsyncResult` restituito da questo metodo.  
  
 Se un flusso scrivibile, scrittura alla fine del flusso si espande il flusso.  
  
 La posizione corrente nel flusso viene aggiornata quando si esegue la lettura o scrittura asincrona, non al completamento dell'operazione dei / o. Più richieste asincrone contemporanee rendono incerto l'ordine di completamento della richiesta.  
  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura.  
  
 Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente `BeginWrite`. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e generano eccezioni quando si chiama `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">È stato eseguito un tentativo di scrittura asincrona oltre la fine del flusso o si è verificato un errore del disco.</exception>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono validi.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <exception cref="T:System.NotSupportedException">L'implementazione corrente di <see langword="Stream" /> non supporta l'operazione di scrittura.</exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il flusso corrente supporta la lettura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la lettura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la lettura, le chiamate al <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, e <xref:System.IO.Stream.BeginRead%2A> metodi generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Di seguito è riportato un esempio di utilizzo di `CanRead` proprietà.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il flusso corrente supporta la ricerca.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la ricerca; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la ricerca, le chiamate a <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, e <xref:System.IO.Stream.Seek%2A> generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che determina se il flusso corrente prevede il timeout.</summary>
        <value>Valore che determina se il flusso corrente prevede il timeout.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.IO.Stream.CanTimeout%2A> restituisce sempre `false`. Alcune implementazioni del flusso richiedono un comportamento diverso, ad esempio <xref:System.Net.Sockets.NetworkStream>, che verifica il timeout se la connettività di rete viene interrotta o persa. Se si sta implementando un flusso che deve essere in grado di timeout, è necessario eseguire l'override di questa proprietà per restituire `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se il flusso corrente supporta la scrittura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la scrittura, una chiamata a <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, o <xref:System.IO.Stream.WriteByte%2A> genera un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Di seguito è riportato un esempio di utilizzo di `CanWrite` proprietà.  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude il flusso corrente e libera le risorse, come socket e handle di file, ad esso associate. Anziché chiamare questo metodo, assicurarsi che il flusso sia eliminato correttamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama <xref:System.IO.Stream.Dispose%2A>, specificando `true` per rilasciare tutte le risorse. Non è necessario chiamare esplicitamente il <xref:System.IO.Stream.Close%2A> metodo. Al contrario, verificare che ogni <xref:System.IO.Stream> oggetto è stato eliminato correttamente. È possibile dichiarare <xref:System.IO.Stream> oggetti all'interno di un `using` blocco (o `Using` blocco in Visual Basic) per garantire che il flusso e tutte le relative risorse vengono eliminate o chiamare in modo esplicito il <xref:System.IO.Stream.Dispose%2A> metodo.  
  
 La cancellazione del flusso non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito un'implementazione di <xref:System.IO.Stream.Flush%2A> o `Close`. Impostazione <xref:System.IO.StreamWriter.AutoFlush%2A> a `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.  
  
 Tenta di modificare il flusso dopo il flusso è stato chiuso potrebbe generare un <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nelle classi derivate, non eseguire l'override di <see cref="M:System.IO.Stream.Close" /> (metodo), invece, inserire tutte la <see langword="Stream" /> logica di pulizia nel <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (metodo). Per ulteriori informazioni, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i byte dal flusso corrente e li scrive in un altro flusso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Flusso in cui verrà copiato il contenuto del flusso corrente.</param>
        <summary>Legge i byte dal flusso corrente e li scrive in un altro flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Copia inizia in corrispondenza della posizione corrente nel flusso corrente e reimposta la posizione del flusso di destinazione al termine dell'operazione di copia.  
  
   
  
## Examples  
 Nell'esempio seguente copia il contenuto di un <xref:System.IO.FileStream> per un <xref:System.IO.MemoryStream>.  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura.  
  
 oppure  
  
 <paramref name="destination" /> non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente o <paramref name="destination" /> sono stati chiusi prima che venisse chiamato il metodo <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Flusso in cui verrà copiato il contenuto del flusso corrente.</param>
        <param name="bufferSize">Dimensione del buffer. Il valore deve essere maggiore di zero. La dimensione predefinita è 81920.</param>
        <summary>Legge tutti i byte dal flusso corrente e li scrive in un altro flusso, usando una dimensione di buffer specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Copia inizia in corrispondenza della posizione corrente nel flusso corrente e reimposta la posizione del flusso di destinazione al termine dell'operazione di copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura.  
  
 oppure  
  
 <paramref name="destination" /> non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente o <paramref name="destination" /> sono stati chiusi prima che venisse chiamato il metodo <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge in modo asincrono i byte dal flusso corrente e li scrive in un altro flusso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Flusso in cui verrà copiato il contenuto del flusso corrente.</param>
        <summary>Legge in modo asincrono i byte dal flusso corrente e li scrive in un altro flusso.</summary>
        <returns>Attività che rappresenta l'operazione di copia asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.CopyToAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 La copia inizia in corrispondenza della posizione corrente nel flusso corrente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare due <xref:System.IO.FileStream> oggetti da copiare in modo asincrono i file da una directory a un altro. La classe <xref:System.IO.FileStream> deriva dalla classe <xref:System.IO.Stream>.  Si noti che il <xref:System.Web.UI.WebControls.Button.Click> gestore eventi per il <xref:System.Windows.Controls.Button> controllo è contrassegnato con il `async` modificatore poiché chiama un metodo asincrono  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente o il flusso di destinazione viene eliminato.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura, o il flusso di destinazione non supporta la scrittura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Flusso in cui verrà copiato il contenuto del flusso corrente.</param>
        <param name="bufferSize">Dimensione del buffer, in byte. Il valore deve essere maggiore di zero. La dimensione predefinita è 81920.</param>
        <summary>Legge in modo asincrono tutti i byte dal flusso corrente e li scrive in un altro flusso, usando una dimensione di buffer specificata.</summary>
        <returns>Attività che rappresenta l'operazione di copia asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.CopyToAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 La copia inizia in corrispondenza della posizione corrente nel flusso corrente.  
  
 Per un esempio di copia tra i due flussi, vedere il <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> è un valore negativo o zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente o il flusso di destinazione viene eliminato.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura, o il flusso di destinazione non supporta la scrittura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">Flusso in cui verrà copiato il contenuto del flusso corrente.</param>
        <param name="bufferSize">Dimensione del buffer, in byte. Il valore deve essere maggiore di zero. La dimensione predefinita è 81920.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento. Il valore predefinito è <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Legge in modo asincrono i byte dal flusso corrente e li scrive in un altro flusso, usando una dimensione di buffer specificata e un token di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di copia asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.CopyToAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà.  
  
 La copia inizia in corrispondenza della posizione corrente nel flusso corrente.  
  
 Per un esempio di copia tra i due flussi, vedere il <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> è un valore negativo o zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente o il flusso di destinazione viene eliminato.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura, o il flusso di destinazione non supporta la scrittura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alloca un oggetto <see cref="T:System.Threading.WaitHandle" />.</summary>
        <returns>Riferimento all'oggetto <see langword="WaitHandle" /> allocato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene chiamato per la prima volta, il metodo corrente viene creato un `WaitHandle` dell'oggetto e lo restituisce. Nelle successive chiamate `CreateWaitHandle` restituisce un riferimento a un nuovo handle di attesa.  
  
 Utilizzare questo metodo se si implementano i metodi asincroni e richiedono una modalità di blocco in <xref:System.IO.Stream.EndRead%2A> o <xref:System.IO.Stream.EndWrite%2A> fino al completamento dell'operazione asincrona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'oggetto <see cref="T:System.IO.Stream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo elimina il flusso, scrivendo le modifiche all'archivio di backup e di chiusura del flusso per rilasciare le risorse.  
  
 La chiamata `Dispose` le risorse utilizzate da di <xref:System.IO.Stream> riallocazione per altri scopi. Per ulteriori informazioni su `Dispose`, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Inserire tutta la logica per l'oggetto flusso in pulizia <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Non eseguire l'override <see cref="M:System.IO.Stream.Close" />.  
  
 Si noti che, a causa dei requisiti di compatibilità con le versioni precedenti, l'implementazione del metodo differisce dalla procedura consigliata per il modello Dispose.  Questo metodo chiama <see cref="M:System.IO.Stream.Close" />, che a sua volta chiama <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.Stream" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario rilasciare tutte le risorse specificando `true` per `disposing`. Quando `disposing` è `true`, il flusso può inoltre garantire che i dati viene cancellati per il buffer sottostante e accedere ad altri oggetti finalizzabili.  Questo potrebbe non essere possibile quando viene chiamato da un finalizzatore per mancanza di ordinamento tra i finalizzatori.  
  
 Se il flusso utilizza un handle del sistema operativo per comunicare con la relativa origine, è consigliabile usare una sottoclasse di <xref:System.Runtime.InteropServices.SafeHandle> a questo scopo.  
  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.ComponentModel.Component.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo. <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.Stream.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.Stream.Dispose%2A> con `disposing` impostato su `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nelle classi derivate, non eseguire l'override di <see cref="M:System.IO.Stream.Close" /> invece inserire tutta la logica di pulizia flusso nel metodo, il <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metodo.  
  
 Il metodo <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see cref="M:System.ComponentModel.Component.Dispose" />. Per ulteriori informazioni su come implementare <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Riferimento alla richiesta asincrona in sospeso da completare.</param>
        <summary>Attende il completamento della lettura asincrona in sospeso. (In alternativa, si consideri l'uso di <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</summary>
        <returns>Numero di byte letti dal flusso, tra zero (0) e il numero di byte richiesto. I flussi restituiscono zero (0) solo alla fine del flusso; in caso contrario, si devono bloccare fino a quando non è disponibile almeno 1 byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti è necessario usare metodi quali <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> per implementare operazioni di I/O asincrone. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, della Guida è implementare più facilmente le operazioni dei / o asincrone.  
  
 Chiamare `EndRead` per determinare il numero di byte letti dal flusso.  
  
 `EndRead` può essere chiamato una volta per ogni <xref:System.IAsyncResult> da <xref:System.IO.Stream.BeginRead%2A>.  
  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Non è disponibile un handle dell'operazione di lettura in sospeso.  
  
 oppure  
  
 L'operazione in sospeso non supporta la lettura.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> non è stato generato da un metodo <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nel flusso corrente.</exception>
        <exception cref="T:System.IO.IOException">Il flusso è chiuso o si è verificato un errore interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Riferimento alla richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione di scrittura asincrona. (In alternativa, si consideri l'uso di <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti è necessario usare metodi quali <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> per implementare operazioni di I/O asincrone. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, della Guida è implementare più facilmente le operazioni dei / o asincrone.  
  
 `EndWrite` deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> da <xref:System.IO.Stream.BeginWrite%2A>.  
  
 Questo metodo mantiene il blocco fino al completamento dell'operazione di I/O. Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e diventano visibili dopo una chiamata a `EndWrite`. Le eccezioni generate dai thread del pool non saranno visibili quando si chiama `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Non è disponibile un handle dell'operazione di scrittura in sospeso.  
  
 oppure  
  
 L'operazione in sospeso non supporta la scrittura.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> non è stato generato da un metodo <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nel flusso corrente.</exception>
        <exception cref="T:System.IO.IOException">Il flusso è chiuso o si è verificato un errore interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cancella tutti i buffer del flusso e determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'override `Flush` su flussi che implementano un buffer. Utilizzare questo metodo per spostare tutte le informazioni da un buffer sottostante alla relativa destinazione, cancellare il buffer o entrambi. In base allo stato dell'oggetto, potrebbe essere necessario modificare la posizione corrente all'interno del flusso (ad esempio, se il flusso sottostante supporta la ricerca). Per ulteriori informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
 Quando si utilizza il <xref:System.IO.StreamWriter> o <xref:System.IO.BinaryWriter> classe, non scaricare la base <xref:System.IO.Stream> oggetto. Utilizzare invece la classe <xref:System.IO.Stream.Flush%2A> o <xref:System.IO.Stream.Close%2A> metodo, che assicura che i dati vengono scaricati prima il flusso sottostante e quindi scritti nel file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cancella in modo asincrono i dati di tutti i buffer del flusso e determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella in modo asincrono i dati di tutti i buffer del flusso e determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante.</summary>
        <returns>Attività che rappresenta l'operazione di scaricamento asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata, ad esempio <xref:System.IO.Compression.DeflateStream> o <xref:System.IO.Compression.GZipStream>, non lo scarica il buffer nella sua implementazione del <xref:System.IO.Stream.Flush%2A> (metodo), il <xref:System.IO.Stream.FlushAsync%2A> metodo non implica lo svuotamento del buffer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento. Il valore predefinito è <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Cancella in modo asincrono i dati di tutti i buffer del flusso, determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scaricamento asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà.  
  
 Se una classe derivata, ad esempio <xref:System.IO.Compression.DeflateStream> o <xref:System.IO.Compression.GZipStream>, non lo scarica il buffer nella sua implementazione del <xref:System.IO.Stream.Flush%2A> (metodo), il <xref:System.IO.Stream.FlushAsync%2A> metodo non implica lo svuotamento del buffer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene la lunghezza in byte del flusso.</summary>
        <value>Valore long che rappresenta la lunghezza del flusso in byte.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Una classe derivata da <see langword="Stream" /> non supporta la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oggetto <see langword="Stream" /> privo di archivio di backup.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare `Null` per reindirizzare l'output in un flusso che non utilizza le risorse del sistema operativo. Quando i metodi di `Stream` che forniscono la scrittura vengono richiamati in `Null`restituisce semplicemente la chiamata e viene scritto alcun dato. `Null` implementa inoltre un `Read` metodo che restituisce zero senza eseguire la lettura dei dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce supporto per un oggetto <see cref="T:System.Diagnostics.Contracts.Contract" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene o imposta la posizione all'interno del flusso corrente.</summary>
        <value>Posizione corrente all'interno del flusso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il flusso deve supportare la ricerca ottenere o impostare la posizione. Utilizzare il <xref:System.IO.Stream.CanSeek%2A> proprietà per determinare se il flusso supporta la ricerca.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata.  
  
 Il `Position` proprietà non tiene traccia del numero di byte del flusso che sono stati usati, ignorato, o entrambi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte. Quando il metodo termina, il buffer contiene la matrice di byte specificata, con i valori compresi tra <c>offset</c> e (<c>offset</c> + <c>count</c> - 1) sostituiti dai byte letti dall'origine corrente.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> in corrispondenza del quale iniziare l'archiviazione dei dati letti dal flusso corrente.</param>
        <param name="count">Numero massimo di byte da leggere dal flusso corrente.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, legge una sequenza di byte dal flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte letti.</summary>
        <returns>Numero complessivo di byte letti nel buffer. È possibile che questo numero sia inferiore a quello dei byte richiesti se la quantità di byte disponibili è minore oppure che corrisponda a zero (0) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.Stream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura. Utilizzare il <xref:System.IO.Stream.ReadAsync%2A> metodo per leggere in modo asincrono dal flusso corrente.  
  
 Le implementazioni di questo metodo leggono un massimo di `count` flusso di byte dall'oggetto corrente e archiviarli in `buffer` a partire da `offset`. La posizione corrente all'interno del flusso viene anticipata per il numero di byte letti. Tuttavia, se si verifica un'eccezione, la posizione corrente all'interno del flusso non subisce modifiche. Le implementazioni restituiscono il numero di byte letti. L'implementazione verrà bloccata finché non è possibile leggere almeno un byte di dati, nel caso in cui non sono disponibili dati. <xref:System.IO.Stream.Read%2A> Restituisce 0 solo quando non sono presenti più dati nel flusso e non sono previsti (ad esempio un socket chiuso o la fine del file). Un'implementazione è gratuita restituire un numero di byte rispetto a quello richiesto, anche se non è stata raggiunta la fine del flusso.  
  
 Utilizzare <xref:System.IO.BinaryReader> per la lettura dei tipi di dati primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.IO.Stream.Read%2A> per leggere un blocco di dati.  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva nel flusso in base al numero di byte letti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> da cui iniziare la scrittura dei dati dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <summary>Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva nel flusso in base al numero di byte letti.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.ReadAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Utilizzare il <xref:System.IO.Stream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come leggere da un file in modo asincrono. Nell'esempio viene utilizzato il <xref:System.IO.FileStream> classe che deriva dalla <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> da cui iniziare la scrittura dei dati dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento. Il valore predefinito è <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte letti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.ReadAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Utilizzare il <xref:System.IO.Stream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
 Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà.  
  
 Per un esempio, vedere il <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di lettura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge un byte dal flusso e sposta in avanti la posizione corrente all'interno del flusso di un byte o restituisce -1 se si trova alla fine del flusso.</summary>
        <returns>Cast di byte senza segno in un parametro <see langword="Int32" /> oppure -1 se si trova alla fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.Stream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
 Eventuali tentativi di modificare il flusso dopo la chiusura di flusso possono generare un <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita su <see langword="Stream" /> crea una nuova matrice a byte singolo e quindi chiama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Mentre sono formalmente corretto, è poco efficiente. Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'assegnazione della matrice aggiuntiva a ogni chiamata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore, in millisecondi, che determina per quanto tempo il flusso tenterà la lettura prima del timeout.</summary>
        <value>Valore in millisecondi che determina per quanto tempo il flusso tenterà la lettura prima del timeout.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="P:System.IO.Stream.ReadTimeout" /> genera sempre un'eccezione <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>Il <see cref="P:System.IO.Stream.ReadTimeout" /> proprietà deve essere sostituita per fornire il comportamento appropriato per il flusso. Se il flusso non supporta il timeout, questa proprietà deve generare un <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Offset di byte relativo al parametro <c>origine</c>.</param>
        <param name="origin">Valore di tipo <see cref="T:System.IO.SeekOrigin" /> che indica il punto di riferimento usato per ottenere la nuova posizione.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, imposta la posizione all'interno del flusso corrente.</summary>
        <returns>Nuova posizione all'interno del flusso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.Stream.CanSeek%2A> proprietà per determinare se l'istanza corrente supporta la ricerca.  
  
 Se `offset` è negativo, la nuova posizione deve precedere quella specificata da `origin` per il numero di byte specificato da `offset`. Se `offset` è zero (0), la nuova posizione è necessaria per la posizione specificata da `origin`. Se `offset` è positivo, la nuova posizione è necessaria seguire la posizione specificata da `origin` per il numero di byte specificato da `offset`.  
  
 Le classi derivate da `Stream` che supportano la ricerca deve eseguire l'override del metodo per fornire la funzionalità descritta in precedenza.  
  
 La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca, come se il flusso fosse stato costruito da un pipe o da un output di console.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Lunghezza desiderata del flusso corrente in byte.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, imposta la lunghezza del flusso corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore specificato è minore della lunghezza corrente del flusso, il flusso viene troncato. Se il valore specificato è maggiore della lunghezza corrente del flusso, il flusso viene esteso. Se il flusso è espanso, il contenuto del flusso tra il vecchio e la nuova lunghezza non definito.  
  
 Un flusso deve supportare sia la ricerca per la scrittura `SetLength` a funzionare.  
  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura e <xref:System.IO.Stream.CanSeek%2A> proprietà per determinare se la ricerca è supportata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura e la ricerca, come se il flusso fosse stato costruito da un pipe o da un output di console.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> da sincronizzare.</param>
        <summary>Crea un wrapper thread-safe (sincronizzato) per l'oggetto <see cref="T:System.IO.Stream" />.</summary>
        <returns>Oggetto <see cref="T:System.IO.Stream" /> thread-safe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce una classe che esegue il wrapping specificato <xref:System.IO.Stream> dell'oggetto e ne limita l'accesso da più thread. L'accesso a tutti i <xref:System.IO.Stream> oggetto è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte. Questo metodo copia i byte di <c>count</c> da <c>buffer</c> nel flusso corrente.</param>
        <param name="offset">Offset di byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso corrente.</param>
        <param name="count">Numero di byte da scrivere nel flusso corrente.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, scrive una sequenza di byte nel flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte scritti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura. Utilizzare il <xref:System.IO.Stream.WriteAsync%2A> metodo per scrivere nel flusso corrente in modo asincrono.  
  
 Se l'operazione di scrittura ha esito positivo, fa avanzare la posizione all'interno del flusso del numero di byte scritti. Se si verifica un'eccezione, la posizione all'interno del flusso rimane invariata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio non è possibile trovare il file specificato.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> è stato chiamato dopo la chiusura del flusso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva nel flusso in base al numero di byte scritti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer da cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <summary>Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva nel flusso in base al numero di byte scritti.</summary>
        <returns>Attività che rappresenta l'operazione di scrittura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.WriteAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come scrivere in modo asincrono in un file. Nell'esempio viene utilizzato il <xref:System.IO.FileStream> classe che deriva dalla <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di scrittura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer da cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento. Il valore predefinito è <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte scritti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scrittura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Stream.WriteAsync%2A> metodo consente di eseguire operazioni dei / o elevato utilizzo di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono utilizzati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura.  
  
 Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà.  
  
 Per un esempio, vedere il <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di scrittura precedente.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte da scrivere nel flusso.</param>
        <summary>Scrive un byte nella posizione corrente del flusso e sposta in avanti di un byte la posizione del flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.Stream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura o è già chiuso.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita su <see langword="Stream" /> crea una nuova matrice a byte singolo e quindi chiama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Mentre sono formalmente corretto, è poco efficiente. Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che consente di scrivere nel buffer direttamente, evitando l'assegnazione della matrice aggiuntiva a ogni chiamata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore, in millisecondi, che determina per quanto tempo il flusso tenterà la scrittura prima del timeout.</summary>
        <value>Valore in millisecondi che determina per quanto tempo il flusso tenterà la scrittura prima del timeout.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="P:System.IO.Stream.WriteTimeout" /> genera sempre un'eccezione <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>Il <see cref="P:System.IO.Stream.WriteTimeout" /> proprietà deve essere sostituita per fornire il comportamento appropriato per il flusso. Se il flusso non supporta il timeout, questa proprietà deve generare un <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>