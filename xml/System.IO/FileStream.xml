<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="905f01b0ff750b605eca8829d7898c8c69263b42" />
    <Meta Name="ms.sourcegitcommit" Value="6f3d3181d9ca22a1ab46a7f61f3ee152f2b844ea" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/27/2018" />
    <Meta Name="ms.locfileid" Value="50179108" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un oggetto <see cref="T:System.IO.Stream" /> per un file, con il supporto di operazioni di lettura e scrittura sincrone e asincrone.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.FileStream> classe per leggere, scrivere, aprire e chiudere i file in un file system e per modificare altri handle correlate ai file del sistema operativo, tra cui pipe standard di input e output standard. È possibile usare la <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, e <xref:System.IO.FileStream.Flush%2A> metodi per eseguire operazioni sincrone, o nella <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A> metodi per l'esecuzione asincrona operazioni. Usare i metodi asincroni per eseguire operazioni sui file di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. <xref:System.IO.FileStream> i buffer di input e output per ottenere prestazioni migliori.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Il <xref:System.IO.FileStream.IsAsync%2A> proprietà rileva se l'handle di file è stato aperto in modo asincrono. Si specifica questo valore quando si crea un'istanza del <xref:System.IO.FileStream> classe usando un costruttore che ha un `isAsync`, `useAsync`, o `options` parametro. Quando la proprietà è `true`, il flusso Usa i/o sovrapposte per eseguire operazioni sui file in modo asincrono. Tuttavia, il <xref:System.IO.FileStream.IsAsync%2A> proprietà non deve essere `true` per chiamare le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> (metodo). Quando la <xref:System.IO.FileStream.IsAsync%2A> è di proprietà `false` e si chiama la lettura asincrona e le operazioni di scrittura, il thread dell'interfaccia utente ancora non è bloccato, ma l'operazione dei / o effettiva viene eseguita in modo sincrono.  
  
 Il <xref:System.IO.FileStream.Seek%2A> metodo supporta l'accesso casuale ai file. <xref:System.IO.FileStream.Seek%2A> consente la posizione di lettura/scrittura da spostare in qualsiasi posizione all'interno del file. Questa operazione viene eseguita con i parametri di punto di riferimento di offset di byte. È l'offset dei byte rispetto al punto di riferimento di ricerca, che può essere l'inizio, la posizione corrente o la fine del file sottostante, come rappresentate da tre membri del <xref:System.IO.SeekOrigin> enumerazione.  
  
> [!NOTE]
>  I file di disco supportano sempre ad accesso casuale. Al momento della costruzione, i <xref:System.IO.FileStream.CanSeek%2A> valore della proprietà è impostato su `true` o `false` a seconda del tipo di file sottostante. Se il tipo di file sottostante è FILE_TYPE_DISK, come definito in winbase. h, il <xref:System.IO.FileStream.CanSeek%2A> valore della proprietà è `true`. In caso contrario, il <xref:System.IO.FileStream.CanSeek%2A> valore della proprietà è `false`.  
  
 Se un processo termina con una parte di un file bloccato o chiude un file con blocchi in attesa, il comportamento è indefinito.  
  
 Per operazioni di directory e altre operazioni di file, vedere la <xref:System.IO.File>, <xref:System.IO.Directory>, e <xref:System.IO.Path> classi. Il <xref:System.IO.File> classe è una classe di utilità che dispone di metodi statici principalmente per la creazione di <xref:System.IO.FileStream> gli oggetti basati su percorsi di file. Il <xref:System.IO.MemoryStream> classe crea un flusso da una matrice di byte ed è simile al <xref:System.IO.FileStream> classe.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Rilevamento delle modifiche della posizione Stream  
 Quando un <xref:System.IO.FileStream> oggetto non dispone di un blocco esclusivo nel relativo handle, un altro thread è stato possibile accedere contemporaneamente l'handle di file e modificare la posizione del puntatore del file del sistema operativo che è associato l'handle di file. In questo caso, la posizione memorizzata nella cache il <xref:System.IO.FileStream> oggetto e i dati memorizzati nel buffer potrebbe essere compromessa. Il <xref:System.IO.FileStream> oggetto regolarmente esegue controlli sui metodi che accedono al buffer memorizzati nella cache per garantire che posizione dell'handle del sistema operativo è quello utilizzato per la posizione memorizzata nella cache usata per il <xref:System.IO.FileStream> oggetto.  
  
 Se viene rilevata una modifica imprevista nella posizione dell'handle in una chiamata al <xref:System.IO.FileStream.Read%2A> (metodo), .NET Framework elimina il contenuto del buffer e legge nuovamente il flusso dal file. Questo può influire sulle prestazioni, a seconda delle dimensioni del file e tutti gli altri processi che possono influenzare la posizione del flusso di file.  
  
 Se viene rilevata una modifica imprevista nella posizione dell'handle in una chiamata ai <xref:System.IO.FileStream.Write%2A> metodo, il contenuto del buffer vengono ignorati e un <xref:System.IO.IOException> viene generata un'eccezione.  
  
 A <xref:System.IO.FileStream> oggetto non avrà un blocco esclusivo nel proprio handle quando entrambi i <xref:System.IO.FileStream.SafeFileHandle%2A> per esporre l'handle di cui si accede alla proprietà o il <xref:System.IO.FileStream> oggetto viene assegnato il <xref:System.IO.FileStream.SafeFileHandle%2A> proprietà nel relativo costruttore.  
  
   
  
## Examples  
 Nell'esempio seguente vengono illustrate alcune delle <xref:System.IO.FileStream> costruttori.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Nell'esempio seguente viene illustrato come scrivere in un file in modo asincrono. Questo codice viene eseguito in un'app WPF con un elemento TextBlock denominati UserInput e un pulsante associata a un gestore eventi Click denominato Button_Click. Il percorso del file deve essere modificato in un file esistente nel computer.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procedura: leggere e scrivere su un file di dati appena creato</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.IO.Stream.Close%2A> viene chiamato, l'handle viene chiuso e il numero di handle del file viene decrementato.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> non è un campo di <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.IO.Stream.Close%2A> viene chiamato, l'handle viene chiuso e il numero di handle del file viene decrementato.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> non è un campo di <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso e la modalità di creazione specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il costruttore viene assegnato l'accesso in lettura/scrittura al file e viene aperto condividendo l'accesso in lettura (vale a dire, le richieste di apertura del file per la scrittura da o in un altro processo avrà esito negativo fino al `FileStream` oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo).  
  
 È possibile utilizzare questo costruttore per aprire i file di sola lettura; In alternativa, è necessario usare un costruttore che accetta un `FileAccess` parametro con il valore impostato su `FileAccess.Read`.  
  
 Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
 Per i costruttori senza una <xref:System.IO.FileAccess> parametro, se il `mode` parametro è impostato su <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> è l'accesso predefinito. In caso contrario, l'accesso viene impostato su <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati è stato scritto correttamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio quando <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="access">Costante <see cref="T:System.IO.FileAccess" /> che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura e la dimensione del buffer specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle. In alternativa, lettura e scrittura per l'handle prima di chiamare questo `FileStream` costruttore.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="handle" /> non è un handle valido.  
  
oppure 
Il parametro <paramref name="handle" /> è un handle sincrono ed è stato usato in modo asincrono.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="bufferSize" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Enumerazioni associate: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se l'handle del file è di proprietà dell'istanza di <see langword="FileStream" />; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura e la proprietà dell'istanza di <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileStream` oggetto viene assegnato l'accesso specificato nel file. Sarà il proprietario dell'handle come specificato. Se questo processo è proprietario dell'handle, una chiamata al <xref:System.IO.Stream.Close%2A> metodo comporterà la chiusura di handle e il numero di handle del file viene decrementato. Il `FileStream` oggetto ha dimensioni predefinite del buffer di 4096 byte.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di e non chiamare metodi diversi da `Close` dopo avere completato usando l'handle.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> non è un campo di <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="access">Costante che determina la modalità di accesso al file da parte dell'oggetto <see langword="FileStream" />. Determina anche i valori restituiti dalle proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> è <see langword="true" /> se il <c>percorso</c> specifica un file su disco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione e l'autorizzazione di lettura/scrittura specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il costruttore viene assegnato l'accesso in lettura/scrittura al file e viene aperto condividendo l'accesso in lettura (vale a dire, le richieste di apertura del file per la scrittura da o in un altro processo avrà esito negativo fino al `FileStream` oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo). Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio se <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" />.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="isAsync">
          <see langword="true" /> se l'handle è stato aperto in modalità asincrona, ovvero in modalità I/O sovrapposta; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la dimensione del buffer e lo stato sincrono o asincrono specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il `isAsync` parametro per `true` per aprire l'handle di file in modo asincrono. Se il parametro è `true`, il flusso Usa i/o sovrapposte per eseguire operazioni sui file in modo asincrono. Tuttavia, non è necessario essere il parametro `true` per chiamare il <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> (metodo). Quando la `isAsync` parametro è `false` e si chiama la lettura asincrona e le operazioni di scrittura, il thread dell'interfaccia utente ancora non è bloccato, ma l'operazione dei / o effettiva viene eseguita in modo sincrono.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle. In alternativa, lettura e scrittura per l'handle prima di chiamare questo `FileStream` costruttore.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="handle" /> non è un handle valido.  
  
oppure 
Il parametro <paramref name="handle" /> è un handle sincrono ed è stato usato in modo asincrono.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="bufferSize" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito. Enumerazioni associate: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" />.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se l'handle del file è di proprietà dell'istanza di <see langword="FileStream" />; in caso contrario, <see langword="false" />.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la proprietà dell'istanza di <see langword="FileStream" /> e la dimensione del buffer specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileStream` oggetto viene assegnato l'accesso specificato nel file. Sarà il proprietario dell'handle come specificato. Se l'oggetto `FileStream` proprietario dell'handle, una chiamata al <xref:System.IO.Stream.Close%2A> metodo comporterà la chiusura di handle. In particolare, il numero di handle del file viene decrementato. Il `FileStream` oggetto ha le dimensioni del buffer specificate.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle. In alternativa, lettura e scrittura per l'handle prima di chiamare questo `FileStream` costruttore.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="access">Costante che determina la modalità di accesso al file da parte dell'oggetto <see langword="FileStream" />. Determina anche i valori restituiti dalle proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> è <see langword="true" /> se il <c>percorso</c> specifica un file su disco.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e l'autorizzazione di condivisione specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
 Il costruttore viene assegnato l'accesso in lettura/scrittura al file e viene aperto condividendo l'accesso in lettura (vale a dire, le richieste di apertura del file per la scrittura da o in un altro processo avrà esito negativo fino al `FileStream` oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo). Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.Lock%2A> (metodo).  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il sistema esegue Windows 98 o Windows 98 Second Edition e <paramref name="share" /> è impostato su <see langword="FileShare.Delete" />.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio se <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle di file relativo al file che sarà incapsulato nell'oggetto <see langword="FileStream" />.</param>
        <param name="access">Costante che imposta le proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se l'handle del file è di proprietà dell'istanza di <see langword="FileStream" />; in caso contrario, <see langword="false" />.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="isAsync">
          <see langword="true" /> se l'handle è stato aperto in modalità asincrona, ovvero in modalità I/O sovrapposta; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la proprietà dell'istanza di <see langword="FileStream" />, la dimensione del buffer e lo stato sincrono o asincrono specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileStream` oggetto viene assegnato l'accesso specificato nel file. Sarà il proprietario dell'handle come specificato. Se l'oggetto `FileStream` proprietario dell'handle, una chiamata al <xref:System.IO.Stream.Close%2A> metodo comporterà la chiusura di handle. In particolare, il numero di handle del file viene decrementato. Il `FileStream` oggetto ha le dimensioni del buffer specificate.  
  
 `FileStream` si presuppone che abbia il controllo esclusivo sul quadratino di ridimensionamento. Le operazioni di lettura, scrittura o ricerca durante una `FileStream` è anche bloccata da un handle può comportare un danneggiamento dei dati. Per garantire la protezione dei dati, chiamare <xref:System.IO.FileStream.Flush%2A> prima di usare l'handle di ed evitare di chiamare qualsiasi metodo diverso da `Close` dopo avere completato usando l'handle. In alternativa, lettura e scrittura per l'handle prima di chiamare questo `FileStream` costruttore.  
  
 `FileShare.Read` il valore predefinito è per quelli <xref:System.IO.FileStream> costruttori senza un `FileShare` parametro.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> è minore di <see langword="FileAccess.Read" /> o maggiore di <see langword="FileAccess.ReadWrite" /> oppure <paramref name="bufferSize" /> è minore o uguale a 0.</exception>
        <exception cref="T:System.ArgumentException">Handle non valido.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio un errore del disco.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e l'handle di file è impostato per l'accesso in sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="access">Costante che determina la modalità di accesso al file da parte dell'oggetto <see langword="FileStream" />. Determina anche i valori restituiti dalle proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> è <see langword="true" /> se il <c>percorso</c> specifica un file su disco.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione e la dimensione del buffer specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
oppure 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il sistema esegue Windows 98 o Windows 98 Second Edition e <paramref name="share" /> è impostato su <see langword="FileShare.Delete" />.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio se <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="access">Costante che determina la modalità di accesso al file da parte dell'oggetto <see langword="FileStream" />. Determina anche i valori restituiti dalle proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> è <see langword="true" /> se il <c>percorso</c> specifica un file su disco.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="useAsync">Specifica se usare I/O asincroni o sincroni. Tenere presente, tuttavia, che il sistema operativo usato potrebbe non supportare le operazioni di I/O asincrone. Quindi, se si specifica <see langword="true" />, l'handle potrebbe essere aperto in modalità sincrona a seconda della piattaforma usata. Quando vengono aperti in modalità asincrona, i metodi <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> e <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> offrono prestazioni migliori nelle operazioni di lettura o scrittura su dati di grandi dimensioni, ma potrebbero offrire prestazioni inferiori nelle operazioni di lettura o scrittura su dati di piccole dimensioni. Se l'applicazione è stata progettata per sfruttare le operazioni di I/O asincrone, impostare il parametro <c>useAsync</c> su <see langword="true" />. Se le operazioni di I/O asincrone vengono usate in modo corretto è possibile ottenere un incremento delle prestazioni delle applicazioni fino a 10 volte, ma se vengono usate senza riprogettare l'applicazione per le operazioni di I/O asincrone le prestazioni possono ridursi fino a 10 volte.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione, la dimensione del buffer e lo stato sincrono o asincrono specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scrivere in modo asincrono i dati in un file e quindi verificare che i dati è stato scritto correttamente. Oggetto `State` oggetto viene creato per passare le informazioni dal thread principale per il `EndReadCallback` e `EndWriteCallback` metodi.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
oppure 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il sistema esegue Windows 98 o Windows 98 Second Edition e <paramref name="share" /> è impostato su <see langword="FileShare.Delete" />.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio se <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see langword="FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="access">Costante che determina la modalità di accesso al file da parte dell'oggetto <see langword="FileStream" />. Determina anche i valori restituiti dalle proprietà <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> dell'oggetto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> è <see langword="true" /> se il <c>percorso</c> specifica un file su disco.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="options">Valore che specifica le opzioni aggiuntive del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione, l'accesso consentito ad altri FileStream allo stesso file, la dimensione del buffer e le opzioni aggiuntive del file specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il `fileOptions` parametro viene utilizzato per fornire l'accesso alle operazioni più avanzate che possono essere usate durante la creazione di un <xref:System.IO.FileStream> oggetto.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente scrive i dati in un file e quindi legge i dati usando il <xref:System.IO.FileStream> oggetto.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
oppure 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.  
  
oppure 
 <see cref="F:System.IO.FileOptions.Encrypted" /> è specificato per <paramref name="options" />, ma la crittografia del file non è supportata sulla piattaforma corrente.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="rights">Costante che determina i diritti di accesso da usare quando si creano regole di accesso e di controllo per il file.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="options">Costante che specifica le opzioni aggiuntive del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, i diritti di accesso e l'autorizzazione di condivisione, la dimensione del buffer e le opzioni aggiuntive del file specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Utilizzare questa opzione <xref:System.IO.FileStream.%23ctor%2A> costruttore per applicare l'accesso i diritti al momento della creazione di un file. Per accedere o modificare i diritti in un file esistente, è consigliabile usare la <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> metodi.  
  
 Il `fileOptions` parametro viene utilizzato per fornire l'accesso alle operazioni più avanzate che possono essere usate durante la creazione di un <xref:System.IO.FileStream> oggetto.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
oppure 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Windows NT o versioni successive.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, ad esempio quando si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.  
  
oppure 
 <see cref="F:System.IO.FileOptions.Encrypted" /> è specificato per <paramref name="options" />, ma la crittografia del file non è supportata sulla piattaforma corrente.</exception>
        <exception cref="T:System.IO.PathTooLongException">L'oggetto <paramref name="path" /> specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</param>
        <param name="mode">Costante che determina la modalità di apertura o di creazione del file.</param>
        <param name="rights">Costante che determina i diritti di accesso da usare quando si creano regole di accesso e di controllo per il file.</param>
        <param name="share">Costante che determina la modalità di condivisione del file da parte dei processi.</param>
        <param name="bufferSize">Valore positivo <see cref="T:System.Int32" /> maggiore di 0 che indica la dimensione del buffer. La dimensione del buffer predefinita è 4096.</param>
        <param name="options">Costante che specifica le opzioni aggiuntive del file.</param>
        <param name="fileSecurity">Costante che determina il controllo di accesso e la sicurezza di controllo del file.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileStream" /> con il percorso, la modalità di creazione, i diritti di accesso e l'autorizzazione di condivisione, la dimensione del buffer, le opzioni aggiuntive del file, il controllo di accesso e la sicurezza di controllo specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici tramite i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Utilizzare questa opzione <xref:System.IO.FileStream.%23ctor%2A> costruttore per applicare l'accesso i diritti al momento della creazione di un file. Per accedere o modificare i diritti in un file esistente, è consigliabile usare la <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> metodi.  
  
 Il `fileOptions` parametro viene utilizzato per fornire l'accesso alle operazioni più avanzate che possono essere usate durante la creazione di un <xref:System.IO.FileStream> oggetto.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!NOTE]
>  `path` non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso attraverso i flussi. Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.  
  
 <xref:System.IO.Stream.CanSeek%2A> viene `true` per tutti i <xref:System.IO.FileStream> gli oggetti che incapsulano i file. Se `path` indica un dispositivo che non supporta la ricerca, il <xref:System.IO.FileStream.CanSeek%2A> proprietà risultante <xref:System.IO.FileStream> è `false`. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente scrive i dati in un file e quindi legge i dati usando il <xref:System.IO.FileStream> oggetto.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.  
  
oppure 
 <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fa riferimento a dispositivi non basati su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> è un valore negativo o zero.  
  
oppure 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contiene un valore non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non è stato trovato, ad esempio se <paramref name="mode" /> è <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" /> e il file specificato da <paramref name="path" /> non esiste. È necessario che il file sia già disponibile in queste modalità.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O, come nel caso in cui si specifica <see langword="FileMode.CreateNew" /> e il file specificato da <paramref name="path" /> è già presente.  
  
oppure 
Il flusso è stato chiuso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <paramref name="access" /> richiesto non è consentito dal sistema operativo per l'oggetto <paramref name="path" /> specificato, ad esempio quando <paramref name="access" /> è <see langword="Write" /> o <see langword="ReadWrite" /> e la directory o il file è impostato per l'accesso in sola lettura.  
  
oppure 
 <see cref="F:System.IO.FileOptions.Encrypted" /> è specificato per <paramref name="options" />, ma la crittografia del file non è supportata sulla piattaforma corrente.</exception>
        <exception cref="T:System.IO.PathTooLongException">L'oggetto <paramref name="path" /> specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Windows NT o versioni successive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura, scrittura e aggiunta ai file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la lettura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la lettura; <see langword="false" /> se il flusso è chiuso o è stato aperto con accesso in sola scrittura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la lettura, le chiamate per il <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, e <xref:System.IO.FileStream.BeginRead%2A> metodi generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di `CanRead` proprietà. L'output di questo codice è "MyFile. txt non è scrivibile." Per ottenere il messaggio di output "MyFile. txt può essere sia scritto e letta da.", modificare il `FileAccess` parametro per `ReadWrite` nel `FileStream` costruttore.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la ricerca.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la ricerca; <see langword="false" /> se il flusso viene chiuso o se <see langword="FileStream" /> è stato costruito da un handle del sistema operativo, ad esempio un pipe o un output di console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la ricerca, le chiamate a <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, e <xref:System.IO.FileStream.Seek%2A> generano un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 L'esempio seguente usa il `CanSeek` proprietà da controllare se il flusso supporta la ricerca.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il flusso corrente supporta la scrittura.</summary>
        <value>
          <see langword="true" /> se il flusso supporta la scrittura; <see langword="false" /> se il flusso è chiuso o è stato aperto con accesso in sola lettura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una classe derivata da <xref:System.IO.Stream> non supporta la scrittura, una chiamata a <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, o <xref:System.IO.FileStream.WriteByte%2A> genera un <xref:System.NotSupportedException>.  
  
 Se il flusso è chiuso, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 L'esempio seguente usa il `CanWrite` proprietà da controllare se il flusso supporta la scrittura.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Di seguito è riportato un esempio utilizzando il `CanWrite` proprietà. L'output di questo codice è "MyFile. txt è scrivibile." Per ottenere il messaggio di output "MyFile. txt può essere sia scritto e letta da.", modificare il `FileAccess` parametro per `ReadWrite` nel `FileStream` costruttore.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.FileStream" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico <xref:System.ComponentModel.Component.Dispose%2A> metodo e <xref:System.Object.Finalize%2A> (metodo). <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.FileStream.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.FileStream.Dispose%2A> con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.FileStream> fa riferimento. Il metodo richiama il metodo <xref:System.ComponentModel.Component.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il metodo 
            <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see cref="M:System.ComponentModel.Component.Dispose" />. Per altre informazioni su come implementare <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Per altre informazioni sulle <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Riferimento alla richiesta asincrona in sospeso da attendere.</param>
        <summary>Attende il completamento dell'operazione di lettura asincrona in sospeso. (In alternativa, si consideri l'uso di <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Numero di byte letti dal flusso, tra 0 e il numero di byte richiesto. I flussi restituiscono 0 solo alla fine del flusso; in caso contrario, si devono bloccare fino a quando non è disponibile almeno 1 byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.FileStream.BeginRead%2A> e <xref:System.IO.FileStream.EndRead%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A> deve essere chiamato esattamente per ogni chiamata a <xref:System.IO.FileStream.BeginRead%2A>. Riesce a terminare un processo di lettura prima di iniziare la lettura di un altro può causare comportamenti indesiderati, ad esempio deadlock.  
  
 Questo metodo esegue l'override di <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> può essere chiamato su ogni <xref:System.IAsyncResult> da <xref:System.IO.FileStream.BeginRead%2A>. La chiamata a <xref:System.IO.FileStream.EndRead%2A> indica il numero di byte letti dal flusso. <xref:System.IO.FileStream.EndRead%2A> blocca fino a quando non è stata completata l'operazione dei / o.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> costruttore.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.IAsyncResult" /> non è stato creato chiamando <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> in questa classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> viene chiamato più volte.</exception>
        <exception cref="T:System.IO.IOException">Il flusso è chiuso o si è verificato un errore interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">I/O di file asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Richiesta di I/O asincrona in sospeso.</param>
        <summary>Termina un'operazione di scrittura asincrona, rimanendo bloccato fino al completamento dell'operazione di I/O. (In alternativa, si consideri l'uso di <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework 4 e versioni precedenti, è necessario usare metodi quali <xref:System.IO.FileStream.BeginWrite%2A> e <xref:System.IO.FileStream.EndWrite%2A> per implementare operazioni asincrone sui file. Questi metodi sono ancora disponibili nel [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per supportare il codice legacy; tuttavia, i nuovi metodi async, come <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, della Guida implementare operazioni asincrone sui file più facilmente.  
  
 Questo metodo esegue l'override di <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> deve essere chiamato una sola volta per ogni <xref:System.IAsyncResult> da <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> blocca fino a quando non è stata completata l'operazione dei / o.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> costruttore.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.IAsyncResult" /> non è stato creato chiamando <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> in questa classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> viene chiamato più volte.</exception>
        <exception cref="T:System.IO.IOException">Il flusso è chiuso o si è verificato un errore interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">I/O di file asincrono</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantisce che le risorse vengano liberate e le altre operazioni di pulizia vengano completate quando l'oggetto <see langword="FileStream" /> viene recuperato da Garbage Collector.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il garbage collector chiama `Finalize` quando l'oggetto corrente è pronto per essere completato. `Finalize` Chiude il `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Quando si chiama il <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> metodo, il buffer dei / o del sistema operativo viene inoltre scaricata.  
  
 Il codificatore del flusso non viene scaricato solo se si chiama esplicitamente <xref:System.IO.FileStream.Flush%2A> o eliminare l'oggetto. L'impostazione <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> a `true` significa che i dati verranno scaricati dal buffer nel flusso, ma non verrà rimosso lo stato del codificatore. In questo modo il codificatore mantenere lo stato (parzialmente caratteri) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7, in cui determinati caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti uno o più caratteri.  
  
 Poiché può essere usato un buffer per la lettura o scrittura, <xref:System.IO.FileStream.Flush> esegue le due funzioni seguenti:  
  
-   Tutti i dati scritti in precedenza per il buffer viene copiati il file e il buffer viene cancellato tranne lo stato di codificatore.  
  
-   Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> è `true` e dei dati è stati copiati in precedenza dal file nel buffer per la lettura, la posizione corrente all'interno del file viene decrementata dal numero di byte letti nel buffer. Il buffer viene quindi cancellato.  
  
 Usare il <xref:System.IO.FileStream.Flush%28System.Boolean%29> overload del metodo quando si desidera garantire che tutti i dati memorizzati nel buffer di file intermedi vengono scritti su disco.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.Lock%2A> (metodo).  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è chiuso.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> per svuotare tutti i buffer di file intermedi; in caso contrario, <see langword="false" />.</param>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nei buffer vengano scritti nel file, cancellando anche tutti i buffer di file intermedi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera garantire che tutti i dati memorizzati nel buffer di file intermedi verrà scritti su disco.  
  
 Quando si chiama il <xref:System.IO.FileStream.Flush%2A> metodo, il buffer dei / o del sistema operativo viene inoltre scaricata.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Cancella in modo asincrono i dati di tutti i buffer del flusso, determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scaricamento asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama il <xref:System.IO.FileStream.FlushAsync%2A> metodo, il buffer dei / o del sistema operativo viene inoltre scaricata.  
  
 Se l'operazione viene annullata prima che venga completato, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà. Se l'handle per il file è stato eliminato, l'attività restituita contiene il <xref:System.ObjectDisposedException> eccezione nel <xref:System.Threading.Tasks.Task.Exception%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annullamento</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) per il file descritto dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</summary>
        <returns>Oggetto che incapsula le impostazioni di controllo di accesso del file descritto dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mentre il <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.GetAccessControl%2A> può essere utilizzato per recuperare le voci di elenco (ACL) di controllo di accesso di un file esistente, è consigliabile usare <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> metodo, perché è più facile da usare.  
  
 Usare il <xref:System.IO.FileStream.GetAccessControl%2A> metodo per recuperare le voci ACL per un file.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono dei diritti ad azioni specifiche per il file specificato. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il file viene chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura del file.</exception>
        <exception cref="T:System.SystemException">Il file non è stato trovato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle di file del sistema operativo per il file incapsulato dall'oggetto <see langword="FileStream" />.</summary>
        <value>Handle di file del sistema operativo per il file incapsulato dall'oggetto <see langword="FileStream" /> oppure -1 se <see langword="FileStream" /> è stato chiuso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è un handle del sistema operativo per l'uso con le chiamate di sistema operativo-fornita dal sistema (ad esempio `ReadFile` su Windows). Non funzionerà con funzioni della libreria C che prevedono un descrittore di file, ad esempio `fread`.  
  
 L'handle del sistema operativo può essere stato aperto in modo sincrono o asincrono, a seconda di quale `FileStream` chiamate al costruttore. Usare il <xref:System.IO.FileStream.IsAsync%2A> proprietà per verificare se questo handle è stato aperto in modo asincrono. In Win32, ciò significa che l'handle è stato aperto per operazioni dei / o sovrapposte e richiede diversi parametri per `ReadFile` e `WriteFile`.  
  
> [!CAUTION]
>  I dati potrebbero venire danneggiati se un `FileStream` viene creato, viene passato l'handle, una determinata operazione Sposta il puntatore di file dell'handle e quindi il `FileStream` viene usato di nuovo. Più thread non è possibile scrivere in modo sicuro nello stesso file contemporaneamente, e `FileStream` buffering codice presuppone che l'handle esclusivamente controlli. `FileStream` potrebbe generare un' <xref:System.IO.IOException> se `FileStream` rileva che un altro processo è stato spostato il puntatore del file. Per evitare questo problema, non scrivere tutti i dati in una parte del file che `FileStream` potrebbe avere memorizzato nel buffer e ripristinare il puntatore del file nel percorso in cui si trovava al momento dell'ultima chiamati ai metodi in `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see langword="FileStream" /> è stato aperto in modalità sincrona o asincrona.</summary>
        <value>
          <see langword="true" /> se <see langword="FileStream" /> è stato aperto in modalità asincrona; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `IsAsync` proprietà rileva se il `FileStream` handle è stato aperto in modo asincrono, consentendo al codice per usare il <xref:System.IO.FileStream.Handle%2A> proprietà correttamente. In Win32 `IsAsync` su true indica che l'handle è stato aperto per i/o sovrapposte e pertanto richiede parametri diversi per `ReadFile` e `WriteFile`.  
  
 Si specifica questo valore quando si crea un'istanza del <xref:System.IO.FileStream> classe usando un costruttore che ha un `isAsync`, `useAsync`, o `options` parametro. Quando la proprietà è `true`, il flusso Usa i/o sovrapposte per eseguire operazioni sui file in modo asincrono. Tuttavia, il <xref:System.IO.FileStream.IsAsync%2A> proprietà non deve essere `true` per chiamare le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> (metodo). Quando la <xref:System.IO.FileStream.IsAsync%2A> è di proprietà `false` e si chiama la lettura asincrona e le operazioni di scrittura, il thread dell'interfaccia utente ancora non è bloccato, ma l'operazione dei / o effettiva viene eseguita in modo sincrono.  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> costruttore.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza in byte del flusso.</summary>
        <value>Valore long che rappresenta la lunghezza del flusso in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente usa il `Length` e `Position` proprietà per verificare la presenza di una condizione di fine del file.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> per questo flusso è <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore I/O, ad esempio il file viene chiuso.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Inizio dell'intervallo da bloccare. Il valore di questo parametro deve essere uguale o maggiore di zero (0).</param>
        <param name="length">Intervallo da bloccare.</param>
        <summary>Impedisce ad altri processi di leggere o scrivere nell'oggetto <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocco di un intervallo di un flusso di file consente di thread del blocco processo l'accesso esclusivo a quell'intervallo di flusso di file.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come parte di un file di blocco in modo che un altro processo non può accedere a tale parte del file anche se ha accesso in lettura/scrittura al file. Eseguire il programma contemporaneamente in diverse finestre di comando e provare a utilizzare le opzioni di input console diverse.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> è negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">Il file viene chiuso.</exception>
        <exception cref="T:System.IO.IOException">Il processo non può accedere al file perché un altro processo ne ha bloccato una parte.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso assoluto del file aperto in <see langword="FileStream" />.</summary>
        <value>Stringa che rappresenta il percorso assoluto del file.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Se il percorso assoluto non è noto, questa proprietà restituisce una stringa simile a "[Unknown]".

 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> costruttore.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione corrente del flusso.</summary>
        <value>Posizione corrente del flusso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca in un punto qualsiasi oltre la lunghezza del flusso è supportata.  Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano.  In Microsoft Windows NT e versioni successive, tutti i dati aggiunti alla fine del file sono impostati su zero.  In Microsoft Windows 98 o versioni precedenti, i dati aggiunti alla fine del file non è impostati su zero, che significa che i dati eliminati in precedenza è visibile nel flusso. Impostazione della posizione del flusso su un valore grande oltre la fine del flusso in Windows 98 o versione precedente può comportare viene generata un'eccezione.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente usa il `Length` e `Position` proprietà per verificare la presenza di una condizione di fine del file.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.  
  
\- oppure - 
La posizione è stata impostata su un valore molto grande oltre la fine del flusso in Windows 98 o versione precedente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Si è provato a impostare la posizione su un valore negativo.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Si è provato a cercare oltre la fine del flusso che non lo supporta.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Quando questo metodo viene restituito, contiene la matrice di byte specificata con i valori compresi tra <c>offset</c> e (<c>offset</c> + <c>count</c> - 1<c>)</c> sostituiti con i byte letti dall'origine corrente.</param>
        <param name="offset">Offset dei byte in <c>array</c> in corrispondenza del quale verranno inseriti i byte letti.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <summary>Legge un blocco di byte dal flusso e scrive i dati in un determinato buffer.</summary>
        <returns>Numero complessivo di byte letti nel buffer. Può essere inferiore al numero dei byte richiesti se tale numero di byte non è disponibile oppure pari a zero se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.Read%2A>.  
  
 Il `offset` parametro fornisce l'offset del byte in `array` (indice del buffer) in corrispondenza del quale iniziare la lettura e il `count` parametro fornisce il numero massimo di byte da leggere dal flusso corrente. Il valore restituito è il numero effettivo di byte letti, oppure zero se viene raggiunta la fine del flusso. Se l'operazione di lettura ha esito positivo, la posizione corrente del flusso viene avanzata il numero di byte letti. Se si verifica un'eccezione, la posizione corrente del flusso è invariata.  
  
 Il <xref:System.IO.FileStream.Read%2A> metodo restituisce zero solo dopo aver raggiunto la fine del flusso. In caso contrario, <xref:System.IO.FileStream.Read%2A> legge sempre almeno un byte dal flusso prima della restituzione. Se non sono disponibili dati dal flusso al momento della chiamata a <xref:System.IO.FileStream.Read%2A>, il metodo si blocca fino a quando non può essere restituito almeno un byte di dati. Un'implementazione è gratuita restituire un minor numero di byte rispetto a quella richiesta, anche se non è stata raggiunta la fine del flusso.  
  
 Usare <xref:System.IO.BinaryReader> per la lettura dei tipi di dati primitivi.  
  
 Interrompe un thread che sta eseguendo un'operazione di lettura. Anche se l'applicazione possa sembrare per eseguire correttamente dopo che il thread viene sbloccato, l'interruzione può ridurre le prestazioni e affidabilità dell'applicazione.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente legge il contenuto da un <xref:System.IO.FileStream> e lo scrive in un altro <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> e <paramref name="count" /> descrivono un intervallo non valido in <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> da cui iniziare la scrittura dei dati dal flusso.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte letti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileStream.ReadAsync%2A> metodo consente di eseguire operazioni sui file di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono usati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Usare il <xref:System.IO.FileStream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura.  
  
 Se l'operazione viene annullata prima che venga completato, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà. Se l'handle per il file è stato eliminato, l'attività restituita contiene il <xref:System.ObjectDisposedException> eccezione nel <xref:System.Threading.Tasks.Task.Exception%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come leggere da un file in modo asincrono.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di lettura precedente.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annullamento</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge un byte dal file e sposta in avanti di un byte la posizione di lettura.</summary>
        <returns>Byte, di cui è stato eseguito il cast a un oggetto <see cref="T:System.Int32" />, oppure -1 se è stata raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Usare il <xref:System.IO.FileStream.CanRead%2A> proprietà per determinare se l'istanza corrente supporta la lettura. Per altre informazioni, vedere <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati è stato scritto correttamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il flusso corrente non supporta la lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso corrente è chiuso.</exception>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita su <see langword="Stream" /> crea una nuova matrice a byte singolo e quindi chiama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Si tratta formalmente corretto, è poco efficiente. Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'allocazione di una matrice aggiuntivi in ogni chiamata.  
  
Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</summary>
        <value>Oggetto che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileStream.SafeFileHandle%2A> proprietà automaticamente Svuota il flusso e imposta la posizione corrente del flusso su 0.  In questo modo il file da spostare o la posizione del flusso per essere reimpostato con un altro flusso di <xref:System.IO.FileStream.SafeFileHandle%2A> restituita da questa proprietà.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">l'autorizzazione chiamare codice non gestito.  
  
Azione di sicurezza: richiesta di collegamento 
Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Punto relativo all'<c>origine</c> da cui avviare la ricerca.</param>
        <param name="origin">Specifica l'inizio, la fine o la posizione corrente come punto di riferimento per <c>offset</c>, usando un valore di tipo <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Imposta la posizione corrente del flusso sul valore dato.</summary>
        <returns>Nuova posizione all'interno del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Usare il <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> proprietà per determinare se l'istanza corrente supporta la ricerca. Per altre informazioni, vedere <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 È possibile cercare in qualsiasi posizione oltre la lunghezza del flusso. Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano. In Windows NT e versioni successive, i dati aggiunti alla fine del file sono impostati su zero. In Windows 98 o versioni precedenti, i dati aggiunti alla fine del file non sono impostati su zero, che significa che i dati eliminati in precedenza è visibile nel flusso.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati è stato scritto correttamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Nell'esempio seguente legge il testo nella direzione inversa, alla fine del file all'inizio del file, utilizzando i vari <xref:System.IO.SeekOrigin> i valori con il <xref:System.IO.FileStream.Seek%2A> (metodo).  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la ricerca, ad esempio se l'oggetto <see langword="FileStream" /> viene costruito da una pipe o da un output di console.</exception>
        <exception cref="T:System.ArgumentException">La ricerca viene tentata prima dell'inizio del flusso.</exception>
        <exception cref="T:System.ObjectDisposedException">Sono stati chiamati dei metodi dopo la chiusura del flusso.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Oggetto che descrive una voce ACL da applicare al file corrente.</param>
        <summary>Applica le voci dell'elenco di controllo di accesso (ACL) descritte da un oggetto <see cref="T:System.Security.AccessControl.FileSecurity" /> nel file specificato dall'oggetto <see cref="T:System.IO.FileStream" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mentre il <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.SetAccessControl%2A> può essere usato in un file esistente, è possibile usare il <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> il metodo è più facile da usare.  
  
 Il <xref:System.IO.FileStream.SetAccessControl%2A> metodo si applica a voci di elenco (ACL) di controllo di accesso a un file che rappresenta l'elenco ACL non ereditato.  
  
> [!CAUTION]
>  L'elenco ACL specificato per il `fileSecurity` parametro sostituisce l'ACL esistente per il file. Per aggiungere le autorizzazioni per un nuovo utente, usare il <xref:System.IO.FileStream.GetAccessControl%2A> metodo per ottenere l'ACL esistente, modificarlo e quindi usare <xref:System.IO.FileStream.SetAccessControl%2A> applicarlo nuovamente al file.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono dei diritti ad azioni specifiche per il file specificato. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il file viene chiuso.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="fileSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Non è stato possibile trovare o modificare il file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il processo corrente non è autorizzato ad accedere per aprire il file.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuova lunghezza del flusso.</param>
        <summary>Imposta la lunghezza del flusso sul valore dato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.SetLength%2A>.  
  
 Se il valore specificato è minore della lunghezza corrente del flusso, il flusso viene troncato. In questo scenario, se la posizione corrente è maggiore della lunghezza di nuovo, la posizione corrente viene spostata l'ultimo byte del flusso. Se il valore specificato è maggiore della lunghezza corrente del flusso, il flusso viene espanso e la posizione corrente rimane invariato. Se il flusso viene espanso, il contenuto del flusso tra la vecchia e nuova lunghezza viene definito.  
  
 Un flusso deve supportare la scrittura e per la ricerca `SetLength` a funzionare.  
  
> [!NOTE]
>  Usare la <xref:System.IO.FileStream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura e il <xref:System.IO.FileStream.CanSeek%2A> proprietà per determinare se la ricerca è supportata. Per altre informazioni, vedere <xref:System.IO.Stream.CanWrite%2A> e <xref:System.IO.Stream.CanSeek%2A>.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta né la scrittura né la ricerca.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Si è provato a impostare il parametro <paramref name="value" /> su un valore minore di 0.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Inizio dell'intervallo da sbloccare.</param>
        <param name="length">Intervallo da sbloccare.</param>
        <summary>Consente ad altri processi di accedere a una parte o a tutto il file bloccato in precedenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come parte di un file di blocco in modo che un altro processo non può accedere a tale parte del file anche se ha accesso in lettura/scrittura al file e quindi sbloccare la parte specificata del file. Eseguire il programma contemporaneamente in diverse finestre di comando e provare a utilizzare le opzioni di input console diverse.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> è negativo.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Buffer contenente i dati da scrivere nel flusso.</param>
        <param name="offset">Offset dei byte in base zero nella <c>matrice</c> da cui iniziare la copia dei byte nel flusso.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <summary>Scrive un blocco di byte nel flusso di file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.Write%2A>.  
  
 Il `offset` parametro fornisce l'offset del byte in `array` (indice del buffer) in corrispondenza del quale iniziare la copia e il `count` parametro indica il numero di byte che verrà scritto nel flusso. Se l'operazione di scrittura ha esito positivo, la posizione corrente del flusso viene avanzata il numero di byte scritti. Se si verifica un'eccezione, la posizione corrente del flusso è invariata.  
  
> [!NOTE]
>  Usare il <xref:System.IO.FileStream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura. Per altre informazioni, vedere <xref:System.IO.Stream.CanWrite%2A>.  
  
 Interrompe un thread che sta eseguendo un'operazione di scrittura. Anche se l'applicazione possa sembrare per eseguire correttamente dopo che il thread viene sbloccato, l'interruzione può ridurre le prestazioni e affidabilità dell'applicazione.  
  
 Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.FileStream.Lock%2A> (metodo).  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> e <paramref name="count" /> descrivono un intervallo non valido in <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.  
  
\- oppure - 
Un altro thread può aver causato una modifica imprevista nella posizione dell'handle di file del sistema operativo.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è chiuso.</exception>
        <exception cref="T:System.NotSupportedException">L'istanza del flusso corrente non supporta la scrittura.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer da cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <param name="cancellationToken">Token per il monitoraggio delle richieste di annullamento.</param>
        <summary>Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte scritti e monitora le richieste di annullamento.</summary>
        <returns>Attività che rappresenta l'operazione di scrittura asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileStream.WriteAsync%2A> metodo consente di eseguire operazioni sui file di risorse senza bloccare il thread principale. Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni. I metodi asincroni vengono usati in combinazione con il `async` e `await` parole chiave in Visual Basic e c#.  
  
 Usare il <xref:System.IO.FileStream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura.  
  
 Se l'operazione viene annullata prima che venga completato, l'attività restituita contiene il <xref:System.Threading.Tasks.TaskStatus.Canceled> valore per il <xref:System.Threading.Tasks.Task.Status%2A> proprietà. Se l'handle per il file è stato eliminato, l'attività restituita contiene il <xref:System.ObjectDisposedException> eccezione nel <xref:System.Threading.Tasks.Task.Exception%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come scrivere in modo asincrono in un file.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="offset" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">Il flusso è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il flusso è attualmente usato da un'operazione di scrittura precedente.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annullamento</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte da scrivere nel flusso.</param>
        <summary>Scrive un byte nella posizione corrente all'interno del flusso di file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.IO.Stream.WriteByte%2A>.  
  
 Uso `WriteByte` per scrivere un byte in un `FileStream` in modo efficiente. Se il flusso è chiuso o non accessibile in scrittura, verrà generata un'eccezione.  
  
> [!NOTE]
>  Usare il <xref:System.IO.FileStream.CanWrite%2A> proprietà per determinare se l'istanza corrente supporta la scrittura. Per altre informazioni, vedere <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati è stato scritto correttamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il flusso è chiuso.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso non supporta la scrittura.</exception>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita su <see langword="Stream" /> crea una nuova matrice a byte singolo e quindi chiama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Si tratta formalmente corretto, è poco efficiente. Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'allocazione di una matrice aggiuntivi in ogni chiamata.  
  
Per un elenco di operazioni di directory e file comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">I/O di file e di flussi</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procedura: leggere testo da un file</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procedura: Scrivere un testo in un file</related>
      </Docs>
    </Member>
  </Members>
</Type>