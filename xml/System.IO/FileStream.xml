<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FileStream.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86ca1270f501ef9faaea438d5520f0e0455a33f21ad.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a1270f501ef9faaea438d5520f0e0455a33f21ad</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> for a file, supporting both synchronous and asynchronous read and write operations.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> per un file, con il supporto di operazioni di lettura e scrittura sincrone e asincrone.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</source>
          <target state="translated">Utilizzare la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> classe per leggere, scrivere per aprire e chiudere i file in un file system e per modificare altri handle del sistema operativo relativi a file, tra cui pipe standard di input e output standard.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You can use the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> methods to perform synchronous operations, or the <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> methods to perform asynchronous operations.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> metodi per eseguire operazioni sincrone, o <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, e <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> metodi per eseguire asincrona operazioni.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">Utilizzare i metodi asincroni per eseguire operazioni sui file di risorse senza bloccare il thread principale.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> buffers input and output for better performance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> buffer di input e output per ottenere prestazioni migliori.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Questo tipo implementa il <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Per eliminare direttamente il tipo, chiamare il relativo <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> metodo in un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio <ph id="ph1">`using`</ph> in C# o <ph id="ph2">`Using`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> argomento relativo all'interfaccia.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property detects whether the file handle was opened asynchronously.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà rileva se l'handle di file è stato aperto in modo asincrono.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">Si specifica questo valore quando si crea un'istanza di <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> classe utilizzando un costruttore che ha un <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, o <ph id="ph4">`options`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Quando la proprietà è <ph id="ph1">`true`</ph>, prevede l'utilizzo di flusso dei / o sovrapposte per eseguire operazioni sui file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà non è necessario essere <ph id="ph2">`true`</ph> per chiamare il <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà <ph id="ph2">`false`</ph> e si chiama la lettura asincrona e le operazioni di scrittura, il thread UI ancora non viene bloccato, ma l'operazione effettiva dei / o viene eseguita in modo sincrono.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method supports random access to files.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> metodo supporta l'accesso casuale ai file.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> allows the read/write position to be moved to any position within the file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> consente la posizione di lettura/scrittura può essere spostata in qualsiasi posizione all'interno del file.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This is done with byte offset reference point parameters.</source>
          <target state="translated">Questa operazione viene eseguita con i parametri di punto di riferimento di offset di byte.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumeration.</source>
          <target state="translated">Offset dei byte è relativo punto di riferimento ricercato, che può essere l'inizio, la posizione corrente o la fine del file sottostante, come rappresentato dalle tre membri del <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Disk files always support random access.</source>
          <target state="translated">I file del disco supportano sempre l'accesso casuale.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>At the time of construction, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is set to <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph> depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph5">`true`</ph>.</source>
          <target state="translated">Al momento della costruzione, il <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> il valore di proprietà è impostato su <ph id="ph2">`true`</ph> o <ph id="ph3">`false`</ph> a seconda del tipo di file sottostante. Se il tipo di file sottostante è FILE_TYPE_DISK, come definito in winbase, il <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> valore della proprietà è <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">In caso contrario, il <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> valore della proprietà è <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</source>
          <target state="translated">Se un processo termina con una parte di un file bloccato o chiude un file con blocchi in attesa, il comportamento è indefinito.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For directory operations and other file operations, see the <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> classes.</source>
          <target state="translated">Per le operazioni di directory e altre operazioni di file, vedere il <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, e <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> classi.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> class is a utility class that has static methods primarily for the creation of <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objects based on file paths.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> classe è una classe di utilità che dispone di metodi statici principalmente per la creazione di <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti basati su percorsi di file.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class creates a stream from a byte array and is similar to the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> class.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe crea un flusso da una matrice di byte ed è simile al <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Detection of Stream Position Changes</source>
          <target state="translated">Rilevamento delle modifiche di posizione di flusso</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</source>
          <target state="translated">Quando un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto non dispone di un blocco esclusivo nel relativo handle, un altro thread può accedere all'handle di file contemporaneamente e modificare la posizione del puntatore del file del sistema operativo che è associato l'handle di file.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>In this case, the cached position in the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and the cached data in the buffer could be compromised.</source>
          <target state="translated">In questo caso, la posizione memorizzata nella cache il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto e i dati memorizzati nel buffer potrebbe essere compromessa.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto esegue regolarmente controlli sui metodi che accedono al buffer memorizzato nella cache per garantire che posizione dell'handle del sistema operativo sia uguale alla posizione memorizzata nella cache utilizzata dal <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</source>
          <target state="translated">Se viene rilevata una modifica imprevista nella posizione dell'handle in una chiamata al <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> (metodo), .NET Framework elimina il contenuto del buffer e legge il flusso dal file di nuovo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</source>
          <target state="translated">Questo può influire sulle prestazioni, a seconda delle dimensioni del file e tutti gli altri processi che possono influenzare la posizione del flusso di file.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> method, the contents of the buffer are discarded and an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> exception is thrown.</source>
          <target state="translated">Se viene rilevata una modifica imprevista nella posizione dell'handle in una chiamata al <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> (metodo), il contenuto del buffer vengono ignorati e un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object will not have an exclusive hold on its handle when either the <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property is accessed to expose the handle or the <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object is given the <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property in its constructor.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto disporrà di un blocco esclusivo nel relativo handle quando entrambi i <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> per esporre l'handle di cui si accede alla proprietà o <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> oggetto viene assegnato il <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> proprietà nel relativo costruttore.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example demonstrates some of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> constructors.</source>
          <target state="translated">Nell'esempio seguente vengono illustrate alcune delle <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> costruttori.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example shows how to write to a file asynchronously.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come scrivere in un file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</source>
          <target state="translated">Questo codice viene eseguito in un'applicazione WPF che dispone di un controllo TextBlock denominato UserInput e un pulsante associata a un gestore eventi Click denominato Button_Click.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The file path needs to be changed to a file than exits on the computer.</source>
          <target state="translated">Il percorso del file deve essere modificato in un file di esistenti nel computer.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura specificata.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> viene chiamato, l'handle viene chiuso e viene ridotto il numero di handle del file.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> non è un campo di <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura specificata.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> viene chiamato, l'handle viene chiuso e viene ridotto il numero di handle del file.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> non è un campo di <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path and creation mode.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso e la modalità di creazione specificati.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">Al costruttore è consentito l'accesso in lettura/scrittura al file, viene aperto condividendo l'accesso in lettura (vale a dire le richieste di aprire il file per la scrittura o in un altro processo avrà esito negativo fino a quando il <ph id="ph1">`FileStream`</ph> oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo).</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a <ph id="ph1">`FileAccess`</ph> parameter with the value set to <ph id="ph2">`FileAccess.Read`</ph>.</source>
          <target state="translated">È possibile utilizzare questo costruttore per aprire i file di sola lettura; In alternativa, è necessario utilizzare un costruttore che accetta un <ph id="ph1">`FileAccess`</ph> parametro con il valore impostato su <ph id="ph2">`FileAccess.Read`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For constructors without a <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parameter, if the <ph id="ph2">`mode`</ph> parameter is set to <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> is the default access.</source>
          <target state="translated">Per i costruttori senza un <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parametro, se il <ph id="ph2">`mode`</ph> parametro è impostato su <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> è l'accesso predefinito.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Otherwise, the access is set to <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</source>
          <target state="translated">In caso contrario, l'accesso è impostato su <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati vengano scritti correttamente.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valore non valido.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> constant that sets the <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> che imposta le proprietà <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, and buffer size.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura e la dimensione del buffer specificate.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">In alternativa, leggere e scrivere l'handle prima di chiamare il <ph id="ph1">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> è di un formato non valido.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> rappresenta un handle sincrono che è stato utilizzato in modo asincrono.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">l'autorizzazione per chiamare codice non gestito.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle del file è di proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission and <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura e la proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto viene assegnato l'accesso specificato al file.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">Sarà il proprietario dell'handle come specificato.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>If this process owns the handle, a call to the <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle and the file's handle count is decremented.</source>
          <target state="translated">Se questo processo è proprietario dell'handle, una chiamata per il <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> metodo comporterà la chiusura di handle e viene ridotto il numero di handle del file.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the default buffer size of 4096 bytes.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto ha le dimensioni predefinite del buffer di 4096 byte.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima utilizzando l'handle ed evitare di chiamare metodi diversi da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> non è un campo di <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che determina la modalità di accesso al file da parte dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Determina anche i valori restituiti dalle proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> se il <bpt id="p1">&lt;c&gt;</bpt>percorso<ept id="p1">&lt;/c&gt;</ept> specifica un file su disco.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, and read/write permission.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione e l'autorizzazione di lettura/scrittura specificati.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">Al costruttore è consentito l'accesso in lettura/scrittura al file, viene aperto condividendo l'accesso in lettura (vale a dire le richieste di aprire il file per la scrittura o in un altro processo avrà esito negativo fino a quando il <ph id="ph1">`FileStream`</ph> oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valore non valido.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle è stato aperto in modalità asincrona, ovvero in modalità I/O sovrapposta; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la dimensione del buffer e lo stato sincrono o asincrono specificati.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>You set the <ph id="ph1">`isAsync`</ph> parameter to <ph id="ph2">`true`</ph> to open the file handle asynchronously.</source>
          <target state="translated">Impostare il <ph id="ph1">`isAsync`</ph> parametro <ph id="ph2">`true`</ph> per aprire l'handle di file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the parameter is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Quando il parametro è <ph id="ph1">`true`</ph>, prevede l'utilizzo di flusso dei / o sovrapposte per eseguire operazioni sui file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>However, the parameter does not have to be <ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Tuttavia, il parametro non deve essere <ph id="ph1">`true`</ph> per chiamare il <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">`isAsync`</ph> parameter is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Quando il <ph id="ph1">`isAsync`</ph> parametro <ph id="ph2">`false`</ph> e si chiama la lettura asincrona e le operazioni di scrittura, il thread UI ancora non viene bloccato, ma l'operazione effettiva dei / o viene eseguita in modo sincrono.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">In alternativa, leggere e scrivere l'handle prima di chiamare il <ph id="ph1">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> è di un formato non valido.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> rappresenta un handle sincrono che è stato utilizzato in modo asincrono.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">l'autorizzazione per chiamare codice non gestito.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle del file è di proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, and buffer size.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> e la dimensione del buffer specificate.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto viene assegnato l'accesso specificato al file.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">Sarà il proprietario dell'handle come specificato.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">Se questo <ph id="ph1">`FileStream`</ph> proprietario dell'handle, una chiamata al <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> metodo comporterà la chiusura di handle.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">In particolare, il numero di handle del file viene decrementato.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto ha le dimensioni del buffer specificato.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">In alternativa, leggere e scrivere l'handle prima di chiamare il <ph id="ph1">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che determina la modalità di accesso al file da parte dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Determina anche i valori restituiti dalle proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> se il <bpt id="p1">&lt;c&gt;</bpt>percorso<ept id="p1">&lt;/c&gt;</ept> specifica un file su disco.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write permission, and sharing permission.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e l'autorizzazione di condivisione specificati.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">Al costruttore è consentito l'accesso in lettura/scrittura al file, viene aperto condividendo l'accesso in lettura (vale a dire le richieste di aprire il file per la scrittura o in un altro processo avrà esito negativo fino a quando il <ph id="ph1">`FileStream`</ph> oggetto è stato chiuso, ma i tentativi di lettura avranno esito positivo).</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">Le dimensioni del buffer sono impostata per la dimensione predefinita di 4096 byte (4 KB).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">Sul sistema è in esecuzione Windows 98 o Windows 98 Second Edition e <ph id="ph1">&lt;paramref name="share" /&gt;</ph> è impostata su <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valore non valido.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Handle di file relativo al file che sarà incapsulato nell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che imposta le proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle del file è di proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'handle è stato aperto in modalità asincrona, ovvero in modalità I/O sovrapposta; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per l'handle di file specificato, con l'autorizzazione di lettura/scrittura, la proprietà dell'istanza di <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>, la dimensione del buffer e lo stato sincrono o asincrono specificati.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto viene assegnato l'accesso specificato al file.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">Sarà il proprietario dell'handle come specificato.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">Se questo <ph id="ph1">`FileStream`</ph> proprietario dell'handle, una chiamata al <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> metodo comporterà la chiusura di handle.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">In particolare, il numero di handle del file viene decrementato.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated">Il <ph id="ph1">`FileStream`</ph> oggetto ha le dimensioni del buffer specificato.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> si presuppone che controllo esclusivo l'handle.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lettura, scrittura o ricerca durante una <ph id="ph1">`FileStream`</ph> contiene inoltre un handle potrebbe causare il danneggiamento dei dati.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Per garantire la protezione dati, chiamare <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> prima di utilizzare l'handle ed evitare di chiamare qualsiasi metodo diverso da <ph id="ph2">`Close`</ph> dopo avere completato utilizzando l'handle.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">In alternativa, leggere e scrivere l'handle prima di chiamare il <ph id="ph1">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> il valore predefinito è pensata per quegli <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> costruttori senza un <ph id="ph3">`FileShare`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is less than <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> or greater than <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph> or <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> è minore di <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> o maggiore di <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph> oppure <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> è minore di o uguale a 0.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The handle is invalid.</source>
          <target state="translated">Handle non valido.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio un errore del disco.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per l'handle di file specificato, ad esempio quando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> è <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> e l'handle di file è impostato per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>for access to unmanaged code.</source>
          <target state="translated">Per accedere al codice non gestito.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che determina la modalità di accesso al file da parte dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Determina anche i valori restituiti dalle proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> se il <bpt id="p1">&lt;c&gt;</bpt>percorso<ept id="p1">&lt;/c&gt;</ept> specifica un file su disco.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione e la dimensione del buffer specificati.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è un valore negativo o zero.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contengono un valore non valido.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">Sul sistema è in esecuzione Windows 98 o Windows 98 Second Edition e <ph id="ph1">&lt;paramref name="share" /&gt;</ph> è impostata su <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che determina la modalità di accesso al file da parte dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Determina anche i valori restituiti dalle proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> se il <bpt id="p1">&lt;c&gt;</bpt>percorso<ept id="p1">&lt;/c&gt;</ept> specifica un file su disco.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096..</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Specifies whether to use asynchronous I/O or synchronous I/O.</source>
          <target state="translated">Specifica se usare I/O asincroni o sincroni.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>However, note that the underlying operating system might not support asynchronous I/O, so when specifying <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the handle might be opened synchronously depending on the platform.</source>
          <target state="translated">Tenere presente, tuttavia, che il sistema operativo usato potrebbe non supportare le operazioni di I/O asincrone. Quindi, se si specifica <ph id="ph1">&lt;see langword="true" /&gt;</ph>, l'handle potrebbe essere aperto in modalità sincrona a seconda della piattaforma usata.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When opened asynchronously, the <ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</source>
          <target state="translated">Quando vengono aperti in modalità asincrona, i metodi <ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> offrono prestazioni migliori nelle operazioni di lettura o scrittura su dati di grandi dimensioni, ma potrebbero offrire prestazioni inferiori nelle operazioni di lettura o scrittura su dati di piccole dimensioni.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If the application is designed to take advantage of asynchronous I/O, set the <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> parameter to <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Se l'applicazione è stata progettata per sfruttare le operazioni di I/O asincrone, impostare il parametro <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> su <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</source>
          <target state="translated">Se le operazioni di I/O asincrone vengono usate in modo corretto è possibile ottenere un incremento delle prestazioni delle applicazioni fino a 10 volte, ma se vengono usate senza riprogettare l'applicazione per le operazioni di I/O asincrone le prestazioni possono ridursi fino a 10 volte.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione, la dimensione del buffer e lo stato sincrono o asincrono specificati.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come scrivere in modo asincrono i dati in un file e quindi verificare che i dati vengano scritti correttamente.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A <ph id="ph1">`State`</ph> object is created to pass information from the main thread to the <ph id="ph2">`EndReadCallback`</ph> and <ph id="ph3">`EndWriteCallback`</ph> methods.</source>
          <target state="translated">Oggetto <ph id="ph1">`State`</ph> oggetto viene creato per passare le informazioni dal thread principale per il <ph id="ph2">`EndReadCallback`</ph> e <ph id="ph3">`EndWriteCallback`</ph> metodi.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è un valore negativo o zero.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contengono un valore non valido.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">Sul sistema è in esecuzione Windows 98 o Windows 98 Second Edition e <ph id="ph1">&lt;paramref name="share" /&gt;</ph> è impostata su <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Costante che determina la modalità di accesso al file da parte dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Determina anche i valori restituiti dalle proprietà <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> dell'oggetto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> se il <bpt id="p1">&lt;c&gt;</bpt>percorso<ept id="p1">&lt;/c&gt;</ept> specifica un file su disco.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A value that specifies additional file options.</source>
          <target state="translated">Valore che specifica le opzioni aggiuntive del file.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, l'autorizzazione di lettura/scrittura e condivisione, l'accesso consentito ad altri FileStream allo stesso file, la dimensione del buffer e le opzioni aggiuntive del file specificati.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">`fileOptions`</ph> parametro viene utilizzato per fornire accesso alle operazioni più avanzate che possono essere utilizzati durante la creazione di un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Nell'esempio seguente scrive i dati in un file e quindi legge i dati utilizzando il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è un valore negativo o zero.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contengono un valore non valido.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> viene specificato per <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, ma la crittografia del file non è supportata sulla piattaforma corrente.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">Costante che determina i diritti di accesso da usare quando si creano regole di accesso e di controllo per il file.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">Costante che specifica le opzioni aggiuntive del file.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, i diritti di accesso e l'autorizzazione di condivisione, la dimensione del buffer e le opzioni aggiuntive del file specificati.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">Utilizzare questo <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> costruttore per applicare l'accesso i diritti al momento della creazione di un file.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Per accedere o modificare i diritti in un file esistente, è consigliabile utilizzare il <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">`fileOptions`</ph> parametro viene utilizzato per fornire accesso alle operazioni più avanzate che possono essere utilizzati durante la creazione di un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è un valore negativo o zero.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contengono un valore non valido.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">Il sistema operativo corrente non è Windows NT o versioni successive.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> viene specificato per <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, ma la crittografia del file non è supportata sulla piattaforma corrente.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, il nome file specificato o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Percorso relativo o assoluto per il file che sarà incapsulato dall'oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Costante che determina la modalità di apertura o di creazione del file.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">Costante che determina i diritti di accesso da usare quando si creano regole di accesso e di controllo per il file.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Costante che determina la modalità di condivisione del file da parte dei processi.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valore positivo <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> maggiore di 0 che indica la dimensione del buffer.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">La dimensione del buffer predefinita è 4096.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">Costante che specifica le opzioni aggiuntive del file.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access control and audit security for the file.</source>
          <target state="translated">Costante che determina il controllo di accesso e la sicurezza di controllo del file.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con il percorso, la modalità di creazione, i diritti di accesso e l'autorizzazione di condivisione, la dimensione del buffer, le opzioni aggiuntive del file, il controllo di accesso e la sicurezza di controllo specificati.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">Utilizzare questo <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> costruttore per applicare l'accesso i diritti al momento della creazione di un file.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Per accedere o modificare i diritti in un file esistente, è consigliabile utilizzare il <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">`fileOptions`</ph> parametro viene utilizzato per fornire accesso alle operazioni più avanzate che possono essere utilizzati durante la creazione di un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Il <ph id="ph1">`path`</ph> parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> non è necessario essere un file archiviato sul disco. può trattarsi di qualsiasi parte di un sistema che supporta l'accesso tramite flussi.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Ad esempio, a seconda del sistema, questa classe possa accedere a un dispositivo fisico.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> è <ph id="ph2">`true`</ph> per tutti i <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> gli oggetti che incapsulano i file.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`path`</ph> indica un dispositivo che non supporta la ricerca, il <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> è <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">Nell'esempio seguente scrive i dati in un file e quindi legge i dati utilizzando il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota (""), contiene solo spazi vuoti oppure contiene uno o più caratteri non validi.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente NTFS.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> fa riferimento a periferiche non basate su file come "con:", "com1:", "lpt1:" e così via in un ambiente non NTFS.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> è un valore negativo o zero.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contengono un valore non valido.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">Impossibile trovare il file, ad esempio quando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> è <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> e il file specificato da <ph id="ph4">&lt;paramref name="path" /&gt;</ph> non è disponibile.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">È necessario che il file sia già disponibile in queste modalità.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Si è verificato un errore di I/O, ad esempio quando si specifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> e il file specificato da <ph id="ph2">&lt;paramref name="path" /&gt;</ph> è già presente.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The stream has been closed.</source>
          <target state="translated">Il flusso è stato chiuso.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="access" /&gt;</ph> richiesto non è consentito dal sistema operativo per il parametro <ph id="ph2">&lt;paramref name="path" /&gt;</ph> specificato, ad esempio quando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> è <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> e il file o la directory è impostata per l'accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> viene specificato per <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, ma la crittografia del file non è supportata sulla piattaforma corrente.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, il nome file specificato o entrambi superano la lunghezza massima definita dal sistema.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">Il sistema operativo corrente non è Windows NT o versioni successive.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">per la lettura, scrittura e aggiunta ai file.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, e <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer to read data into.</source>
          <target state="translated">Buffer in cui leggere i dati.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin reading.</source>
          <target state="translated">Offset dei byte nella <bpt id="p1">&lt;c&gt;</bpt>matrice<ept id="p1">&lt;/c&gt;</ept> da cui iniziare la lettura.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Numero massimo di byte da leggere.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous read operation is completed.</source>
          <target state="translated">Metodo da chiamare quando l'operazione di lettura asincrona viene completata.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous read request from other requests.</source>
          <target state="translated">Oggetto fornito dall'utente che distingue questa specifica richiesta di lettura asincrona da altre richieste.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous read operation.</source>
          <target state="translated">Inizia un'operazione di lettura asincrona.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(In alternativa, si consideri l'uso di <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous read.</source>
          <target state="translated">Oggetto che fa riferimento alla lettura asincrona.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> per implementare operazioni asincrone sui file.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Questi metodi sono ancora disponibili nel <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, della Guida è implementare operazioni asincrone sui file più facilmente.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> deve essere chiamato esattamente una volta per ogni chiamata a <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">Impossibile terminare un processo di lettura prima di iniziare la lettura di un altro può causare un comportamento indesiderato, ad esempio i deadlock.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> fornisce due modalità diverse di funzionamento: i/o sincrone e asincrone.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">Mentre è possibile utilizzare una, risorse del sistema operativo sottostante potrebbero consentire l'accesso in una sola di queste modalità.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">Per impostazione predefinita, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> viene aperto l'handle del sistema operativo in modo sincrono.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">In Windows, ciò rallenta metodi asincroni.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Se si utilizzano metodi asincroni, utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la lettura.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated">Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">Gli errori che si verificano durante una richiesta di lettura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e diventano visibili dopo una chiamata a <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> deve essere chiamato con questo <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> per verificare il numero di byte letti.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">Più richieste asincrone contemporanee rendono incerto l'ordine di completamento della richiesta.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The array length minus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated">La lunghezza della matrice meno <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> è minore di <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An asynchronous read was attempted past the end of the file.</source>
          <target state="translated">Si è provato a eseguire la lettura asincrona oltre la fine del file.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer containing data to write to the current stream.</source>
          <target state="translated">Buffer contenente i dati da scrivere nel flusso corrente.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">Offset dei byte in base zero nella <bpt id="p1">&lt;c&gt;</bpt>matrice<ept id="p1">&lt;/c&gt;</ept> da cui iniziare la copia dei byte nel flusso corrente.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Numero massimo di byte da scrivere.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous write operation is completed.</source>
          <target state="translated">Metodo da chiamare quando l'operazione di scrittura asincrona viene completata.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous write request from other requests.</source>
          <target state="translated">Oggetto fornito dall'utente che distingue questa specifica richiesta di scrittura asincrona da altre richieste.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous write operation.</source>
          <target state="translated">Inizia un'operazione di scrittura asincrona.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(In alternativa, si consideri l'uso di <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous write.</source>
          <target state="translated">Oggetto che fa riferimento alla scrittura asincrona.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> per implementare operazioni asincrone sui file.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Questi metodi sono ancora disponibili nel <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, della Guida è implementare operazioni asincrone sui file più facilmente.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> deve essere chiamato esattamente una volta per ogni <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> da <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> verrà bloccata finché non viene completata l'operazione dei / o.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> fornisce due modalità diverse di funzionamento: i/o sincrone e asincrone.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">Mentre è possibile utilizzare una, risorse del sistema operativo sottostante potrebbero consentire l'accesso in una sola di queste modalità.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">Per impostazione predefinita, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> viene aperto l'handle del sistema operativo in modo sincrono.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">In Windows, ciò rallenta metodi asincroni.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Se si utilizzano metodi asincroni, utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">Se il flusso è chiuso o si passa un argomento non valido, le eccezioni vengono generate immediatamente <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">Gli errori che si verificano durante una richiesta di scrittura asincrona, ad esempio un errore del disco durante una richiesta dei / o, si verificano nel pool di thread e diventano visibili dopo una chiamata a <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">Più richieste asincrone contemporanee rendono incerto l'ordine di completamento della richiesta.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> length minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="array" /&gt;</ph> meno <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> è minore di <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream does not support writing.</source>
          <target state="translated">Il flusso non supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream is closed.</source>
          <target state="translated">Il flusso è chiuso.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">Ottiene un valore che indica se il flusso corrente supporta la lettura.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports reading; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with write-only access.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il flusso supporta la lettura; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se il flusso è chiuso o è stato aperto con accesso in sola scrittura.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> methods throw a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se una classe derivata da <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> non supporta la lettura, le chiamate al <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> metodi generano un <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se il flusso è chiuso, questa proprietà restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The following example demonstrates a use of the <ph id="ph1">`CanRead`</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene illustrato un utilizzo del <ph id="ph1">`CanRead`</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The output of this code is "MyFile.txt is not writable."</source>
          <target state="translated">L'output di questo codice è "MyFile.txt non è accessibile in scrittura."</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">Per ottenere il messaggio di output "MyFile.txt possibile sia per leggere e scrivere da.", modifica il <ph id="ph1">`FileAccess`</ph> parametro <ph id="ph2">`ReadWrite`</ph> nel <ph id="ph3">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">Ottiene un valore che indica se il flusso corrente supporta la ricerca.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports seeking; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or if the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> was constructed from an operating-system handle such as a pipe or output to the console.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il flusso supporta la ricerca; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se il flusso viene chiuso o se <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> è stato costruito da un handle del sistema operativo, ad esempio un pipe o un output di console.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se una classe derivata da <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> non supporta la ricerca, le chiamate a <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> generano un <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se il flusso è chiuso, questa proprietà restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>The following example uses the <ph id="ph1">`CanSeek`</ph> property to check whether a stream supports seeking.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">`CanSeek`</ph> proprietà per controllare se il flusso supporta la ricerca.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">Ottiene un valore che indica se il flusso corrente supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with read-only access.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il flusso supporta la scrittura; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se il flusso è chiuso o è stato aperto con accesso in sola lettura.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se una classe derivata da <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> non supporta la scrittura, una chiamata a <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> genera un <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se il flusso è chiuso, questa proprietà restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following example uses the <ph id="ph1">`CanWrite`</ph> property to check whether a stream supports writing.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">`CanWrite`</ph> proprietà per controllare se il flusso supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following is an example using the <ph id="ph1">`CanWrite`</ph> property.</source>
          <target state="translated">Di seguito è riportato un esempio utilizzando il <ph id="ph1">`CanWrite`</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The output of this code is "MyFile.txt is writable."</source>
          <target state="translated">L'output di questo codice è "MyFile.txt è accessibile in scrittura".</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">Per ottenere il messaggio di output "MyFile.txt possibile sia per leggere e scrivere da.", modifica il <ph id="ph1">`FileAccess`</ph> parametro <ph id="ph2">`ReadWrite`</ph> nel <ph id="ph3">`FileStream`</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per rilasciare sia le risorse gestite sia quelle non gestite; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per rilasciare solo le risorse non gestite.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">Rilascia le risorse non gestite usate da <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> e, facoltativamente, le risorse gestite.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene chiamato dal metodo pubblico <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> richiama il metodo protetto <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> metodo con il <ph id="ph3">`disposing`</ph> parametro impostato su <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> richiama <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> con <ph id="ph3">`disposing`</ph> impostato su <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> references.</source>
          <target state="translated">Se il parametro <ph id="ph1">`disposing`</ph> è <ph id="ph2">`true`</ph>, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> fa riferimento.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">Il metodo richiama il metodo <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> di ciascun oggetto cui viene fatto riferimento.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated">Il metodo <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> può essere chiamato più volte da altri oggetti.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">Quando si esegue l'override <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph> prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni su come implementare <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>, vedere <bpt id="p1">[</bpt>implementazione di un metodo Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, vedere <bpt id="p1">[</bpt>la pulizia di risorse non gestite<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The reference to the pending asynchronous request to wait for.</source>
          <target state="translated">Riferimento alla richiesta asincrona in sospeso da attendere.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Waits for the pending asynchronous read operation to complete.</source>
          <target state="translated">Attende il completamento dell'operazione di lettura asincrona in sospeso.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(In alternativa, si consideri l'uso di <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The number of bytes read from the stream, between 0 and the number of bytes you requested.</source>
          <target state="translated">Numero di byte letti dal flusso, tra 0 e il numero di byte richiesto.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</source>
          <target state="translated">I flussi restituiscono 0 solo alla fine del flusso; in caso contrario, si devono bloccare fino a quando non è disponibile almeno 1 byte.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> per implementare operazioni asincrone sui file.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Questi metodi sono ancora disponibili nel <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, della Guida è implementare operazioni asincrone sui file più facilmente.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> deve essere chiamato esattamente per ogni chiamata a <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">Impossibile terminare un processo di lettura prima di iniziare la lettura di un altro può causare un comportamento indesiderato, ad esempio i deadlock.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> can be called on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> può essere chiamato su ogni <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> da <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Calling <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> tells you how many bytes were read from the stream.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> indica il numero di byte letti dal flusso.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> verrà bloccata finché non viene completata l'operazione dei / o.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> non è stato creato chiamando <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> in questa classe.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph> viene chiamato più volte.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">Il flusso è chiuso o si è verificato un errore interno.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The pending asynchronous I/O request.</source>
          <target state="translated">Richiesta di I/O asincrona in sospeso.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>Ends an asynchronous write operation and blocks until the I/O operation is complete.</source>
          <target state="translated">Termina un'operazione di scrittura asincrona, rimanendo bloccato fino al completamento dell'operazione di I/O.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(In alternativa, si consideri l'uso di <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In .NET Framework 4 e versioni precedenti, è necessario utilizzare i metodi, ad esempio <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> per implementare operazioni asincrone sui file.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Questi metodi sono ancora disponibili nel <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> per supportare il codice legacy; tuttavia, nuovi metodi async, ad esempio <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, della Guida è implementare operazioni asincrone sui file più facilmente.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> deve essere chiamato esattamente una volta per ogni <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> da <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> verrà bloccata finché non viene completata l'operazione dei / o.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> non è stato creato chiamando <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> in questa classe.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph> viene chiamato più volte.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">Il flusso è chiuso o si è verificato un errore interno.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">Garantisce che le risorse vengano liberate e le altre operazioni di pulizia vengano completate quando l'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> viene recuperato da Garbage Collector.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source>The garbage collector calls <ph id="ph1">`Finalize`</ph> when the current object is ready to be finalized.</source>
          <target state="translated">Il garbage collector chiama <ph id="ph1">`Finalize`</ph> quando l'oggetto corrente è pronto per essere completato.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source><ph id="ph1">`Finalize`</ph> closes the <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> Chiude il <ph id="ph2">`FileStream`</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Quando si chiama il <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph> (metodo), il buffer dei / o del sistema operativo viene inoltre scaricata.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>A stream’s encoder is not flushed unless you explicitly call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> or dispose of the object.</source>
          <target state="translated">Il codificatore del flusso non viene cancellato a meno che non chiama in modo esplicito <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> o eliminare l'oggetto.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Setting <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</source>
          <target state="translated">Impostazione <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> a <ph id="ph2">`true`</ph> , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</source>
          <target state="translated">In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</source>
          <target state="translated">Questo scenario riguarda UTF8 e UTF7, in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve adiacenti carattere o caratteri.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Because a buffer can be used for either reading or writing, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> performs the following two functions:</source>
          <target state="translated">Poiché un buffer può essere utilizzato per la lettura o scrittura, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> esegue le due funzioni seguenti:</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</source>
          <target state="translated">Tutti i dati scritti in precedenza per il buffer viene copiati il file e il buffer viene cancellato tranne lo stato del codificatore.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>If <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">`true`</ph> and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> è <ph id="ph2">`true`</ph> e dati sono stati copiati in precedenza dal file nel buffer per la lettura, la posizione corrente all'interno del file viene applicata il numero di byte letti nel buffer.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>The buffer is then cleared.</source>
          <target state="translated">Il buffer viene quindi cancellato.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> overload del metodo quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi vengono scritti su disco.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>The stream is closed.</source>
          <target state="translated">Il flusso è chiuso.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to flush all intermediate file buffers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per svuotare tutti i buffer di file intermedi; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</source>
          <target state="translated">Cancella i buffer del flusso e fa sì che i dati memorizzati nei buffer vengano scritti nel file, cancellando anche tutti i buffer di file intermedi.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">Utilizzare questo overload quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi sia scritti su disco.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Quando si chiama il <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> (metodo), il buffer dei / o del sistema operativo viene inoltre scaricata.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token per il monitoraggio delle richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</source>
          <target state="translated">Cancella in modo asincrono i dati di tutti i buffer del flusso, determina la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante e monitora le richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Attività che rappresenta l'operazione di scaricamento asincrona.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Quando si chiama il <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> (metodo), il buffer dei / o del sistema operativo viene inoltre scaricata.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valore per il <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Se l'handle del file viene eliminato, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> eccezione nella <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Il flusso è stato eliminato.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object that encapsulates the access control list (ACL) entries for the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> che incapsula le voci dell'elenco di controllo di accesso (ACL) per il file descritto dall'oggetto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An object that encapsulates the access control settings for the file described by the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Oggetto che incapsula le impostazioni di controllo di accesso del file descritto dall'oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method, as it is easier to use.</source>
          <target state="translated">Mentre il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> classe e <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> può essere utilizzato per recuperare le voci di elenco (ACL) di controllo di accesso di un file esistente, è consigliabile utilizzare <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> del metodo, è più facile da utilizzare.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to retrieve the ACL entries for a file.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> metodo per recuperare le voci ACL per un file.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche per il file specificato.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file is closed.</source>
          <target state="translated">Il file viene chiuso.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An I/O error occurred while opening the file.</source>
          <target state="translated">Si è verificato un errore di I/O durante l'apertura del file.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file could not be found.</source>
          <target state="translated">Il file non è stato trovato.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>This operation is not supported on the current platform.</source>
          <target state="translated">L'operazione non è supportata sulla piattaforma corrente.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>Gets the operating system file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Ottiene l'handle di file del sistema operativo per il file incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system file handle for the file encapsulated by this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object, or -1 if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> has been closed.</source>
          <target state="translated">Handle di file del sistema operativo per il file incapsulato dall'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> oppure -1 se <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> è stato chiuso.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This property is an operating system handle for use with operating-system-provided system calls (such as <ph id="ph1">`ReadFile`</ph> on Windows).</source>
          <target state="translated">Questa proprietà è un handle del sistema operativo per l'utilizzo con chiamate di sistema operativo-fornita dal sistema (ad esempio <ph id="ph1">`ReadFile`</ph> in Windows).</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>It will not work with C library functions that expect a file descriptor, such as <ph id="ph1">`fread`</ph>.</source>
          <target state="translated">Non funzionerà con funzioni della libreria C che richiedono un descrittore di file, ad esempio <ph id="ph1">`fread`</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system handle might have been opened synchronously or asynchronously, depending on which <ph id="ph1">`FileStream`</ph> constructor was called.</source>
          <target state="translated">L'handle del sistema operativo può essere stato aperto in modo sincrono o asincrono, a seconda di quale <ph id="ph1">`FileStream`</ph> costruttore è stato chiamato.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property to discover whether this handle was opened asynchronously.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà per verificare se l'handle è stato aperto in modo asincrono.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to <ph id="ph1">`ReadFile`</ph> and <ph id="ph2">`WriteFile`</ph>.</source>
          <target state="translated">In Win32, ciò significa che l'handle è stato aperto per operazioni dei / o sovrapposte e richiede parametri diversi per <ph id="ph1">`ReadFile`</ph> e <ph id="ph2">`WriteFile`</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Data corruption might occur if a <ph id="ph1">`FileStream`</ph> is created, its handle is passed, some operation moves the handle's file pointer, and then the <ph id="ph2">`FileStream`</ph> is used again.</source>
          <target state="translated">Il danneggiamento dei dati può verificarsi se un <ph id="ph1">`FileStream`</ph> viene creato, viene passato al relativo handle, alcune operazioni Sposta puntatore del file dell'handle e quindi il <ph id="ph2">`FileStream`</ph> viene usato di nuovo.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Multiple threads cannot safely write to the same file simultaneously, and <ph id="ph1">`FileStream`</ph> buffering code assumes that it exclusively controls the handle.</source>
          <target state="translated">Più thread non è possibile scrivere in modo sicuro nello stesso file contemporaneamente, e <ph id="ph1">`FileStream`</ph> buffering codice presuppone che controlli esclusivamente l'handle.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source><ph id="ph1">`FileStream`</ph> might throw an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if <ph id="ph3">`FileStream`</ph> detects that some other process has moved the file pointer.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> potrebbe generare un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> se <ph id="ph3">`FileStream`</ph> rileva che un altro processo è stato spostato il puntatore del file.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>To avoid this, do not write any data into a portion of the file that <ph id="ph1">`FileStream`</ph> might have buffered, and restore the file pointer to the location it had when methods were last called on <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated">Per evitare questo problema, non scrivere dati in una parte del file che <ph id="ph1">`FileStream`</ph> potrebbe avere memorizzato nel buffer e ripristinare il puntatore del file nel percorso in cui si trovava al momento dell'ultima chiamati ai metodi in <ph id="ph2">`FileStream`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Il chiamante non dispone dell'autorizzazione richiesta.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>for the ability to access unmanaged code.</source>
          <target state="translated">Per poter accedere a codice non gestito.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> Security action: <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> azione di sicurezza: <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.IsAsync">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously or synchronously.</source>
          <target state="translated">Ottiene un valore che indica se <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> è stato aperto in modalità sincrona o asincrona.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> è stato aperto in modalità asincrona; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>The <ph id="ph1">`IsAsync`</ph> property detects whether the <ph id="ph2">`FileStream`</ph> handle was opened asynchronously, enabling your code to use the <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> property correctly.</source>
          <target state="translated">Il <ph id="ph1">`IsAsync`</ph> proprietà rileva se il <ph id="ph2">`FileStream`</ph> handle è stato aperto in modo asincrono, consentendo il codice per utilizzare il <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> proprietà correttamente.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>In Win32, <ph id="ph1">`IsAsync`</ph> being true means the handle was opened for overlapped I/O, and thus requires different parameters to <ph id="ph2">`ReadFile`</ph> and <ph id="ph3">`WriteFile`</ph>.</source>
          <target state="translated">In Win32 <ph id="ph1">`IsAsync`</ph> su true indica che l'handle è stato aperto per i/o sovrapposte e pertanto richiede parametri diversi per <ph id="ph2">`ReadFile`</ph> e <ph id="ph3">`WriteFile`</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">Si specifica questo valore quando si crea un'istanza di <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> classe utilizzando un costruttore che ha un <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, o <ph id="ph4">`options`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Quando la proprietà è <ph id="ph1">`true`</ph>, prevede l'utilizzo di flusso dei / o sovrapposte per eseguire operazioni sui file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà non è necessario essere <ph id="ph2">`true`</ph> per chiamare il <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> proprietà <ph id="ph2">`false`</ph> e si chiama la lettura asincrona e le operazioni di scrittura, il thread UI ancora non viene bloccato, ma l'operazione effettiva dei / o viene eseguita in modo sincrono.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>Gets the length in bytes of the stream.</source>
          <target state="translated">Ottiene la lunghezza in byte del flusso.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>A long value representing the length of the stream in bytes.</source>
          <target state="translated">Valore long che rappresenta la lunghezza del flusso in byte.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">`Length`</ph> e <ph id="ph2">`Position`</ph> proprietà per controllare la condizione di fine del file.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> for this stream is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> per questo flusso è <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>An I/O error, such as the file being closed, occurred.</source>
          <target state="translated">Si è verificato un errore I/O, ad esempio il file viene chiuso.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The beginning of the range to lock.</source>
          <target state="translated">Inizio dell'intervallo da bloccare.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The value of this parameter must be equal to or greater than zero (0).</source>
          <target state="translated">Il valore di questo parametro deve essere uguale o maggiore di zero (0).</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The range to be locked.</source>
          <target state="translated">Intervallo da bloccare.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Prevents other processes from reading from or writing to the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</source>
          <target state="translated">Impedisce ad altri processi di leggere o scrivere nell'oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</source>
          <target state="translated">Bloccando l'intervallo di un flusso di file offre i thread dell'accesso esclusivo processo blocco di intervallo del flusso di file.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come parte di un file di blocco in modo che un altro processo non può accedere la parte del file anche se ha accesso in lettura/scrittura al file.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">Eseguire il programma contemporaneamente in diverse finestre di comando e provare a utilizzare le opzioni di input console diverse.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The file is closed.</source>
          <target state="translated">Il file viene chiuso.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The process cannot access the file because another process has locked a portion of the file.</source>
          <target state="translated">Il processo non può accedere al file perché un altro processo ne ha bloccato una parte.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Name">
          <source>Gets the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> that was passed to the constructor.</source>
          <target state="translated">Ottiene il nome dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> passato al costruttore.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>A string that is the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">Stringa che rappresenta il nome dell'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>for access to the path.</source>
          <target state="translated">Per accedere al percorso.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Gets or sets the current position of this stream.</source>
          <target state="translated">Ottiene o imposta la posizione corrente del flusso.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The current position of this stream.</source>
          <target state="translated">Posizione corrente del flusso.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">La ricerca in qualsiasi posizione oltre la lunghezza del flusso è supportata.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</source>
          <target state="translated">In Microsoft Windows NT e versioni più recenti, i dati aggiunti alla fine del file sono impostati su zero.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">In Microsoft Windows 98 o versioni precedenti, i dati aggiunti alla fine del file non sono impostati su zero, che significa che i dati eliminati in precedenza è visibile nel flusso.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</source>
          <target state="translated">L'impostazione della posizione del flusso su un valore grande oltre la fine del flusso in Windows 98 o versione precedente potrebbe viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">`Length`</ph> e <ph id="ph2">`Position`</ph> proprietà per controllare la condizione di fine del file.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The stream does not support seeking.</source>
          <target state="translated">Il flusso non supporta la ricerca.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oppure -</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</source>
          <target state="translated">La posizione è stata impostata su un valore molto grande oltre la fine del flusso in Windows 98 o versione precedente.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted to set the position to a negative value.</source>
          <target state="translated">Si è provato a impostare la posizione su un valore negativo.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted seeking past the end of a stream that does not support this.</source>
          <target state="translated">Si è provato a cercare oltre la fine del flusso che non lo supporta.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> replaced by the bytes read from the current source.</source>
          <target state="translated">Quando questo metodo viene restituito, contiene la matrice di byte specificata con i valori compresi tra <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> sostituiti con i byte letti dall'origine corrente.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which the read bytes will be placed.</source>
          <target state="translated">Offset dei byte in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale verranno inseriti i byte letti.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Numero massimo di byte da leggere.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the stream and writes the data in a given buffer.</source>
          <target state="translated">Legge un blocco di byte dal flusso e scrive i dati in un determinato buffer.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes read into the buffer.</source>
          <target state="translated">Numero complessivo di byte letti nel buffer.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</source>
          <target state="translated">Può essere inferiore al numero dei byte richiesti se tale numero di byte non è disponibile oppure pari a zero se è stata raggiunta la fine del flusso.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin reading, and the <ph id="ph3">`count`</ph> parameter gives the maximum number of bytes to be read from this stream.</source>
          <target state="translated">Il <ph id="ph1">`offset`</ph> parametro fornisce l'offset del byte in <ph id="ph2">`array`</ph> (indice del buffer) in corrispondenza del quale iniziare la lettura e <ph id="ph3">`count`</ph> parametro fornisce il numero massimo di byte da leggere dal flusso corrente.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">Il valore restituito è il numero effettivo di byte letti, oppure zero se viene raggiunta la fine del flusso.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</source>
          <target state="translated">Se l'operazione di lettura ha esito positivo, la posizione corrente del flusso viene anticipata per il numero di byte letti.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">Se si verifica un'eccezione, la posizione corrente del flusso viene modificata.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method returns zero only after reaching the end of the stream.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> restituisce zero solo dopo il raggiungimento della fine del flusso.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">In caso contrario, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> legge sempre almeno un byte dal flusso prima della restituzione.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If no data is available from the stream upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, the method will block until at least one byte of data can be returned.</source>
          <target state="translated">Se non sono disponibili dati dal flusso dopo una chiamata a <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, il metodo verrà bloccato fino a quando non può essere restituito almeno un byte di dati.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Un'implementazione è gratuita restituire un numero di byte rispetto a quello richiesto, anche se non è stata raggiunta la fine del flusso.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">Utilizzare <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> per la lettura dei tipi di dati primitivi.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a read operation.</source>
          <target state="translated">Non interrompere un thread che sta eseguendo un'operazione di lettura.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">Anche se può sembrare che l'applicazione eseguita correttamente dopo aver sbloccato il thread, l'interruzione può ridurre le prestazioni e affidabilità dell'applicazione.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The following example reads the contents from a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> and writes it into another <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene letto il contenuto da un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> e lo scrive in un altro <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support reading.</source>
          <target state="translated">Il flusso non supporta la lettura.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> descrivono un intervallo non valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Sono stati chiamati dei metodi dopo la chiusura del flusso.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">Buffer in cui scrivere i dati.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">Offset dei byte in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> da cui iniziare la scrittura dei dati dal flusso.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Numero massimo di byte da leggere.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token per il monitoraggio delle richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">Legge in modo asincrono una sequenza di byte dal flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte letti e monitora le richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Attività che rappresenta l'operazione di lettura asincrona.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">Il valore del parametro di <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene il numero totale di byte letti nel buffer.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a 0 (zero) se è stata raggiunta la fine del flusso.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> metodo consente di eseguire operazioni sui file di risorse senza bloccare il thread principale.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">I metodi asincroni vengono utilizzati in combinazione con il <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> parole chiave in Visual Basic e c#.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la lettura.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valore per il <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Se l'handle del file viene eliminato, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> eccezione nella <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to read from a file asynchronously.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come leggere da un file in modo asincrono.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza del buffer.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">Il flusso non supporta la lettura.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Il flusso è stato eliminato.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">Il flusso è attualmente usato da un'operazione di lettura precedente.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>Reads a byte from the file and advances the read position one byte.</source>
          <target state="translated">Legge un byte dal file e sposta in avanti di un byte la posizione di lettura.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The byte, cast to an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated">Byte, di cui è stato eseguito il cast a un oggetto <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, oppure -1 se è stata raggiunta la fine del flusso.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la lettura.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati vengano scritti correttamente.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream does not support reading.</source>
          <target state="translated">Il flusso corrente non supporta la lettura.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream is closed.</source>
          <target state="translated">Il flusso corrente è chiuso.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">L'implementazione predefinita su <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> crea una nuova matrice a byte singolo e quindi chiama <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">Mentre sono formalmente corretto, è poco efficiente.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'assegnazione della matrice aggiuntiva a ogni chiamata.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> object that represents the operating system file handle for the file that the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>An object that represents the operating system file handle for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Oggetto che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property automatically flushes the stream and sets the current stream position to 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> automaticamente Scarica il flusso e imposta la posizione corrente del flusso a 0.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This allows the file to be moved or the stream position to be reset by another stream using the <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> returned by this property.</source>
          <target state="translated">In questo modo il file da spostare o la posizione del flusso per essere ripristinato da un altro flusso utilizzando il <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> restituita da questa proprietà.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">l'autorizzazione per chiamare codice non gestito.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Security action: Link Demand</source>
          <target state="translated">Azione di sicurezza: richiesta di collegamento</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The point relative to <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> from which to begin seeking.</source>
          <target state="translated">Punto relativo all'<bpt id="p1">&lt;c&gt;</bpt>origine<ept id="p1">&lt;/c&gt;</ept> da cui avviare la ricerca.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Specifies the beginning, the end, or the current position as a reference point for <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept>, using a value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">Specifica l'inizio, la fine o la posizione corrente come punto di riferimento per <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept>, usando un valore di tipo <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the current position of this stream to the given value.</source>
          <target state="translated">Imposta la posizione corrente del flusso sul valore dato.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position in the stream.</source>
          <target state="translated">Nuova posizione all'interno del flusso.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the current instance supports seeking.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> proprietà per determinare se l'istanza corrente supporta la ricerca.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>You can seek to any location beyond the length of the stream.</source>
          <target state="translated">È possibile effettuare ricerche in qualsiasi posizione oltre la lunghezza del flusso.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">Quando esegue la ricerca oltre la lunghezza del file, le dimensioni del file aumentano.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows NT and later versions, data added to the end of the file is set to zero.</source>
          <target state="translated">In Windows NT e versioni successive, i dati aggiunti alla fine del file sono impostati su zero.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">In Windows 98 o versioni precedenti, non è impostati su zero, il che significa che i dati eliminati in precedenza è visibile nel flusso di dati aggiunti alla fine del file.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati vengano scritti correttamente.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> values with the <ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente legge il testo nella direzione inversa, dalla fine del file all'inizio del file, usando i diversi <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> con i valori di <ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream does not support seeking, such as if the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> is constructed from a pipe or console output.</source>
          <target state="translated">Il flusso non supporta la ricerca, come nel caso in cui l'oggetto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> venga costruito da un pipe o da un output di console.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">La ricerca viene tentata prima dell'inizio del flusso.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Sono stati chiamati dei metodi dopo la chiusura del flusso.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An object that describes an ACL entry to apply to the current file.</source>
          <target state="translated">Oggetto che descrive una voce ACL da applicare al file corrente.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>Applies access control list (ACL) entries described by a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object to the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Applica le voci dell'elenco di controllo di accesso (ACL) descritte da un oggetto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> nel file specificato dall'oggetto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> can be used on an existing file, consider using the <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method as it is easier to use.</source>
          <target state="translated">Mentre il <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> classe e <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> può essere utilizzato in un file esistente, è possibile utilizzare il <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> il metodo è più facile da utilizzare.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> metodo si applica a voci di elenco (ACL) di controllo di accesso a un file che rappresenta l'elenco ACL non ereditato.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The ACL specified for the <ph id="ph1">`fileSecurity`</ph> parameter replaces the existing ACL for the file.</source>
          <target state="translated">L'ACL specificato per il <ph id="ph1">`fileSecurity`</ph> parametro sostituisce l'ACL per il file esistente.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>To add permissions for a new user, use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to obtain the existing ACL, modify it, and then use <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> to apply it back to the file.</source>
          <target state="translated">Per aggiungere autorizzazioni per un nuovo utente, utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> metodo per ottenere l'ACL esistente, modificarlo e quindi usare <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> per applicarlo nuovamente al file.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche per il file specificato.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file is closed.</source>
          <target state="translated">Il file viene chiuso.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file could not be found or modified.</source>
          <target state="translated">Non è stato possibile trovare o modificare il file.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The current process does not have access to open the file.</source>
          <target state="translated">Il processo corrente non è autorizzato ad accedere per aprire il file.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The new length of the stream.</source>
          <target state="translated">Nuova lunghezza del flusso.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Sets the length of this stream to the given value.</source>
          <target state="translated">Imposta la lunghezza del flusso sul valore dato.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">Se il valore specificato è minore della lunghezza corrente del flusso, il flusso viene troncato.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</source>
          <target state="translated">In questo scenario, se la posizione corrente è maggiore della lunghezza di nuovo, la posizione corrente viene spostata l'ultimo byte del flusso.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</source>
          <target state="translated">Se il valore specificato è maggiore della lunghezza corrente del flusso, il flusso viene esteso e la posizione corrente rimane invariato.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the stream is expanded, the contents of the stream between the old and the new length are undefined.</source>
          <target state="translated">Se il flusso è espanso, il contenuto del flusso tra il vecchio e la nuova lunghezza non è definito.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>A stream must support both writing and seeking for <ph id="ph1">`SetLength`</ph> to work.</source>
          <target state="translated">Un flusso deve supportare sia la ricerca per la scrittura <ph id="ph1">`SetLength`</ph> a funzionare.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing, and the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property to determine whether seeking is supported.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la scrittura e <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> proprietà per determinare se la ricerca è supportata.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>An I/O error has occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The stream does not support both writing and seeking.</source>
          <target state="translated">Il flusso non supporta né la scrittura né la ricerca.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Attempted to set the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter to less than 0.</source>
          <target state="translated">Si è tentato di impostare il parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> su un valore minore di 0.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The beginning of the range to unlock.</source>
          <target state="translated">Inizio dell'intervallo da sbloccare.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The range to be unlocked.</source>
          <target state="translated">Intervallo da sbloccare.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Allows access by other processes to all or part of a file that was previously locked.</source>
          <target state="translated">Consente ad altri processi di accedere a una parte o a tutto il file bloccato in precedenza.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come parte di un file di blocco in modo che un altro processo non è possibile accedere a tale parte del file anche se ha accesso in lettura/scrittura al file e quindi sbloccare la parte specificata del file.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">Eseguire il programma contemporaneamente in diverse finestre di comando e provare a utilizzare le opzioni di input console diverse.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer containing data to write to the stream.</source>
          <target state="translated">Buffer contenente i dati da scrivere nel flusso.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Offset dei byte in base zero nella <bpt id="p1">&lt;c&gt;</bpt>matrice<ept id="p1">&lt;/c&gt;</ept> da cui iniziare la copia dei byte nel flusso.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Numero massimo di byte da scrivere.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the file stream.</source>
          <target state="translated">Scrive un blocco di byte nel flusso di file.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin copying, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes that will be written to the stream.</source>
          <target state="translated">Il <ph id="ph1">`offset`</ph> parametro fornisce l'offset del byte in <ph id="ph2">`array`</ph> (indice del buffer) in corrispondenza del quale iniziare la copia e <ph id="ph3">`count`</ph> parametro fornisce il numero di byte che verranno scritti nel flusso.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</source>
          <target state="translated">Se l'operazione di scrittura ha esito positivo, la posizione corrente del flusso viene anticipata per il numero di byte scritti.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">Se si verifica un'eccezione, la posizione corrente del flusso viene modificata.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a write operation.</source>
          <target state="translated">Non interrompere un thread che sta eseguendo un'operazione di scrittura.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">Anche se può sembrare che l'applicazione eseguita correttamente dopo aver sbloccato il thread, l'interruzione può ridurre le prestazioni e affidabilità dell'applicazione.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> descrivono un intervallo non valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">Si è verificato un errore di I/O.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oppure -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Another thread may have caused an unexpected change in the position of the operating system's file handle.</source>
          <target state="translated">Un altro thread può aver causato una modifica imprevista nella posizione dell'handle di file del sistema operativo.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed.</source>
          <target state="translated">Il flusso è chiuso.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance does not support writing.</source>
          <target state="translated">L'istanza del flusso corrente non supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">Buffer da cui scrivere i dati.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Offset dei byte in base zero in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> da cui iniziare la copia dei byte nel flusso.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Numero massimo di byte da scrivere.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token per il monitoraggio delle richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Scrive in modo asincrono una sequenza di byte nel flusso corrente e passa alla posizione successiva all'interno del flusso corrente in base al numero di byte scritti e monitora le richieste di annullamento.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Attività che rappresenta l'operazione di scrittura asincrona.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> metodo consente di eseguire operazioni sui file di risorse senza bloccare il thread principale.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Questa considerazione sulle prestazioni è particolarmente importante in un'applicazione <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> in cui tramite un'operazione di flusso per cui è richiesto molto tempo è possibile bloccare il thread UI e far sembrare che l'applicazione non funzioni.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">I metodi asincroni vengono utilizzati in combinazione con il <ph id="ph1">`async`</ph> e <ph id="ph2">`await`</ph> parole chiave in Visual Basic e c#.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la lettura.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se l'operazione viene annullata prima del completamento, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valore per il <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Se l'handle del file viene eliminato, l'attività restituita contiene il <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> eccezione nella <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to write asynchronously to a file.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come scrivere in modo asincrono in un file.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> è maggiore della lunghezza del buffer.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">Il flusso non supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Il flusso è stato eliminato.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">Il flusso è attualmente usato da un'operazione di scrittura precedente.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>A byte to write to the stream.</source>
          <target state="translated">Byte da scrivere nel flusso.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current position in the file stream.</source>
          <target state="translated">Scrive un byte nella posizione corrente all'interno del flusso di file.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo esegue l'override del metodo <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use <ph id="ph1">`WriteByte`</ph> to write a byte to a <ph id="ph2">`FileStream`</ph> efficiently.</source>
          <target state="translated">Utilizzare <ph id="ph1">`WriteByte`</ph> per scrivere un byte in un <ph id="ph2">`FileStream`</ph> in modo efficiente.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>If the stream is closed or not writable, an exception will be thrown.</source>
          <target state="translated">Se il flusso è chiuso o non accessibile in scrittura, verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> proprietà per determinare se l'istanza corrente supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come scrivere i dati in un file, byte per byte e quindi verificare che i dati vengano scritti correttamente.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream is closed.</source>
          <target state="translated">Il flusso è chiuso.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">Il flusso non supporta la scrittura.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">L'implementazione predefinita su <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> crea una nuova matrice a byte singolo e quindi chiama <ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">Mentre sono formalmente corretto, è poco efficiente.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">Qualsiasi flusso con un buffer interno deve eseguire l'override di questo metodo e fornire una versione molto più efficiente che legge il buffer direttamente, evitando l'assegnazione della matrice aggiuntiva a ogni chiamata.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Per un elenco di file comuni e le operazioni di directory, vedere <bpt id="p1">[</bpt>comuni attività dei / o<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>