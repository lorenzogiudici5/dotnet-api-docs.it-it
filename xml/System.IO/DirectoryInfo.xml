<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3335d1cdc13ad2b58c4f218d726dde6c0d0dc82" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39983746" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Espone i metodi dell'istanza per la creazione, lo spostamento e l'enumerazione tramite directory e sottodirectory. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.DirectoryInfo> classe per operazioni tipiche, quali copia, lo spostamento, ridenominazione, creazione e l'eliminazione di directory.  
  
 Se si intende riutilizzare un oggetto più volte, è consigliabile usare il metodo di istanza di <xref:System.IO.DirectoryInfo> anziché i corrispondenti metodi statici del <xref:System.IO.Directory> classe, poiché un controllo di sicurezza non saranno sempre necessario.  
  
> [!NOTE]
>  I membri che accettano un percorso come una stringa di input, che il percorso deve essere nel formato corretto o viene generata un'eccezione. Ad esempio, se un percorso completo, ma inizia con uno spazio, il percorso non viene ritagliato in metodi della classe. Di conseguenza, il percorso sia valido e viene generata un'eccezione. Analogamente, un percorso o una combinazione di percorsi non può essere completamente qualificata due volte. Ad esempio, "c:\windows c:\temp" genera anche un'eccezione nella maggior parte dei casi. Assicurarsi che i percorsi siano in formato corretto quando si usano i metodi che accettano una stringa di percorso.  
  
 Nei membri che accettano un percorso, il percorso può fare riferimento a un file o solo una directory. Il percorso specificato può anche fare riferimento a un percorso relativo o un percorso Universal Naming Convention (UNC) per un nome di server e la condivisione. Ad esempio, le condizioni seguenti sono percorsi accettabili:  
  
-   "c:\\\MyDir\\\MyFile.txt" in c# o "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "c:\\\MyDir" in c# o "c:\MyDir" in Visual Basic.  
  
-   "MyDir\\\MySubdir" in c# o "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" nel linguaggio c#, o "\\\MyServer\MyShare" in Visual Basic.  
  
 Per impostazione predefinita, accesso completo in lettura/scrittura di nuove directory viene concesso a tutti gli utenti.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra alcuni dei membri principali del `DirectoryInfo` classe.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Nell'esempio seguente viene illustrato come copiare una directory e il relativo contenuto.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Stringa che specifica il percorso nel quale creare l'oggetto <see langword="DirectoryInfo" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.DirectoryInfo" /> nel percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non verifica se è presente una directory. Questo costruttore è un segnaposto per una stringa che viene utilizzato per accedere al disco in operazioni successive.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione di Universal Naming Convention (UNC).  
  
> [!CAUTION]
>  Quando si compila un set di caratteri con una lingua specifica e si recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe generare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente utilizza questo costruttore per creare la directory e sottodirectory specificata e viene dimostrato che non è possibile eliminare una directory che contiene le sottodirectory.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene caratteri non validi, ad esempio ", &lt;, &gt; o |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura da file e directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la directory esiste già, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se esiste una directory specificata, crea la directory se non esiste e consente di eliminare la directory.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Non è possibile creare la directory.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura di file. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Controllo di accesso da applicare alla directory.</param>
        <summary>Crea una directory usando l'oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per creare una directory con controllo degli accessi, pertanto non c'è alcuna possibilità che di accesso può essere eseguito prima che venga applicata la protezione.  
  
 Se la directory esiste già, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La directory specificata da <paramref name="path" /> è di sola lettura o non è vuota.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">Si è provato a creare una directory usando solo il carattere due punti (:).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione per creare una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una o più sottodirectory nel percorso specificato. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso specificato. Non può essere un volume del disco o un nome UNC (Universal Naming Convention) diverso.</param>
        <summary>Crea una o più sottodirectory nel percorso specificato. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Ultima directory specificata in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutte le directory specificate nelle `path` vengono creati, a meno che una parte del `path` non è valido. Il `path` parametro specifica un percorso di directory, non un percorso di file. Se esiste già nella sottodirectory, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata la creazione di una sottodirectory. In questo esempio, le directory vengono rimossi dopo la creazione. Pertanto, per testare questo esempio, impostare come commento le righe eliminate nel codice.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non specifica un percorso file valido o contiene caratteri <see langword="DirectoryInfo" /> non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Non è possibile creare la sottodirectory.  
  
oppure 
Un file o directory ha già il nome specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non è autorizzato ad accedere al codice per creare la directory.  
  
oppure 
Il chiamante non ha l'autorizzazione di accesso al codice per leggere la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> restituito.  Questo problema può verificarsi quando il parametro <paramref name="path" /> descrive una directory esistente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carattere due punti (:) che non fa parte di un'etichetta di unità ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Percorso specificato. Non può essere un volume del disco o un nome UNC (Universal Naming Convention) diverso.</param>
        <param name="directorySecurity">Sicurezza da applicare.</param>
        <summary>Crea una o più sottodirectory nel percorso specificato con la sicurezza specificata. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Ultima directory specificata in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutte le directory specificate nelle `path` vengono creati, a meno che una parte del `path` non è valido. Il `path` parametro specifica un percorso di directory, non un percorso di file. Se esiste già nella sottodirectory, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non specifica un percorso file valido o contiene caratteri <see langword="DirectoryInfo" /> non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Non è possibile creare la sottodirectory.  
  
oppure 
Un file o directory ha già il nome specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non è autorizzato ad accedere al codice per creare la directory.  
  
oppure 
Il chiamante non ha l'autorizzazione di accesso al codice per leggere la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> restituito.  Questo problema può verificarsi quando il parametro <paramref name="path" /> descrive una directory esistente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carattere due punti (:) che non fa parte di un'etichetta di unità ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un oggetto <see cref="T:System.IO.DirectoryInfo" /> e il relativo contenuto da un percorso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina questo oggetto <see cref="T:System.IO.DirectoryInfo" /> se è vuoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente genera un'eccezione se si tenta di eliminare una directory non vuota.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La directory contiene un file di sola lettura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> non esiste o non è stato possibile trovarla.</exception>
        <exception cref="T:System.IO.IOException">La directory non è vuota.  
  
oppure 
La directory è la directory di lavoro corrente dell'applicazione.  
  
oppure 
C'è un handle aperto sulla directory e il sistema operativo è Windows XP o versione precedente. Questo handle aperto può derivare dall'enumerazione di directory. Per altre informazioni, vedere [Procedura: enumerare directory e file](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura di directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive">
          <see langword="true" /> per eliminare la directory, le rispettive sottodirectory e tutti i file; in caso contrario, <see langword="false" />.</param>
        <summary>Elimina questa istanza di <see cref="T:System.IO.DirectoryInfo" />, specificando se eliminare le subdirectory e i file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `DirectoryInfo` non dispone di alcun file o sottodirectory, questo metodo elimina il `DirectoryInfo` anche se `recursive` è `false`. Tentativo di eliminare un `DirectoryInfo` che non è vuota quando `recursive` viene `false` genera un <xref:System.IO.IOException>.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra l'eliminazione di una directory. Poiché la directory viene rimossa, prima di tutto impostare come commento il `Delete` riga per verificare che la directory esista. Quindi rimuovere il commento dalla stessa riga di codice per verificare che la directory è stato rimosso correttamente.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La directory contiene un file di sola lettura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> non esiste o non è stato possibile trovarla.</exception>
        <exception cref="T:System.IO.IOException">La directory è di sola lettura.  
  
oppure 
La directory contiene uno o più file o sottodirectory e <paramref name="recursive" /> è <see langword="false" />.  
  
oppure 
La directory è la directory di lavoro corrente dell'applicazione.  
  
oppure 
C'è un handle aperto sulla directory o su uno dei relativi file e il sistema operativo è Windows XP o versione precedente. Questo handle aperto può derivare dall'enumerazione di directory e file. Per altre informazioni, vedere [Procedura: enumerare directory e file](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Flag necessaria l'autorizzazione di scrittura per scrivere il <see langword="DirectoryInfo" /> e le sottodirectory da eliminare.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory nella directory corrente.</summary>
        <returns>Raccolta enumerabile di directory nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.DirectoryInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente enumera le sottodirectory nella directory C:\Program Files e Usa una query LINQ per restituire i nomi di tutte le directory che sono stati creati prima del 2009 controllando il valore della <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> proprietà.  
  
 Se sono necessari solo i nomi delle sottodirectory, usare il metodo statico <xref:System.IO.Directory> classe per ottenere prestazioni migliori. Per un esempio, vedere il <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> (metodo).  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory che corrisponde a un criterio di ricerca specificato.</summary>
        <returns>Raccolta enumerabile di directory che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.DirectoryInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di directory che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.DirectoryInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 L'esempio seguente, a partire da una directory specificata, Usa questo metodo e il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> metodo per enumerare i file e directory all'interno della directory di avvio e visualizzare i dettagli di qualsiasi file oltre 10 MB di dimensioni.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file nella directory corrente.</summary>
        <returns>Raccolta enumerabile dei file nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente enumera i file in una directory specificata e Usa una query LINQ per restituire i nomi di tutti i file che sono stati creati prima del 2009 controllando il valore della <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> proprietà.  
  
 Se sono necessari solo i nomi dei file, usare il metodo statico <xref:System.IO.Directory> classe per ottenere prestazioni migliori. Per un esempio, vedere il <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file che corrisponde a un criterio di ricerca.</summary>
        <returns>Raccolta enumerabile di file che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di file che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system nella directory corrente.</summary>
        <returns>Raccolta enumerabile di informazioni sul file system nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileSystemInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system che corrisponde a un criterio di ricerca specificato.</summary>
        <returns>Raccolta enumerabile di oggetti di informazione sul file system che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileSystemInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di oggetti di informazione sul file system che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileSystemInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può risultare più efficiente.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non viene memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la directory esiste.</summary>
        <value>
          <see langword="true" /> se la directory esiste; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.Exists%2A> restituisce proprietà `false` se si verifica un errore durante il tentativo di determinare se il file specificato esiste. Ciò può verificarsi nelle situazioni che generano eccezioni, ad esempio passando un nome di file con caratteri non validi o troppi caratteri, un disco mancante o non superato o se il chiamante non dispone dell'autorizzazione per leggere il file.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di `Exists` proprietà nel contesto della copia di una directory di origine in una directory di destinazione.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso completo della directory.</summary>
        <value>Stringa contenente il percorso completo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene le voci dell'elenco di controllo di accesso (ACL) per la directory corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodi per recuperare l'accesso controllano le voci dell'elenco (ACL) per il file corrente.  
  
 Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) per la directory descritta nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le regole di controllo di accesso per la directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.IO.Directory.GetAccessControl%2A> overload del metodo e specificando l'accesso di controllo nelle sezioni <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> in Visual Basic).  
  
 Usare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per il file corrente.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> e <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso di controllo voce di elenco (ACL) da una directory.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Non è possibile trovare o modificare la directory.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La directory è di sola lettura.  
  
oppure 
L'operazione non è supportata sulla piattaforma corrente.  
  
oppure 
Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura della directory.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione enumerare un elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlSections" /> che specifica il tipo di informazioni relative all'elenco di controllo di accesso (ACL) da ricevere.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula il tipo specificato di voci dell'elenco di controllo di accesso (ACL) per la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le regole di controllo di accesso del file descritto dal parametro <paramref name="path" />.  
  
Eccezioni 
 <list type="table"><listheader><term> Tipo di eccezione </term><description> Condizione </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Non è possibile trovare o modificare la directory.  </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Il processo corrente non ha accesso all'apertura della directory.  </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Si è verificato un errore di I/O durante l'apertura della directory.  </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.  </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> La directory è di sola lettura - oppure - Questa operazione non è supportata nella piattaforma corrente. oppure - Il chiamante non dispone delle autorizzazioni necessarie.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per il file corrente.  
  
 Un ACL vengono descritti i singoli utenti e/o gruppi che hanno o non si dispongono, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione enumerare un elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce le sottodirectory della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce le sottodirectory della directory corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.IO.DirectoryInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti sottodirectory, questo metodo restituisce una matrice vuota. Questo metodo non è ricorsiva.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente recupera tutte le directory nella directory radice e visualizza i nomi delle directory.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido, poiché, ad esempio, si trova su un'unità non connessa.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura delle directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una matrice di directory nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente corrispondente ai criteri di ricerca specificati.</summary>
        <returns>Matrice di tipo <see langword="DirectoryInfo" /> corrispondente a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene contato le directory in un percorso che contengono la lettera specificata.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see langword="DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory.</param>
        <summary>Restituisce una matrice di directory nella classe <see cref="T:System.IO.DirectoryInfo" /> corrente che corrisponde al criterio di ricerca specificato e usando un valore per determinare se eseguire la ricerca nelle sottodirectory.</summary>
        <returns>Matrice di tipo <see langword="DirectoryInfo" /> corrispondente a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Se non sono presenti sottodirectory o alcuna sottodirectory non corrisponde il `searchPattern` parametro, questo metodo restituisce una matrice vuota.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L'esempio seguente elenca tutte le directory e file che iniziano con la lettera "c" in "c:\\".  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see langword="DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un elenco di file della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un elenco di file della directory corrente.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Se non sono presenti file nei <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 L'ordine dei nomi di file restituito non è garantito. usare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura delle directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce un elenco di file della directory corrente corrispondente al criterio di ricerca specificato.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Se non sono presenti file nei <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 I seguenti caratteri jolly sono consentiti nel `searchPattern` parametro.  
  
|carattere jolly|Descrizione|  
|------------------------|-----------------|  
|*|Zero o più caratteri.|  
|?|Esattamente uno o nessun carattere.|  
  
 L'ordine dei nomi di file restituito non è garantito. usare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` stringa "*. txt" ricerche per tutti i file i nomi con un'estensione di "txt". Il `searchPattern` stringa "s\*" ricerca per tutti i file i nomi che iniziano con la lettera "s". Se non esistono Nessun file e No negli altri file che corrispondono al `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
> [!NOTE]
>  Quando si usa il carattere jolly asterisco in un' `searchPattern` (ad esempio, "*. txt"), il comportamento corrispondente varia a seconda della lunghezza dell'estensione di file specificato. Oggetto `searchPattern` con un file di estensione di esattamente tre caratteri restituisce i file con un'estensione di tre o più caratteri, in cui i primi tre caratteri corrisponderanno l'estensione di file specificata nel `searchPattern`. Oggetto `searchPattern` con un file di estensione di uno, due o più di tre caratteri restituisce solo i file con estensioni della lunghezza specificata che corrispondono all'estensione di file specificato nella `searchPattern`. Quando si usa il carattere jolly punto interrogativo, questo metodo restituisce solo i file che corrispondono all'estensione di file specificato. Si consideri ad esempio due file in una directory, "file1" e "file1. txtother", un criterio di ricerca di "file?. txt"restituisce solo il primo file, mentre un criterio di ricerca di" file\*. txt "restituisce entrambi i file.  
  
> [!NOTE]
>  Poiché questo metodo controlla quale confrontare i nomi file con il formato del nome di 8.3 file sia il formato del nome file di lunga durata, un criterio di ricerca simile a "* 1\*. txt" potrebbero restituire i nomi di file imprevista. Ad esempio, usando un criterio di ricerca di "\*1\*. txt" restituirà "txt" perché il formato del nome di 8.3 file equivalente sarebbe "longf~1.txt".  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso e per la lettura da file e directory. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory.</param>
        <summary>Restituisce un elenco di file dalla directory corrente che corrisponde al criterio di ricerca specificato e usando un valore per determinare se eseguire la ricerca nelle sottodirectory.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare l'enumerazione dell'insieme di <xref:System.IO.FileInfo> oggetti prima che venga restituita l'intera raccolta.  
  
-   Quando si usa <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può risultare più efficiente.  
  
 Se non sono presenti file nei <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|carattere jolly|Descrizione|  
|------------------------|-----------------|  
|* (asterisco)|Zero o più caratteri.|  
|? (punto interrogativo)|Esattamente uno o nessun carattere.|  
  
 L'ordine dei nomi di file restituito non è garantito. usare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` stringa "*. txt" ricerche per tutti i file i nomi con un'estensione di "txt". Il `searchPattern` stringa "s\*" ricerca per tutti i file i nomi che iniziano con la lettera "s". Se non esistono Nessun file e No negli altri file che corrispondono al `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
> [!NOTE]
>  Quando si usa il carattere jolly asterisco in un' `searchPattern` (ad esempio, "*. txt"), il comportamento corrispondente varia a seconda della lunghezza dell'estensione di file specificato. Oggetto `searchPattern` con un file di estensione di esattamente tre caratteri restituisce i file con un'estensione di tre o più caratteri, in cui i primi tre caratteri corrisponderanno l'estensione di file specificata nel `searchPattern`. Oggetto `searchPattern` con un file di estensione di uno, due o più di tre caratteri restituisce solo i file con estensioni della lunghezza specificata che corrispondono all'estensione di file specificato nella `searchPattern`. Quando si usa il carattere jolly punto interrogativo, questo metodo restituisce solo i file che corrispondono all'estensione di file specificato. Si consideri ad esempio due file in una directory, "file1" e "file1. txtother", un criterio di ricerca di "file?. txt"restituisce solo il primo file, mentre un criterio di ricerca di" file\*. txt "restituisce entrambi i file.  
  
 Nell'elenco seguente viene illustrato il comportamento di lunghezze diverse per il `searchPattern` parametro:  
  
-   "* abc" restituisce i file che presentano of.abc,.abcd,.abcde,.abcdef un'estensione, e così via.  
  
-   * ". abcd" restituisce solo i file con estensione abcd.  
  
-   "*. abcde" restituisce solo i file con estensione ABCDE.  
  
-   * ". abcdef" restituisce solo i file con estensione abcdef.  
  
> [!NOTE]
>  Poiché questo metodo controlla quale confrontare i nomi file con il formato del nome di 8.3 file sia il formato del nome file di lunga durata, un criterio di ricerca simile a "* 1\*. txt" potrebbero restituire i nomi di file imprevista. Ad esempio, usando un criterio di ricerca di "\*1\*. txt" restituirà "txt" perché il formato del nome di 8.3 file equivalente sarebbe "longf~1.txt".  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileInfo> proprietà:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory tramite diverse opzioni di ricerca. Nell'esempio si presuppone una directory con file denominati log1.txt log2.txt, test1.txt, test2.txt, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso e per la lettura da file e directory. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzati che rappresenta i file e le sottodirectory della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di voci <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzate che rappresenta tutti i file e le sottodirectory in una directory.</summary>
        <returns>Matrice di voci <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti file o directory nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota. Questo metodo non è ricorsiva.  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Usare la <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene contato il file e directory nella directory specificata.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory e dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzati che rappresenta i file e le sottodirectory corrispondenti ai criteri di ricerca specificati.</summary>
        <returns>Matrice di oggetti <see langword="FileSystemInfo" /> fortemente tipizzati che corrispondono ai criteri di ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Questo metodo non è ricorsiva.  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Usare la <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` stringa "* t" Cerca tutti i nomi di directory in `path` che terminano con la lettera "t". Il `searchPattern` stringa "s\*" Cerca tutti i nomi di directory in `path` iniziano con la lettera "s".  
  
 La stringa ".." può essere usato solo in `searchPattern` se viene specificato come parte di un nome di directory valido, ad esempio nel nome della directory "un.. b." Non è utilizzabile per spostare verso l'alto della gerarchia di directory. Se non esistono Nessun file o directory, o alcun file o directory che soddisfano il `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene contato i file e directory che corrispondono al criterio di ricerca specificato.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory e dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> che rappresentano i file e le sottodirectory corrispondenti ai criteri di ricerca specificati.</summary>
        <returns>Matrice di voci di file system corrispondenti ai criteri di ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta le espressioni regolari. I seguenti caratteri jolly sono consentiti nelle `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in quella posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Usare la <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 Questo metodo popola preventivamente i valori delle opzioni seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nome e percorso in cui spostare la directory. La destinazione non può essere un altro volume del disco o una directory con lo stesso nome. Può essere una directory esistente in cui si intende aggiungere la directory come sottodirectory.</param>
        <summary>Sposta un'istanza di <see cref="T:System.IO.DirectoryInfo" /> e il relativo contenuto in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera un <xref:System.IO.IOException> se, ad esempio, provare a spostare c:\mydir su c:\public e c:\public esiste già. È necessario specificare "c:\\\public\\\mydir" come il `destDirName` parametro, oppure specificare un nuovo nome di directory, ad esempio "c:\\\newdir".  
  
 Questo metodo consente di spostare una directory in una directory di sola lettura. L'attributo di lettura/scrittura della directory non è interessato.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato lo spostamento di una directory.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destDirName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destDirName" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.IOException">È stato effettuato un tentativo di spostare una directory in un diverso volume.  
  
oppure 
 <paramref name="destDirName" /> esiste già.  
  
oppure 
Non si ha l'autorizzazione di accesso a questo percorso.  
  
oppure 
La directory spostata e la directory di destinazione hanno lo stesso nome.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Non è possibile trovare la directory di destinazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file e directory e per l'accesso alla directory di destinazione. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome di questa istanza di <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <value>Nome della directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò <xref:System.IO.DirectoryInfo.Name%2A> proprietà restituisce solo il nome della directory, ad esempio "Bin". Per ottenere il percorso completo, ad esempio "c:\public\Bin", usare il <xref:System.IO.FileSystemInfo.FullName%2A> proprietà.  
  
 Il <xref:System.IO.DirectoryInfo.Name%2A> proprietà di un <xref:System.IO.DirectoryInfo> non richiede alcuna autorizzazione (oltre l'autorizzazione di lettura nella directory necessari per costruire il <xref:System.IO.DirectoryInfo.Exists%2A>) ma può fornire il nome della directory. Se è necessaria per presentare un <xref:System.IO.DirectoryInfo> in una directory protetta con un nome sicuro a livello di crittografia, creare una directory fittizia per l'uso del codice non attendibile.  
  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome dell'istanza corrente `DirectoryInfo` solo dell'istanza.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory padre di una sottodirectory specificata.</summary>
        <value>Directory padre oppure <see langword="null" /> se il percorso è null o se il percorso del file indica una directory radice (ad esempio "\\", "C", oppure * "\\\server\share").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco delle attività dei / o comuni, vedere [attività dei / o comuni](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il riferimento alla directory padre di una directory specificata.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la parte radice della directory.</summary>
        <value>Oggetto che rappresenta la radice della directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza percorsi radice per la directory specificata.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dal file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Oggetto che descrive una voce dell'elenco di controllo di accesso da applicare alla directory descritta dal parametro <c>path</c>.</param>
        <summary>Applica le voci dell'elenco di controllo di accesso (ACL) descritte da un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> nella directory specificata dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un elenco di controllo di accesso (ACL) descrive i singoli utenti e/o gruppi che hanno o non si dispongono, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Il <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodo voci ACL si applica a un file che rappresenta l'elenco ACL non ereditato.  
  
> [!CAUTION]
>  L'elenco ACL specificato per `directorySecurity` sostituisce l'ACL per la directory esistente. Per aggiungere le autorizzazioni per un nuovo utente, usare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per ottenere l'ACL esistente e modificarlo.  
  
 Il <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodo persiste solo <xref:System.Security.AccessControl.DirectorySecurity> gli oggetti che sono stati modificati dopo la creazione di oggetti.  Se un <xref:System.Security.AccessControl.DirectorySecurity> oggetto non è stato modificato, non essere mantenuto in un file.  Non è pertanto possibile recuperare un <xref:System.Security.AccessControl.DirectorySecurity> dell'oggetto da un file e riapplicare lo stesso oggetto in un altro file.  
  
 Per copiare le informazioni di ACL da un file a un altro:  
  
1.  Usare la <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare il <xref:System.Security.AccessControl.DirectorySecurity> oggetto dal file di origine.  
  
2.  Creare un nuovo <xref:System.Security.AccessControl.DirectorySecurity> oggetto per il file di destinazione.  
  
3.  Usare la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> oppure <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo dell'origine <xref:System.Security.AccessControl.DirectorySecurity> oggetto per recuperare le informazioni di ACL.  
  
4.  Usare la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oppure <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodo per copiare le informazioni recuperate nel passaggio 3 nella destinazione <xref:System.Security.AccessControl.DirectorySecurity> oggetto.  
  
5.  Impostare la destinazione <xref:System.Security.AccessControl.DirectorySecurity> oggetto per il file di destinazione usando il <xref:System.IO.DirectoryInfo.SetAccessControl%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> e <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso di controllo voce di elenco (ACL) da una directory.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="directorySecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Non è stato possibile trovare o modificare il file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il processo corrente non è autorizzato ad accedere per aprire il file.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione enumerare l'elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il percorso originale passato dall'utente.</summary>
        <returns>Restituisce il percorso originale passato dall'utente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>