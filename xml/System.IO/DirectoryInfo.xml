<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b69335aac8e7540a5332afd838259ddeab44204" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299077" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Espone i metodi dell'istanza per la creazione, lo spostamento e l'enumerazione tramite directory e sottodirectory. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.IO.DirectoryInfo> classe per le operazioni tipiche, ad esempio la copia, lo spostamento, ridenominazione, creazione e l'eliminazione di directory.  
  
 Se si intende riutilizzare più volte un oggetto, è consigliabile utilizzare il metodo di istanza <xref:System.IO.DirectoryInfo> anziché i metodi statici corrispondenti del <xref:System.IO.Directory> classe, poiché un controllo di sicurezza non sarà sempre necessario.  
  
> [!NOTE]
>  I membri che accettano un percorso come una stringa di input, che il percorso deve essere corretto o viene generata un'eccezione. Ad esempio, se un percorso completo inizia con uno spazio, il percorso non viene ritagliato in metodi della classe. Pertanto, il percorso sia valido e viene generata un'eccezione. Analogamente, un percorso o una combinazione di percorsi non può essere completo due volte. Ad esempio, "c:\temp c:\windows" genera anche un'eccezione nella maggior parte dei casi. Verificare che i percorsi siano ben formati quando si utilizzano i metodi che accettano una stringa di percorso.  
  
 Nei membri che accettano un percorso, il percorso può fare riferimento a un file o solo una directory. Il percorso specificato può anche fare riferimento a un percorso relativo o un percorso UNC Universal Naming Convention () per un nome di server e la condivisione. Ad esempio, le condizioni seguenti sono percorsi accettabili:  
  
-   "c:\\\MyDir\\\MyFile.txt" in c# o "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "c:\\\MyDir" in c# o "c:\MyDir" in Visual Basic.  
  
-   "MyDir\\\MySubdir" in c# o "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in c#, o "\\\MyServer\MyShare" in Visual Basic.  
  
 Per impostazione predefinita, accesso di lettura/scrittura per le directory nuova viene concesso a tutti gli utenti.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio seguente illustra alcuni membri principali della `DirectoryInfo` classe.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Nell'esempio seguente viene illustrato come copiare una directory e il relativo contenuto.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Stringa che specifica il percorso nel quale creare l'oggetto <see langword="DirectoryInfo" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.DirectoryInfo" /> nel percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non verifica se esiste una directory. Questo costruttore è un segnaposto per una stringa che viene utilizzato per accedere al disco nelle operazioni successive.  
  
 Il `path` parametro può essere un nome di file, incluso un file in una condivisione UNC Universal Naming Convention ().  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e potrebbe provocare un'eccezione generata.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente utilizza questo costruttore per creare la directory e sottodirectory specificata e viene illustrato che è Impossibile eliminare una directory che contiene le sottodirectory.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene caratteri non validi, ad esempio ", &lt;, &gt; o |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura da file e directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la directory esiste già, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene controllato se esiste una directory specificata, crea la directory se non esiste e viene eliminata la directory.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Non è possibile creare la directory.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura di file. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Controllo di accesso da applicare alla directory.</param>
        <summary>Crea una directory usando l'oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per creare una directory con il controllo di accesso, pertanto non c'è alcuna possibilità che può accedere alla directory prima dell'applicazione di protezione.  
  
 Se la directory esiste già, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La directory specificata da <paramref name="path" /> è di sola lettura o non è vuota.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti o contiene uno o più caratteri non validi definiti da <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.NotSupportedException">Si è provato a creare una directory usando solo il carattere due punti (:).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">l'autorizzazione per creare una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una o più sottodirectory nel percorso specificato. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso specificato. Non può essere un volume del disco o un nome UNC (Universal Naming Convention) diverso.</param>
        <summary>Crea una o più sottodirectory nel percorso specificato. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Ultima directory specificata in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutte le directory specificate in `path` vengono creati, a meno che una parte di `path` non è valido. Il `path` parametro specifica un percorso di directory, non un percorso file. Se esiste già nella sottodirectory, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata la creazione di una sottodirectory. In questo esempio, le directory vengono rimossi dopo averlo creato. Pertanto, per testare questo esempio, impostare come commento le righe eliminate nel codice.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non specifica un percorso file valido o contiene caratteri <see langword="DirectoryInfo" /> non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Non è possibile creare la sottodirectory.  - oppure - Un file o directory ha già il nome specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non è autorizzato ad accedere al codice per creare la directory.  - oppure - Il chiamante non ha l'autorizzazione di accesso al codice per leggere la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> restituito.  Questo problema può verificarsi quando il parametro <paramref name="path" /> descrive una directory esistente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carattere due punti (:) che non fa parte di un'etichetta di unità ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Percorso specificato. Non può essere un volume del disco o un nome UNC (Universal Naming Convention) diverso.</param>
        <param name="directorySecurity">Sicurezza da applicare.</param>
        <summary>Crea una o più sottodirectory nel percorso specificato con la sicurezza specificata. Il percorso specificato può essere relativo a questa istanza della classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Ultima directory specificata in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutte le directory specificate in `path` vengono creati, a meno che una parte di `path` non è valido. Il `path` parametro specifica un percorso di directory, non un percorso file. Se esiste già nella sottodirectory, questo metodo non esegue alcuna operazione.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non specifica un percorso file valido o contiene caratteri <see langword="DirectoryInfo" /> non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.IO.IOException">Non è possibile creare la sottodirectory.  - oppure - Un file o directory ha già il nome specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non è autorizzato ad accedere al codice per creare la directory.  - oppure - Il chiamante non ha l'autorizzazione di accesso al codice per leggere la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> restituito.  Questo problema può verificarsi quando il parametro <paramref name="path" /> descrive una directory esistente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carattere due punti (:) che non fa parte di un'etichetta di unità ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un oggetto <see cref="T:System.IO.DirectoryInfo" /> e il relativo contenuto da un percorso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina questo oggetto <see cref="T:System.IO.DirectoryInfo" /> se è vuoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente genera un'eccezione se si tenta di eliminare una directory che non sia vuota.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La directory contiene un file di sola lettura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> non esiste o non è stato possibile trovarla.</exception>
        <exception cref="T:System.IO.IOException">La directory non è vuota.  - oppure - La directory è la directory di lavoro corrente dell'applicazione.  - oppure - C'è un handle aperto sulla directory e il sistema operativo è Windows XP o versione precedente. Questo handle aperto può derivare dall'enumerazione di directory. Per altre informazioni, vedere [Procedura: enumerare directory e file](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura di directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive">
          <see langword="true" /> per eliminare la directory, le rispettive sottodirectory e tutti i file; in caso contrario, <see langword="false" />.</param>
        <summary>Elimina questa istanza di <see cref="T:System.IO.DirectoryInfo" />, specificando se eliminare le subdirectory e i file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `DirectoryInfo` non contiene file o sottodirectory, questo metodo elimina il `DirectoryInfo` anche se `recursive` è `false`. Il tentativo di eliminare un `DirectoryInfo` che non è vuoto quando `recursive` è `false` genera un <xref:System.IO.IOException>.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata l'eliminazione di una directory. Poiché la directory viene rimossa, prima come commento il `Delete` riga per verificare l'esistenza della directory. Quindi rimuovere il commento stessa riga di codice per verificare che la directory è stato rimosso correttamente.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La directory contiene un file di sola lettura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> non esiste o non è stato possibile trovarla.</exception>
        <exception cref="T:System.IO.IOException">La directory è di sola lettura.  - oppure - La directory contiene uno o più file o sottodirectory e <paramref name="recursive" /> è <see langword="false" />.  - oppure - La directory è la directory di lavoro corrente dell'applicazione.  - oppure - C'è un handle aperto sulla directory o su uno dei relativi file e il sistema operativo è Windows XP o versione precedente. Questo handle aperto può derivare dall'enumerazione di directory e file. Per altre informazioni, vedere [Procedura: enumerare directory e file](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Flag di scrittura richiesto per l'autorizzazione di scrittura per il <see langword="DirectoryInfo" /> e le sottodirectory devono essere eliminati.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory nella directory corrente.</summary>
        <returns>Raccolta enumerabile di directory nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.DirectoryInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente enumera le sottodirectory nella directory C:\Program Files e Usa una query LINQ per restituire i nomi di tutte le directory che sono stati creati prima del 2009 controllando il valore di <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> proprietà.  
  
 Se sono necessari solo i nomi delle sottodirectory, utilizzare il metodo statico <xref:System.IO.Directory> classe per ottenere prestazioni migliori. Per un esempio, vedere il <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> metodo.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory che corrisponde a un criterio di ricerca specificato.</summary>
        <returns>Raccolta enumerabile di directory che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.DirectoryInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sulla directory che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di directory che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.DirectoryInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetDirectories%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.DirectoryInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 L'esempio seguente, a partire da una directory specificata, Usa questo metodo e <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> per enumerare i file e le directory all'interno della directory di avvio e visualizzare i dettagli di qualsiasi file oltre 10 MB di dimensioni.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file nella directory corrente.</summary>
        <returns>Raccolta enumerabile dei file nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente enumera i file in una directory specificata e Usa una query LINQ per restituire i nomi di tutti i file che sono stati creati prima del 2009 controllando il valore di <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> proprietà.  
  
 Se è necessario solo i nomi dei file, utilizzare il metodo statico <xref:System.IO.Directory> classe per ottenere prestazioni migliori. Per un esempio, vedere il <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file che corrisponde a un criterio di ricerca.</summary>
        <returns>Raccolta enumerabile di file che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sui file che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di file che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare i file in una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system nella directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system nella directory corrente.</summary>
        <returns>Raccolta enumerabile di informazioni sul file system nella directory corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileSystemInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system che corrisponde a un criterio di ricerca specificato.</summary>
        <returns>Raccolta enumerabile di oggetti di informazione sul file system che corrisponde a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileSystemInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Restituisce una raccolta enumerabile di informazioni sul file system che corrisponde a un criterio di ricerca e all'opzione di ricerca subdirectory specificati.</summary>
        <returns>Raccolta enumerabile di oggetti di informazione sul file system che corrisponde a <paramref name="searchPattern" /> e <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> e <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileSystemInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileSystemInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> può essere più efficiente.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La raccolta restituita non è memorizzato nella cache; ogni chiamata al <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metodo per la raccolta verrà avviata una nuova enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la directory esiste.</summary>
        <value>
          <see langword="true" /> se la directory esiste; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.Exists%2A> restituisce proprietà `false` se si verifica un errore durante il tentativo di determinare se il file specificato esiste. Questo può verificarsi in situazioni che generano eccezioni, ad esempio si passa un nome di file con caratteri non validi o troppi caratteri, un disco mancante o non superato o se il chiamante non dispone dell'autorizzazione per leggere il file.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del `Exists` proprietà nel contesto di copiare una directory di origine in una directory di destinazione.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso completo della directory.</summary>
        <value>Stringa contenente il percorso completo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene le voci dell'elenco di controllo di accesso (ACL) per la directory corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodi per recuperare l'accesso controllano le voci dell'elenco (ACL) per il file corrente.  
  
 Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) per la directory descritta nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le regole di controllo di accesso per la directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.IO.Directory.GetAccessControl%2A> overload del metodo e specificando l'accesso di controllo nelle sezioni <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> in Visual Basic).  
  
 Utilizzare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per il file corrente.  
  
 Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> e <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso controllano voce di elenco (ACL) da una directory.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Non è possibile trovare o modificare la directory.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La directory è di sola lettura.  - oppure - L'operazione non è supportata sulla piattaforma corrente.  - oppure - Il chiamante non ha l'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O durante l'apertura della directory.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione enumerare un elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlSections" /> che specifica il tipo di informazioni relative all'elenco di controllo di accesso (ACL) da ricevere.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula il tipo specificato di voci dell'elenco di controllo di accesso (ACL) per la directory descritta dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> che incapsula le regole di controllo di accesso del file descritto dal parametro <paramref name="path" />.  Eccezioni  <list type="table"><listheader><term> Tipo di eccezione  </term><description> Condizione  </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Non è possibile trovare o modificare la directory.  </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Il processo corrente non ha accesso all'apertura della directory.  </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Si è verificato un errore di I/O durante l'apertura della directory.  </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.  </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> La directory è di sola lettura - oppure - Questa operazione non è supportata nella piattaforma corrente. oppure - Il chiamante non dispone delle autorizzazioni necessarie.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare le voci di elenco (ACL) di controllo di accesso per il file corrente.  
  
 Un ACL descrive singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione enumerare un elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce le sottodirectory della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce le sottodirectory della directory corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.IO.DirectoryInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti sottodirectory, questo metodo restituisce una matrice vuota. Questo metodo non è ricorsiva.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente recupera tutte le directory nella directory radice e visualizza i nomi delle directory.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> non è valido, poiché, ad esempio, si trova su un'unità non connessa.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura delle directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce una matrice di directory nell'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente corrispondente ai criteri di ricerca specificati.</summary>
        <returns>Matrice di tipo <see langword="DirectoryInfo" /> corrispondente a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene contato le directory in un percorso che contengono la lettera specificata.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see langword="DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory.</param>
        <summary>Restituisce una matrice di directory nella classe <see cref="T:System.IO.DirectoryInfo" /> corrente che corrisponde al criterio di ricerca specificato e usando un valore per determinare se eseguire la ricerca nelle sottodirectory.</summary>
        <returns>Matrice di tipo <see langword="DirectoryInfo" /> corrispondente a <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Se non sono presenti sottodirectory o nessuna sottodirectory corrisponde il `searchPattern` parametro, questo metodo restituisce una matrice vuota.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.DirectoryInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente vengono elencate tutte le directory e i file che iniziano con la lettera "c" in "c:\\".  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso incapsulato nell’oggetto <see langword="DirectoryInfo" /> non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un elenco di file della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un elenco di file della directory corrente.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Se non esistono nel file di <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 L'ordine dei nomi di file restituiti non è garantito. Utilizzare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura delle directory. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Restituisce un elenco di file della directory corrente corrispondente al criterio di ricerca specificato.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Se non esistono nel file di <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 I seguenti caratteri jolly sono consentiti nel `searchPattern` parametro.  
  
|Carattere jolly|Descrizione|  
|------------------------|-----------------|  
|*|Zero o più caratteri.|  
|?|Esattamente zero o un carattere.|  
  
 L'ordine dei nomi di file restituiti non è garantito. Utilizzare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` la stringa "*.txt" ricerche per tutti i file con estensione "txt" nomi. Il `searchPattern` stringa "s\*" Cerca tutti i file di nomi che iniziano con la lettera "s". Se non esistono alcun file o no, i file che corrispondono il `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
> [!NOTE]
>  Quando si utilizza il carattere jolly asterisco in un `searchPattern` (ad esempio, "*.txt"), il comportamento corrispondente varia a seconda della lunghezza dell'estensione di file specificato. Oggetto `searchPattern` con un file di estensione di esattamente tre caratteri restituisce i file con un'estensione di tre o più caratteri, dove i primi tre caratteri corrispondono all'estensione di file specificato nella `searchPattern`. Oggetto `searchPattern` con un file di estensione di uno, due o più di tre caratteri restituisce solo i file con estensioni della lunghezza specificata che corrispondono all'estensione di file specificato nella `searchPattern`. Quando si utilizza il carattere jolly punto interrogativo, questo metodo restituisce solo i file che corrispondono all'estensione di file specificato. Si consideri ad esempio due file in una directory, "file1.txt" e "file1. txtother", un criterio di ricerca di "file?. txt"restituisce solo il primo file, mentre un criterio di ricerca di" file\*. txt "restituisce entrambi i file.  
  
> [!NOTE]
>  Poiché questo metodo confrontato con i nomi di file con il formato del nome 8.3 file e il formato del nome file lungo, un criterio di ricerca simile a "* 1\*. txt" può restituire i nomi di file imprevista. Ad esempio, utilizzando un criterio di ricerca di "\*1\*. txt" restituirà "txt" perché il formato del nome 8.3 file equivalente sarebbe "longf~1.txt".  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso e per la lettura da file e directory. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory.</param>
        <summary>Restituisce un elenco di file dalla directory corrente che corrisponde al criterio di ricerca specificato e usando un valore per determinare se eseguire la ricerca nelle sottodirectory.</summary>
        <returns>Matrice di tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> e <xref:System.IO.DirectoryInfo.GetFiles%2A> metodi differiscono nel modo seguente:  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, è possibile avviare la raccolta di enumerazione <xref:System.IO.FileInfo> oggetti prima che venga restituito l'intera raccolta.  
  
-   Quando si utilizza <xref:System.IO.DirectoryInfo.GetFiles%2A>, è necessario attendere che l'intera matrice di <xref:System.IO.FileInfo> oggetti da restituire prima che sia possibile accedere alla matrice.  
  
 Pertanto, quando si lavora con molti file e directory, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> può essere più efficiente.  
  
 Se non esistono nel file di <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Carattere jolly|Descrizione|  
|------------------------|-----------------|  
|* (asterisco)|Zero o più caratteri.|  
|? (punto interrogativo)|Esattamente zero o un carattere.|  
  
 L'ordine dei nomi di file restituiti non è garantito. Utilizzare il <xref:System.Array.Sort%2A> metodo se è necessario un ordinamento specifico.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` la stringa "*.txt" ricerche per tutti i file con estensione "txt" nomi. Il `searchPattern` stringa "s\*" Cerca tutti i file di nomi che iniziano con la lettera "s". Se non esistono alcun file o no, i file che corrispondono il `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
> [!NOTE]
>  Quando si utilizza il carattere jolly asterisco in un `searchPattern` (ad esempio, "*.txt"), il comportamento corrispondente varia a seconda della lunghezza dell'estensione di file specificato. Oggetto `searchPattern` con un file di estensione di esattamente tre caratteri restituisce i file con un'estensione di tre o più caratteri, dove i primi tre caratteri corrispondono all'estensione di file specificato nella `searchPattern`. Oggetto `searchPattern` con un file di estensione di uno, due o più di tre caratteri restituisce solo i file con estensioni della lunghezza specificata che corrispondono all'estensione di file specificato nella `searchPattern`. Quando si utilizza il carattere jolly punto interrogativo, questo metodo restituisce solo i file che corrispondono all'estensione di file specificato. Si consideri ad esempio due file in una directory, "file1.txt" e "file1. txtother", un criterio di ricerca di "file?. txt"restituisce solo il primo file, mentre un criterio di ricerca di" file\*. txt "restituisce entrambi i file.  
  
 Nell'elenco seguente viene illustrato il comportamento di lunghezze diverse per il `searchPattern` parametro:  
  
-   "* abc" restituisce i file con un'estensione of.abc,.abcd,.abcde,.abcdef, e così via.  
  
-   * ". abcd" restituisce solo i file con estensione abcd.  
  
-   "*. abcde" restituisce solo i file con estensione ABCDE.  
  
-   * ". abcdef" restituisce solo i file con estensione abcdef.  
  
> [!NOTE]
>  Poiché questo metodo confrontato con i nomi di file con il formato del nome 8.3 file e il formato del nome file lungo, un criterio di ricerca simile a "* 1\*. txt" può restituire i nomi di file imprevista. Ad esempio, utilizzando un criterio di ricerca di "\*1\*. txt" restituirà "txt" perché il formato del nome 8.3 file equivalente sarebbe "longf~1.txt".  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileInfo> proprietà:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere un elenco di file da una directory con diverse opzioni di ricerca. Nell'esempio si presuppone una directory con i file denominati log1.txt, log2.txt, Test1, test2, test3. txt e una sottodirectory con un file denominato SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso e per la lettura da file e directory. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzati che rappresenta i file e le sottodirectory della directory corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di voci <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzate che rappresenta tutti i file e le sottodirectory in una directory.</summary>
        <returns>Matrice di voci <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non esistono file o directory di <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota. Questo metodo non è ricorsiva.  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Utilizzare il <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente viene contato il file e directory nella directory specificata.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory e dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> fortemente tipizzati che rappresenta i file e le sottodirectory corrispondenti ai criteri di ricerca specificati.</summary>
        <returns>Matrice di oggetti <see langword="FileSystemInfo" /> fortemente tipizzati che corrispondono ai criteri di ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Questo metodo non è ricorsiva.  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Utilizzare il <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 I caratteri jolly sono consentiti. Ad esempio, il `searchPattern` stringa "* t" Cerca tutti i nomi di directory in `path` che terminano con la lettera "t". Il `searchPattern` stringa "s\*" Cerca tutti i nomi di directory in `path` iniziano con la lettera "s".  
  
 La stringa "..." può essere utilizzato solo `searchPattern` se viene specificato come parte di un nome di directory valido, ad esempio nel nome della directory "un.. b." Non può essere utilizzato per spostare in alto della gerarchia di directory. Se non esistono alcun file o directory, o nessun file o directory che corrispondono il `searchPattern` stringa nel <xref:System.IO.DirectoryInfo>, questo metodo restituisce una matrice vuota.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Nell'esempio seguente conta i file e directory che corrispondono al criterio di ricerca specificato.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido, ad esempio si trova in un'unità non mappata.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Stringa di ricerca in base alla quale confrontare i nomi delle directory e dei file.  Questo parametro può contenere una combinazione di caratteri del percorso letterale e caratteri jolly (* e ?) validi, ma non supporta le espressioni regolari.</param>
        <param name="searchOption">Uno dei valori di enumerazione che specifica se l'operazione di ricerca deve includere solo la directory corrente o tutte le sottodirectory. Il valore predefinito è <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Recupera una matrice di oggetti <see cref="T:System.IO.FileSystemInfo" /> che rappresentano i file e le sottodirectory corrispondenti ai criteri di ricerca specificati.</summary>
        <returns>Matrice di voci di file system corrispondenti ai criteri di ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` può essere una combinazione di caratteri letterali e caratteri jolly, ma non supporta espressioni regolari. I seguenti caratteri jolly sono consentiti `searchPattern`.  
  
|Identificatore con caratteri jolly|Corrispondenze|  
|------------------------|-------------|  
|* (asterisco)|Zero o più caratteri in tale posizione.|  
|? (punto interrogativo)|Zero o un carattere in tale posizione.|  
  
 I caratteri diversi dal carattere jolly sono caratteri letterali. Ad esempio, la stringa "* t" Cerca tutti i nomi che terminano con la lettera "t". ". Il `searchPattern` stringa "s\*" Cerca tutti i nomi in `path` iniziano con la lettera "s".  
  
 Per le sottodirectory, il <xref:System.IO.FileSystemInfo> possono eseguire il cast di oggetti restituiti da questo metodo alla classe derivata <xref:System.IO.DirectoryInfo>. Utilizzare il <xref:System.IO.FileAttributes> valore restituito dal <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.IO.FileSystemInfo> rappresenta un file o una directory.  
  
 Questo metodo pre-popola i valori dei seguenti <xref:System.IO.FileSystemInfo> proprietà:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contiene uno o più caratteri non validi definiti dal metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> non è un valore valido di <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso specificato non è valido (ad esempio, si trova in un'unità non mappata).</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nome e percorso in cui spostare la directory. La destinazione non può essere un altro volume del disco o una directory con lo stesso nome. Può essere una directory esistente in cui si intende aggiungere la directory come sottodirectory.</param>
        <summary>Sposta un'istanza di <see cref="T:System.IO.DirectoryInfo" /> e il relativo contenuto in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera un <xref:System.IO.IOException> se, ad esempio, si tenta di spostare c:\mydir in c:\public e c:\public esiste già. È necessario specificare "c:\\\public\\\mydir" come il `destDirName` parametro, o specificare un nuovo nome di directory, ad esempio "c:\\\newdir".  
  
 Questo metodo consente di spostare una directory in una directory di sola lettura. L'attributo di lettura/scrittura della directory non è interessato.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato lo spostamento di una directory.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destDirName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destDirName" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.IOException">È stato effettuato un tentativo di spostare una directory in un diverso volume.  - oppure - <paramref name="destDirName" /> esiste già.  - oppure - Non si ha l'autorizzazione di accesso a questo percorso.  - oppure - La directory spostata e la directory di destinazione hanno lo stesso nome.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Non è possibile trovare la directory di destinazione.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file e directory e per l'accesso alla directory di destinazione. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome di questa istanza di <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <value>Nome della directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo <xref:System.IO.DirectoryInfo.Name%2A> proprietà restituisce solo il nome della directory, ad esempio "Bin". Per ottenere il percorso completo, ad esempio "c:\public\Bin", usare il <xref:System.IO.FileSystemInfo.FullName%2A> proprietà.  
  
 Il <xref:System.IO.DirectoryInfo.Name%2A> proprietà di un <xref:System.IO.DirectoryInfo> non richiede permessi (oltre l'autorizzazione di lettura alla directory necessari per costruire il <xref:System.IO.DirectoryInfo.Exists%2A>) ma può fornire il nome della directory. Se è necessario passare un <xref:System.IO.DirectoryInfo> a una directory protetta con un nome crittograficamente sicuro, creare una directory fittizia per l'utilizzo del codice non attendibile.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome dell'oggetto corrente `DirectoryInfo` solo l'istanza.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory padre di una sottodirectory specificata.</summary>
        <value>La directory padre, o <see langword="null" /> se il percorso è null o se il percorso del file indica una directory radice (ad esempio "\\", "C:" oppure * "\\\server\share").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il riferimento alla directory padre di una directory specificata.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la parte radice della directory.</summary>
        <value>Oggetto che rappresenta la radice della directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente mostra i percorsi principali per la directory specificata.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di file e directory e per l'accesso al percorso. Enumerazioni associate: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Oggetto che descrive una voce dell'elenco di controllo di accesso da applicare alla directory descritta dal parametro <c>path</c>.</param>
        <summary>Applica le voci dell'elenco di controllo di accesso (ACL) descritte da un oggetto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> nella directory specificata dall'oggetto <see cref="T:System.IO.DirectoryInfo" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un elenco di controllo di accesso (ACL) descrive i singoli utenti o gruppi che dispongono o non si dispone, diritti per azioni specifiche su un determinato file o directory. Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Il <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodo applica le voci dell'elenco ACL in un file che rappresenta l'elenco ACL non ereditato.  
  
> [!CAUTION]
>  L'ACL specificato per `directorySecurity` sostituisce l'ACL per la directory esistente. Per aggiungere autorizzazioni per un nuovo utente, utilizzare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> per ottenere l'ACL esistente e modificarlo.  
  
 Il <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodo persiste solo <xref:System.Security.AccessControl.DirectorySecurity> oggetti che sono stati modificati dopo la creazione dell'oggetto.  Se un <xref:System.Security.AccessControl.DirectorySecurity> oggetto non è stato modificato, non verranno resi persistenti in un file.  Pertanto, non è possibile recuperare un <xref:System.Security.AccessControl.DirectorySecurity> dell'oggetto da un file e applicare di nuovo lo stesso oggetto in un altro file.  
  
 Copiare informazioni ACL da un file a un'altra:  
  
1.  Utilizzare il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodo per recuperare il <xref:System.Security.AccessControl.DirectorySecurity> oggetto dal file di origine.  
  
2.  Creare un nuovo <xref:System.Security.AccessControl.DirectorySecurity> oggetto per il file di destinazione.  
  
3.  Utilizzare il <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo dell'origine <xref:System.Security.AccessControl.DirectorySecurity> oggetto per recuperare le informazioni di ACL.  
  
4.  Utilizzare il <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodo per copiare le informazioni recuperate nel passaggio 3 nella destinazione <xref:System.Security.AccessControl.DirectorySecurity> oggetto.  
  
5.  Impostare la destinazione <xref:System.Security.AccessControl.DirectorySecurity> oggetto al file di destinazione mediante la <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.DirectoryInfo.GetAccessControl%2A> e <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metodi per aggiungere e rimuovere un accesso controllano voce di elenco (ACL) da una directory.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="directorySecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Non è stato possibile trovare o modificare il file.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il processo corrente non è autorizzato ad accedere per aprire il file.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Microsoft Windows 2000 o versioni successive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'autorizzazione enumerare l'elenco di controllo di accesso (ACL) per una directory. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il percorso originale passato dall'utente.</summary>
        <returns>Restituisce il percorso originale passato dall'utente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>