<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10cab9d5d130cd5e31ba2f2a3417bc5bac002972" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37652568" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Listens to the file system change notifications and raises events when a directory, or file in a directory, changes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.IO.FileSystemWatcher> controllare le modifiche in una directory specificata. È possibile controllare le modifiche nei file e le sottodirectory della directory specificata. È possibile creare un componente per controllare i file in un computer locale, un'unità di rete o un computer remoto.  
  
 Per controllare le modifiche in tutti i file, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà in una stringa vuota ("") o usare caratteri jolly ("*.\*"). Per guardare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà sul nome di file. Ad esempio, per controllare le modifiche apportate al file MyDoc, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "MyDoc". È anche possibile guardare le modifiche in un determinato tipo di file. Ad esempio, per controllare le modifiche nei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "\*. txt".  
  
 Esistono diversi tipi di modifiche per cui è possibile guardare in un file o directory. Ad esempio, è possibile controllare le modifiche apportate `Attributes`, il `LastWrite` data e ora, o il `Size` di file o directory. Questa operazione viene eseguita impostando il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> una delle proprietà il <xref:System.IO.NotifyFilters> valori. Per altre informazioni sul tipo di modifiche è possibile guardare, vedere <xref:System.IO.NotifyFilters>.  
  
 È possibile guardare la ridenominazione, eliminazione o la creazione di file o directory. Ad esempio, per controllare la ridenominazione dei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "*. txt" e chiamare il <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> metodo con un <xref:System.IO.WatcherChangeTypes.Renamed> specificato per il parametro.  
  
 Il sistema operativo Windows invia una notifica di modifiche ai file in un buffer creati dal componente di <xref:System.IO.FileSystemWatcher>. Se sono presenti numerose modifiche in un breve periodo di tempo, il buffer potrà verificarsi un overflow. In questo modo il componente non terrà traccia delle modifiche nella directory, e si limiterà a fornire la notifica di copertura. Aumento delle dimensioni del buffer con il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà è dispendiosa, perché proviene da memoria non di paging che non è possibile eseguire lo swapping su disco, in modo che il buffer di piccole dimensioni ma grandi dimensioni sufficienti per non perdere tutti i file degli eventi di modifica. Per evitare un sovraccarico del buffer, usare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica delle proprietà in modo che è possibile filtrare i indesiderati.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.IO.FileSystemWatcher>, vedere il <xref:System.IO.FileSystemWatcher.%23ctor%2A> costruttore.  
  
 Si noti quanto segue quando si usa il <xref:System.IO.FileSystemWatcher> classe.  
  
-   I file nascosti non vengono ignorati.  
  
-   In alcuni sistemi, <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file usando il formato del nome di 8.3 file brevi. Ad esempio, è stato possibile segnalare una modifica a "Longfilename" come "LONGFI ~. LON".  
  
-   Questa classe contiene una richiesta di collegamento e una richiesta di ereditarietà a livello di classe che si applica a tutti i membri. Oggetto <xref:System.Security.SecurityException> viene generata quando il chiamante immediato o la classe derivata non dispone dell'autorizzazione di attendibilità. Per informazioni dettagliate sui requisiti di sicurezza, vedere [richieste di collegamento](~/docs/framework/misc/link-demands.md).  
  
-   La dimensione massima è possibile impostare per il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà per il monitoraggio di una directory in rete è di 64 KB.  
  
> [!NOTE]
>  Esecuzione <xref:System.IO.FileSystemWatcher> in Windows 98 non è supportato.  
  
## <a name="copying-and-moving-folders"></a>Copiare e spostare cartelle  
 Il sistema operativo e <xref:System.IO.FileSystemWatcher> oggetto interpretare una Taglia e Incolla o un'operazione di spostamento come azione di ridenominazione per una cartella e il relativo contenuto. Se si taglia e Incolla di una cartella con i file in una cartella controllata, la <xref:System.IO.FileSystemWatcher> oggetto prestazione solo la cartella come nuovo, ma non il relativo contenuto in quanto sono essenzialmente solo rinominati.  
  
 Per essere notificato che il contenuto delle cartelle è stato spostato o copiato in una cartella controllata, fornire <xref:System.IO.FileSystemWatcher.OnChanged%2A> e <xref:System.IO.FileSystemWatcher.OnRenamed%2A> metodi del gestore eventi come indicato nella tabella seguente.  
  
|Gestore dell'evento|Eventi gestiti|Esegue|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Segnalare le modifiche in attributi di file, i file creati e i file eliminati.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Elencare i percorsi vecchi e nuovi di rinominati i file e cartelle mediante l'espansione ricorsiva se necessario.|  
  
## <a name="events-and-buffer-sizes"></a>Dimensioni Buffer e gli eventi  
 Si noti che alcuni fattori possono influenzare gli eventi di modifica del file system vengono generati, come descritto nel modo seguente:  
  
-   Operazioni comuni del file system potrebbero generare più di un evento. Ad esempio, quando un file viene spostato da una directory a un'altra, diversi <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcune <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> vengano generati eventi. Lo spostamento di che un file è un'operazione complessa costituito da più operazioni semplici, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
-   Il <xref:System.IO.FileSystemWatcher> può controllare i dischi finché non vengono passati o rimosso. Il <xref:System.IO.FileSystemWatcher> non genera eventi per CD e DVD, perché non è possibile modificare proprietà e i timbri data / ora. Nei computer remoti deve essere una delle piattaforme necessari installate per il componente funzioni correttamente.  
  
-   Se più <xref:System.IO.FileSystemWatcher> oggetti vengono monitorato lo stesso percorso UNC in Windows XP precedenti al Service Pack 1 o Windows 2000 SP2 o versioni precedenti, solo uno degli oggetti genera un evento. Nei computer che eseguono Windows XP SP1 e versioni successive, Windows 2000 SP3 o versioni successive o Windows Server 2003, tutti <xref:System.IO.FileSystemWatcher> oggetti genererà gli eventi appropriati.  
  
 Si noti che un <xref:System.IO.FileSystemWatcher> potrebbe non essere un evento quando viene superata la dimensione del buffer. Per evitare la perdita di eventi, seguire queste linee guida:  
  
-   Aumentare le dimensioni del buffer, impostando il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
-   Evitare il controllo di file con nomi lunghi, poiché un nome di file lungo contribuisce all'esaurimento dello spazio nel buffer. Prendere in considerazione la ridenominazione di questi file usando nomi più brevi.  
  
-   Mantenere il codice più corte possibili di gestione degli eventi.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente viene impostato per controllare le modifiche nei `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando un file viene rinominato, il vecchio e nuovo percorso di stampa nella console.  
  
 Usare la <xref:System.Diagnostics> e <xref:System.IO> spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">per la derivazione da di <see cref="T:System.Diagnostics.ProcessStartInfo" /> classe. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Set di autorizzazioni denominati: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer Windows NT 4.0 remoto da un computer Windows NT 4.0.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.IO.FileSystemWatcher>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinazione bit per bit dei `LastWrite`, `FileName`, e `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Controlla tutti i file.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|una stringa vuota ("")|  
  
> [!NOTE]
>  Il componente non lo guarderanno fino alla directory specificata di <xref:System.IO.FileSystemWatcher.Path%2A> è impostato, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> oggetto da controllare la directory specificata in fase di esecuzione. Il <xref:System.IO.FileSystemWatcher> verifica la presenza di modifiche nell'oggetto `LastWrite` e `LastAccess` orari e per la creazione, eliminazione o ridenominazione di testo file nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene visualizzato nella console. Quando viene rinominato un file, i percorsi di vecchi e nuovi visualizzano nella console.  
  
 Questo esempio Usa la <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory to monitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il componente non lo guarderanno fino alla directory specificata di <xref:System.IO.FileSystemWatcher.Path%2A> è impostato, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il componente può controllare i file nel computer personale, un'unità di rete o un computer remoto.  
  
 Non è possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer Windows NT 4.0 remoto da un computer Windows NT 4.0. Il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà è impostata per impostazione predefinita per il controllo di tutti i file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is an empty string ("").  -or-  The path specified through the <paramref name="path" /> parameter does not exist.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> is too long.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</param>
        <param name="filter">The type of files to watch. For example, "*.txt" watches for changes to all text files.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory and type of files to monitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il componente non lo guarderanno fino alla directory specificata di <xref:System.IO.FileSystemWatcher.Path%2A> è impostato, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il componente può controllare i file nel computer personale, un'unità di rete o un computer remoto.  
  
 Non è possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer Windows NT 4.0 remoto da un computer Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.  -or-  The <paramref name="filter" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is an empty string ("").  -or-  The path specified through the <paramref name="path" /> parameter does not exist.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> is too long.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente Usa questo metodo per avviare l'inizializzazione di un componente usato in un form o da un altro componente. Il <xref:System.IO.FileSystemWatcher.EndInit%2A> metodo termina l'inizializzazione. Usando il <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato quando vengono apportate modifiche alle dimensioni, attributi di sistema, dell'ultima scrittura ora, ora dell'ultimo accesso o le autorizzazioni di sicurezza di un file o directory nella directory da monitorare.  
  
> [!NOTE]
>  Operazioni comuni del file system potrebbero generare più di un evento. Ad esempio, quando un file viene spostato da una directory a un'altra, diversi <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcune <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> vengano generati eventi. Lo spostamento di che un file è un'operazione complessa costituito da più operazioni semplici, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
 Usare <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> per limitare il numero di notifiche generate quando questo evento viene gestito.  
  
> [!NOTE]
>  Il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato in modo imprevisto quando un file viene rinominato, ma non viene generato quando una directory viene rinominata. Per controllare la ridenominazione, usare il <xref:System.IO.FileSystemWatcher.Renamed> evento.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non `null`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Changed> evento per visualizzare il percorso del file di console ogni volta che viene modificato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma questi causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory a cui è stato copiato il file, se tale directory viene controllata. Se è stata controllata da un'altra istanza di directory da cui è stato copiato <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, si crea due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your documenti". Se si copia un file da "My Documents" in "Altri documenti", un <xref:System.IO.FileSystemWatcher.Created> verrà generato l'evento FileSystemWatcher2, ma per FileSystemWatcher1 viene generato alcun evento. A differenza della copia, lo spostamento di un file o directory genererebbe due eventi. Nell'esempio precedente, se si sposta un file da "My Documents" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
> [!NOTE]
>  Operazioni comuni del file system potrebbero generare più di un evento. Ad esempio, quando un file viene spostato da una directory a un'altra, diversi <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcune <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> vengano generati eventi. Lo spostamento di che un file è un'operazione complessa costituito da più operazioni semplici, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Created> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non `null`.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento viene generato appena viene creato un file. Se un file viene copiato o trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguita da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> gli eventi.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Created> evento per visualizzare il percorso del file di console ogni volta che viene creato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma questi causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory a cui è stato copiato il file, se tale directory viene controllata. Se è stata controllata da un'altra istanza di directory da cui è stato copiato <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, si crea due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your documenti". Se si copia un file da "My Documents" in "Altri documenti", un <xref:System.IO.FileSystemWatcher.Created> verrà generato l'evento FileSystemWatcher2, ma per FileSystemWatcher1 viene generato alcun evento. A differenza della copia, lo spostamento di un file o directory genererebbe due eventi. Nell'esempio precedente, se si sposta un file da "My Documents" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
> [!NOTE]
>  Operazioni comuni del file system potrebbero generare più di un evento. Ad esempio, quando un file viene spostato da una directory a un'altra, diversi <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcune <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> vengano generati eventi. Lo spostamento di che un file è un'operazione complessa costituito da più operazioni semplici, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Deleted> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non `null`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Deleted> evento per visualizzare il percorso del file di console ogni volta che viene eliminato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.FileSystemWatcher" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico <xref:System.ComponentModel.Component.Dispose%2A> metodo e <xref:System.Object.Finalize%2A> (metodo). <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.FileSystemWatcher.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.FileSystemWatcher.Dispose%2A> con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.Compression.DeflateStream> fa riferimento. Il metodo richiama il metodo <xref:System.ComponentModel.Component.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see cref="M:System.ComponentModel.Component.Dispose" />. Per altre informazioni su come implementare <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, vedere [che implementa un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per altre informazioni sulle <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the component is enabled.</summary>
        <value>
          <see langword="true" /> se il componente è abilitato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />. Se si usa il componente in una finestra di progettazione [! INCLUDE[vsprvslong](~/Includes/vsprvslong-MD.MD)], il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il componente non genererà gli eventi a meno che non si imposta <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> a `true`.  
  
> [!NOTE]
>  Il componente non lo guarderanno fino alla directory specificata di <xref:System.IO.FileSystemWatcher.Path%2A> proprietà è stata impostata e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> consente ai gestori di eventi da richiamare per rispondere alle modifiche al file anche se questa proprietà è impostata su `false`.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente viene impostato per controllare le modifiche nei `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando un file viene rinominato, il vecchio e nuovo percorso di stampa nella console.  
  
 Usare la <xref:System.Diagnostics> e <xref:System.IO> spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.FileSystemWatcher" /> object has been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current operating system is not Microsoft Windows NT or later.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The directory specified in <see cref="P:System.IO.FileSystemWatcher.Path" /> could not be found.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> has not been set or is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente utilizza questo metodo per terminare l'inizializzazione di un componente usato in un form o da un altro componente. Il <xref:System.IO.FileSystemWatcher.BeginInit%2A> metodo avvia l'inizializzazione. Usando il <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the instance of <see cref="T:System.IO.FileSystemWatcher" /> is unable to continue monitoring changes or when the internal buffer overflows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato ogni volta che un elemento impedisce il <xref:System.IO.FileSystemWatcher> oggetto dal monitoraggio delle modifiche. Ad esempio, se l'oggetto esegue il monitoraggio delle modifiche in una directory remota e la connessione a tale directory viene persa, il <xref:System.IO.FileSystemWatcher.Error> viene generato l'evento.  
  
 Il sistema invia una notifica di modifiche ai file, e archivia tali modifiche in un buffer che il componente crea e passa per le API. Se sono presenti numerose modifiche in un breve periodo di tempo, il buffer potrà verificarsi un overflow. In questo modo il componente non terrà traccia delle modifiche nella directory, e si limiterà a fornire la notifica di copertura. Aumento delle dimensioni del buffer è costoso, perché proviene da non di paging della memoria che non può essere lo swapping su disco, in questo caso tenere il buffer più piccolo possibile. Per evitare un sovraccarico del buffer, usare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica delle proprietà per filtrare le indesiderati.  
  
> [!NOTE]
>  Operazioni comuni del file system potrebbero generare più di un evento. Ad esempio, quando un file viene spostato da una directory a un'altra, diversi <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcune <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> vengano generati eventi. Lo spostamento di che un file è un'operazione complessa costituito da più operazioni semplici, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the filter string used to determine what files are monitored in a directory.</summary>
        <value>Stringa di filtro. Il valore predefinito è "*. \*"(Controlla tutti i file.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare le modifiche in tutti i file, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà in una stringa vuota (""). Per guardare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà sul nome di file. Ad esempio, per controllare le modifiche apportate al file MyDoc, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "MyDoc". È anche possibile guardare le modifiche in un determinato tipo di file. Ad esempio, per controllare le modifiche nei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "*. txt". Uso di più filtri, ad esempio "\*. txt&#124;\*doc" non è supportato.  
  
 Il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà può essere modificata dopo la <xref:System.IO.FileSystemWatcher> oggetto ha avviato la ricezione di eventi.  
  
 Per altre informazioni sull'applicazione di filtri alle notifiche, vedere la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> accetta i caratteri jolly per i file corrispondenti, come illustrato negli esempi seguenti.  
  
|Stringa di filtro|Controlla che i file seguenti|  
|-------------------|---------------------------------|  
|*.\*|Tutti i file (impostazione predefinita). Una stringa vuota ("") controlla anche che tutti i file.|  
|*.txt|Tutti i file con estensione "txt".|  
|*recipe.doc|Tutti i file che terminano con "ricetta" con l'estensione "doc".|  
|win*.xml|Tutti i file che iniziano con "win" con un'estensione "xml".|  
|Vendite * 200?. con estensione xls|Corrisponde a quanto segue:<br /><br /> Vendite di luglio 2001.xlsSales Aug 2002.xlsSales marzo 2004.xls<br /><br /> ma non corrisponde a:<br /><br /> 1999.xls Nov vendite|  
|MyReport.Doc|Verifica la presenza solo MyReport|  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente viene impostato per controllare le modifiche nei `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando un file viene rinominato, il vecchio e nuovo percorso di stampa nella console.  
  
 Usare la <xref:System.Diagnostics> e <xref:System.IO> spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether subdirectories within the specified path should be monitored.</summary>
        <value>
          <see langword="true" /> per monitorare le sottodirectory; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> al `true` quando si desidera controllare le notifiche di modifica per i file e directory contenute all'interno della directory specificata tramite il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà e nelle relative sottodirectory. Impostando il <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> proprietà `false` contribuisce a ridurre il numero di notifiche inviate al buffer interno. Per altre informazioni sull'applicazione di filtri alle notifiche, vedere la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
 Quando `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> è ricorsiva tramite il sottoalbero intero, non solo le directory figlio immediati. Restituisce il percorso relativo a un file o directory all'interno della sottostruttura ad albero nel <xref:System.IO.FileSystemEventArgs.Name%2A> proprietà di <xref:System.IO.FileSystemEventArgs> e il <xref:System.IO.RenamedEventArgs.OldName%2A> proprietà della <xref:System.IO.RenamedEventArgs>, a seconda che si stanno controllando le modifiche. È possibile ottenere il percorso completo dal <xref:System.IO.FileSystemEventArgs.FullPath%2A> proprietà di <xref:System.IO.FileSystemEventArgs> e il <xref:System.IO.RenamedEventArgs.OldFullPath%2A> proprietà della <xref:System.IO.RenamedEventArgs>, a seconda le modifiche che si stanno controllando.  
  
 Se viene creata una directory nella sottostruttura della directory che si sta controllando, e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> è `true`, verrà controllata automaticamente tale directory.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the size (in bytes) of the internal buffer.</summary>
        <value>Dimensioni del buffer interno in byte. L'impostazione predefinita è 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile impostare il buffer a 4 KB o superiori, ma non deve superare 64 KB. Se si prova a impostare il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> a meno di 4096 byte, il valore vengono ignorati e il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> è impostata su 4096 byte. Per prestazioni ottimali, usare un multiplo di 4 KB nei computer basati su Intel.  
  
 Il sistema di notifica al componente di modifiche ai file, e archivia tali modifiche in un buffer, il componente crea e passa per le API. Ogni evento può usare fino a 16 byte di memoria, senza includere il nome del file. Se sono presenti numerose modifiche in un breve periodo di tempo, il buffer potrà verificarsi un overflow. In questo modo il componente non terrà traccia delle modifiche nella directory, e si limiterà a fornire la notifica di copertura. Aumento delle dimensioni del buffer può impedire mancanti del sistema di file degli eventi di modifica. Tuttavia, l'aumento delle dimensioni del buffer è costoso, perché proviene da memoria non di paging che non è possibile eseguire lo swapping su disco, pertanto, mantenere il buffer più piccoli possibile. Per evitare un sovraccarico del buffer, usare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica delle proprietà per filtrare le indesiderati.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of changes to watch for.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.NotifyFilters" />. Il valore predefinito è la combinazione OR bit per bit di <see langword="LastWrite" />, <see langword="FileName" /> e <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile combinare i membri del <xref:System.IO.NotifyFilters> enumerazione per il controllo più di un tipo di modifica alla volta. Ad esempio, è possibile guardare le modifiche nella dimensione di un file e le modifiche apportate il `LastWrite` ora. Questo genera un evento ogni volta che viene apportata una modifica nelle dimensioni del file o cartella oppure una modifica nel `LastWrite` ora del file o della cartella.  
  
 Questo è un modo per filtrare le notifiche non desiderate. Per altre informazioni sull'applicazione di filtri alle notifiche, vedere la <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente viene impostato per controllare le modifiche nei `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando un file viene rinominato, il vecchio e nuovo percorso di stampa nella console.  
  
 Usare la <xref:System.Diagnostics> e <xref:System.IO> spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is not a valid bitwise OR combination of the <see cref="T:System.IO.NotifyFilters" /> values.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value that is being set is not valid.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Changed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> viene chiamato quando vengono apportate modifiche alla dimensione, attributi di sistema, ora dell'ultima scrittura, ora dell'ultimo accesso o le autorizzazioni di sicurezza di un file o directory nella directory da monitorare.  
  
 Usare la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> proprietà per limitare il numero di eventi di eccezione generata quando il <xref:System.IO.FileSystemWatcher.Changed> viene gestito l'evento.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento viene generato appena viene creato un file. Se un file viene copiato o trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguita da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> gli eventi.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> (metodo).</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Created" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> viene chiamato quando viene creato un file o directory nella directory da monitorare.  
  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma questi causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory a cui è stato copiato il file, se tale directory viene controllata. Se è stata controllata da un'altra istanza di directory da cui è stato copiato <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, si crea due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your documenti". Se si copia un file da "My Documents" e incollare il codice in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> verrà generato l'evento in FileSystemWatcher2, ma per FileSystemWatcher1 viene generato alcun evento. A differenza della copia, lo spostamento di un file o directory genera due eventi. Nell'esempio precedente, se si sposta un file da "My Documents" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> essere generato un evento in FileSystemWatcher2 e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento viene generato appena viene creato un file. Se un file viene copiato o trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguita da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> gli eventi.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> (metodo).</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Deleted" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> viene chiamato quando viene eliminato un file o directory, all'interno della directory da monitorare.  
  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma questi causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory a cui è stato copiato il file, se tale directory viene controllata. Se è stata controllata da un'altra istanza di directory da cui è stato copiato <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, si crea due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your documenti". Se si copia un file da "My Documents" in "Altri documenti", un <xref:System.IO.FileSystemWatcher.Created> verrà generato l'evento FileSystemWatcher2, ma per FileSystemWatcher1 viene generato alcun evento. A differenza della copia, lo spostamento di un file o directory genera due eventi. Nell'esempio precedente, se si sposta un file da "My Documents" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> (metodo).</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.IO.ErrorEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Error" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> viene chiamato quando si verifica un errore.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> (metodo).</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.RenamedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Renamed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> viene chiamato quando viene rinominato un file o una directory all'interno della directory da monitorare. Relativo <xref:System.IO.RenamedEventArgs> argomento contiene informazioni sull'operazione di ridenominazione, ad esempio il tipo di modifica, il vecchio e nuovo percorso e il nome di vecchio e nuovo. Si noti che relativo <xref:System.IO.FileSystemEventArgs.Name> può essere null per la proprietà degli eventi rinominati se il <xref:System.IO.FileSystemWatcher> non ottenere corrispondenza eventi vecchi e nuovi nome dal sistema operativo. 
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per altre informazioni, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> (metodo).</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the path of the directory to watch.</summary>
        <value>Percorso da monitorare. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un percorso completo di una directory. Se il <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> è di proprietà `true`, questa directory è la radice in corrispondenza del quale il sistema verifica la presenza di modifiche; in caso contrario, si tratta della directory sola controllata. Per guardare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà nella directory completa e corretta e il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà sul nome di file.  
  
 Il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà supporta i percorsi UNC (Universal Naming Convention).  
  
> [!NOTE]
>  Questa proprietà deve essere impostata prima che il componente è possibile controllare le modifiche.  
  
 Quando si rinomina una directory, il <xref:System.IO.FileSystemWatcher> automaticamente Ricollega stesso all'elemento appena rinominata. Ad esempio, se si imposta il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà su "C:\My Documents" e quindi rinominare manualmente la directory "C:\Your documenti", il componente rimane in ascolto per le notifiche di modifica alla directory appena rinominata. Tuttavia, quando si richiede il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà contiene il percorso precedente. Ciò accade perché il componente determina la directory da controllare in base l'handle, anziché il nome della directory. La ridenominazione non influenza l'handle. Pertanto, se si elimina il componente e quindi ricrearlo senza l'aggiornamento di <xref:System.IO.FileSystemWatcher.Path%2A> proprietà, l'applicazione avrà esito negativo perché la directory non esiste più.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente viene impostato per controllare le modifiche nei `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando un file viene rinominato, il vecchio e nuovo percorso di stampa nella console.  
  
 Usare la <xref:System.Diagnostics> e <xref:System.IO> spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified path does not exist or could not be found.  -or-  The specified path contains wildcard characters.  -or-  The specified path contains invalid path characters.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is renamed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Renamed` evento è un <xref:System.IO.RenamedEventHandler> delegato con la firma seguente:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Il <xref:System.IO.RenamedEventArgs> oggetto fornisce informazioni sull'operazione di ridenominazione, ad esempio il tipo di ridenominazione (il <xref:System.IO.FileSystemEventArgs.ChangeType> proprietà), il vecchio e nuovo nome e il percorso di vecchio e nuovo. Si noti che il <xref:System.IO.FileSystemEventArgs.Name> può essere null per la proprietà degli eventi rinominati se il <xref:System.IO.FileSystemWatcher> non ottenere corrispondenza eventi vecchi e nuovi nome dal sistema operativo.

 La ridenominazione della directory che si sta controllando non genererà una notifica. Le notifiche vengono generate solo per le voci all'interno della directory che si sta controllando.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Renamed> evento per visualizzare il percorso del file di console ogni volta che viene rinominato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associano i siti di una <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> e abilitare la comunicazione tra di essi, nonché forniscono un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls issued as a result of a directory change.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi eseguite in seguito a una modifica della directory. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> viene `null`, metodi che gestiscono le <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> gli eventi vengono chiamati su un thread dal pool di thread di sistema. Per altre informazioni sui pool di thread di sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando la <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> vengono gestiti gli eventi da un componente visivo di Windows Form, ad esempio un <xref:System.Windows.Forms.Button>, accedere al componente tramite il pool di thread di sistema potrebbero non funzionare o potrebbe generare un'eccezione. Evitare questo problema impostando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> a un componente di Windows Form, in modo che i metodi che gestiscono le <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> eventi da chiamare sullo stesso thread in cui è stato creato il componente.  
  
 Se il <xref:System.IO.FileSystemWatcher> viene usata all'interno [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in una finestra di progettazione Windows Form <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> imposta automaticamente al controllo che contiene il <xref:System.IO.FileSystemWatcher>. Ad esempio, se si inserisce un <xref:System.IO.FileSystemWatcher> in una finestra di progettazione Form1 (che eredita da <xref:System.Windows.Forms.Form>) la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà della <xref:System.IO.FileSystemWatcher> è impostato per l'istanza di Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</param>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo attende indefinitamente la prima modifica viene eseguita e quindi viene restituito. Ciò è simile all'utilizzo <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> con il `timeout` parametro impostato su -1.  
  
> [!NOTE]
>  Questo metodo consente a un gestore eventi da richiamare per rispondere ai file delle modifiche anche nel caso il <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è impostata su `false`.  
  
 In alcuni sistemi, <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file usando il formato del nome di 8.3 file brevi. Ad esempio, è stato possibile segnalare una modifica a "Longfilename" come "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</param>
        <param name="timeout">The time (in milliseconds) to wait before timing out.</param>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor and the time (in milliseconds) to wait before timing out.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo attende fino a quando non viene apportata una modifica o è scaduta. Il valore -1 per il `timeout` parametro indica un'attesa indefinita.  
  
> [!NOTE]
>  Questo metodo consente a un gestore eventi da richiamare per rispondere ai file delle modifiche anche nel caso il <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è impostata su `false`.  
  
 In alcuni sistemi, <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file usando il formato del nome di 8.3 file brevi. Ad esempio, è stato possibile segnalare una modifica a "Longfilename" come "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>