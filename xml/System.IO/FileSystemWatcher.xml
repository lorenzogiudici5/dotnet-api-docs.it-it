<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f524b1e2438cea1c3c824aa9514a36244ccff373" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420555" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Attende le notifiche di modifica del file system e genera eventi quando una directory o un file in una directory viene modificato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.IO.FileSystemWatcher> per controllare le modifiche in una directory specificata. È possibile controllare le modifiche nel file e le sottodirectory della directory specificata. È possibile creare un componente per controllare i file su un computer locale, un'unità di rete o un computer remoto.  
  
 Per controllare le modifiche in tutti i file, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà in una stringa vuota ("") o usare caratteri jolly ("*.\*"). Per controllare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà per il nome del file. Ad esempio, per controllare le modifiche apportate al file MyDoc, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "MyDoc". È inoltre possibile controllare le modifiche in un determinato tipo di file. Ad esempio, per controllare le modifiche nei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "\*. txt".  
  
 Esistono diversi tipi di modifiche per cui è possibile controllare in un file o directory. Ad esempio, è possibile controllare le modifiche in `Attributes`, `LastWrite` di data e ora o `Size` di file o directory. Questa operazione viene eseguita impostando il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> proprietà su uno del <xref:System.IO.NotifyFilters> valori. Per ulteriori informazioni sul tipo di modifiche è possibile controllare, vedere <xref:System.IO.NotifyFilters>.  
  
 È possibile controllare la ridenominazione, eliminazione o la creazione di file o directory. Ad esempio, per controllare la ridenominazione dei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "*. txt" e chiamare il <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> metodo con un <xref:System.IO.WatcherChangeTypes.Renamed> specificato per il parametro.  
  
 Il sistema operativo Windows invia una notifica di modifiche ai file in un buffer creato dal componente di <xref:System.IO.FileSystemWatcher>. Se si apportano numerose modifiche in breve tempo, può espandersi, il buffer. In questo modo il componente non terrà traccia delle modifiche nella directory, ed esegue solo la notifica programmato. Aumento delle dimensioni del buffer con il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà è dispendiosa, perché proviene da memoria non di paging che non può essere scambiata su disco, pertanto è opportuno conservare ancora il buffer di piccole dimensioni grandi dimensioni sufficienti per non perdere tutti i file degli eventi di modifica. Per evitare un overflow del buffer, utilizzare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica delle proprietà in modo è possibile filtrare indesiderato.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.IO.FileSystemWatcher>, vedere il <xref:System.IO.FileSystemWatcher.%23ctor%2A> costruttore.  
  
 Si noti quanto segue quando si utilizza la <xref:System.IO.FileSystemWatcher> classe.  
  
-   I file nascosti non vengono ignorati.  
  
-   In alcuni sistemi <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file utilizzando il formato del nome 8.3 file breve. Ad esempio, potrebbe essere segnalata una modifica a "Longfilename" come "LONGFI ~. LON".  
  
-   Questa classe contiene una richiesta di collegamento e una richiesta di ereditarietà a livello di classe che si applica a tutti i membri. Oggetto <xref:System.Security.SecurityException> viene generata quando il chiamante immediato o la classe derivata non dispone dell'autorizzazione di attendibilità totale. Per informazioni dettagliate sui requisiti di sicurezza, vedere [le richieste di collegamento](~/docs/framework/misc/link-demands.md).  
  
-   La dimensione massima che è possibile impostare per il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà per il monitoraggio di una directory in rete è 64 KB.  
  
> [!NOTE]
>  Esecuzione <xref:System.IO.FileSystemWatcher> in Windows 98 non è supportata.  
  
## <a name="copying-and-moving-folders"></a>Copia e spostamento di cartelle  
 Il sistema operativo e <xref:System.IO.FileSystemWatcher> oggetto interpretano un'operazione di taglia e Incolla o di un'operazione di spostamento come una ridenominazione di una cartella e il relativo contenuto. Se si taglia e Incolla di una cartella con i file in una cartella controllata, la <xref:System.IO.FileSystemWatcher> oggetto segnala solo la cartella come nuovo, ma non il contenuto in quanto sono essenzialmente solo rinominati.  
  
 Per ricevere una notifica che il contenuto delle cartelle è stato spostato o copiato in una cartella controllata, fornire <xref:System.IO.FileSystemWatcher.OnChanged%2A> e <xref:System.IO.FileSystemWatcher.OnRenamed%2A> metodi del gestore eventi come indicato nella tabella seguente.  
  
|Gestore dell'evento|Eventi gestiti|Esegue|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Modifiche al report in attributi di file, i file creati e file eliminati.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Elenca i percorsi precedenti e nuovi file rinominati e le cartelle, mediante l'espansione ricorsiva se necessario.|  
  
## <a name="events-and-buffer-sizes"></a>Gli eventi e le dimensioni del Buffer  
 Si noti che dipende da vari fattori gli eventi di modifica del file system vengono generati, come descritto di seguito:  
  
-   Operazioni comuni di file system potrebbero generare più eventi. Ad esempio, quando un file viene spostato da una directory a un altro, molti <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcuni <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventi potrebbero essere generati. Lo spostamento di che un file è un'operazione complessa costituito da più semplici operazioni, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati gli eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
-   Il <xref:System.IO.FileSystemWatcher> può controllare i dischi finché non vengono commutati o rimossi. Il <xref:System.IO.FileSystemWatcher> non genera eventi per CD e DVD, in quanto non è possibile modificare i timestamp e le proprietà. Computer remoto deve avere una delle piattaforme necessarie installate per il corretto funzionamento del componente.  
  
-   Se più <xref:System.IO.FileSystemWatcher> oggetti controllano lo stesso percorso UNC in Windows XP Service Pack 1 prima di, o Windows 2000 SP2 o versioni precedenti, solo uno degli oggetti genererà un evento. Nei computer che eseguono Windows XP SP1 e versioni successive, Windows 2000 SP3 o versioni successive o Windows Server 2003, tutti <xref:System.IO.FileSystemWatcher> oggetti genererà gli eventi appropriati.  
  
 Si noti che un <xref:System.IO.FileSystemWatcher> potrebbe non essere implementato un evento quando viene superata la dimensione del buffer. Per evitare la perdita di eventi, seguire queste linee guida:  
  
-   Aumentare le dimensioni del buffer impostando il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
-   Evitare il controllo di file con nomi di file lunghi, poiché un nome di file lunghi contribuisce alla compilazione del buffer su. Eseguire la ridenominazione di tali file con nomi più brevi.  
  
-   Mantenere il codice più brevi possibili di gestione di eventi.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente è impostato per controllare le modifiche in `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso di stampa nella console.  
  
 Utilizzare il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">per la derivazione da di <see cref="T:System.Diagnostics.ProcessStartInfo" /> classe. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Set di autorizzazioni denominati: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer remoto di Windows NT 4.0 da un computer Windows NT 4.0.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.IO.FileSystemWatcher>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinazione OR bit per bit di `LastWrite`, `FileName`, e `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Controlla tutti i file.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|una stringa vuota ("")|  
  
> [!NOTE]
>  Il componente non controllerà la directory specificata finché la <xref:System.IO.FileSystemWatcher.Path%2A> è impostata, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> oggetto da controllare la directory specificata in fase di esecuzione. Il <xref:System.IO.FileSystemWatcher> oggetto controlla le modifiche in `LastWrite` e `LastAccess` volte e per la creazione, eliminazione o ridenominazione di testo file nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene visualizzato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso visualizzato nella console.  
  
 Questo esempio viene utilizzato il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Directory da monitorare, nella notazione standard o UNC (Universal Naming Convention).</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileSystemWatcher" />, una volta specificata la directory da monitorare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il componente non controllerà la directory specificata finché la <xref:System.IO.FileSystemWatcher.Path%2A> è impostata, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il componente può controllare i file nel computer personale, un'unità di rete o un computer remoto.  
  
 È possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer remoto di Windows NT 4.0 da un computer Windows NT 4.0. Il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà è impostata per impostazione predefinita per il controllo di tutti i file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 Il percorso specificato mediante il parametro <paramref name="path" /> è inesistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> è troppo lungo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Directory da monitorare, nella notazione standard o UNC (Universal Naming Convention).</param>
        <param name="filter">Tipo di file da controllare. Ad esempio, "*.txt" controlla le modifiche apportate a tutti i file di testo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.FileSystemWatcher" />, una volta specificati la directory e il tipo di file da monitorare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il componente non controllerà la directory specificata finché la <xref:System.IO.FileSystemWatcher.Path%2A> è impostata, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il componente può controllare i file nel computer personale, un'unità di rete o un computer remoto.  
  
 È possibile controllare un computer remoto che non dispone di Windows NT o Windows 2000. È possibile controllare un computer remoto di Windows NT 4.0 da un computer Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è una stringa vuota ("").  
  
 oppure  
  
 Il percorso specificato mediante il parametro <paramref name="path" /> è inesistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> è troppo lungo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione di un oggetto <see cref="T:System.IO.FileSystemWatcher" /> usato in un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente di progettazione questo metodo per avviare l'inizializzazione di un componente utilizzato in un form o da un altro componente. Il <xref:System.IO.FileSystemWatcher.EndInit%2A> metodo termina l'inizializzazione. Utilizzo di <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla modifica di un file o di una directory nella proprietà <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato quando vengono apportate modifiche alle dimensioni, attributi di sistema, dell'ultima scrittura ora, l'ora dell'ultimo accesso o le autorizzazioni di sicurezza di un file o directory nella directory da monitorare.  
  
> [!NOTE]
>  Operazioni comuni di file system potrebbero generare più eventi. Ad esempio, quando un file viene spostato da una directory a un altro, molti <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcuni <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventi potrebbero essere generati. Lo spostamento di che un file è un'operazione complessa costituito da più semplici operazioni, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati gli eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
 Utilizzare <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> per limitare il numero di notifiche generate quando questo evento viene gestito.  
  
> [!NOTE]
>  Il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato in modo imprevisto quando un file viene rinominato, ma non viene generato quando viene rinominata una directory. Per controllare la ridenominazione, utilizzare il <xref:System.IO.FileSystemWatcher.Renamed> evento.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Changed> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando il <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non è `null`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Changed> evento per visualizzare il percorso del file di console ogni volta che viene modificato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla creazione di un file o di una directory nella proprietà <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory in cui è stato copiato il file, se tale directory è controllata. Se è stata controllata da un'altra istanza di directory da cui è stata copiata <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, creare due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your Documents". Se si copia un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> evento FileSystemWatcher2, ma viene generato alcun evento per FileSystemWatcher1. A differenza della copia, lo spostamento di un file o directory genererebbe due eventi. Nell'esempio precedente, se si sposta un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
> [!NOTE]
>  Operazioni comuni di file system potrebbero generare più eventi. Ad esempio, quando un file viene spostato da una directory a un altro, molti <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcuni <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventi potrebbero essere generati. Lo spostamento di che un file è un'operazione complessa costituito da più semplici operazioni, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati gli eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Created> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando il <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non è `null`.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> viene generato l'evento non appena viene creato un file. Se un file viene copiato o essere trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguito da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventi.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Created> evento per visualizzare il percorso del file di console ogni volta che viene creato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica all'eliminazione di un file o di una directory nella proprietà <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory in cui è stato copiato il file, se tale directory è controllata. Se è stata controllata da un'altra istanza di directory da cui è stata copiata <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, creare due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your Documents". Se si copia un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> evento FileSystemWatcher2, ma viene generato alcun evento per FileSystemWatcher1. A differenza della copia, lo spostamento di un file o directory genererebbe due eventi. Nell'esempio precedente, se si sposta un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
> [!NOTE]
>  Operazioni comuni di file system potrebbero generare più eventi. Ad esempio, quando un file viene spostato da una directory a un altro, molti <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcuni <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventi potrebbero essere generati. Lo spostamento di che un file è un'operazione complessa costituito da più semplici operazioni, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati gli eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L'ordine in cui il <xref:System.IO.FileSystemWatcher.Deleted> evento viene generato in relazione a altra <xref:System.IO.FileSystemWatcher> eventi potrebbero cambiare quando il <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà non è `null`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Deleted> evento per visualizzare il percorso del file di console ogni volta che viene eliminato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.FileSystemWatcher" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.ComponentModel.Component.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo. <xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.FileSystemWatcher.Dispose%2A> metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.FileSystemWatcher.Dispose%2A> con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.Compression.DeflateStream> fa riferimento. Il metodo richiama il metodo <xref:System.ComponentModel.Component.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <see cref="M:System.ComponentModel.Component.Dispose" />. Per ulteriori informazioni su come implementare <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il componente è abilitato.</summary>
        <value>
          <see langword="true" /> se il componente è abilitato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />. Se si usa il componente in una finestra di progettazione in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], l'impostazione predefinita è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il componente non genera eventi a meno che non si imposta <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> a `true`.  
  
> [!NOTE]
>  Il componente non controllerà la directory specificata finché la <xref:System.IO.FileSystemWatcher.Path%2A> proprietà è stata impostata e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è `true`.  
  
 Il <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> metodo consente ai gestori di eventi da richiamare per rispondere alle modifiche al file anche se questa proprietà è impostata su `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente è impostato per controllare le modifiche in `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso di stampa nella console.  
  
 Utilizzare il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.IO.FileSystemWatcher" /> è stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo corrente non è Microsoft Windows NT o versioni successive.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare la directory specificata in <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException">
          La proprietà <see cref="P:System.IO.FileSystemWatcher.Path" /> non è stata impostata o non è valida.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione di un oggetto <see cref="T:System.IO.FileSystemWatcher" /> usato in un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente di progettazione questo metodo per terminare l'inizializzazione di un componente utilizzato in un form o da un altro componente. Il <xref:System.IO.FileSystemWatcher.BeginInit%2A> metodo avvia l'inizializzazione. Utilizzo di <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'istanza dell'oggetto <see cref="T:System.IO.FileSystemWatcher" /> non è in grado di continuare il monitoraggio delle modifiche o quando si verifica un overflow del buffer interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato ogni volta che un elemento impedisce il <xref:System.IO.FileSystemWatcher> oggetto di monitoraggio delle modifiche. Ad esempio, se l'oggetto esegue il monitoraggio delle modifiche in una directory remota e la connessione a tale directory è andato persa, il <xref:System.IO.FileSystemWatcher.Error> viene generato l'evento.  
  
 Il sistema di notifica di modifiche al file, e tali modifiche vengono memorizzate in un buffer che il componente creato e passato alle API. Se si apportano numerose modifiche in breve tempo, può espandersi, il buffer. In questo modo il componente non terrà traccia delle modifiche nella directory, ed esegue solo la notifica programmato. Aumento delle dimensioni del buffer è costoso, perché proviene da non di paging della memoria che non può essere scambiata su disco, quindi tenere buffer quanto più breve possibile. Per evitare un overflow del buffer, utilizzare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica di proprietà da filtrare indesiderato.  
  
> [!NOTE]
>  Operazioni comuni di file system potrebbero generare più eventi. Ad esempio, quando un file viene spostato da una directory a un altro, molti <xref:System.IO.FileSystemWatcher.OnChanged%2A> e alcuni <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventi potrebbero essere generati. Lo spostamento di che un file è un'operazione complessa costituito da più semplici operazioni, generano più eventi. Analogamente, alcune applicazioni (ad esempio, il software antivirus) vengano generati gli eventi di sistema aggiuntive del file che vengono rilevati da <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la stringa di filtro usata per determinare quali file vengono monitorati in una directory.</summary>
        <value>Stringa di filtro. Il valore predefinito è "*. \*"(Controlla tutti i file.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare le modifiche in tutti i file, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà in una stringa vuota (""). Per controllare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà per il nome del file. Ad esempio, per controllare le modifiche apportate al file MyDoc, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "MyDoc". È inoltre possibile controllare le modifiche in un determinato tipo di file. Ad esempio, per controllare le modifiche nei file di testo, impostare il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà su "*. txt". Utilizzo di più filtri, ad esempio "\*txt&#124;\*doc" non è supportata.  
  
 Il <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà può essere modificata dopo il <xref:System.IO.FileSystemWatcher> oggetto ha avviato la ricezione di eventi.  
  
 Per ulteriori informazioni sull'applicazione di filtri alle notifiche, vedere il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> accetta i caratteri jolly per i file corrispondenti, come illustrato negli esempi seguenti.  
  
|Stringa di filtro|Controlla che i file seguenti|  
|-------------------|---------------------------------|  
|*.\*|Tutti i file (impostazione predefinita). Una stringa vuota ("") controlla anche tutti i file.|  
|*.txt|Tutti i file con estensione "txt".|  
|*recipe.doc|Tutti i file che terminano con "recipe" con l'estensione "doc".|  
|win*.xml|Tutti i file che iniziano con "win" con estensione "xml".|  
|Sales*200?.xls|Corrisponde a quanto segue:<br /><br /> Vendita di luglio 2001.xlsSales ago 2002.xlsSales marzo 2004.xls<br /><br /> ma non corrisponde a:<br /><br /> Vendita di novembre 1999.xls|  
|MyReport.Doc|Controlla solo MyReport|  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente è impostato per controllare le modifiche in `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso di stampa nella console.  
  
 Utilizzare il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le sottodirectory nel percorso specificato devono essere monitorate.</summary>
        <value>
          <see langword="true" /> per monitorare le sottodirectory; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> a `true` quando si desidera controllare le notifiche di modifica per file e directory contenute all'interno della directory specificata tramite la <xref:System.IO.FileSystemWatcher.Path%2A> proprietà e nelle relative sottodirectory. L'impostazione di <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> proprietà `false` consente di ridurre il numero di notifiche inviate al buffer interno. Per ulteriori informazioni sull'applicazione di filtri alle notifiche, vedere il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
 Quando `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> è ricorsiva in tutta la sottostruttura, non solo le directory figlio immediati. Restituisce il percorso relativo di un file o directory all'interno della sottostruttura di <xref:System.IO.FileSystemEventArgs.Name%2A> proprietà di <xref:System.IO.FileSystemEventArgs> e <xref:System.IO.RenamedEventArgs.OldName%2A> proprietà di <xref:System.IO.RenamedEventArgs>, a seconda delle modifiche che si stanno controllando. È possibile ottenere il percorso completo dal <xref:System.IO.FileSystemEventArgs.FullPath%2A> proprietà di <xref:System.IO.FileSystemEventArgs> e <xref:System.IO.RenamedEventArgs.OldFullPath%2A> proprietà di <xref:System.IO.RenamedEventArgs>, a seconda delle modifiche che si stanno controllando.  
  
 Se viene creata una directory nella sottostruttura della directory che si sta controllando, e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> è `true`, tale directory verrà creata automaticamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le dimensioni predefinite (in byte) del buffer interno.</summary>
        <value>Dimensioni del buffer interno in byte. L'impostazione predefinita è 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile impostare il buffer a 4 KB o superiori, ma non deve superare i 64 KB. Se si tenta di impostare il <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> a meno di 4096 byte, il valore vengono ignorati e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> è impostata su 4096 byte. Per prestazioni ottimali, utilizzare un multiplo di 4 KB nei computer basati su Intel.  
  
 Il sistema informa il componente di modifiche al file, e tali modifiche vengono memorizzate in un buffer creato e passato alle API il componente. Ogni evento può utilizzare fino a 16 byte di memoria, non comprensivo del nome di file. Se si apportano numerose modifiche in breve tempo, può espandersi, il buffer. In questo modo il componente non terrà traccia delle modifiche nella directory, ed esegue solo la notifica programmato. Può impedire l'aumento delle dimensioni del buffer degli eventi di modifica mancante file sistema. Tuttavia, l'aumento delle dimensioni del buffer è operazioni onerose, perché proviene dalla memoria non di paging che non è possibile eseguire lo swapping su disco, è consigliabile limitare al minimo il buffer. Per evitare un overflow del buffer, utilizzare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> le notifiche di modifica di proprietà da filtrare indesiderato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di modifiche da controllare.</summary>
        <value>Uno dei valori di <see cref="T:System.IO.NotifyFilters" />. Il valore predefinito è la combinazione OR bit per bit di <see langword="LastWrite" />, <see langword="FileName" /> e <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile combinare i membri del <xref:System.IO.NotifyFilters> enumerazione per controllare più di un tipo di modifica alla volta. Ad esempio, è possibile controllare le modifiche nella dimensione di un file e le modifiche apportate il `LastWrite` ora. Questo genera un evento ogni volta che viene apportata una modifica nelle dimensioni file o cartella oppure una modifica nel `LastWrite` ora del file o della cartella.  
  
 Questo è un modo per filtrare le notifiche non desiderate. Per ulteriori informazioni sull'applicazione di filtri alle notifiche, vedere il <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente è impostato per controllare le modifiche in `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso di stampa nella console.  
  
 Utilizzare il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore non è una combinazione OR bit per bit valida dei valori di <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il valore impostato non è valido.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.IO.FileSystemEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> viene chiamato quando vengono apportate modifiche alla dimensione, attributi di sistema, ora dell'ultima scrittura, ora dell'ultimo accesso o le autorizzazioni di sicurezza di un file o directory nella directory da monitorare.  
  
 Utilizzare il <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> proprietà per limitare il numero di eventi di eccezione generata quando il <xref:System.IO.FileSystemWatcher.Changed> viene gestito l'evento.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> viene generato l'evento non appena viene creato un file. Se un file viene copiato o essere trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguito da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventi.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> metodo.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.IO.FileSystemEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> viene chiamato quando viene creato un file o directory nella directory da monitorare.  
  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory in cui è stato copiato il file, se tale directory è controllata. Se è stata controllata da un'altra istanza di directory da cui è stata copiata <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, creare due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your Documents". Se si copia un file da "Documenti" e incollarlo in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> evento verrà generato in FileSystemWatcher2, ma viene generato alcun evento per FileSystemWatcher1. A differenza della copia, lo spostamento di un file o directory genera due eventi. Nell'esempio precedente, se si sposta un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> in FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
 Il <xref:System.IO.FileSystemWatcher.OnCreated%2A> viene generato l'evento non appena viene creato un file. Se un file viene copiato o essere trasferiti in una directory controllata, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento verrà generato immediatamente, seguito da uno o più <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventi.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> metodo.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.IO.FileSystemEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> viene chiamato quando viene eliminato un file o directory, all'interno della directory da monitorare.  
  
 Alcune occorrenze comuni, ad esempio la copia o spostamento di un file o directory, non corrispondono direttamente a un evento, ma causano la generazione di eventi. Quando si copia un file o directory, il sistema genera un <xref:System.IO.FileSystemWatcher.Created> evento nella directory in cui è stato copiato il file, se tale directory è controllata. Se è stata controllata da un'altra istanza di directory da cui è stata copiata <xref:System.IO.FileSystemWatcher>, non verrà generato alcun evento. Ad esempio, creare due istanze di <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 è impostato per il controllo "C:\My Documents" e FileSystemWatcher2 è impostato per il controllo "C:\Your Documents". Se si copia un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> evento FileSystemWatcher2, ma viene generato alcun evento per FileSystemWatcher1. A differenza della copia, lo spostamento di un file o directory genera due eventi. Nell'esempio precedente, se si sposta un file da "Documenti" in "Documenti", un <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 essere generato un evento e un <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 essere generato un evento.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> metodo.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.IO.ErrorEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> viene chiamato quando si verifica un errore.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> metodo.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.IO.RenamedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> viene chiamato quando viene rinominato un file o directory all'interno della directory da monitorare. Relativo <xref:System.IO.RenamedEventArgs> argomento contiene informazioni sull'operazione di ridenominazione, ad esempio il tipo di modifica, il vecchio e il nuovo percorso e il nome precedente e nuovo. Si noti che il relativo <xref:System.IO.FileSystemEventArgs.Name> proprietà può essere null per rinominare gli eventi se il <xref:System.IO.FileSystemWatcher> non ottenere vecchio e il nuovo nome gli eventi corrispondenti dal sistema operativo. 
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> metodo.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il percorso della directory da controllare.</summary>
        <value>Percorso da monitorare. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un percorso completo di una directory. Se il <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> proprietà `true`, questa directory è la radice in cui il sistema verifica la presenza di modifiche in caso contrario è il sola directory controllata. Per controllare un file specifico, impostare il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà nella directory completa e corretta e <xref:System.IO.FileSystemWatcher.Filter%2A> proprietà per il nome del file.  
  
 Il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà supporta i percorsi UNC Universal Naming Convention ().  
  
> [!NOTE]
>  Questa proprietà deve essere impostata prima che il componente è possibile controllare le modifiche.  
  
 Quando una directory viene rinominata, il <xref:System.IO.FileSystemWatcher> automaticamente viene ricollegato automaticamente all'elemento appena rinominata. Ad esempio, se si imposta la <xref:System.IO.FileSystemWatcher.Path%2A> proprietà su "C:\My Documents" e quindi rinominare manualmente la directory "C:\Your Documents", il componente continua ad attendere le notifiche di modifica alla directory appena rinominata. Tuttavia, quando si richiede il <xref:System.IO.FileSystemWatcher.Path%2A> proprietà, che contiene il percorso precedente. Ciò accade perché il componente determina la directory da controllare in base l'handle, anziché il nome della directory. La ridenominazione non influisce l'handle. Pertanto, se si elimina il componente e quindi ricrearlo senza l'aggiornamento di <xref:System.IO.FileSystemWatcher.Path%2A> proprietà, l'applicazione avrà esito negativo perché la directory non esiste più.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.IO.FileSystemWatcher> per controllare la directory specificata in fase di esecuzione. Il componente è impostato per controllare le modifiche in `LastWrite` e `LastAccess` ora, la creazione, eliminazione o ridenominazione dei file di testo nella directory. Se un file viene modificato, creato o eliminato, il percorso del file viene stampato nella console. Quando viene rinominato un file, il vecchio e nuovo percorso di stampa nella console.  
  
 Utilizzare il <xref:System.Diagnostics> e <xref:System.IO> gli spazi dei nomi per questo esempio.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso specificato non esiste o non è stata trovato.  
  
 oppure  
  
 Il percorso specificato contiene caratteri jolly.  
  
 oppure  
  
 Il percorso specificato contiene caratteri di percorso non validi.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla ridenominazione di un file o di una directory nella proprietà <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Renamed` evento è un <xref:System.IO.RenamedEventHandler> delegato che ha la firma seguente:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Il <xref:System.IO.RenamedEventArgs> oggetto fornisce informazioni sull'operazione di ridenominazione, ad esempio il tipo della ridenominazione (il <xref:System.IO.FileSystemEventArgs.ChangeType> proprietà), il vecchio e il nuovo nome e il percorso precedente e nuovo. Si noti che il <xref:System.IO.FileSystemEventArgs.Name> proprietà può essere null per rinominare gli eventi se i <xref:System.IO.FileSystemWatcher> non ottenere vecchio e il nuovo nome gli eventi corrispondenti dal sistema operativo.

 La ridenominazione della directory che si sta controllando non genererà una notifica. Le notifiche vengono generate solo per le voci all'interno della directory che si sta controllando.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.FileSystemWatcher.Renamed> evento per visualizzare il percorso del file di console ogni volta che viene rinominato il file controllato.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siti associano un <xref:System.ComponentModel.Component> per un <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> e abilitare la comunicazione tra di essi, nonché fornire un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi eseguite in seguito alla modifica di una directory.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi eseguite in seguito a una modifica della directory. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> è `null`, metodi che gestiscono il <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> eventi vengono chiamati su un thread dal pool di thread del sistema. Per ulteriori informazioni sui pool di thread del sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> vengono gestiti gli eventi da un componente di Windows Form visivo, ad esempio un <xref:System.Windows.Forms.Button>, accesso al componente tramite il pool di thread di sistema potrebbero non funzionare o generare un'eccezione. Evitare questa situazione impostando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> a un componente di Windows Form, che chiama i metodi che gestiscono il <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> gli eventi da chiamare sullo stesso thread in cui è stato creato il componente.  
  
 Se il <xref:System.IO.FileSystemWatcher> viene utilizzata all'interno [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in una finestra di progettazione Windows Form, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> imposta automaticamente al controllo che contiene il <xref:System.IO.FileSystemWatcher>. Ad esempio, se si inserisce un <xref:System.IO.FileSystemWatcher> in una finestra di progettazione Form1 (che eredita da <xref:System.Windows.Forms.Form>) il <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> proprietà <xref:System.IO.FileSystemWatcher> è impostato per l'istanza di Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metodo sincrono che restituisce una struttura contenente informazioni specifiche sulla modifica effettuata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Oggetto <see cref="T:System.IO.WatcherChangeTypes" /> da controllare.</param>
        <summary>Metodo sincrono che restituisce una struttura contenente informazioni specifiche sulle modifica effettuata, una volta definito il tipo di modifica da monitorare.</summary>
        <returns>Oggetto <see cref="T:System.IO.WaitForChangedResult" /> che contiene informazioni specifiche sulle modifiche effettuate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo attende indefinitamente la prima modifica viene generato e quindi restituisce. Ciò è simile all'utilizzo <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> con il `timeout` parametro impostato su -1.  
  
> [!NOTE]
>  Questo metodo consente a un gestore eventi da richiamare in modo che risponda se anche le modifiche di file di <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è impostata su `false`.  
  
 In alcuni sistemi <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file utilizzando il formato del nome 8.3 file breve. Ad esempio, potrebbe essere segnalata una modifica a "Longfilename" come "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Oggetto <see cref="T:System.IO.WatcherChangeTypes" /> da controllare.</param>
        <param name="timeout">Tempo di attesa espresso in millisecondi prima del timeout.</param>
        <summary>Metodo sincrono che restituisce una struttura contenente informazioni specifiche sulle modifica effettuata, una volta definiti il tipo di modifica da monitorare e il tempo di attesa espresso in millisecondi prima del timeout.</summary>
        <returns>Oggetto <see cref="T:System.IO.WaitForChangedResult" /> che contiene informazioni specifiche sulle modifiche effettuate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo attende fino a quando non viene apportata una modifica o è scaduta. Il valore-1 per il `timeout` parametro indica un'attesa indefinita.  
  
> [!NOTE]
>  Questo metodo consente a un gestore eventi da richiamare in modo che risponda se anche le modifiche di file di <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> è impostata su `false`.  
  
 In alcuni sistemi <xref:System.IO.FileSystemWatcher> segnala le modifiche apportate ai file utilizzando il formato del nome 8.3 file breve. Ad esempio, potrebbe essere segnalata una modifica a "Longfilename" come "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>