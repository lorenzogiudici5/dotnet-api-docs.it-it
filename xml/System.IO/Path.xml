<Type Name="Path" FullName="System.IO.Path">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ef473bd6615db5908afedacb6564d0e78685953" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911233" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Esegue operazioni sulle istanze <see cref="T:System.String" /> che contengono informazioni sul percorso di file o directory. Le operazioni vengono eseguite su più piattaforme.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Un percorso è una stringa che fornisce la posizione di un file o directory. Un percorso non è necessariamente punta a una posizione sul disco. ad esempio, potrebbe eseguire il mapping di un percorso in una posizione in memoria o su un dispositivo. Il formato esatto di un percorso è determinato dalla piattaforma corrente. In alcuni sistemi, ad esempio, un percorso può iniziare con una lettera di unità o volume, mentre l'elemento non è presente in altri sistemi. In alcuni sistemi, i percorsi di file possono contenere le estensioni che indicano il tipo di informazioni archiviate nel file. Il formato di un'estensione di file è dipendente dalla piattaforma. ad esempio, alcuni sistemi di limitano le estensioni a tre caratteri e non altre. La piattaforma corrente determina anche il set di caratteri utilizzato per separare gli elementi di un percorso e il set di caratteri che non può essere utilizzato quando si specificano i percorsi. A causa di tali differenze, i campi del `Path` classe nonché il comportamento di alcuni membri della `Path` classe dipendono dalla piattaforma.  
  
 Un percorso può contenere informazioni sul percorso assoluto o relativo. Percorsi assoluti completamente specificano un percorso: il file o directory può essere identificata indipendentemente dalla posizione corrente. I percorsi relativi specificano un percorso parziale: il percorso corrente viene utilizzato come punto di partenza per l'individuazione di un file specificato con un percorso relativo. Per determinare la directory corrente, chiamare <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  
  
 La maggior parte dei membri del `Path` classe non interagiscono con il file system e non verifica l'esistenza del file specificato da una stringa di percorso. `Path` modificano una stringa di percorso, ad esempio i membri di classe <xref:System.IO.Path.ChangeExtension%2A>, non hanno alcun effetto sui nomi dei file nel file system. `Path` i membri, tuttavia, convalidare il contenuto di una stringa di percorso specificato e genera un <xref:System.ArgumentException> eccezione se la stringa contiene caratteri non validi nelle stringhe di percorso, come definito nei caratteri restituiti dal <xref:System.IO.Path.GetInvalidPathChars%2A> metodo. Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere le virgolette ("), minore di (\<), maggiore di (>), barra verticale (&#124;), backspace (\b), null (\0) e i caratteri Unicode 16 a 18 e 20 e 25.  
  
 I membri del `Path` classe consentono di eseguire rapidamente e facilmente operazioni comuni, ad esempio consentono di determinare se un'estensione di file fa parte di un percorso e combinare due stringhe in un nome di percorso.  
  
 Tutti i membri del `Path` classe sono statica e possono quindi essere chiamati senza un'istanza di un percorso.  
  
> [!NOTE]
>  I membri che accettano un percorso come una stringa di input, che il percorso deve essere corretto o viene generata un'eccezione. Ad esempio, se un percorso completo inizia con uno spazio, il percorso non viene ritagliato in metodi della classe. Pertanto, il percorso sia valido e viene generata un'eccezione. Analogamente, un percorso o una combinazione di percorsi non può essere completo due volte. Ad esempio, "c:\temp c:\windows" genera anche un'eccezione nella maggior parte dei casi. Verificare che i percorsi siano ben formati quando si utilizzano i metodi che accettano una stringa di percorso.  
  
 Nei membri che accettano un percorso, il percorso può fare riferimento a un file o solo una directory. Il percorso specificato può anche fare riferimento a un percorso relativo o un percorso UNC Universal Naming Convention () per un nome di server e la condivisione. Ad esempio, le condizioni seguenti sono percorsi accettabili:  
  
-   "c:\\\MyDir\\\MyFile.txt" in c# o "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "c:\\\MyDir" in c# o "c:\MyDir" in Visual Basic.  
  
-   "MyDir\\\MySubdir" in c# o "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in c#, o "\\\MyServer\MyShare" in Visual Basic.  
  
 Perché tutte queste operazioni vengono eseguite su stringhe, non è possibile verificare che i risultati sono validi in tutti gli scenari. Ad esempio, il <xref:System.IO.Path.GetExtension%2A> metodo analizza una stringa che vengono passati e restituisce l'estensione da tale stringa. Tuttavia, ciò non significa che un file con estensione esista sul disco.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente vengono illustrati alcuni dei membri principali del `Path` classe.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce un carattere alternativo specifico della piattaforma usato per separare i livelli di directory in una stringa di percorso che riflette un'organizzazione di file system gerarchica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere archiviato in questo campo non può essere <xref:System.IO.Path.InvalidPathChars>. Questo campo può essere impostato sullo stesso valore di <xref:System.IO.Path.DirectorySeparatorChar>. `AltDirectorySeparatorChar` e <xref:System.IO.Path.DirectorySeparatorChar> sono entrambi validi per separare i livelli di directory in una stringa di percorso.  
  
 Il valore di questo campo è una barra ('/') nei sistemi operativi Windows, UNIX e Macintosh.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del `AltDirectorySeparatorChar` campo.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Informazioni sul percorso da modificare. Il percorso non può contenere i caratteri definiti in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">Nuova estensione, con o senza un punto iniziale. Specificare <see langword="null" /> per rimuovere un'estensione esistente da <c>path</c>.</param>
        <summary>Cambia l'estensione di una stringa di percorso.</summary>
        <returns>Informazioni sul percorso modificato.  
  
 Nelle piattaforme desktop basate su Windows, se <paramref name="path" /> è <see langword="null" /> o una stringa vuota (""), le informazioni sul percorso verranno restituite immutate. Se <paramref name="extension" /> è <see langword="null" />, la stringa restituita conterrà il percorso specificato senza estensione. Se <paramref name="path" /> non ha estensione e <paramref name="extension" /> non è <see langword="null" />, la stringa di percorso restituita conterrà <paramref name="extension" /> alla fine di <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si specifica `path` né `extension` contiene un punto (.), `ChangeExtension` aggiunge il periodo.  
  
 Il `extension` parametro può contenere più periodi e i caratteri di percorso valido e può essere qualsiasi lunghezza. Se `extension` è `null`, la stringa restituita conterrà il contenuto di `path` con l'ultimo periodo e tutti i caratteri successivi viene rimosso.  
  
 Se `extension` è una stringa vuota, la stringa di percorso restituita contiene il contenuto di `path` con i caratteri successivi all'ultimo punto rimosso.  
  
 Se `path` non dispone di un'estensione e `extension` non `null`, la stringa restituita conterrà `path` seguito da `extension`.  
  
 Se `extension` non `null` e non contiene un punto iniziale, quest ' ultimo viene aggiunto.  
  
 Se `path` contiene un'estensione multipla separata da più punti, la stringa restituita conterrà il contenuto di `path` con l'ultimo periodo e tutti i caratteri successivi viene sostituito da `extension`. Ad esempio, se `path` è "\Dir1\examples\pathtests.csx.txt" e `extension` è "cs", il percorso modificato è "\Dir1\examples\pathtests.csx.cs".  
  
 Non è possibile verificare che i risultati restituiti sono validi in tutti gli scenari. Ad esempio, se `path` è vuoto, `extension` viene aggiunto.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del `ChangeExtension` metodo.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combina stringhe in un percorso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Matrice di parti del percorso.</param>
        <summary>Combina una matrice di stringhe in un percorso.</summary>
        <returns>Percorsi combinati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `paths` deve essere una matrice delle parti del percorso da combinare. Se uno dei percorsi successivi è un percorso assoluto, l'operazione di combinazione Reimposta a partire da quel percorso assoluto, eliminando tutti i percorsi combinati precedenti.  
  
 Stringhe di lunghezza zero vengono omessi dal percorso combinato.  
  
 I parametri non vengono analizzati se contengono spazi vuoti.  
  
 Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il `Combine` (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca. Ad esempio, mentre `Path.Combine("c:\\", "*.txt")` potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca. Di conseguenza viene interpretato correttamente dal `Combine` metodo.  
  
   
  
## Examples  
 Nell'esempio seguente combina una matrice di stringhe in un percorso.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Una delle stringhe nella matrice contiene almeno un carattere non valido definito in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Una delle stringhe nella matrice è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">Primo percorso da combinare.</param>
        <param name="path2">Secondo percorso da combinare.</param>
        <summary>Combina due stringhe in un percorso.</summary>
        <returns>Percorsi combinati. Se uno dei percorsi specificati è una stringa di lunghezza zero, il metodo restituirà solo l'altro percorso. Se <paramref name="path2" /> contiene un percorso assoluto, il metodo restituisce <paramref name="path2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `path1` non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> viene aggiunto al `path1` prima della concatenazione.  
  
 Se `path2` non include una radice (ad esempio, se `path2` non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti. Se `path2` include una directory radice, `path2` viene restituito.  
  
 I parametri non vengono analizzati se contengono spazi vuoti. Pertanto, se `path2` include uno spazio vuoto (ad esempio, "\file.txt"), il <xref:System.IO.Path.Combine%2A> metodo aggiunge `path2` a `path1` anziché restituire solo `path2`.  
  
 Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il `Combine` (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca. Ad esempio, mentre `Path.Combine("c:\\", "*.txt")` potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca. Di conseguenza viene interpretato correttamente dal `Combine` metodo.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `Combine` metodo in una piattaforma desktop basati su Windows.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path1" /> o <paramref name="path2" /> contiene uno o più caratteri non validi definiti in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path1" /> o <paramref name="path2" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">Primo percorso da combinare.</param>
        <param name="path2">Secondo percorso da combinare.</param>
        <param name="path3">Terzo percorso da combinare.</param>
        <summary>Combina tre stringhe in un percorso.</summary>
        <returns>Percorsi combinati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` deve essere un percorso assoluto (ad esempio, "d:\archives" o "\\\archives\public"). Se `path2` o `path3` è anche un percorso assoluto, la combinazione operazione Elimina combinati precedentemente tutti i percorsi e reimposta il percorso assoluto.  
  
 Stringhe di lunghezza zero vengono omessi dal percorso combinato.  
  
 Se `path1` non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> viene aggiunto al `path1` prima della concatenazione.  
  
 Se `path2` non include una radice (ad esempio, se `path2` non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti. Se `path2` include una directory radice, `path2` viene restituito.  
  
 I parametri non vengono analizzati se contengono spazi vuoti. Pertanto, se `path2` include uno spazio vuoto (ad esempio, "\file.txt"), il <xref:System.IO.Path.Combine%2A> metodo aggiunge `path2` a `path1`.  
  
 Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il `Combine` (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca. Ad esempio, mentre `Path.Combine("c:\\", "*.txt")` potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca. Di conseguenza viene interpretato correttamente dal `Combine` metodo.  
  
   
  
## Examples  
 Nell'esempio seguente combina tre percorsi.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path1" />, <paramref name="path2" /> o <paramref name="path3" /> contiene uno o più dei caratteri non validi definiti in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path1" />, <paramref name="path2" /> o <paramref name="path3" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
        <Parameter Name="path4" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">Primo percorso da combinare.</param>
        <param name="path2">Secondo percorso da combinare.</param>
        <param name="path3">Terzo percorso da combinare.</param>
        <param name="path4">Quarto percorso da combinare.</param>
        <summary>Combina quattro stringhe in un percorso.</summary>
        <returns>Percorsi combinati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` deve essere un percorso assoluto (ad esempio, "d:\archives" o "\\\archives\public"). Se uno dei percorsi successivi è anche un percorso assoluto, l'operazione di combinazione ignora tutti i percorsi precedentemente combinati e reimposta il percorso assoluto.  
  
 Stringhe di lunghezza zero vengono omessi dal percorso combinato.  
  
 Se `path1` non è un riferimento a un'unità (vale a dire, "C:" o "D") e che non termina con un carattere separatore valido come definito in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> viene aggiunto al `path1` prima della concatenazione.  
  
 Se `path2` non include una radice (ad esempio, se `path2` non inizia con una specifica di unità o di un carattere separatore), il risultato è una concatenazione di due percorsi, con un carattere separatore coinvolti. Se `path2` include una directory radice, `path2` viene restituito.  
  
 I parametri non vengono analizzati se contengono spazi vuoti. Pertanto, se `path2` include uno spazio vuoto (ad esempio, "\file.txt"), il <xref:System.IO.Path.Combine%2A> metodo aggiunge `path2` a `path1`.  
  
 Non tutti i caratteri non validi per i nomi di file e directory vengono interpretati come accettabile per il `Combine` (metodo), poiché è possibile utilizzare questi caratteri per i caratteri jolly di ricerca. Ad esempio, mentre `Path.Combine("c:\\", "*.txt")` potrebbe non essere valido se fosse necessario creare un file da esso, è valido come una stringa di ricerca. Di conseguenza viene interpretato correttamente dal `Combine` metodo.  
  
   
  
## Examples  
 Nell'esempio seguente combina quattro percorsi.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> o <paramref name="path4" /> contiene uno o più dei caratteri non validi definiti in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> o <paramref name="path4" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce un carattere specifico della piattaforma usato per separare i livelli di directory in una stringa di percorso che riflette un'organizzazione di file system gerarchica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere archiviato in questo campo non può essere <xref:System.IO.Path.InvalidPathChars>. <xref:System.IO.Path.AltDirectorySeparatorChar> e `DirectorySeparatorChar` sono entrambi validi per separare i livelli di directory in una stringa di percorso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `DirectorySeparatorChar` campo.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso di un file o di una directory.</param>
        <summary>Restituisce le informazioni sulla directory per la stringa di percorso specificata.</summary>
        <returns>Informazioni sulla directory per <paramref name="path" /> o <see langword="null" /> se <paramref name="path" /> indica una directory radice o è Null. Restituisce <see cref="F:System.String.Empty" /> se <paramref name="path" /> non contiene informazioni sulla directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, la stringa restituita da questo metodo è costituito da tutti i caratteri del percorso fino all'ultimo escluso <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>. Se il percorso costituito da una directory radice, ad esempio "c:\\", viene restituito null. Si noti che questo metodo non supporta percorsi utilizzando "file:". Poiché il percorso restituito non include il <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, passando il percorso restituito nuovamente il <xref:System.IO.Path.GetDirectoryName%2A> metodo comporterà il troncamento di una cartella di livello superiore per la chiamata successiva nella stringa di risultato. Ad esempio, passando il percorso "C:\Directory\SubDirectory\test.txt" nel <xref:System.IO.Path.GetDirectoryName%2A> metodo verrà restituito "C:\Directory\SubDirectory". Passare la stringa "C:\Directory\SubDirectory", in <xref:System.IO.Path.GetDirectoryName%2A> verrà generato "C:\Directory".  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `GetDirectoryName` metodo in una piattaforma desktop basati su Windows.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> contiene caratteri non validi, è vuoto o contiene solo spazi vuoti.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 La lunghezza del parametro <paramref name="path" /> è maggiore della lunghezza massima definita nel sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Stringa di percorso dalla quale ottenere l'estensione.</param>
        <summary>Restituisce l'estensione della stringa di percorso specificata.</summary>
        <returns>Estensione del percorso specificato, incluso il punto ("."), oppure <see langword="null" /> oppure <see cref="F:System.String.Empty" />. Se <paramref name="path" /> è <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> restituisce <see langword="null" />. Se <paramref name="path" /> non include informazioni sull'estensione, <see cref="M:System.IO.Path.GetExtension(System.String)" /> restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'estensione di `path` viene ottenuto eseguendo una ricerca `path` per un punto (.), a partire dall'ultimo carattere del percorso e risalendo verso l'inizio del percorso. Se si trova un punto prima un <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar> carattere, la stringa restituita conterrà il periodo di e i caratteri dopo di esso; in caso contrario, <xref:System.String.Empty> viene restituito.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `GetExtension` metodo in una piattaforma desktop basati su Windows.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Stringa di percorso dalla quale ottenere il nome del file e l'estensione.</param>
        <summary>Restituisce il nome del file e l'estensione della stringa di percorso specificata.</summary>
        <returns>Caratteri successivi all'ultimo carattere di directory in <paramref name="path" />. Se l'ultimo carattere di <paramref name="path" /> è un separatore di directory o di volumi, questo metodo restituisce <see cref="F:System.String.Empty" />. Se <paramref name="path" /> è <see langword="null" />, questo metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito è `null` se il percorso del file `null`.  
  
 Il carattere separatore usato per determinare l'inizio del nome del file sono <xref:System.IO.Path.DirectorySeparatorChar> e <xref:System.IO.Path.AltDirectorySeparatorChar>.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento del `GetFileName` metodo in una piattaforma desktop basati su Windows.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file.</param>
        <summary>Restituisce il nome del file della stringa di percorso specificata senza estensione.</summary>
        <returns>Stringa restituita da <see cref="M:System.IO.Path.GetFileName(System.String)" />, senza l'ultimo punto (.) e tutti i caratteri che lo seguono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non verifica che il nome file o il percorso esista.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del `GetFileNameWithoutExtension` metodo.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">File o directory per cui ottenere informazioni relative al percorso assoluto.</param>
        <summary>Restituisce il percorso assoluto della stringa di percorso specificata.</summary>
        <returns>Percorso completo di <paramref name="path" />, ad esempio "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Il percorso assoluto include tutte le informazioni necessarie per individuare un file o directory in un sistema.  
  
 Il file o directory specificata da `path` non deve necessariamente esistere. Ad esempio, se c:\temp\newdir è la directory corrente, la chiamata `GetFullPath` in un file di nome, ad esempio test.txt restituisce c:\temp\newdir\test.txt. Il file non deve esistere.  
  
 Tuttavia, se `path` esiste, il chiamante deve disporre dell'autorizzazione per ottenere informazioni sul percorso di `path`. Si noti che, contrariamente alla maggior parte dei membri del <xref:System.IO.Path> (classe), questo metodo accede al file system.  
  
 Questo metodo utilizza directory corrente e le informazioni di volume corrente per qualificare completamente `path`. Se si specifica un file solo in nome `path`, `GetFullPath` restituisce il percorso completo della directory corrente.  
  
 Se si passa un nome file breve, viene espanso in un nome di file lunghi.  
  
 Se un percorso non contiene caratteri significativi non è consentito a meno che non contiene uno o più "."caratteri seguiti da un numero qualsiasi di spazi, quindi, verrà analizzato come"."o"...".  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il `GetFullPath` metodo in una piattaforma desktop basati su Windows.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa di lunghezza zero, contiene solo spazi vuoti oppure uno o più caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 oppure  
  
 Il sistema non è riuscito a recuperare il percorso assoluto.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha le autorizzazioni richieste.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene due punti (":") che non fanno parte di un identificatore di volume (ad esempio "c:\\").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema. Ad esempio, nelle piattaforme basate su Windows i percorsi devono contenere meno di 248 caratteri e i nomi file meno di 260 caratteri.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="basePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="basePath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice contenente i caratteri non consentiti nei nomi di file.</summary>
        <returns>Matrice contenente i caratteri non consentiti nei nomi di file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory. Il set completo di caratteri non validi può variare dal file system. Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (\<), maggiore di (>), barra verticale (&#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.IO.Path.GetInvalidFileNameChars%2A> (metodo) e <xref:System.IO.Path.GetInvalidPathChars%2A> metodo per recuperare i caratteri non validi.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice contenente i caratteri non consentiti nei nomi di percorso.</summary>
        <returns>Matrice contenente i caratteri non consentiti nei nomi di percorso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory. Il set completo di caratteri non validi può variare dal file system. Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (\<), maggiore di (>), barra verticale (&#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.IO.Path.GetInvalidFileNameChars%2A> (metodo) e <xref:System.IO.Path.GetInvalidPathChars%2A> metodo per recuperare i caratteri non validi.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso dal quale ottenere informazioni sulla directory radice.</param>
        <summary>Ottiene la directory radice del percorso specificato.</summary>
        <returns>La directory radice di <paramref name="path" />, ad esempio "C:\\" oppure <see langword="null" /> se <paramref name="path" /> è <see langword="null" /> oppure una stringa vuota se <paramref name="path" /> non contiene informazioni sulla directory radice.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non verifica che il nome file o il percorso esista.  
  
 Di seguito sono riportati i motivi possibili per la stringa restituita da questo metodo:  
  
-   Una stringa vuota (`path` specificato un percorso relativo in un volume o l'unità corrente).  
  
-   "/" (`path` ha specificato un percorso assoluto nell'unità corrente).  
  
-   "X" (`path` specificato un percorso relativo in un'unità, dove X rappresenta una lettera di unità o volume).  
  
-   "X /" (`path` specificato un percorso assoluto in una determinata unità).  
  
-   "\\\ComputerName\SharedFolder" (un percorso UNC).  
  
 .NET Framework non supporta l'accesso diretto ai dischi fisici mediante i percorsi di nomi di dispositivo, ad esempio "\\\\. \PHYSICALDRIVE0".  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un utilizzo del `GetPathRoot` metodo.  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 oppure  
  
 <see cref="F:System.String.Empty" /> è stato passato a <paramref name="path" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un nome casuale di cartella o di file.</summary>
        <returns>Nome casuale di cartella o di file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Path.GetRandomFileName%2A> metodo restituisce una stringa casuale crittograficamente sicura che può essere utilizzata come nome di una cartella o un nome file. A differenza di <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> non crea un file. Quando la sicurezza del file system è fondamentale, questo metodo deve essere utilizzato al posto di <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente mostra l'output di <xref:System.IO.Path.GetRandomFileName%2A> metodo.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeTo">To be added.</param>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un file temporaneo a zero byte con nome univoco sul disco e restituisce il percorso intero di quel file.</summary>
        <returns>Percorso completo del file temporaneo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un file temporaneo con una. Estensione di file TMP. Il file temporaneo viene creato nella cartella temporanea dell'utente, che è il percorso restituito dal <xref:System.IO.Path.GetTempPath%2A> metodo.  
  
 Il <xref:System.IO.Path.GetTempFileName%2A> metodo genererà un' <xref:System.IO.IOException> se viene utilizzato per creare più di 65535 file senza eliminare i file temporanei precedenti.  
  
 Il <xref:System.IO.Path.GetTempFileName%2A> metodo genererà un' <xref:System.IO.IOException> se non è disponibile alcun nome file temporaneo univoco. Per risolvere questo errore, eliminare tutti i file temporanei non necessari.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si verifica un errore I/O, ad esempio non è disponibile alcun nome univoco del file temporaneo.  
  
 \- oppure -  
  
 Il metodo non consente la creazione di un file temporaneo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la scrittura alla directory temporanea. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il percorso della cartella temporanea dell'utente corrente.</summary>
        <returns>Percorso alla cartella temporanea che termina con una barra rovesciata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo verifica l'esistenza delle variabili di ambiente nell'ordine seguente e utilizza il primo percorso trovato:  
  
1.  Il percorso specificato dalla variabile di ambiente TMP.  
  
2.  Il percorso specificato dalla variabile di ambiente TEMP.  
  
3.  Il percorso specificato dalla variabile di ambiente USERPROFILE.  
  
4.  La directory di Windows.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato come chiamare il metodo <xref:System.IO.Path.GetTempPath%2A>.  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 In questo esempio restituisce un output simile al seguente.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha le autorizzazioni richieste.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso illimitato alle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso in cui cercare un'estensione.</param>
        <summary>Determina se un percorso include un'estensione di nome di file.</summary>
        <returns>
          <see langword="true" /> se i caratteri che seguono l'ultimo separatore di directory (\\\ o /) o di volume (:) nel percorso includono un punto (.) seguito da uno o più caratteri; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dalla fine di `path`, questo metodo cerca un punto (.) seguito da almeno un carattere. Se questo modello si trova prima un <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar> viene rilevato carattere, questo metodo restituisce `true`.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `HasExtension` metodo.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce una matrice di caratteri specifici della piattaforma che non possono essere usati negli argomenti della stringa di percorso passati ai membri della classe <see cref="T:System.IO.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice restituita da questo metodo non deve necessariamente contenere il set completo di caratteri non validi nei nomi di file e directory. Il set completo di caratteri non validi può variare dal file system. Ad esempio, nelle piattaforme desktop basate su Windows, caratteri di percorso non valido potrebbero includere caratteri ASCII/Unicode compresi tra 1 e 31, nonché utilizzare le virgolette ("), minore di (\<), maggiore di (>), barra verticale (&#124;), backspace (\b), null (\0) e carattere di tabulazione (\t).  
  
> [!CAUTION]
>  Non utilizzare <xref:System.IO.Path.InvalidPathChars> se si ritiene che il codice possa essere eseguito nello stesso dominio applicazione come codice non attendibile. <xref:System.IO.Path.InvalidPathChars> è una matrice, pertanto i relativi elementi possono essere sovrascritti. Se il codice non attendibile sovrascrive gli elementi di <xref:System.IO.Path.InvalidPathChars>, potrebbe verificarsi del codice in modo tale che può essere sfruttata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `InvalidPathChars` proprietà.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso da testare.</param>
        <summary>Ottiene un valore che indica se la stringa di percorso specificata contiene una directory radice.</summary>
        <returns>
          <see langword="true" /> se <paramref name="path" /> contiene un percorso radice, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.Path.IsPathRooted%2A> restituisce `true` se il primo carattere è un carattere separatore di directory, ad esempio "\\", o se il percorso deve iniziare con una lettera di unità e i due punti (:). Ad esempio, viene restituito `true` per `path` stringhe, ad esempio "\\\MyDir\\\MyFile.txt", "c:\\\MyDir", o "C:MyDir". Restituisce `false` per `path` stringhe, ad esempio "MyDir".  
  
 Questo metodo non verifica che il nome file o il percorso esista.  
  
 Per un elenco delle attività dei / o comuni, vedere [comuni attività dei / o](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come la `IsPathRooted` metodo può essere utilizzato per testare tre stringhe.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contiene uno o più dei caratteri non validi definiti nel metodo <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carattere separatore specifico della piattaforma, usato per separare le stringhe di percorso nelle variabili di ambiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle piattaforme desktop basate su Windows, il valore di questo campo è il punto e virgola (;) per impostazione predefinita, ma potrebbe variare in altre piattaforme.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `PathSeparator` campo.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce un carattere separatore di volume specifico della piattaforma.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questo campo è di due punti (:) in Windows e Macintosh e una barra (/) nei sistemi operativi UNIX. Ciò è particolarmente utile per l'analisi dei percorsi, ad esempio "c:\windows" o "Cartella MacVolume: System".  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `VolumeSeparatorChar` campo.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>