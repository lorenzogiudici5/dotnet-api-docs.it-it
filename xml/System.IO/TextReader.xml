<Type Name="TextReader" FullName="System.IO.TextReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="54f7136318c4cec38e221ed4595e19903db091e1" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36560653" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TextReader : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit TextReader extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.TextReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextReader&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextReader abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type TextReader = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un visualizzatore in grado di leggere una serie sequenziale di caratteri.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.TextReader> è la classe basa astratta del <xref:System.IO.StreamReader> e <xref:System.IO.StringReader>, quale leggere caratteri da flussi e stringhe, rispettivamente. Utilizzare queste classi derivate per aprire un file di testo per la lettura di un intervallo specificato di caratteri, o per creare un lettore in base a un flusso esistente.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato qualsiasi tipo che deriva da questo tipo, è necessario eliminarlo direttamente o indirettamente di esso. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IO.TextReader.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" e Dispose il <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
   
  
## Examples  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Il <xref:System.IO.StreamReader> classe deriva da <xref:System.IO.TextReader> e fornisce le implementazioni dei membri per la lettura da un flusso. Nell'esempio seguente viene illustrato come leggere tutti i caratteri in un file utilizzando il <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo. Verifica se ogni carattere è una lettera, cifre o spazi vuoti prima di aggiungere il carattere in un'istanza del <xref:System.Text.StringBuilder> classe.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Una classe derivata deve implementare almeno il <see cref="M:System.IO.TextReader.Peek" /> e <see cref="M:System.IO.TextReader.Read" /> metodi per creare un'istanza utile di <see cref="T:System.IO.TextReader" />.</para>
    </block>
    <altmember cref="T:System.IO.StringReader" />
    <altmember cref="T:System.IO.StreamReader" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per le classi derivate.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="textReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude l'oggetto <see cref="T:System.IO.TextReader" /> e libera tutte le risorse di sistema associate a <see langword="TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione di `Close` chiamate il <xref:System.IO.StringReader.Dispose%28System.Boolean%29?displayProperty=nameWithType> metodo e passa un `true` valore.  
  
 Lo scaricamento il lettore di testo non svuotamento del codificatore sottostante a meno che non si chiama in modo esplicito `Close`. Impostazione di <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> proprietà `true` , i dati verranno scaricati dal buffer nel flusso, ma lo stato del codificatore non verrà rimosso. In questo modo il codificatore mantenere lo stato (caratteri parziali) in modo che può codificare correttamente il blocco successivo di caratteri. Questo scenario riguarda UTF8 e UTF7 in cui alcuni caratteri possono essere codificati solo dopo che il codificatore riceve un adiacenti o più caratteri.  
  
> [!NOTE]
>  Nelle classi derivate, non eseguire l'override di <xref:System.IO.TextReader.Close%2A> metodo. Al contrario, eseguire l'override di <xref:System.IO.TextReader.Dispose%28System.Boolean%29?displayProperty=nameWithType> metodo per aggiungere il codice per il rilascio delle risorse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'oggetto <see cref="T:System.IO.TextReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'oggetto <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo <xref:System.IO.TextReader.Dispose%2A> dopo aver terminato di utilizzare l'oggetto <xref:System.IO.TextReader>. Il metodo <xref:System.IO.TextReader.Dispose%2A> lascia l'oggetto <xref:System.IO.TextReader> in una condizione di inutilizzabilità. Dopo la chiamata <xref:System.IO.TextReader.Dispose%2A>, è necessario rilasciare tutti i riferimenti per il <xref:System.IO.TextReader> consentire al garbage collector di recuperare la memoria che il <xref:System.IO.TextReader> occupata.  
  
 Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo <xref:System.IO.TextReader.Dispose%2A> prima di rilasciare l'ultimo riferimento a <xref:System.IO.TextReader>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.IO.TextReader> dell'oggetto <xref:System.Object.Finalize%2A> non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.TextReader" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico `Dispose` metodo e il <xref:System.Object.Finalize%2A> metodo. Per impostazione predefinita, questo metodo consente di specificare il `disposing` parametro come `true`. <xref:System.Object.Finalize%2A> Specifica il `disposing` parametro come `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.IO.TextReader> fa riferimento. Il metodo richiama il metodo `Dispose` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override di questo metodo, prestare attenzione a non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per ulteriori informazioni su come implementare questo metodo, vedere [implementazione di un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per ulteriori informazioni <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.TextReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.TextReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.TextReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As TextReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::TextReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.TextReader" Usage="System.IO.TextReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce un oggetto <see langword="TextReader" /> senza dati da cui sia possibile eseguire letture.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leggere la <xref:System.IO.TextReader.Null> lettore di testo è simile alla lettura dalla fine di un flusso:  
  
-   Il <xref:System.IO.TextReader.Read%2A> e <xref:System.IO.TextReader.Peek%2A> metodi restituiscono -1.  
  
-   Il <xref:System.IO.TextReader.ReadBlock%2A> metodo restituirà zero.  
  
-   Il <xref:System.IO.TextReader.ReadLine%2A> metodo `null`.  
  
-   Il <xref:System.IO.TextReader.ReadToEnd%2A> metodo restituisce una stringa vuota.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; int&#xA;override this.Peek : unit -&gt; int" Usage="textReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge il carattere successivo senza modificare lo stato del visualizzatore o dell'origine del carattere. Restituisce il successivo carattere disponibile senza leggerlo effettivamente dal lettore.</summary>
        <returns>Intero che rappresenta il carattere successivo da leggere oppure -1 se non sono disponibili altri caratteri o se il lettore non supporta la ricerca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.TextReader.Peek%2A> metodo restituisce un valore intero per determinare se si è verificata la fine del file o un altro errore. Ciò consente a un utente verificare se il valore restituito è -1 prima di eseguire il cast a un <xref:System.Char> tipo.  
  
 La posizione corrente del <xref:System.IO.TextReader> non viene modificato da questa operazione. Il valore restituito è -1 se non sono altri caratteri disponibili. L'implementazione predefinita restituisce -1.  
  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.Peek%2A> metodo, vedere il <xref:System.IO.StreamReader.Peek%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <altmember cref="M:System.IO.StreamReader.Peek" />
        <altmember cref="M:System.IO.StringReader.Peek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge dati dal lettore di testo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; int&#xA;override this.Read : unit -&gt; int" Usage="textReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge il carattere successivo dal lettore di testo e fa avanzare di un carattere la posizione del carattere.</summary>
        <returns>Carattere successivo del lettore di testo oppure -1 se non sono disponibili altri caratteri. L'implementazione predefinita restituisce -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.Read%2A> metodo, vedere il <xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <altmember cref="M:System.IO.StreamReader.Read" />
        <altmember cref="M:System.IO.StringReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;char&gt; -&gt; int&#xA;override this.Read : Span&lt;char&gt; -&gt; int" Usage="textReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : char[] * int * int -&gt; int&#xA;override this.Read : char[] * int * int -&gt; int" Usage="textReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se viene raggiunta la fine del reader prima che il numero di caratteri specificato venga letto nel buffer, il metodo restituisce un risultato.</param>
        <summary>Legge un numero massimo specificato di caratteri dal lettore corrente e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Numero di caratteri letti. Il numero sarà minore o uguale a <paramref name="count" />, a seconda che i dati siano disponibili all'interno del lettore o meno. Se viene chiamato quando non sono più disponibili altri caratteri da leggere, questo metodo restituirà zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene restituito dopo che `count` caratteri vengono letti o viene raggiunta la fine del file. <xref:System.IO.TextReader.ReadBlock%2A> è una versione che causano il blocco di questo metodo.  
  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.Read%2A> metodo, vedere il <xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza del buffer meno <paramref name="index" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <altmember cref="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="textReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="textReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se viene raggiunta la fine del testo prima che il numero di caratteri specificato venga letto nel buffer, il metodo corrente terminerà.</param>
        <summary>Legge un numero massimo specificato di caratteri dal lettore di testo corrente in modo asincrono e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a zero se è stata raggiunta la fine del testo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività viene completata dopo che il numero di caratteri specificato dal `count` parametro vengono lette o viene raggiunta la fine del file.  
  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.ReadAsync%2A> metodo, vedere il <xref:System.IO.StreamReader.ReadAsync%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="index" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">Il lettore di testo è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public virtual int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlock : Span&lt;char&gt; -&gt; int&#xA;override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="textReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public virtual int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlock : char[] * int * int -&gt; int&#xA;override this.ReadBlock : char[] * int * int -&gt; int" Usage="textReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina,questo parametro contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere.</param>
        <summary>Legge un numero massimo specificato di caratteri dal lettore di testo corrente e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Numero di caratteri letti. Il numero sarà minore o uguale a <paramref name="count" />, a seconda che tutti i caratteri di input siano stati letti o meno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La posizione del lettore di testo sottostante viene anticipata per il numero di caratteri letti nella `buffer`.  
  
 Il metodo si blocca fino a quando non `count` vengono letti i caratteri, o sono stati letti tutti i caratteri. Si tratta di una versione che causano il blocco di <xref:System.IO.TextReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza del buffer meno <paramref name="index" /> è minore di <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="textReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="textReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando il metodo termina, il buffer contiene la matrice di caratteri specificata con i valori compresi tra <c>index</c> e (<c>index</c> + <c>count</c> - 1) sostituiti dai caratteri letti dall'origine corrente.</param>
        <param name="index">Posizione in <c>buffer</c> da cui iniziare la scrittura.</param>
        <param name="count">Numero massimo di caratteri da leggere. Se viene raggiunta la fine del testo prima che il numero di caratteri specificato venga letto nel buffer, il metodo corrente terminerà.</param>
        <summary>Legge un numero massimo specificato di caratteri dal lettore di testo corrente in modo asincrono e scrive i dati in un buffer, a partire dall'indice specificato.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro di <paramref name="TResult" /> contiene il numero totale di byte letti nel buffer. Il valore del risultato può essere minore del numero di byte richiesti se il numero di byte attualmente disponibili è minore di quelli richiesti o può essere pari a zero se è stata raggiunta la fine del testo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività non viene completata finché il numero di caratteri specificato dal `count` parametro sono di lettura o è stata raggiunta la fine del testo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">La somma di <paramref name="index" /> e <paramref name="count" /> è maggiore della lunghezza del buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">Il lettore di testo è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public virtual string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="abstract member ReadLine : unit -&gt; string&#xA;override this.ReadLine : unit -&gt; string" Usage="textReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge una riga di caratteri dal lettore di testo e restituisce i dati come stringa.</summary>
        <returns>Riga successiva dal lettore oppure <see langword="null" /> se tutti i caratteri sono stati letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una riga viene definita come una sequenza di caratteri seguiti da un ritorno a capo (0x000d), un avanzamento riga (0x000a), un ritorno a capo seguito da un avanzamento riga, <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>, o il marcatore di fine del flusso. La stringa restituita non contiene il carattere di terminazione ritorno a capo o avanzamento riga. Il valore restituito è `null` se è stata raggiunta la fine del flusso di input.  
  
 Se il metodo genera un' <xref:System.OutOfMemoryException> eccezione, la posizione del lettore nell'oggetto sottostante <xref:System.IO.Stream> avanzate per il numero di caratteri, il metodo è stato in grado di leggere, ma i caratteri che sono stati già letta interna <xref:System.IO.TextReader.ReadLine%2A> sono buffer rimossi. Poiché la posizione del lettore nel flusso non può essere modificata, i caratteri che sono stati già letti sono irreversibili e sono accessibili solo reinizializzando il <xref:System.IO.TextReader> oggetto. Se la posizione iniziale all'interno del flusso è sconosciuta o il flusso non supporta il posizionamento, sottostante <xref:System.IO.Stream> deve inoltre essere reinizializzata.  
  
 Per evitare una situazione di questo tipo e produrre codice efficiente è consigliabile utilizzare il <xref:System.IO.TextReader.Read%2A> (metodo) e store i caratteri di lettura in un buffer allocato precedentemente.  
  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.ReadLine%2A> metodo, vedere il <xref:System.IO.StreamReader.ReadLine%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per l’allocazione di un buffer per la stringa restituita.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri nella riga successiva è maggiore di <see cref="F:System.Int32.MaxValue" /></exception>
        <altmember cref="M:System.IO.StreamReader.ReadLine" />
        <altmember cref="M:System.IO.StringReader.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="textReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge una riga di caratteri in modo asincrono e restituisce i dati come stringa.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene la riga successiva del lettore di testo oppure è <see langword="null" /> se tutti i caratteri sono stati letti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.ReadLineAsync%2A> metodo, vedere il <xref:System.IO.StreamReader.ReadLineAsync%2A?displayProperty=nameWithType> metodo.  
  
 Se corrente <xref:System.IO.TextReader> rappresenta il flusso di input standard restituito dal <xref:System.Console.In%2A?displayProperty=nameWithType> proprietà, il <xref:System.IO.TextReader.ReadLineAsync%2A> il metodo viene eseguito in modo sincrono anziché in modo asincrono.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri nella riga successiva è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il lettore di testo è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadLineAsync" />
        <altmember cref="M:System.IO.StringReader.ReadLineAsync" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public virtual string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="abstract member ReadToEnd : unit -&gt; string&#xA;override this.ReadToEnd : unit -&gt; string" Usage="textReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge tutti i caratteri dalla posizione corrente fino alla fine del lettore di testo e li restituisce come singola stringa.</summary>
        <returns>Stringa contenente tutti i caratteri dalla posizione corrente fino alla fine del lettore di testo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il metodo genera un' <xref:System.OutOfMemoryException> eccezione, la posizione del lettore nell'oggetto sottostante <xref:System.IO.Stream> avanzate per il numero di caratteri, il metodo è stato in grado di leggere, ma i caratteri che sono stati già letta interna <xref:System.IO.TextReader.ReadToEnd%2A> sono buffer rimossi. Poiché la posizione del lettore nel flusso non può essere modificata, i caratteri che sono stati già letti sono irreversibili e sono accessibili solo reinizializzando il <xref:System.IO.TextReader>. Se la posizione iniziale all'interno del flusso è sconosciuta o il flusso non supporta il posizionamento, sottostante <xref:System.IO.Stream> deve inoltre essere reinizializzata.  
  
 Per evitare una situazione di questo tipo e produrre codice efficiente è consigliabile utilizzare il <xref:System.IO.TextReader.Read%2A> (metodo) e store i caratteri di lettura in un buffer allocato precedentemente.  
  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.ReadToEnd%2A> metodo, vedere il <xref:System.IO.StreamReader.ReadToEnd%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.TextReader" /> è chiuso.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per l’allocazione di un buffer per la stringa restituita.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri nella riga successiva è maggiore di <see cref="F:System.Int32.MaxValue" /></exception>
        <altmember cref="M:System.IO.StreamReader.ReadToEnd" />
        <altmember cref="M:System.IO.StringReader.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="textReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.IO.TextReader/&lt;ReadToEndAsync&gt;c__async0))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge in modo asincrono tutti i caratteri dalla posizione corrente fino alla fine del lettore di testo e li restituisce come singola stringa.</summary>
        <returns>Attività che rappresenta l'operazione di lettura asincrona. Il valore del parametro <paramref name="TResult" /> contiene una stringa con i caratteri compresi tra la posizione corrente e l'estremità del lettore di testo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.TextReader> è una classe astratta. Di conseguenza, non verrà creata un'istanza nel codice. Per un esempio di utilizzo di <xref:System.IO.TextReader.ReadToEndAsync%2A> metodo, vedere il <xref:System.IO.StreamReader.ReadToEndAsync%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di caratteri è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il lettore di testo è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">Il lettore è attualmente usato da un'operazione di lettura precedente.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadToEndAsync" />
        <altmember cref="M:System.IO.StringReader.ReadToEndAsync" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader Synchronized (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.TextReader Synchronized(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Synchronized(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (reader As TextReader) As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::TextReader ^ Synchronized(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.TextReader -&gt; System.IO.TextReader" Usage="System.IO.TextReader.Synchronized reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see langword="TextReader" /> da sincronizzare.</param>
        <summary>Crea un wrapper thread-safe per l'oggetto <see langword="TextReader" /> specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.TextReader" /> thread-safe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo corrente terminerà di una classe che esegue il wrapping intorno specificato <xref:System.IO.TextReader> istanza e ne limita l'accesso da più thread. Tutte le letture dal wrapper restituito sarà thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>