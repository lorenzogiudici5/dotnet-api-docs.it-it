<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac3ffad84738935580a11dd5acf01cdedc2192d2" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52218304" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il modulo <see langword="FileSystem" /> contiene le procedure utilizzate per eseguire operazioni su file, directory o cartelle e sistema. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto all'utilizzo del modulo <see langword="FileSystem" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo modulo supporta le parole chiave del linguaggio Visual Basic e membri delle librerie di runtime che accedono a file e cartelle.  
  
   
  
## Examples  
 Questo esempio viene usato il `GetAttr` funzione per determinare gli attributi di file e directory o cartella.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Riepilogo di directory e file</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Riepilogo di input e output</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Parole chiave (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory o la cartella che diventa la nuova directory o cartella predefinita. Il parametro <paramref name="Path" /> può includere l'unità. Se non viene specificata alcuna unità, <see langword="ChDir" /> cambia la directory o cartella predefinita dell'unità corrente.</param>
        <summary>Cambia la directory o cartella corrente. Nelle operazioni di I/O su file la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="ChDir" />. Per ulteriori informazioni, vedi <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDir` funzione modifica la directory predefinita, ma non l'unità predefinita. Ad esempio, se l'unità predefinita è C, l'istruzione seguente modifica la directory predefinita nell'unità D, mentre C rimane l'unità predefinita:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 È possibile rendere relativo le modifiche della directory è necessario digitare due punti, come indicato di seguito:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Il `ChDir` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e.  
  
   
  
## Examples  
 Questo esempio viene usato il `ChDir` funzione per modificare la directory o cartella corrente.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> è vuoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedura: analizzare percorsi di file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Creazione, eliminazione e spostamento di file e directory in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cambia l'unità corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Obbligatorio. Espressione String che specifica un'unità esistente. Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata. Se l'argomento <paramref name="Drive" /> è una stringa di più caratteri, <see langword="ChDrive" /> utilizza solo la prima lettera.</param>
        <summary>Cambia l'unità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDrive` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio viene usato il `ChDrive` funzione per modificare l'unità corrente. La funzione genera un'eccezione se l'unità non esiste.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Obbligatorio. Espressione String che specifica un'unità esistente. Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata. Se l'argomento <paramref name="Drive" /> è una stringa di più caratteri, <see langword="ChDrive" /> utilizza solo la prima lettera.</param>
        <summary>Cambia l'unità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDrive` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio viene usato il `ChDrive` funzione per modificare l'unità corrente. La funzione genera un'eccezione se l'unità non esiste.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Stringa che rappresenta il percorso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene usato il `CurDir` funzione per restituire il percorso corrente.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Facoltativo. Espressione <see langword="Char" /> che specifica un'unità esistente. Se non si specifica alcuna unità, o se <paramref name="Drive" /> è una strina di lunghezza zero (""), <see langword="CurDir" /> restituisce il percorso dell'unità corrente.</param>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Stringa che rappresenta il percorso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene usato il `CurDir` funzione per restituire il percorso corrente.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.  
  
 `VbVolume` Restituisce l'etichetta di volume per l'unità anziché un nome file specifico.  
  
 È necessario specificare una `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l'elemento successivo, è possibile eseguire le chiamate successive al `Dir` funzione senza parametri.  
  
> [!IMPORTANT]
>  Per eseguire correttamente, il `Dir` funzione richiede la <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbnormal`|Predefinita. Specifica i file senza attributi.|  
|`ReadOnly`|`vbReadOnly`|Specifica i file di sola lettura, nonché i file senza attributi.|  
|`Hidden`|`vbHidden`|Specifica i file nascosti, nonché i file senza attributi.|  
|`System`|`vbSystem`|Specifica i file di sistema, nonché i file senza attributi.|  
|`Volume`|`vbVolume`|Specifica l'etichetta di volume. Se viene specificato qualsiasi altro attributo, `vbVolume` viene ignorato.|  
|`Directory`|`vbDirectory`|Specifica le directory o cartelle, nonché i file senza attributi.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni sono specificate dal linguaggio Visual Basic e possono essere utilizzate ovunque nel codice anziché i valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene usato il `Dir` per verificare la presenza di determinati file e directory.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Facoltativo. Espressione <see langword="String" /> che specifica un nome di file, directory o cartella o un'etichetta di volume di un'unità. Se <paramref name="PathName" /> non viene trovato, verrà restituita una stringa di lunghezza zero (<see langword="&quot;&quot;" />).</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Facoltativo. Enumerazione o espressione numerica il cui valore specifica attributi di file. Se omesso, <see langword="Dir" /> restituisce file che corrispondono a <paramref name="PathName" /> ma sono privi di attributi.</param>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.  
  
 `VbVolume` Restituisce l'etichetta di volume per l'unità anziché un nome file specifico.  
  
 È necessario specificare una `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l'elemento successivo, è possibile eseguire le chiamate successive al `Dir` funzione senza parametri.  
  
> [!IMPORTANT]
>  Per eseguire correttamente, il `Dir` funzione richiede la <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbnormal`|Predefinita. Specifica i file che sono privi di attributi.|  
|`ReadOnly`|`vbReadOnly`|Specifica i file di sola lettura, oltre ai file che sono privi di attributi.|  
|`Hidden`|`vbHidden`|Specifica i file nascosti, oltre ai file che sono privi di attributi.|  
|`System`|`vbSystem`|Specifica i file di sistema, oltre ai file che sono privi di attributi.|  
|`Volume`|`vbVolume`|Specifica l'etichetta di volume. Se viene specificato qualsiasi altro attributo, `vbVolume` viene ignorato.|  
|`Directory`|`vbDirectory`|Specifica le directory o cartelle, oltre ai file che sono privi di attributi.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni sono specificate dal linguaggio Visual Basic e possono essere utilizzate ovunque nel codice al posto dei valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene usato il `Dir` per verificare la presenza di determinati file e directory.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene qualsiasi numero di file valido.</param>
        <summary>Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</summary>
        <returns>Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare `EOF` per evitare l'errore generato dal tentativo di ottenere l'input oltre la fine di un file.  
  
 Il `EOF` funzione restituisce `False` fino a quando non è stata raggiunta la fine del file. Con i file aperti per `Random` o `Binary` access `EOF` restituisce `False` fino all'ultima esecuzione `FileGet` funzione è in grado di leggere un intero record.  
  
 Con i file aperti per `Binary` accedere, un tentativo di leggere il file usando il `Input` funzionare fino all'avviso `EOF` restituisce `True` genera un errore. Usare la `LOF` e `Loc` funzioni anziché `EOF` durante la lettura di file binari con `Input`, o usare `Get` quando si usa il `EOF` (funzione). Con i file aperti per `Output`, `EOF` restituisce sempre `True`.  
  
   
  
## Examples  
 Questo esempio viene usato il `EOF` funzione per rilevare la fine di un file. Questo esempio si presuppone che `Testfile` è un file di testo che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" />. Qualsiasi numero di file valido.</param>
        <summary>Restituisce un'enumerazione che rappresenta la modalità di file per i file aperti utilizzando la funzione <see langword="FileOpen" />. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="FileAttr" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>La modalità di accesso al file è indicata dai seguenti valori di enumerazione: 
 <list type="table"><item><term> Valore 
 </term><description> Modalità 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa funzione restituisce un'enumerazione che rappresenta la modalità di file per i file aperti utilizzando la `FileOpen` (funzione).  
  
   
  
## Examples  
 Questo esempio viene usato il `FileAttr` funzione per restituire la modalità file di un file aperto.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Facoltativo. Matrice di parametri di 0 o più canali da chiudere.</param>
        <summary>Conclude le operazioni di input/output (I/O) in un file aperto con la funzione <see langword="FileOpen" />. Nelle operazioni di I/O di file <see langword="My" /> garantisce produttività e prestazioni migliori. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileClose` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [come: Leggi testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), e [procedura dettagliata: modifica dei file e directory in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Se si omette `FileNumbers`, tutti i file attivi aperti dal `FileOpen` funzione vengono chiusi.  
  
 Quando si chiudono i file che sono stati aperti per `Output` o `Append`, il buffer finale dell'output viene scritto nel buffer del sistema operativo per il file. Spazio associato chiuso tutti i buffer file viene rilasciato.  
  
 Quando il `FileClose` funzione viene eseguita, l'associazione di un file con il relativo file numero termina.  
  
   
  
## Examples  
 Questo esempio Usa la `FileClose` funzione per chiudere un file aperto per `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Istruzione End</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Istruzione Stop (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Obbligatorio. Espressione <see langword="String" /> che specifica il nome del file da copiare. L'oggetto <paramref name="Source" /> può includere la directory o la cartella e l'unità del file di origine.</param>
        <param name="Destination">Obbligatorio. Espressione <see langword="String" /> che specifica il nome file di destinazione. L'oggetto <paramref name="Destination" /> può includere la directory o la cartella e l'unità del file di destinazione.</param>
        <summary>Copia un file. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="FileCopy" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si prova a usare il `FileCopy` funzionano in un file attualmente aperto, si verifica un errore.  
  
 `FileCopy` richiede l'attendibilità a funzionare nell'unità locale.  
  
   
  
## Examples  
 Questo esempio viene usato il `FileCopy` per copiare un file a un'altra funzione. Ai fini di questo esempio, si supponga che `SrcFile` è un file che contiene i dati.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> o <paramref name="Destination" /> non è valido o non è specificato.</exception>
        <exception cref="T:System.IO.IOException">Il file è già aperto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Procedura: creare una copia di un file in una directory diversa in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedura: creare una copia di un file nella stessa directory in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedura: copiare una directory in un'altra directory di Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome file. <paramref name="PathName" /> può includere la directory o cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="Date" /> che indica la data e l'ora della scrittura in un file. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileDateTime" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Valore <see langword="Date" /> che indica la data e l'ora di creazione o dell'ultima modifica di un file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene usato il `FileDateTime` funzione per determinare la data e ora di un file è stato creato o modificato. Il formato della data e ora visualizzata è basato sulle impostazioni locali del sistema.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> non è valido o contiene caratteri jolly.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di destinazione non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il`FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se non viene utilizzato il descrittore. Le dimensioni e i limiti della matrice passato nella `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione,`FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il`FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza. Il valore predefinito è <see langword="False" />.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <param name="ArrayIsDynamic">Facoltativo. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere considerata una matrice dinamica e se è necessario un descrittore della matrice che descrive le dimensioni e i limiti della matrice.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza. Il valore predefinito è <see langword="False" />.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record. Lo spazio tra la fine di un record e il valore iniziale del record successivo viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore di, è necessario il descrittore di lettura. Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i loro descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco.  La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGetObject" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileGetObject` funzione viene usata invece di `FileGet` per evitare ambiguità in fase di compilazione se tipo `Object` viene restituito invece un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.  
  
 Se si prevede di scrivere la `Variant` tipo, `FileGetObject` è obbligatorio. In caso di dubbi, se si usa un oggetto per il secondo parametro, è consigliabile usare `FilePutObject` e `FileGetObject`.  
  
 `FileGetObject` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati letti tramite `FileGetObject` vengono in genere scritti con `FilePutObject`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, `FileGetObject` legge il record o byte dopo l'ultimo `FileGetObject` oppure `FilePutObject` funzione (o a cui punta l'ultimo `Seek` (funzione)).  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGetObject` legge i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare in modo preciso, è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Se la variabile in cui si legge è una stringa, per impostazione predefinita `FileGetObject` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano le stringhe a lunghezza fissa e durante la lettura in un file, il descrittore di lunghezza non viene scritto. Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è necessario che la lunghezza del record specificata dal parametro `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: 2 + 8 * NumberOfDimensions.  
  
     Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     I byte 218 vengono distribuiti come segue: 18 byte per il descrittore di (2 + 8 * 2) e 100 byte per i dati (10 * 5 * 4).  
  
-   `FileGetObject` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePutObject`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: 2 + 8 * NumberOfDimensions. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi, incluse le matrici e i loro descrittori. Il <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe può essere applicata ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, tutti i `Random` si applicano le regole, con le seguenti eccezioni:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FileGetObject` legge tutte le variabili da disco in modo contiguo, vale a dire, senza alcun riempimento tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGetObject` legge solo i dati. Nessun descrittore di lettura.  
  
 `FileGetObject` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
   
  
## Examples  
 Nell'esempio seguente legge un record in un file di test e quindi li recupera.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un file. <paramref name="PathName" /> può includere la directory o cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="Long" /> che specifica la lunghezza di un file in byte. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileLen" />. Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Valore <see langword="Long" /> che specifica la lunghezza di un file in byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file specificato è aperto quando il `FileLen` funzione viene chiamata, il valore restituito rappresenta le dimensioni del file al momento è stato aperto.  
  
> [!NOTE]
>  Per ottenere la lunghezza corrente di un file aperto, usare il `LOF` (funzione).  
  
   
  
## Examples  
 Questo esempio viene usato il `FileLen` funzione per restituire la lunghezza di un file in byte. Ai fini di questo esempio, si supponga che `TestFile` è un file che contiene alcuni dati.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il file non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido. Utilizza la funzione <see langword="FreeFile" /> per ottenere il successivo numero di file disponibile.</param>
        <param name="FileName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome di file. Può includere la directory o la cartella e l'unità.</param>
        <param name="Mode">Obbligatorio. Enumerazione che specifica la modalità per il file: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> o <see langword="Random" />. Per ulteriori informazioni, vedi <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Facoltativo. Enumerazione che specifica le operazioni autorizzate sul file aperto: <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />. Il valore predefinito è <see langword="ReadWrite" />. Per ulteriori informazioni, vedi <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Facoltativo. Enumerazione che specifica le operazioni non autorizzate sul file aperto da altri processi: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> e <see langword="Lock Read Write" />. Il valore predefinito è <see langword="Lock Read Write" />. Per ulteriori informazioni, vedi <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Facoltativo. Numero minore o uguale a 32.767 byte. Per i file aperti per l'accesso Random, questo valore rappresenta la lunghezza del record. Per i file sequenziali, questo valore rappresenta il numero di caratteri memorizzati nel buffer.</param>
        <summary>Apre un file per l'input o l'output. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileOpen" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileOpen` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 È necessario aprire un file prima di qualsiasi operazione dei / o può essere eseguita su di esso. `FileOpen` Alloca un buffer dei / o al file e determina la modalità di accesso da usare con il buffer.  
  
> [!IMPORTANT]
>  Quando si scrive in un file, un'applicazione potrebbe essere necessario creare un file, se il file a cui sta tentando di scrivere non esiste. A tale scopo, necessaria l'autorizzazione per la directory in cui il file deve essere creato. Tuttavia, se il file specificato da `FileName` esiste, l'applicazione deve `Write` l'autorizzazione solo per il file stesso. Ovunque possibile, per migliorare la sicurezza, creare il file durante la distribuzione e concedere `Write` le autorizzazioni per tale file unico, anziché per l'intera directory. Per contribuire al miglioramento della protezione, scrivere i dati invece di directory degli utenti della directory radice o nella directory programmi.  
  
 È reperibile il canale da aprire usando la `FreeFile()` (funzione).  
  
> [!IMPORTANT]
>  Il `FileOpen` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere l'enumerazione <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In questo esempio illustra i vari utilizzi del `FileOpen` funzione per abilitare l'input e output in un file.  
  
 Il codice seguente apre il file `TestFile` in `Input` modalità.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Questo esempio viene aperto il file in `Binary` modalità per operazioni di sola scrittura.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Nell'esempio seguente viene aperto il file in `Random` modalità. Il file contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Questo esempio di codice consente di aprire il file in `Output` modalità, le operazioni possono leggere o scrivere nel file.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Questo esempio di codice consente di aprire il file in `Binary` modalità per la lettura; gli altri processi non è possibile leggere i file.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Lunghezza del record negativa (e diversa da -1).</exception>
        <exception cref="T:System.IO.IOException">Il parametro <paramref name="FileName" /> è già aperto oppure <paramref name="FileName" /> non è valido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il`VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel`RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <param name="ArrayIsDynamic">Facoltativo. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere considerata dinamica e se deve essere scritto un descrittore di matrice per la stringa che descrive la lunghezza.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`. Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice. Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.  
  
    > [!NOTE]
    >  Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Viene scritto alcun descrittore.  
  
-   `FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco.  La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePutObject" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FilePutObject` funzione viene usata invece di `FilePut` per evitare ambiguità in fase di compilazione se tipo `Object` viene passato anziché un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.  
  
 `FilePutObject` scrive e legge i descrittori che descrivono l'oggetto. Se si prevede di scrivere la `Variant` tipo, `FilePutObject` è obbligatorio. In caso di dubbi, se si usa un oggetto per il secondo parametro, è consigliabile usare sempre `FilePutObject` e `FileGetObject`.  
  
 `FilePutObject` è valido solo nei `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePutObject` vengono in genere letti da un file usando `FileGetObject`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via. Se si omette `RecordNumber`, `FilePutObject` scriva il record o byte dopo l'ultimo `FileGetObject` oppure `FilePutObject` funzione (o il record o byte a cui punta l'ultimo `Seek` (funzione)).  
  
 Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePutObject` non scrive il descrittore di lunghezza quando l'argomento è `True`. Se si usa `StringIsFixedLength`  =  `True` con `FilePutObject`, è necessario eseguire la stessa operazione con `FileGetObject`, e assicurarsi che la stringa viene inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, applicano le regole seguenti:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePutObject` scrive i record successivi su limiti di lunghezza di record. Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente. Poiché la quantità di dati di spaziatura interna non è possibile determinare in modo preciso, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, viene generata un'eccezione.  
  
-   Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePutObject` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePutObject` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se un oggetto che contiene una stringa, la variabile scritta `FilePutObject` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario che la lunghezza del record specificata dalla clausola `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità. La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, tutti la `Random` si applicano le regole della modalità, ad eccezione di:  
  
-   Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto. `FilePutObject` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.  
  
   
  
## Examples  
 Questo esempio viene usato il `FilePutObject` funzione per scrivere una stringa in un file.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="RecordWidth">Obbligatorio. Espressione numerica compresa nell'intervallo tra 0 e 255 inclusi, che indica quanti caratteri devono comparire in una riga prima che venga iniziata una nuova riga. Se <paramref name="RecordWidth" /> è uguale a 0, non viene impostato alcun limite per la lunghezza delle righe. Il valore predefinito di <paramref name="RecordWidth" /> è 0.</param>
        <summary>Assegna lo spessore della linea di output per un file aperto mediante la funzione <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene usato il `FileWidth` funzione per impostare la larghezza della riga di output per un file.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</summary>
        <returns>Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare `FreeFile` per fornire un numero di file che non è già in uso.  
  
   
  
## Examples  
 Questo esempio viene usato il `FreeFile` funzione per restituire il successivo numero di file disponibili. Cinque file aperti per l'output all'interno del ciclo e alcuni dati di esempio sono scritto per ognuno.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Più di 255 file sono in uso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome di file, directory o cartella. L'oggetto <paramref name="PathName" /> può includere la directory o la cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="FileAttribute" /> che rappresenta gli attributi di un file, di una directory o di una cartella. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileAttribute" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Il valore restituito dalla funzione <see langword="GetAttr" /> è la somma dei seguenti valori di enumerazione: 
 <list type="table"><item><term> Valore 
 </term><description> Costante 
 </description><description> Descrizione 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normale.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Sola lettura.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Nascosto.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> File di sistema.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory o cartella.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Il file è stato modificato dopo l'ultimo backup.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Il file ha un nome diverso.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Queste enumerazioni sono specificate dal linguaggio Visual Basic. e possono essere utilizzate in qualsiasi punto del codice in sostituzione dei valori effettivi.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare quali attributi sono impostati, usare il `And` operatore per eseguire un confronto bit per bit del valore restituito dal `GetAttr` (funzione) e il valore dell'attributo del file desiderato. Se il risultato non è zero, tale attributo è impostato per il file specificato. Ad esempio, il valore restituito di quanto segue `And` espressione è zero se il `Archive` attributo non è impostato:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Viene restituito un valore diverso da zero se il `Archive` attributo è impostato.  
  
   
  
## Examples  
 Questo esempio viene usato il `GetAttr` funzione per determinare gli attributi di file e directory o cartella.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> non è valido o contiene caratteri jolly.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di destinazione non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">Operatore And (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.  
  
 Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica. Nella tabella seguente viene illustrato come vengono considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Eliminazione di virgola o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|Per la compilazione di TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La data o ora rappresentato dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili. Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="CharCount">Obbligatorio. Qualsiasi espressione numerica valida che specifica il numero di caratteri da leggere.</param>
        <summary>Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `InputString` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dati letti con il `InputString` funzione viene in genere scritti in un file mediante `Print` o `FilePut`. Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.  
  
 A differenza di `Input` funzione, il `InputString` funzione restituisce tutti i caratteri letti. Si tratta di virgole, ritorni a capo, avanzamento riga, racchiusi tra virgolette e spazi iniziali.  
  
 Con i file aperti per `Binary` accedere, un tentativo di leggere i file usando il `InputString` funzionare fino al `EOF` restituisce `True` genera un errore. Usare la `LOF` e `Loc` funzioni anziché `EOF` quando la lettura di file binari tramite `InputString`, o usare `FileGet` quando si usa il `EOF` (funzione).  
  
> [!NOTE]
>  Durante la lettura dai file, non prendere decisioni di protezione sul contenuto del file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
   
  
## Examples  
 Questo esempio Usa la `InputString` funzione per leggere un carattere alla volta da un file ed eseguire la stampa per il `Output` finestra. Questo esempio si presuppone che `MyFile` è un file di testo che presenta più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 o &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica uno o più nomi file da eliminare. L'oggetto <paramref name="PathName" /> può includere la directory o la cartella e l'unità.</param>
        <summary>Elimina i file da un disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Kill" />. Per ulteriori informazioni, vedi <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.  
  
 **Nota sulla sicurezza** per eseguire, il `Kill` funzione richiede `Read` e `PathDiscovery` flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione. Per altre informazioni, vedere <xref:System.Security.SecurityException> [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Questo esempio viene usato il `Kill` funzione per eliminare un file da un disco.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File di destinazione aperti.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File di destinazione non trovati.</exception>
        <exception cref="T:System.Security.SecurityException">Autorizzazione negata.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</summary>
        <returns>Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `LineInput` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti tramite `LineInput` viene in genere scritti in un file mediante `Print`.  
  
> [!IMPORTANT]
>  Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.  
  
 Il `LineInput` funzione legge da un file di un carattere alla volta finché non viene rilevato un ritorno a capo (`Chr(13)`) o ritorno a capo/avanzamento riga (`Chr(13) + Chr(10)`) sequenza. Le sequenze di feed di ritorno a capo/riga vengono ignorate invece di aggiunto alla stringa di caratteri.  
  
> [!IMPORTANT]
>  Lettura da un file usando il `LineInput` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene usato il `LineInput` funzione per leggere una riga da un file sequenziale e assegnarlo a una variabile. Questo esempio si presuppone che `TestFile` è un file di testo che presenta più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Raggiunta la fine del file.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file <see langword="Integer" /> valido.</param>
        <summary>Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</summary>
        <returns>Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Loc` funzione è in base zero, usarlo per recuperare il primo byte in un file, verrà restituito 0.  
  
 Il `Loc` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Di seguito viene descritto il valore restituito per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero dell'ultimo record di leggere o scrivere nel file.|  
|`Sequential`|Posizione corrente di byte nel file diviso 128. Tuttavia, le informazioni restituite dalla `Loc` per file sequenziali non viene utilizzata né necessaria.|  
|`Binary`|Posizione dell'ultimo byte letti o scritti.|  
  
   
  
## Examples  
 Questo esempio viene usato il `Loc` funzione per restituire la posizione di lettura/scrittura corrente in un file aperto. Questo esempio si presuppone che `MyFile` è un file di testo che presenta più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Record">Facoltativo. Numero del record o byte da bloccare o sbloccare</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="FromRecord">Facoltativo. Numero del primo record o byte da bloccare o sbloccare.</param>
        <param name="ToRecord">Facoltativo. Numero dell'ultimo record o byte da bloccare o sbloccare.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <summary>Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il `FileLen` funzione per ottenere la lunghezza di un file che non è aperta.  
  
   
  
## Examples  
 Questo esempio viene usato il `LOF` funzione per determinare le dimensioni di un file aperto. Questo esempio si presuppone che `TestFile` è un file di testo che contiene i dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory da creare. Il parametro <paramref name="Path" /> può includere l'unità. Se non viene specificata alcuna unità, <see langword="MkDir" /> crea la nuova directory nell'unità corrente.</param>
        <summary>Crea una nuova directory. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="MkDir" />. Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa funzione crea una nuova directory.  
  
   
  
## Examples  
 Questo esempio viene usato il `MkDir` funzione per creare una directory. Se l'unità non è specificato, viene creata nella nuova directory nell'unità corrente.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> non è specificato o è vuoto.</exception>
        <exception cref="T:System.Security.SecurityException">Autorizzazione negata.</exception>
        <exception cref="T:System.IO.IOException">Directory già esistente.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Procedura: creare una directory in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Output">Facoltativo. Zero o più espressioni con valori delimitati da virgole da scrivere in un file.  
  
Le impostazioni dell'argomento <paramref name="Output" /> sono le seguenti: 
 <see langword="T:System.IO.IOException" />: la modalità File non è valida.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> non esiste.</param>
        <summary>Scrive i dati formattati per la visualizzazione in un file sequenziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Print` e `PrintLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` non include una riga alla fine di una riga; del feed Tuttavia, `PrintLine` includono un avanzamento riga.  
  
 I dati scritti con `Print` viene in genere letti da un file mediante `LineInput` o `Input`.  
  
 Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota al file; per `Print`, nulla è output. Più espressioni separate da virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.  
  
 Per la `Boolean` dei dati, ad esempio `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.  
  
 Dati relativi alla data viene scritto nel file usando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.  
  
 Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` i dati elenco viene `DBNull`, `Null` viene scritto nel file.  
  
 Per la `Error` dei dati, l'output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.  
  
 Tutti i dati scritti nel file usando `Print` internazionali; vale a dire i dati siano formattati correttamente usando il separatore decimale appropriato. Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.  
  
 La scrittura in un file usando il `Print` o `PrintLine` funzioni richiede `Write` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio Usa la `Print` e `PrintLine` funzioni per scrivere dati in un file.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Output">Facoltativo. Zero o più espressioni con valori delimitati da virgole da scrivere in un file.  
  
Le impostazioni dell'argomento <paramref name="Output" /> sono le seguenti: 
 <see langword="T:System.IO.IOException" />: la modalità File non è valida.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> non esiste.</param>
        <summary>Scrive i dati formattati per la visualizzazione in un file sequenziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Print` e `PrintLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` non include una riga alla fine di una riga; del feed Tuttavia,`PrintLine` includono un avanzamento riga.  
  
 I dati scritti con `Print` viene in genere letti da un file mediante `LineInput` o `Input`.  
  
 Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota al file; per `Print`, nulla è output. Più espressioni separate da virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.  
  
 Per la `Boolean` dei dati, ad esempio `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.  
  
 Dati relativi alla data viene scritto nel file usando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.  
  
 Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` i dati elenco viene `DBNull`, `Null` viene scritto nel file.  
  
 Per la `Error` dei dati, l'output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.  
  
 Tutti i dati scritti nel file usando `Print` internazionali; vale a dire i dati siano formattati correttamente usando il separatore decimale appropriato. Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.  
  
 La scrittura in un file usando il `Print` o `PrintLine` funzioni richiede `Write` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio Usa la `Print` e `PrintLine` funzioni per scrivere dati in un file.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Obbligatorio. Espressione <see langword="String" /> che specifica il nome file esistente e il relativo percorso. L'oggetto <paramref name="OldPath" /> può includere la directory e l'unità del file.</param>
        <param name="NewPath">Obbligatorio. Espressione <see langword="String" /> che specifica il nuovo nome file e il relativo percorso. L'oggetto <paramref name="NewPath" /> può includere la directory e l'unità del percorso di destinazione. Il nome file specificato da <paramref name="NewPath" /> non deve esistere.</param>
        <summary>Rinomina un file o una directory su disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Rename" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il`Rename` funzione Rinomina un file e spostarlo in una directory diversa, se necessario. Il `Rename` funzione può spostare un file in unità, ma è possibile rinominare solo una directory esistente quando entrambe `NewPath` e `OldPath` si trovano nella stessa unità. `Rename` non è possibile creare un nuovo file o directory.  
  
 Uso di `Rename` funzione in un file aperto genera un errore. È necessario chiudere un file aperto prima di rinominarlo. `Rename` argomenti non possono includere più caratteri (*) e caratteri jolly (?) di caratteri a singolo.  
  
> [!IMPORTANT]
>  Quando si usa `Rename` per copiare un file da un percorso non protetto in un percorso protetto, il file mantiene i diritti meno restrittivi. Verifica per accertarsi che a non introdurre possibili rischi di sicurezza.  
  
   
  
## Examples  
 Questo esempio viene usato il `Rename` funzione per rinominare un file. Ai fini di questo esempio, si supponga che esistano le directory in cui siano già state specificate.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file <paramref name="OldPath" /> non esiste.</exception>
        <exception cref="T:System.IO.IOException">Impossibile rinominare con il nome di un'altro dispositivo.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedura: rinominare un file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude tutti i file su disco aperti mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Reset" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Reset` funzione chiude tutti i file aperti per il `FileOpen` funzione e ha la stessa funzione `FileClose()` senza parametri.  
  
   
  
## Examples  
 Questo esempio viene usato il `Reset` (funzione) per chiudere tutti i file aperti e scrivere il contenuto di tutti i buffer di file su disco. Si noti l'uso del `Object` variabile `FileNumber` come una stringa e un numero.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Istruzione End</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory o la cartella da rimuovere. Il parametro <paramref name="Path" /> può includere l'unità. Se non viene specificata alcuna unità, <see langword="RmDir" /> rimuove la directory nell'unità corrente.</param>
        <summary>Rimuove una directory esistente. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="RmDir" />. Per ulteriori informazioni, vedere <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si verifica un errore se si prova a usare `RmDir` in una directory che contiene i file. Usare il `Kill` funzione eliminare tutti i file prima di provare a rimuovere una directory.  
  
   
  
## Examples  
 Questo esempio viene usato il `RmDir` funzione per rimuovere una directory esistente.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> non è specificato o è vuoto.</exception>
        <exception cref="T:System.IO.IOException">La directory di destinazione contiene file.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La directory non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.  
  
 Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero del record successivo letto o scritto|  
|`Binary`, `Input`, `Output`, `Append`|Posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Il primo byte in un file corrisponde alla posizione 1, il secondo byte è nella posizione 2 e così via.|  
  
   
  
## Examples  
 Questo esempio viene usato il `Seek` funzione per restituire la posizione corrente del file. Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Per i file aperti in modalità diverso da `Random` modalità `Seek` restituisce la posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Questo esempio viene usato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura e scrittura in un file.  
  
 Per i file aperti in modalità diverso da `Random` modalità `Seek` imposta la posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <param name="Position">Obbligatorio. Numero compreso nell'intervallo da 1 a 2.147.483.647 inclusi, che indica dove deve aver luogo la successiva operazione di lettura/scrittura.</param>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.  
  
 Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero del record successivo letto o scritto|  
|`Binary`, `Input`, `Output`, `Append`|Posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Il primo byte in un file corrisponde alla posizione 1, il secondo byte è nella posizione 2 e così via.|  
  
   
  
## Examples  
 Questo esempio viene usato il `Seek` funzione per restituire la posizione corrente del file. Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Per i file aperti in modalità diverso da `Random` modalità `Seek` restituisce la posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Questo esempio viene usato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura e scrittura in un file.  
  
 Per i file aperti in modalità diverso da `Random` modalità `Seek` imposta la posizione di byte in corrispondenza del quale si verifica all'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lettura da file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Scrittura su file in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome file. L'oggetto <paramref name="PathName" /> può includere la directory o la cartella e l'unità.</param>
        <param name="Attributes">Obbligatorio. Costante o espressione numerica la cui somma specifica attributi di file.</param>
        <summary>Imposta le informazioni degli attributi per un file. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="SetAttr" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si prova a impostare gli attributi di un file aperto, si verifica un errore di run-time.  
  
 Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbNormal`|Normale (impostazione predefinita).|  
|`ReadOnly`|`vbReadOnly`|Sola lettura.|  
|`Hidden`|`vbHidden`|Nascosto.|  
|`System`|`vbSystem`|File di sistema.|  
|`Volume`|`vbVolume`|Etichetta del volume|  
|`Directory`|`vbDirectory`|Directory o cartella.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni sono specificate dal linguaggio Visual Basic. I nomi possono essere utilizzati ovunque nel codice anziché i valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene usato il `SetAttr` funzione per impostare gli attributi per un file.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tipo di <paramref name="Attribute" /> non valido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Obbligatorio. Numero di spazi da inserire prima di visualizzare o stampare la successiva espressione di un elenco.</param>
        <summary>Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</summary>
        <returns>Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Count` è inferiore alla lunghezza della riga di output, la posizione successiva immediatamente segue il numero di spazi stampato. Se`Count` è maggiore della larghezza della riga di output, `SPC` calcolerà la posizione successiva usando la formula:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Ad esempio, se la posizione di stampa è 24, la larghezza della riga di output è 80 e si specifica `SPC(90)`, la stampa Avanti inizierà nella posizione di 34 (posizione di stampa corrente + la parte restante del 90/80). Se la differenza tra la posizione di stampa e la larghezza della riga di output è inferiore a `Count` (o `Count` `Mod` *larghezza*), il `SPC` funzione passerà all'inizio della riga successiva e che genera l'errore è uguale a spazi `Count` – (*larghezza* – *currentprintposition*).  
  
> [!NOTE]
>  Assicurarsi che le colonne di tabella sono sufficientemente ampia per consentire caratteri ampi.  
  
   
  
## Examples  
 Questo esempio Usa il `SPC` per posizionare l'output in un file e in funzione il **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operatore Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
        <returns>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la posizione di stampa corrente nella riga corrente è più grande `Column`, `TAB` passerà al valore di colonna uguale a `Column` nella successiva riga di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa per la colonna 1. Se `Column` è maggiore della larghezza di riga di output, `TAB` calcolerà la posizione successiva usando la formula:  
  
 Larghezza della colonna Mod  
  
 Ad esempio, se *larghezza* 80 e specificazione `TAB(90)`, la stampa Avanti inizierà dalla colonna 10 (il resto pari a 80 o 90). Se `Column` è minore della posizione corrente di stampa, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, stampa inizierà dalla calcolata stampa posizione sulla stessa riga.  
  
 La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si usa la `Print` oppure `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).  
  
 Il `TAB` funzione può essere usata anche con il `WriteLine` (funzione). Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assicurarsi che le colonne di tabella sono sufficientemente ampia per contenere i caratteri wide.  
  
   
  
## Examples  
 Questo esempio Usa il `TAB` per posizionare l'output in un file e in funzione il **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operatore Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Facoltativo. Numero della colonna a cui passare prima di visualizzare o stampare la successiva espressione di un elenco. In caso di omissione, <see langword="TAB" /> sposterà il punto di inserimento all'inizio della successiva area di stampa.</param>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
        <returns>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la posizione di stampa nella riga corrente è maggiore `Column`, `TAB` passerà al valore di colonna uguale a `Column` nella successiva riga di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa per la colonna 1. Se `Column` è maggiore della larghezza della riga di output, `TAB` calcolerà la posizione successiva usando la formula:  
  
 Larghezza della colonna Mod  
  
 Ad esempio, se *larghezza* 80 e specificazione `TAB(90)`, la stampa Avanti inizierà dalla colonna 10 (il resto pari a 80 o 90). Se `Column` è minore della posizione corrente di stampa, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, la stampa inizierà a calcolata stampa posizione sulla stessa riga.  
  
 La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si usa la `Print` oppure `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).  
  
 Il `TAB` funzione può essere usata anche con il `WriteLine` (funzione). Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assicurarsi che le colonne di tabella sono sufficientemente ampia per contenere i caratteri wide.  
  
   
  
## Examples  
 Questo esempio Usa il `TAB` per posizionare l'output in un file e in funzione il **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operatore Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Record">Facoltativo. Numero del record o byte da bloccare o sbloccare</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="FromRecord">Facoltativo. Numero del primo record o byte da bloccare o sbloccare.</param>
        <param name="ToRecord">Facoltativo. Numero dell'ultimo record o byte da bloccare o sbloccare.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.  
  
 `Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia. Gli argomenti `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file. Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni. Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Espressione <see langword="Integer" /> contenente un numero di file valido.</param>
        <param name="Output">Facoltativo. Una o più espressioni con valori delimitati da virgole da scrivere in un file.</param>
        <summary>Scrive dati in un file sequenziale. I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Write` e `WriteLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separati da una virgola.  
  
 A differenza di `Print` funzione, il `Write` funzione inserisce le virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell'elenco. Quando `Write` consente di scrivere dati in un file, solo alfanumerici `Boolean`, data, null e `Error` sono supportati i formati di dati. I presupposti seguenti universali vengono seguiti in modo che i dati possono sempre essere letti e interpreta correttamente usando `Input`, indipendentemente dalle impostazioni locali:  
  
-   Dati numerici vengono sempre scritti usando il punto come separatore decimale.  
  
-   Per la `Boolean` dei dati, ad esempio `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.  
  
-   Le date vengono scritte nel file usando il formato della data universal. Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.  
  
-   Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.  
  
-   Per la `Error` dei dati, l'output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene convertito, indipendentemente dalle impostazioni locali.  
  
 `WriteLine` Inserisce un carattere di nuova riga (vale a dire, un ritorno a capo/avanzamento riga, oppure `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.  
  
 È possibile incorporare virgolette in una stringa con virgolette doppie, o "". Ad esempio,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.  
  
 La scrittura in un file usando il `Write` o `WriteLine` funzioni richiede `Append` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Espressione <see langword="Integer" /> contenente un numero di file valido.</param>
        <param name="Output">Facoltativo. Una o più espressioni con valori delimitati da virgole da scrivere in un file.</param>
        <summary>Scrive dati in un file sequenziale. I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Write` e `WriteLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separati da una virgola.  
  
 A differenza di `Print` funzione, il `Write` funzione inserisce le virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell'elenco. Quando `Write` consente di scrivere dati in un file, solo alfanumerici `Boolean`, data, null e `Error` sono supportati i formati di dati. I presupposti seguenti universali vengono seguiti in modo che i dati possono sempre essere letti e interpreta correttamente usando `Input`, indipendentemente dalle impostazioni locali:  
  
-   Dati numerici vengono sempre scritti usando il punto come separatore decimale.  
  
-   Per la `Boolean` dei dati, ad esempio `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.  
  
-   Le date vengono scritte nel file usando il formato della data universal. Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.  
  
-   Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.  
  
-   Per la `Error` dei dati, l'output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene convertito, indipendentemente dalle impostazioni locali.  
  
 `WriteLine` Inserisce un carattere di nuova riga (vale a dire, un ritorno a capo/avanzamento riga, oppure `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.  
  
 È possibile incorporare virgolette in una stringa con virgolette doppie, o "". Ad esempio,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.  
  
 La scrittura in un file usando il `Write` o `WriteLine` funzioni richiede `Append` accedere dal `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene usato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accesso ai file con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Procedura: scrivere testo in file in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedura: scrivere testo in un File con un oggetto Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>