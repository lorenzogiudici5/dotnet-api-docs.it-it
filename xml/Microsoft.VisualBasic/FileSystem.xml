<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76423e19c418e3145c1946201eeb07bad53c0200" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39908794" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b3575-101">Il modulo <see langword="FileSystem" /> contiene le procedure utilizzate per eseguire operazioni su file, directory o cartelle e sistema.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3575-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span>
      </span>
      <span data-ttu-id="b3575-102">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto all'utilizzo del modulo <see langword="FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3575-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span>
      </span>
      <span data-ttu-id="b3575-103">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3575-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-104">Questo modulo supporta le parole chiave del linguaggio Visual Basic e membri delle librerie di runtime che accedono a file e cartelle.</span><span class="sxs-lookup"><span data-stu-id="b3575-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-105">Questo esempio viene usato il `GetAttr` funzione per determinare gli attributi di file e directory o cartella.</span><span class="sxs-lookup"><span data-stu-id="b3575-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="b3575-106">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-106">Required.</span>
          </span>
          <span data-ttu-id="b3575-107">Espressione <see langword="String" /> che identifica la directory o la cartella che diventa la nuova directory o cartella predefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span>
          </span>
          <span data-ttu-id="b3575-108">L'elemento <c>Path</c> può includere l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-108">
              <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="b3575-109">Se non viene specificata alcuna unità, <see langword="ChDir" /> cambia la directory o cartella predefinita dell'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-110">Cambia la directory o cartella corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-110">Changes the current directory or folder.</span>
          </span>
          <span data-ttu-id="b3575-111">Nelle operazioni di I/O su file la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="ChDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span>
          </span>
          <span data-ttu-id="b3575-112">Per altre informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-113">Il `ChDir` funzione modifica la directory predefinita, ma non l'unità predefinita.</span><span class="sxs-lookup"><span data-stu-id="b3575-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="b3575-114">Ad esempio, se l'unità predefinita è C, l'istruzione seguente modifica la directory predefinita nell'unità D, mentre C rimane l'unità predefinita:</span><span class="sxs-lookup"><span data-stu-id="b3575-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="b3575-115">È possibile rendere relativo le modifiche della directory è necessario digitare due punti, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="b3575-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-116">Il `ChDir` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="b3575-117">Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e.</span><span class="sxs-lookup"><span data-stu-id="b3575-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-118">Questo esempio viene usato il `ChDir` funzione per modificare la directory o cartella corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-119">
            <paramref name="Path" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-119">
              <paramref name="Path" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-120">L'unità specificata non è valida o non è disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-120">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-121">Cambia l'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-121">Changes the current drive.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="b3575-122">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-122">Required.</span>
          </span>
          <span data-ttu-id="b3575-123">Espressione String che specifica un'unità esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-123">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="b3575-124">Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-124">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="b3575-125">Se l'argomento <c>Drive</c> è una stringa a più caratteri, <see langword="ChDrive" /> usa solo la prima lettera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-126">Cambia l'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-126">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-127">Il `ChDrive` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="b3575-128">Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="b3575-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-129">Questo esempio viene usato il `ChDrive` funzione per modificare l'unità corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="b3575-130">La funzione genera un'eccezione se l'unità non esiste.</span><span class="sxs-lookup"><span data-stu-id="b3575-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-131">L'unità specificata non è valida o non è disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-131">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="b3575-132">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-132">Required.</span>
          </span>
          <span data-ttu-id="b3575-133">Espressione String che specifica un'unità esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-133">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="b3575-134">Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-134">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="b3575-135">Se l'argomento <c>Drive</c> è una stringa a più caratteri, <see langword="ChDrive" /> usa solo la prima lettera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-136">Cambia l'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-136">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-137">Il `ChDrive` funzione richiede l'autorizzazione per codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="b3575-138">Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="b3575-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-139">Questo esempio viene usato il `ChDrive` funzione per modificare l'unità corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="b3575-140">La funzione genera un'eccezione se l'unità non esiste.</span><span class="sxs-lookup"><span data-stu-id="b3575-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-141">L'unità specificata non è valida o non è disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-141">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-142">Restituisce una stringa che rappresenta il percorso corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-142">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="b3575-143">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="b3575-144">Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3575-145">Restituisce una stringa che rappresenta il percorso corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-145">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="b3575-146">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="b3575-147">Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-148">Stringa che rappresenta il percorso corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-148">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3575-149">Questo esempio viene usato il `CurDir` funzione per restituire il percorso corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="b3575-150">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-150">Optional.</span>
          </span>
          <span data-ttu-id="b3575-151">Espressione <see langword="Char" /> che specifica un'unità esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-151">
              <see langword="Char" /> expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="b3575-152">Se non si specifica alcuna unità, o se l'elemento <c>Drive</c> è una stringa di lunghezza zero (""), <see langword="CurDir" /> restituisce il percorso dell'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-153">Restituisce una stringa che rappresenta il percorso corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-153">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="b3575-154">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="b3575-155">Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-156">Stringa che rappresenta il percorso corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-156">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3575-157">Questo esempio viene usato il `CurDir` funzione per restituire il percorso corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-158">Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="b3575-159">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="b3575-160">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3575-161">Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="b3575-162">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="b3575-163">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-164">Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-165">Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.</span><span class="sxs-lookup"><span data-stu-id="b3575-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="b3575-166">`VbVolume` Restituisce l'etichetta di volume per l'unità anziché un nome file specifico.</span><span class="sxs-lookup"><span data-stu-id="b3575-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="b3575-167">È necessario specificare una `PathName` la prima volta che si chiama il `Dir` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="b3575-168">Per recuperare l'elemento successivo, è possibile eseguire le chiamate successive al `Dir` funzione senza parametri.</span><span class="sxs-lookup"><span data-stu-id="b3575-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-169">Per eseguire correttamente, il `Dir` funzione richiede la <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b3575-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="b3575-170">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="b3575-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="b3575-171">Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="b3575-172">Valore</span><span class="sxs-lookup"><span data-stu-id="b3575-172">Value</span></span>|<span data-ttu-id="b3575-173">Costante</span><span class="sxs-lookup"><span data-stu-id="b3575-173">Constant</span></span>|<span data-ttu-id="b3575-174">Descrizione</span><span class="sxs-lookup"><span data-stu-id="b3575-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="b3575-175">Predefinita.</span><span class="sxs-lookup"><span data-stu-id="b3575-175">Default.</span></span> <span data-ttu-id="b3575-176">Specifica i file senza attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="b3575-177">Specifica i file di sola lettura, nonché i file senza attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="b3575-178">Specifica i file nascosti, nonché i file senza attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="b3575-179">Specifica i file di sistema, nonché i file senza attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="b3575-180">Specifica l'etichetta di volume. Se viene specificato qualsiasi altro attributo, `vbVolume` viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="b3575-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="b3575-181">Specifica le directory o cartelle, nonché i file senza attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="b3575-182">Il file è stato modificato dopo l'ultimo backup.</span><span class="sxs-lookup"><span data-stu-id="b3575-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="b3575-183">Il file ha un nome diverso.</span><span class="sxs-lookup"><span data-stu-id="b3575-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="b3575-184">Queste enumerazioni sono specificate dal linguaggio Visual Basic e possono essere utilizzate ovunque nel codice anziché i valori effettivi.</span><span class="sxs-lookup"><span data-stu-id="b3575-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-185">Questo esempio viene usato il `Dir` per verificare la presenza di determinati file e directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-186">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-186">Optional.</span>
          </span>
          <span data-ttu-id="b3575-187">Espressione <see langword="String" /> che specifica un nome di file, directory o cartella o un'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-187">
              <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span>
          </span>
          <span data-ttu-id="b3575-188">Viene restituita una stringa di lunghezza zero (<see langword="&quot;&quot;" />) se l'elemento <c>PathName</c> non viene trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span>
          </span>
        </param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">
          <span data-ttu-id="b3575-189">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-189">Optional.</span>
          </span>
          <span data-ttu-id="b3575-190">Enumerazione o espressione numerica il cui valore specifica attributi di file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-190">Enumeration or numeric expression whose value specifies file attributes.</span>
          </span>
          <span data-ttu-id="b3575-191">Se omesso, <see langword="Dir" /> restituisce file che corrispondono a <c>PathName</c> ma sono privi di attributi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-192">Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="b3575-193">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="b3575-194">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-195">Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-196">Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.</span><span class="sxs-lookup"><span data-stu-id="b3575-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="b3575-197">`VbVolume` Restituisce l'etichetta di volume per l'unità anziché un nome file specifico.</span><span class="sxs-lookup"><span data-stu-id="b3575-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="b3575-198">È necessario specificare una `PathName` la prima volta che si chiama il `Dir` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="b3575-199">Per recuperare l'elemento successivo, è possibile eseguire le chiamate successive al `Dir` funzione senza parametri.</span><span class="sxs-lookup"><span data-stu-id="b3575-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-200">Per eseguire correttamente, il `Dir` funzione richiede la <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b3575-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="b3575-201">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="b3575-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="b3575-202">Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="b3575-203">Valore</span><span class="sxs-lookup"><span data-stu-id="b3575-203">Value</span></span>|<span data-ttu-id="b3575-204">Costante</span><span class="sxs-lookup"><span data-stu-id="b3575-204">Constant</span></span>|<span data-ttu-id="b3575-205">Descrizione</span><span class="sxs-lookup"><span data-stu-id="b3575-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="b3575-206">Predefinita.</span><span class="sxs-lookup"><span data-stu-id="b3575-206">Default.</span></span> <span data-ttu-id="b3575-207">Specifica i file che sono privi di attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="b3575-208">Specifica i file di sola lettura, oltre ai file che sono privi di attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="b3575-209">Specifica i file nascosti, oltre ai file che sono privi di attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="b3575-210">Specifica i file di sistema, oltre ai file che sono privi di attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="b3575-211">Specifica l'etichetta di volume. Se viene specificato qualsiasi altro attributo, `vbVolume` viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="b3575-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="b3575-212">Specifica le directory o cartelle, oltre ai file che sono privi di attributi.</span><span class="sxs-lookup"><span data-stu-id="b3575-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="b3575-213">Il file è stato modificato dopo l'ultimo backup.</span><span class="sxs-lookup"><span data-stu-id="b3575-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="b3575-214">Il file ha un nome diverso.</span><span class="sxs-lookup"><span data-stu-id="b3575-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="b3575-215">Queste enumerazioni sono specificate dal linguaggio Visual Basic e possono essere utilizzate ovunque nel codice al posto dei valori effettivi.</span><span class="sxs-lookup"><span data-stu-id="b3575-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-216">Questo esempio viene usato il `Dir` per verificare la presenza di determinati file e directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-217">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-217">Required.</span>
          </span>
          <span data-ttu-id="b3575-218">
            <see langword="Integer" /> che contiene qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-218">An <see langword="Integer" /> that contains any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-219">Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-220">Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-221">Usare `EOF` per evitare l'errore generato dal tentativo di ottenere l'input oltre la fine di un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="b3575-222">Il `EOF` funzione restituisce `False` fino a quando non è stata raggiunta la fine del file.</span><span class="sxs-lookup"><span data-stu-id="b3575-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="b3575-223">Con i file aperti per `Random` o `Binary` access `EOF` restituisce `False` fino all'ultima esecuzione `FileGet` funzione è in grado di leggere un intero record.</span><span class="sxs-lookup"><span data-stu-id="b3575-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="b3575-224">Con i file aperti per `Binary` accedere, un tentativo di leggere il file usando il `Input` funzionare fino all'avviso `EOF` restituisce `True` genera un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="b3575-225">Usare la `LOF` e `Loc` funzioni anziché `EOF` durante la lettura di file binari con `Input`, o usare `Get` quando si usa il `EOF` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="b3575-226">Con i file aperti per `Output`, `EOF` restituisce sempre `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-227">Questo esempio viene usato il `EOF` funzione per rilevare la fine di un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="b3575-228">Questo esempio si presuppone che `Testfile` è un file di testo che contiene più righe di testo.</span><span class="sxs-lookup"><span data-stu-id="b3575-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-229">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-229">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-230">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-230">Required.</span>
          </span>
          <span data-ttu-id="b3575-231">
            <see langword="Integer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-231">
              <see langword="Integer" />.</span>
          </span>
          <span data-ttu-id="b3575-232">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-232">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-233">Restituisce un'enumerazione che rappresenta la modalità di file per i file aperti utilizzando la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-234">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="FileAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span>
          </span>
          <span data-ttu-id="b3575-235">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-236">La modalità di accesso al file è indicata dai seguenti valori di enumerazione:</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-236">The following enumeration values indicate the file access mode:</span>
          </span>
          <span data-ttu-id="b3575-237">
            <list type="table">
              <item>
                <term> Valore </term>
                <description> Modalità </description>
              </item>
              <item>
                <term> 1 </term>
                <description>
                  <see langword="OpenMode.Input" />
                </description>
              </item>
              <item>
                <term> 2 </term>
                <description>
                  <see langword="OpenMode.Output" />
                </description>
              </item>
              <item>
                <term> 4 </term>
                <description>
                  <see langword="OpenMode.Random" />
                </description>
              </item>
              <item>
                <term> 8 </term>
                <description>
                  <see langword="OpenMode.Append" />
                </description>
              </item>
              <item>
                <term> 32 </term>
                <description>
                  <see langword="OpenMode.Binary" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-237">
              <list type="table">
                <item>
                  <term> Value  </term>
                  <description> Mode  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <see langword="OpenMode.Input" />
                  </description>
                </item>
                <item>
                  <term> 2  </term>
                  <description>
                    <see langword="OpenMode.Output" />
                  </description>
                </item>
                <item>
                  <term> 4  </term>
                  <description>
                    <see langword="OpenMode.Random" />
                  </description>
                </item>
                <item>
                  <term> 8  </term>
                  <description>
                    <see langword="OpenMode.Append" />
                  </description>
                </item>
                <item>
                  <term> 32  </term>
                  <description>
                    <see langword="OpenMode.Binary" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-238">Questa funzione restituisce un'enumerazione che rappresenta la modalità di file per i file aperti utilizzando la `FileOpen` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-238">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-239">Questo esempio viene usato il `FileAttr` funzione per restituire la modalità file di un file aperto.</span><span class="sxs-lookup"><span data-stu-id="b3575-239">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">
          <span data-ttu-id="b3575-240">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-240">Optional.</span>
          </span>
          <span data-ttu-id="b3575-241">Matrice di parametri di 0 o più canali da chiudere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-241">Parameter array of 0 or more channels to be closed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-242">Conclude le operazioni di input/output (I/O) in un file aperto con la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-242">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-243">Nelle operazioni di I/O di file <see langword="My" /> garantisce produttività e prestazioni migliori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-243">
              <see langword="My" /> gives you better productivity and performance in file I/O operations.</span>
          </span>
          <span data-ttu-id="b3575-244">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-244">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-245">Il `FileClose` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-245">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-246">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-246">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-247">Per altre informazioni, vedere [come: Leggi testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), e [procedura dettagliata: modifica dei file e directory in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-247">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="b3575-248">Se si omette `FileNumbers`, tutti i file attivi aperti dal `FileOpen` funzione vengono chiusi.</span><span class="sxs-lookup"><span data-stu-id="b3575-248">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="b3575-249">Quando si chiudono i file che sono stati aperti per `Output` o `Append`, il buffer finale dell'output viene scritto nel buffer del sistema operativo per il file.</span><span class="sxs-lookup"><span data-stu-id="b3575-249">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="b3575-250">Spazio associato chiuso tutti i buffer file viene rilasciato.</span><span class="sxs-lookup"><span data-stu-id="b3575-250">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="b3575-251">Quando il `FileClose` funzione viene eseguita, l'associazione di un file con il relativo file numero termina.</span><span class="sxs-lookup"><span data-stu-id="b3575-251">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-252">Questo esempio Usa la `FileClose` funzione per chiudere un file aperto per `Input`.</span><span class="sxs-lookup"><span data-stu-id="b3575-252">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-253">
            <paramref name="FileNumber" /> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-253">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">
          <span data-ttu-id="b3575-254">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-254">Required.</span>
          </span>
          <span data-ttu-id="b3575-255">Espressione <see langword="String" /> che specifica il nome del file da copiare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-255">
              <see langword="String" /> expression that specifies the name of the file to be copied.</span>
          </span>
          <span data-ttu-id="b3575-256">Il parametro <c>Source</c> può includere la directory o la cartella e l'unità del file di origine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-256">
              <c>Source</c> may include the directory or folder, and drive, of the source file.</span>
          </span>
        </param>
        <param name="Destination">
          <span data-ttu-id="b3575-257">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-257">Required.</span>
          </span>
          <span data-ttu-id="b3575-258">Espressione <see langword="String" /> che specifica il nome file di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-258">
              <see langword="String" /> expression that specifies the destination file name.</span>
          </span>
          <span data-ttu-id="b3575-259">Il parametro <c>Destination</c> può includere la directory o la cartella e l'unità del file di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-259">
              <c>Destination</c> may include the directory or folder, and drive, of the destination file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-260">Copia un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-260">Copies a file.</span>
          </span>
          <span data-ttu-id="b3575-261">Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="FileCopy" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-261">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span>
          </span>
          <span data-ttu-id="b3575-262">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-262">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-263">Se si prova a usare il `FileCopy` funzionano in un file attualmente aperto, si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-263">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="b3575-264">`FileCopy` richiede l'attendibilità a funzionare nell'unità locale.</span><span class="sxs-lookup"><span data-stu-id="b3575-264">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-265">Questo esempio viene usato il `FileCopy` per copiare un file a un'altra funzione.</span><span class="sxs-lookup"><span data-stu-id="b3575-265">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="b3575-266">Ai fini di questo esempio, si supponga che `SrcFile` è un file che contiene i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-266">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-267">
            <paramref name="Source" /> o <paramref name="Destination" /> non è valido o non è specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-267">
              <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-268">Il file è già aperto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-268">File is already open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-269">Il file non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-269">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-270">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-270">Required.</span>
          </span>
          <span data-ttu-id="b3575-271">Espressione <see langword="String" /> che specifica un nome file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-271">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="b3575-272">Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-272">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-273">Restituisce un valore <see langword="Date" /> che indica la data e l'ora della scrittura in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-273">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span>
          </span>
          <span data-ttu-id="b3575-274">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileDateTime" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-274">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span>
          </span>
          <span data-ttu-id="b3575-275">Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-275">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-276">Valore <see langword="Date" /> che indica la data e l'ora di creazione o dell'ultima modifica di un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-276">
              <see langword="Date" /> value that indicates the date and time a file was created or last modified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3575-277">Questo esempio viene usato il `FileDateTime` funzione per determinare la data e ora di un file è stato creato o modificato.</span><span class="sxs-lookup"><span data-stu-id="b3575-277">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="b3575-278">Il formato della data e ora visualizzata è basato sulle impostazioni locali del sistema.</span><span class="sxs-lookup"><span data-stu-id="b3575-278">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-279">
            <paramref name="PathName" /> non è valido o contiene caratteri jolly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-279">
              <paramref name="PathName" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-280">Il file di destinazione non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-280">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-281">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-281">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-282">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-282">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-283">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-283">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-284">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-284">Required.</span>
          </span>
          <span data-ttu-id="b3575-285">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-285">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-286">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-286">Required.</span>
          </span>
          <span data-ttu-id="b3575-287">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-287">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-288">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-288">Optional.</span>
          </span>
          <span data-ttu-id="b3575-289">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-289">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-290">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-290">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-291">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-291">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-292">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-292">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-293">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-293">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-294">I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-294">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-295">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-295">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-296">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-296">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-297">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-297">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-298">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-298">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-299">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-299">Random Mode</span></span>  
 <span data-ttu-id="b3575-300">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-300">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-301">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-301">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-302">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-302">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-303">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-303">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-304">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-304">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-305">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-305">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-306">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-306">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-307">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-307">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-308">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-308">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-309">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-309">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-310">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-310">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-311">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-311">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-312">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-312">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-313">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-313">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-314">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-314">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-315">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-315">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-316">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-316">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-317">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-317">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-318">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-318">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-319">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-319">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-320">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-320">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-321">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-321">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-322">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-322">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-323">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-323">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-324">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-324">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-325">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-325">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-326">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-326">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-327">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-327">Binary Mode</span></span>  
 <span data-ttu-id="b3575-328">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-328">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-329">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-329">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-330">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-330">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-331">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-331">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-332">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-332">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-333">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-333">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-334">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-334">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-335">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-335">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-336">Lettura da un file usando il`FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-336">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-337">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-337">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-338">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-338">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-339">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-339">Required.</span>
          </span>
          <span data-ttu-id="b3575-340">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-340">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-341">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-341">Required.</span>
          </span>
          <span data-ttu-id="b3575-342">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-342">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-343">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-343">Optional.</span>
          </span>
          <span data-ttu-id="b3575-344">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-344">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-345">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-345">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-346">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-346">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-347">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-347">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-348">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-348">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-349">I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-349">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-350">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-350">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-351">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-351">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-352">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-352">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-353">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-353">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-354">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-354">Random Mode</span></span>  
 <span data-ttu-id="b3575-355">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-355">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-356">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-356">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-357">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-357">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-358">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-358">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-359">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-359">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-360">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-360">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-361">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-361">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-362">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-362">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-363">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-363">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-364">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-364">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-365">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-365">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-366">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-366">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-367">Se non viene utilizzato il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-367">If the descriptor is not used.</span></span> <span data-ttu-id="b3575-368">Le dimensioni e i limiti della matrice passato nella `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-368">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-369">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-369">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-370">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-370">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-371">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-371">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-372">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-372">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-373">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-373">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-374">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-374">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-375">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-375">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-376">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-376">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-377">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-377">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-378">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-378">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-379">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-379">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-380">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-380">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-381">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-381">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-382">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-382">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-383">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-383">Binary Mode</span></span>  
 <span data-ttu-id="b3575-384">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-384">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-385">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-385">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-386">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-386">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-387">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-387">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-388">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-388">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-389">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-389">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-390">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-390">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-391">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-391">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-392">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-392">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-393">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-393">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-394">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-394">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-395">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-395">Required.</span>
          </span>
          <span data-ttu-id="b3575-396">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-396">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-397">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-397">Required.</span>
          </span>
          <span data-ttu-id="b3575-398">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-398">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-399">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-399">Optional.</span>
          </span>
          <span data-ttu-id="b3575-400">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-400">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-401">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-401">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-402">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-402">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-403">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-403">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-404">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-404">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-405">I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-405">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-406">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-406">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-407">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-407">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-408">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-408">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-409">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-409">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-410">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-410">Random Mode</span></span>  
 <span data-ttu-id="b3575-411">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-411">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-412">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-412">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-413">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-413">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-414">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-414">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-415">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-415">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-416">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-416">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-417">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-417">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-418">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-418">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-419">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-419">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-420">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-420">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-421">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-421">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-422">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-422">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-423">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-423">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-424">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-424">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-425">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-425">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-426">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-426">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-427">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-427">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-428">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-428">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-429">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-429">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-430">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-430">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-431">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-431">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-432">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-432">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-433">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-433">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-434">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-434">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-435">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-435">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-436">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-436">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-437">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-437">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-438">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-438">Binary Mode</span></span>  
 <span data-ttu-id="b3575-439">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-439">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-440">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-440">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-441">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-441">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-442">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-442">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-443">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-443">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-444">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-444">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-445">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-445">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-446">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-446">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-447">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-447">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-448">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-448">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-449">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-449">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-450">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-450">Required.</span>
          </span>
          <span data-ttu-id="b3575-451">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-451">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-452">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-452">Required.</span>
          </span>
          <span data-ttu-id="b3575-453">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-453">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-454">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-454">Optional.</span>
          </span>
          <span data-ttu-id="b3575-455">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-455">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-456">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-456">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-457">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-457">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-458">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-458">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-459">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-459">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-460">I dati letti tramite `FileGet` vengono in genere scritti in un file con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-460">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-461">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-461">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-462">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-462">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-463">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-463">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-464">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-464">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-465">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-465">Random Mode</span></span>  
 <span data-ttu-id="b3575-466">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-466">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-467">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione,`FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-467">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-468">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-468">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-469">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-469">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-470">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-470">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-471">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-471">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-472">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-472">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-473">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-473">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-474">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-474">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-475">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-475">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-476">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-476">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-477">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-477">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-478">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-478">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-479">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-479">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-480">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-480">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-481">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-481">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-482">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-482">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-483">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-483">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-484">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-484">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-485">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-485">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-486">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-486">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-487">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-487">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-488">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-488">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-489">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-489">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-490">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-490">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-491">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-491">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-492">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-492">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-493">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-493">Binary Mode</span></span>  
 <span data-ttu-id="b3575-494">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-494">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-495">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-495">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-496">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-496">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-497">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-497">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-498">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-498">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-499">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-499">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-500">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-500">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-501">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-501">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-502">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-502">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-503">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-503">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-504">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-504">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-505">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-505">Required.</span>
          </span>
          <span data-ttu-id="b3575-506">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-506">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-507">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-507">Required.</span>
          </span>
          <span data-ttu-id="b3575-508">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-508">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-509">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-509">Optional.</span>
          </span>
          <span data-ttu-id="b3575-510">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-510">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-511">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-511">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-512">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-512">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-513">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-513">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-514">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-514">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-515">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-515">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-516">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-516">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-517">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-517">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-518">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-518">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-519">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-519">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-520">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-520">Random Mode</span></span>  
 <span data-ttu-id="b3575-521">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-521">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-522">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-522">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-523">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-523">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-524">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-524">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-525">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-525">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-526">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-526">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-527">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-527">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-528">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-528">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-529">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-529">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-530">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-530">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-531">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-531">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-532">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-532">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-533">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-533">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-534">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-534">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-535">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-535">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-536">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-536">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-537">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-537">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-538">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-538">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-539">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-539">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-540">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-540">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-541">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-541">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-542">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-542">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-543">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-543">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-544">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-544">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-545">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-545">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-546">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-546">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-547">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-547">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-548">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-548">Binary Mode</span></span>  
 <span data-ttu-id="b3575-549">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-549">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-550">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-550">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-551">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-551">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-552">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-552">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-553">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-553">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-554">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-554">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-555">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-555">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-556">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-556">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-557">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-557">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-558">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-558">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-559">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-559">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-560">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-560">Required.</span>
          </span>
          <span data-ttu-id="b3575-561">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-561">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-562">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-562">Required.</span>
          </span>
          <span data-ttu-id="b3575-563">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-563">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-564">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-564">Optional.</span>
          </span>
          <span data-ttu-id="b3575-565">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-565">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-566">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-566">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-567">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-567">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-568">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-568">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-569">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-569">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-570">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-570">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-571">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-571">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-572">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-572">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-573">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-573">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-574">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-574">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-575">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-575">Random Mode</span></span>  
 <span data-ttu-id="b3575-576">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-576">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-577">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-577">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-578">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-578">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-579">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-579">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-580">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-580">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-581">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-581">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-582">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-582">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-583">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-583">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-584">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-584">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-585">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-585">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-586">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-586">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-587">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-587">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-588">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-588">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-589">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-589">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-590">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-590">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-591">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-591">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-592">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-592">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-593">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-593">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-594">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-594">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-595">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-595">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-596">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-596">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-597">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-597">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-598">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-598">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-599">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-599">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-600">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-600">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-601">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-601">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-602">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-602">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-603">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-603">Binary Mode</span></span>  
 <span data-ttu-id="b3575-604">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-604">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-605">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-605">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-606">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-606">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-607">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-607">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-608">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-608">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-609">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-609">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-610">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-610">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-611">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-611">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-612">Lettura da un file usando il`FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-612">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-613">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-613">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-614">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-614">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-615">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-615">Required.</span>
          </span>
          <span data-ttu-id="b3575-616">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-616">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-617">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-617">Required.</span>
          </span>
          <span data-ttu-id="b3575-618">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-618">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-619">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-619">Optional.</span>
          </span>
          <span data-ttu-id="b3575-620">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-620">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-621">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-621">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-622">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-622">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-623">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-623">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-624">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-624">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-625">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-625">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-626">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-626">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-627">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-627">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-628">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-628">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-629">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-629">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-630">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-630">Random Mode</span></span>  
 <span data-ttu-id="b3575-631">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-631">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-632">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-632">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-633">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-633">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-634">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-634">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-635">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-635">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-636">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-636">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-637">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-637">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-638">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-638">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-639">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-639">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-640">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-640">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-641">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-641">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-642">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-642">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-643">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-643">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-644">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-644">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-645">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-645">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-646">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-646">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-647">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-647">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-648">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-648">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-649">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-649">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-650">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-650">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-651">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-651">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-652">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-652">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-653">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-653">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-654">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-654">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-655">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-655">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-656">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-656">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-657">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-657">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-658">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-658">Binary Mode</span></span>  
 <span data-ttu-id="b3575-659">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-659">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-660">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-660">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-661">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-661">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-662">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-662">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-663">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-663">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-664">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-664">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-665">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-665">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-666">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-666">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-667">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-667">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-668">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-668">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-669">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-669">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-670">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-670">Required.</span>
          </span>
          <span data-ttu-id="b3575-671">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-671">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-672">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-672">Required.</span>
          </span>
          <span data-ttu-id="b3575-673">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-673">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-674">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-674">Optional.</span>
          </span>
          <span data-ttu-id="b3575-675">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-675">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-676">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-676">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-677">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-677">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-678">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-678">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-679">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-679">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-680">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-680">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-681">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-681">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-682">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-682">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-683">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-683">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-684">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-684">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-685">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-685">Random Mode</span></span>  
 <span data-ttu-id="b3575-686">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-686">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-687">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-687">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-688">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-688">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-689">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-689">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-690">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-690">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-691">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-691">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-692">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-692">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-693">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-693">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-694">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-694">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-695">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-695">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-696">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-696">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-697">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-697">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-698">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-698">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-699">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-699">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-700">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-700">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-701">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-701">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-702">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-702">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-703">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-703">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-704">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-704">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-705">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-705">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-706">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-706">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-707">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-707">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-708">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-708">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-709">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-709">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-710">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-710">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-711">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-711">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-712">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-712">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-713">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-713">Binary Mode</span></span>  
 <span data-ttu-id="b3575-714">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-714">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-715">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-715">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-716">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-716">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-717">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-717">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-718">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-718">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-719">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-719">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-720">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-720">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-721">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-721">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-722">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-722">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-723">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-723">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-724">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-724">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-725">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-725">Required.</span>
          </span>
          <span data-ttu-id="b3575-726">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-726">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-727">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-727">Required.</span>
          </span>
          <span data-ttu-id="b3575-728">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-728">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-729">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-729">Optional.</span>
          </span>
          <span data-ttu-id="b3575-730">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-730">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-731">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-731">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-732">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-732">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-733">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-733">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-734">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-734">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-735">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-735">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-736">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-736">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-737">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-737">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-738">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-738">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-739">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-739">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-740">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-740">Random Mode</span></span>  
 <span data-ttu-id="b3575-741">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-741">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-742">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-742">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-743">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-743">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-744">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-744">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-745">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-745">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-746">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-746">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-747">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-747">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-748">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-748">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-749">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-749">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-750">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-750">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-751">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-751">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-752">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-752">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-753">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-753">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-754">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-754">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-755">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-755">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-756">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-756">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-757">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-757">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-758">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-758">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-759">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-759">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-760">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-760">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-761">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-761">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-762">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-762">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-763">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-763">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-764">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-764">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-765">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-765">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-766">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-766">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-767">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-767">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-768">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-768">Binary Mode</span></span>  
 <span data-ttu-id="b3575-769">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-769">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-770">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-770">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-771">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-771">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-772">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-772">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-773">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-773">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-774">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-774">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-775">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-775">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-776">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-776">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-777">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-777">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-778">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-778">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-779">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-779">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-780">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-780">Required.</span>
          </span>
          <span data-ttu-id="b3575-781">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-781">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-782">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-782">Required.</span>
          </span>
          <span data-ttu-id="b3575-783">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-783">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-784">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-784">Optional.</span>
          </span>
          <span data-ttu-id="b3575-785">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-785">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-786">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-786">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-787">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-787">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-788">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-788">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-789">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-789">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-790">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-790">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-791">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-791">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-792">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-792">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-793">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-793">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-794">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-794">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-795">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-795">Random Mode</span></span>  
 <span data-ttu-id="b3575-796">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-796">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-797">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-797">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-798">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-798">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-799">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-799">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-800">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-800">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-801">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-801">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-802">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-802">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-803">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-803">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-804">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-804">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-805">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-805">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-806">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-806">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-807">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-807">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-808">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-808">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-809">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-809">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-810">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-810">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-811">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-811">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-812">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-812">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-813">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-813">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-814">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-814">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-815">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-815">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-816">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-816">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-817">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-817">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-818">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-818">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-819">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-819">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-820">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-820">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-821">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-821">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-822">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-822">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-823">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-823">Binary Mode</span></span>  
 <span data-ttu-id="b3575-824">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-824">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-825">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-825">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-826">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-826">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-827">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-827">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-828">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-828">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-829">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-829">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-830">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-830">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-831">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-831">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-832">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-832">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-833">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-833">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-834">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-834">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-835">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-835">Required.</span>
          </span>
          <span data-ttu-id="b3575-836">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-836">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-837">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-837">Required.</span>
          </span>
          <span data-ttu-id="b3575-838">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-838">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-839">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-839">Optional.</span>
          </span>
          <span data-ttu-id="b3575-840">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-840">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-841">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-841">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-842">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-842">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-843">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-843">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-844">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-844">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-845">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-845">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-846">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-846">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-847">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-847">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-848">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-848">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-849">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-849">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-850">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-850">Random Mode</span></span>  
 <span data-ttu-id="b3575-851">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-851">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-852">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-852">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-853">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-853">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-854">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-854">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-855">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-855">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-856">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-856">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-857">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-857">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-858">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-858">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-859">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-859">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-860">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-860">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-861">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-861">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-862">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-862">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-863">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-863">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-864">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-864">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-865">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-865">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-866">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-866">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-867">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-867">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-868">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-868">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-869">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-869">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-870">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-870">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-871">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-871">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-872">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-872">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-873">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-873">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-874">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-874">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-875">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-875">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-876">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-876">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-877">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-877">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-878">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-878">Binary Mode</span></span>  
 <span data-ttu-id="b3575-879">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-879">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-880">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-880">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-881">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-881">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-882">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-882">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-883">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-883">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-884">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-884">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-885">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-885">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-886">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-886">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-887">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-887">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-888">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-888">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-889">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-889">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-890">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-890">Required.</span>
          </span>
          <span data-ttu-id="b3575-891">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-891">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-892">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-892">Required.</span>
          </span>
          <span data-ttu-id="b3575-893">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-893">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-894">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-894">Optional.</span>
          </span>
          <span data-ttu-id="b3575-895">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-895">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="b3575-896">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-896">Optional.</span>
          </span>
          <span data-ttu-id="b3575-897">Si applica solo durante la scrittura di una stringa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-897">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="b3575-898">Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-898">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="b3575-899">Il valore predefinito è <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-899">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-900">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-900">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-901">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-901">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-902">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-902">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-903">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-903">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-904">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-904">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-905">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-905">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-906">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-906">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-907">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-907">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-908">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-908">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-909">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-909">Random Mode</span></span>  
 <span data-ttu-id="b3575-910">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-910">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-911">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-911">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-912">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-912">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-913">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-913">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-914">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-914">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-915">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-915">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-916">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-916">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-917">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-917">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-918">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-918">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-919">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-919">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-920">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-920">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-921">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-921">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-922">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-922">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-923">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-923">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-924">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-924">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-925">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-925">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-926">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-926">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-927">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-927">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-928">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-928">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-929">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-929">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-930">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-930">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-931">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-931">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-932">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-932">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-933">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-933">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-934">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-934">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-935">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-935">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-936">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-936">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-937">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-937">Binary Mode</span></span>  
 <span data-ttu-id="b3575-938">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-938">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-939">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-939">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-940">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-940">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-941">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-941">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-942">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-942">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-943">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-943">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-944">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-944">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-945">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-945">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-946">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-946">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-947">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-947">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-948">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-948">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-949">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-949">Required.</span>
          </span>
          <span data-ttu-id="b3575-950">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-950">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-951">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-951">Required.</span>
          </span>
          <span data-ttu-id="b3575-952">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-952">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-953">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-953">Optional.</span>
          </span>
          <span data-ttu-id="b3575-954">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-954">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="b3575-955">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-955">Optional.</span>
          </span>
          <span data-ttu-id="b3575-956">Si applica solo durante la scrittura di una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-956">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="b3575-957">Specifica se la matrice deve essere considerata una matrice dinamica e se è necessario un descrittore della matrice che descrive le dimensioni e i limiti della matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-957">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="b3575-958">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-958">Optional.</span>
          </span>
          <span data-ttu-id="b3575-959">Si applica solo durante la scrittura di una stringa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-959">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="b3575-960">Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-960">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="b3575-961">Il valore predefinito è <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-961">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-962">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-962">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-963">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-963">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="b3575-964">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-964">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-965">`FileGet` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-965">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-966">I dati letti tramite `FileGet` viene in genere scritti in un file mediante `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-966">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="b3575-967">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-967">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-968">Se si omette `RecordNumber`, il record o byte successivi all'ultimo `FileGet` oppure `FilePut` funzione (o a cui punta l'ultimo `Seek` (funzione)) viene letto.</span><span class="sxs-lookup"><span data-stu-id="b3575-968">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-969">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-969">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-970">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-970">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-971">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-971">Random Mode</span></span>  
 <span data-ttu-id="b3575-972">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-972">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-973">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGet` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-973">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-974">Lo spazio tra la fine di un record e il valore iniziale del record successivo viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-974">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-975">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-975">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-976">Per impostazione predefinita, se la variabile in cui si legge è una stringa, `FileGet` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-976">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-977">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-977">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-978">Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando vengono inserite in un file, il descrittore di lunghezza non viene scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-978">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-979">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-979">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-980">Se la variabile in cui si legge è una matrice, è possibile scegliere se si desidera leggere un descrittore per le dimensioni e la dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-980">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="b3575-981">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-981">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-982">Durante la lettura della matrice, si devono corrispondere il modo in cui che è stata scritta la matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-982">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="b3575-983">Se è stato scritto con il descrittore di, è necessario il descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-983">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="b3575-984">Se il descrittore non viene utilizzato, le dimensioni e i limiti della matrice passato nel `FileGet` determinare gli elementi da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-984">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="b3575-985">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-985">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-986">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-986">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-987">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-987">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-988">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-988">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="b3575-989">I byte 218 vengono distribuiti come segue:</span><span class="sxs-lookup"><span data-stu-id="b3575-989">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="b3575-990">18 byte per il descrittore: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="b3575-990">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="b3575-991">200 byte per i dati: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-991">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="b3575-992">Se la variabile in cui si legge è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-992">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="b3575-993">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-993">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-994">`FileGet` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-994">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-995">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-995">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-996">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-996">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="b3575-997">Ciò include le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-997">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-998">Il `VBFixedString` attributo può essere applicato ai campi stringa in strutture per indicare le dimensioni di una stringa quando viene scritta su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-998">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-999">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-999">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1000">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1000">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1001">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1001">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1002">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1002">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1003">`FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire, senza spaziatura tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1003">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1004">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1004">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="b3575-1005">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-1005">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="b3575-1006">`FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1006">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1007">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1007">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="b3575-1008">Lettura da un file usando il `FileGet` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1008">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1009">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1009">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1010">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1010">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1011">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1011">Required.</span>
          </span>
          <span data-ttu-id="b3575-1012">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1012">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1013">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1013">Required.</span>
          </span>
          <span data-ttu-id="b3575-1014">Nome valido della variabile in cui vengono letti i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1014">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1015">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1015">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1016">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1016">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1017">Legge i dati in una variabile da un file aperto sul disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1017">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="b3575-1018">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGetObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1018">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span>
          </span>
          <span data-ttu-id="b3575-1019">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1019">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1020">Il `FileGetObject` funzione viene usata invece di `FileGet` per evitare ambiguità in fase di compilazione se tipo `Object` viene restituito invece un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1020">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="b3575-1021">Se si prevede di scrivere la `Variant` tipo, `FileGetObject` è obbligatorio.</span><span class="sxs-lookup"><span data-stu-id="b3575-1021">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="b3575-1022">In caso di dubbi, se si usa un oggetto per il secondo parametro, è consigliabile usare `FilePutObject` e `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1022">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="b3575-1023">`FileGetObject` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1023">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1024">I dati letti tramite `FileGetObject` vengono in genere scritti con `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1024">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="b3575-1025">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1025">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1026">Se si omette `RecordNumber`, `FileGetObject` legge il record o byte dopo l'ultimo `FileGetObject` oppure `FilePutObject` funzione (o a cui punta l'ultimo `Seek` (funzione)).</span><span class="sxs-lookup"><span data-stu-id="b3575-1026">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1027">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1027">Random Mode</span></span>  
 <span data-ttu-id="b3575-1028">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1028">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1029">Se la lunghezza dei dati da leggere è inferiore alla lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FileGetObject` legge i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1029">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1030">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1030">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1031">Poiché la quantità di dati di spaziatura interna non è possibile determinare in modo preciso, è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1031">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="b3575-1032">Se la variabile in cui si legge è una stringa, per impostazione predefinita `FileGetObject` legge un descrittore a due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1032">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1033">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1033">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1034">Visual Basic 6.0 e versioni precedenti supportano le stringhe a lunghezza fissa e durante la lettura in un file, il descrittore di lunghezza non viene scritto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1034">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="b3575-1035">Se si desidera una stringa senza il descrittore di lettura, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1035">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1036">Se la variabile in cui si legge è una matrice, è necessario che la lunghezza del record specificata dal parametro `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1036">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1037">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1037">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1038">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="b3575-1038">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="b3575-1039">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco:</span><span class="sxs-lookup"><span data-stu-id="b3575-1039">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="b3575-1040">I byte 218 vengono distribuiti come segue: 18 byte per il descrittore di (2 + 8 \* 2) e 100 byte per i dati (10 \* 5 \* 4).</span><span class="sxs-lookup"><span data-stu-id="b3575-1040">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="b3575-1041">`FileGetObject` legge gli elementi di strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1041">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="b3575-1042">Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePutObject`) preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="b3575-1042">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="b3575-1043">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi, incluse le matrici e i loro descrittori.</span><span class="sxs-lookup"><span data-stu-id="b3575-1043">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="b3575-1044">Il <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe può essere applicata ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1044">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1045">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1045">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1046">Per i file aperti `Binary` modalità, tutti i `Random` si applicano le regole, con le seguenti eccezioni:</span><span class="sxs-lookup"><span data-stu-id="b3575-1046">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="b3575-1047">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1047">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1048">`FileGetObject` legge tutte le variabili da disco in modo contiguo, vale a dire, senza alcun riempimento tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1048">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1049">Per qualsiasi matrice diverso da una matrice in una struttura, `FileGetObject` legge solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1049">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="b3575-1050">Nessun descrittore di lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-1050">No descriptor is read.</span></span>  
  
 <span data-ttu-id="b3575-1051">`FileGetObject` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1051">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1052">Il numero di byte letti è uguale al numero di caratteri già nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1052">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-1053">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1053">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-1054">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-1054">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1055">Nell'esempio seguente legge un record in un file di test e quindi li recupera.</span><span class="sxs-lookup"><span data-stu-id="b3575-1055">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-1056">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1056">Required.</span>
          </span>
          <span data-ttu-id="b3575-1057">Espressione <see langword="String" /> che specifica un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1057">
              <see langword="String" /> expression that specifies a file.</span>
          </span>
          <span data-ttu-id="b3575-1058">Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1058">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1059">Restituisce un valore <see langword="Long" /> che specifica la lunghezza di un file in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1059">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
          <span data-ttu-id="b3575-1060">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileLen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1060">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span>
          </span>
          <span data-ttu-id="b3575-1061">Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1061">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-1062">Valore <see langword="Long" /> che specifica la lunghezza di un file in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1062">
              <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1063">Se il file specificato è aperto quando il `FileLen` funzione viene chiamata, il valore restituito rappresenta le dimensioni del file al momento è stato aperto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1063">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-1064">Per ottenere la lunghezza corrente di un file aperto, usare il `LOF` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-1064">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1065">Questo esempio viene usato il `FileLen` funzione per restituire la lunghezza di un file in byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1065">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="b3575-1066">Ai fini di questo esempio, si supponga che `TestFile` è un file che contiene alcuni dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1066">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-1067">Il file non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1067">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1068">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1068">Required.</span>
          </span>
          <span data-ttu-id="b3575-1069">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1069">Any valid file number.</span>
          </span>
          <span data-ttu-id="b3575-1070">Utilizza la funzione <see langword="FreeFile" /> per ottenere il successivo numero di file disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1070">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span>
          </span>
        </param>
        <param name="FileName">
          <span data-ttu-id="b3575-1071">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1071">Required.</span>
          </span>
          <span data-ttu-id="b3575-1072">Espressione <see langword="String" /> che specifica un nome di file. Può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1072">
              <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Mode">
          <span data-ttu-id="b3575-1073">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1073">Required.</span>
          </span>
          <span data-ttu-id="b3575-1074">Enumerazione che specifica la modalità per il file: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> o <see langword="Random" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1074">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span>
          </span>
          <span data-ttu-id="b3575-1075">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1075">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span>
          </span>
        </param>
        <param name="Access">
          <span data-ttu-id="b3575-1076">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1076">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1077">Enumerazione che specifica le operazioni autorizzate sul file aperto: <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1077">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="b3575-1078">Il valore predefinito è <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1078">Defaults to <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="b3575-1079">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1079">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span>
          </span>
        </param>
        <param name="Share">
          <span data-ttu-id="b3575-1080">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1080">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1081">Enumerazione che specifica le operazioni non autorizzate sul file aperto da altri processi: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> e <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1081">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="b3575-1082">Il valore predefinito è <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1082">Defaults to <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="b3575-1083">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1083">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span>
          </span>
        </param>
        <param name="RecordLength">
          <span data-ttu-id="b3575-1084">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1084">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1085">Numero minore o uguale a 32.767 byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1085">Number less than or equal to 32,767 (bytes).</span>
          </span>
          <span data-ttu-id="b3575-1086">Per i file aperti per l'accesso Random, questo valore rappresenta la lunghezza del record.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1086">For files opened for random access, this value is the record length.</span>
          </span>
          <span data-ttu-id="b3575-1087">Per i file sequenziali, questo valore rappresenta il numero di caratteri memorizzati nel buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1087">For sequential files, this value is the number of characters buffered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1088">Apre un file per l'input o l'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1088">Opens a file for input or output.</span>
          </span>
          <span data-ttu-id="b3575-1089">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1089">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span>
          </span>
          <span data-ttu-id="b3575-1090">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1090">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1091">Il `FileOpen` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1091">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-1092">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-1092">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-1093">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-1093">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-1094">È necessario aprire un file prima di qualsiasi operazione dei / o può essere eseguita su di esso.</span><span class="sxs-lookup"><span data-stu-id="b3575-1094">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="b3575-1095">`FileOpen` Alloca un buffer dei / o al file e determina la modalità di accesso da usare con il buffer.</span><span class="sxs-lookup"><span data-stu-id="b3575-1095">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-1096">Quando si scrive in un file, un'applicazione potrebbe essere necessario creare un file, se il file a cui sta tentando di scrivere non esiste.</span><span class="sxs-lookup"><span data-stu-id="b3575-1096">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="b3575-1097">A tale scopo, necessaria l'autorizzazione per la directory in cui il file deve essere creato.</span><span class="sxs-lookup"><span data-stu-id="b3575-1097">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="b3575-1098">Tuttavia, se il file specificato da `FileName` esiste, l'applicazione deve `Write` l'autorizzazione solo per il file stesso.</span><span class="sxs-lookup"><span data-stu-id="b3575-1098">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="b3575-1099">Ovunque possibile, per migliorare la sicurezza, creare il file durante la distribuzione e concedere `Write` le autorizzazioni per tale file unico, anziché per l'intera directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-1099">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="b3575-1100">Per contribuire al miglioramento della protezione, scrivere i dati invece di directory degli utenti della directory radice o nella directory programmi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1100">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="b3575-1101">È reperibile il canale da aprire usando la `FreeFile()` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-1101">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-1102">Il `FileOpen` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione, che può influire sull'esecuzione in situazioni di attendibilità parziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-1102">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="b3575-1103">Per ulteriori informazioni, vedere l'enumerazione <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-1103">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1104">In questo esempio illustra i vari utilizzi del `FileOpen` funzione per abilitare l'input e output in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1104">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="b3575-1105">Il codice seguente apre il file `TestFile` in `Input` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1105">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="b3575-1106">Questo esempio viene aperto il file in `Binary` modalità per operazioni di sola scrittura.</span><span class="sxs-lookup"><span data-stu-id="b3575-1106">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="b3575-1107">Nell'esempio seguente viene aperto il file in `Random` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1107">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="b3575-1108">Il file contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1108">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="b3575-1109">Questo esempio di codice consente di aprire il file in `Output` modalità, le operazioni possono leggere o scrivere nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1109">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="b3575-1110">Questo esempio di codice consente di aprire il file in `Binary` modalità per la lettura; gli altri processi non è possibile leggere i file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1110">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1111">Lunghezza del record negativa (e diversa da -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1111">Record length is negative (and not equal to -1).</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1112">Il parametro <paramref name="FileName" /> è già aperto oppure <paramref name="FileName" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1112">
              <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-1113">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1113">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1114">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1114">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1115">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1115">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1116">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1116">Required.</span>
          </span>
          <span data-ttu-id="b3575-1117">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1117">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1118">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1118">Required.</span>
          </span>
          <span data-ttu-id="b3575-1119">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1119">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1120">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1120">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1121">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1121">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1122">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1122">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1123">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1123">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1124">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1124">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1125">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1125">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1126">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1126">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1127">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1127">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1128">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1128">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1129">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1129">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1130">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1130">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1131">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1131">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1132">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1132">Random Mode</span></span>  
 <span data-ttu-id="b3575-1133">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1133">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1134">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1134">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1135">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1135">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1136">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1136">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1137">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1137">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1138">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1138">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1139">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1139">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1140">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1140">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1141">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1141">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1142">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1142">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1143">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1143">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1144">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1144">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1145">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1145">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1146">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1146">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1147">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1147">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1148">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1148">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1149">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1149">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1150">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1150">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1151">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1151">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1152">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1152">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1153">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1153">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1154">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1154">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1155">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1155">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1156">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1156">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1157">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1157">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1158">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1158">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1159">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1159">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1160">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1160">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1161">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1161">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1162">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1162">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1163">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1163">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1164">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1164">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1165">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1165">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1166">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1166">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1167">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1167">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1168">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1168">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1169">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1169">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1170">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1170">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1171">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1171">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1172">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1172">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1173">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1173">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1174">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1174">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1175">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1175">Required.</span>
          </span>
          <span data-ttu-id="b3575-1176">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1176">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1177">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1177">Required.</span>
          </span>
          <span data-ttu-id="b3575-1178">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1178">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1179">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1179">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1180">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1180">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1181">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1181">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1182">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1182">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1183">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1183">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1184">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1184">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1185">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1185">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1186">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1186">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1187">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1187">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1188">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1188">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1189">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1189">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1190">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1190">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1191">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1191">Random Mode</span></span>  
 <span data-ttu-id="b3575-1192">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1192">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1193">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1193">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1194">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1194">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1195">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1195">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1196">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1196">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1197">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1197">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1198">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1198">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1199">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1199">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1200">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1200">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1201">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1201">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1202">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1202">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1203">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1203">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1204">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1204">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1205">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1205">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1206">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1206">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1207">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1207">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1208">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1208">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1209">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1209">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1210">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1210">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1211">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1211">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1212">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1212">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1213">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1213">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1214">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1214">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1215">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1215">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1216">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1216">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1217">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1217">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1218">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1218">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1219">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1219">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1220">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1220">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1221">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1221">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1222">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1222">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1223">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1223">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1224">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1224">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1225">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1225">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1226">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1226">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1227">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1227">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1228">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1228">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1229">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1229">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1230">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1230">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1231">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1231">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1232">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1232">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1233">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1233">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1234">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1234">Required.</span>
          </span>
          <span data-ttu-id="b3575-1235">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1235">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1236">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1236">Required.</span>
          </span>
          <span data-ttu-id="b3575-1237">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1237">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1238">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1238">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1239">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1239">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1240">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1240">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1241">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1241">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1242">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1242">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1243">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1243">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1244">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1244">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1245">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1245">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1246">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1246">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1247">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1247">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1248">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1248">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1249">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1249">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1250">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1250">Random Mode</span></span>  
 <span data-ttu-id="b3575-1251">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1251">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1252">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1252">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1253">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1253">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1254">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1254">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1255">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1255">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1256">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1256">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1257">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1257">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1258">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1258">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1259">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1259">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1260">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1260">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1261">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1261">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1262">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1262">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1263">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1263">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1264">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1264">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1265">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1265">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1266">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1266">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1267">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1267">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1268">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1268">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1269">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1269">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1270">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1270">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1271">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1271">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1272">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1272">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1273">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1273">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1274">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1274">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1275">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1275">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1276">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1276">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1277">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1277">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1278">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1278">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1279">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1279">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1280">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1280">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1281">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1281">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1282">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1282">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1283">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1283">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1284">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1284">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1285">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1285">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1286">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1286">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1287">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1287">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1288">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1288">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1289">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1289">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1290">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1290">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1291">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1291">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1292">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1292">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1293">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1293">Required.</span>
          </span>
          <span data-ttu-id="b3575-1294">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1294">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1295">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1295">Required.</span>
          </span>
          <span data-ttu-id="b3575-1296">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1296">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1297">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1297">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1298">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1298">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1299">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1299">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1300">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1300">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1301">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1301">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1302">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1302">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1303">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1303">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1304">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1304">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1305">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1305">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1306">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1306">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1307">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1307">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1308">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1308">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1309">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1309">Random Mode</span></span>  
 <span data-ttu-id="b3575-1310">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1310">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1311">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1311">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1312">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1312">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1313">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1313">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1314">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1314">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1315">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1315">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1316">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1316">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1317">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1317">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1318">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1318">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1319">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1319">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1320">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1320">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1321">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1321">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1322">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1322">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1323">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1323">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1324">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1324">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1325">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1325">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1326">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1326">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1327">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1327">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1328">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1328">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1329">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1329">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1330">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1330">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1331">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1331">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1332">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1332">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1333">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1333">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1334">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1334">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1335">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1335">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1336">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1336">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1337">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1337">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1338">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1338">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1339">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1339">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1340">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1340">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1341">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1341">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1342">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1342">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1343">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1343">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1344">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1344">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1345">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1345">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1346">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1346">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1347">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1347">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1348">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1348">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1349">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1349">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1350">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1350">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1351">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1351">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1352">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1352">Required.</span>
          </span>
          <span data-ttu-id="b3575-1353">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1353">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1354">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1354">Required.</span>
          </span>
          <span data-ttu-id="b3575-1355">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1355">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1356">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1356">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1357">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1357">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1358">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1358">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1359">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1359">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1360">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1360">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1361">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1361">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1362">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1362">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1363">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1363">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1364">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1364">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1365">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1365">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1366">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1366">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1367">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1367">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1368">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1368">Random Mode</span></span>  
 <span data-ttu-id="b3575-1369">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1369">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1370">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1370">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1371">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1371">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1372">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1372">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1373">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1373">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1374">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1374">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1375">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1375">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1376">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1376">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1377">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1377">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1378">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1378">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1379">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1379">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1380">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1380">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1381">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1381">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1382">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1382">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1383">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1383">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1384">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1384">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1385">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1385">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1386">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1386">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1387">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1387">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1388">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1388">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1389">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1389">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1390">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1390">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1391">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1391">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1392">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1392">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1393">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1393">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1394">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1394">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1395">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1395">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1396">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1396">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1397">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1397">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1398">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1398">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1399">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1399">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1400">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1400">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1401">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1401">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1402">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1402">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1403">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1403">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1404">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1404">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1405">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1405">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1406">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1406">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1407">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1407">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1408">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1408">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1409">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1409">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1410">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1410">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1411">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1411">Required.</span>
          </span>
          <span data-ttu-id="b3575-1412">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1412">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1413">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1413">Required.</span>
          </span>
          <span data-ttu-id="b3575-1414">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1414">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1415">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1415">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1416">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1416">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1417">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1417">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1418">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1418">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1419">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1419">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1420">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1420">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1421">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1421">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1422">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1422">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1423">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1423">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1424">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1424">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1425">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1425">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1426">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1426">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1427">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1427">Random Mode</span></span>  
 <span data-ttu-id="b3575-1428">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1428">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1429">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1429">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1430">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1430">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1431">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1431">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1432">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1432">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1433">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1433">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1434">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1434">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1435">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1435">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1436">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1436">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1437">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1437">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1438">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1438">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1439">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1439">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1440">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1440">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1441">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1441">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1442">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1442">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1443">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1443">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1444">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1444">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1445">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1445">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1446">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1446">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1447">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1447">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1448">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1448">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1449">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1449">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1450">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1450">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1451">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1451">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1452">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1452">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1453">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1453">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1454">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1454">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1455">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1455">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1456">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1456">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1457">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1457">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1458">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1458">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1459">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1459">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1460">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1460">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1461">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1461">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1462">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1462">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1463">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1463">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1464">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1464">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1465">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1465">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1466">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1466">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1467">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1467">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1468">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1468">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1469">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1469">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1470">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1470">Required.</span>
          </span>
          <span data-ttu-id="b3575-1471">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1471">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1472">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1472">Required.</span>
          </span>
          <span data-ttu-id="b3575-1473">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1473">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1474">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1474">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1475">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1475">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1476">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1476">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1477">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1477">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1478">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1478">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1479">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1479">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1480">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1480">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1481">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1481">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1482">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1482">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1483">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1483">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1484">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1484">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1485">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1485">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1486">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1486">Random Mode</span></span>  
 <span data-ttu-id="b3575-1487">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1487">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1488">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1488">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1489">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1489">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1490">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1490">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1491">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1491">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1492">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1492">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1493">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1493">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1494">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1494">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1495">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1495">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1496">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1496">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1497">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il`VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1497">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1498">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1498">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1499">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1499">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1500">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1500">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1501">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1501">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1502">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1502">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1503">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1503">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1504">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1504">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1505">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1505">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1506">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1506">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1507">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1507">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1508">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1508">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1509">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1509">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1510">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1510">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1511">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1511">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1512">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1512">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1513">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1513">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1514">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1514">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1515">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1515">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1516">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1516">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1517">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1517">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1518">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1518">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1519">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1519">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1520">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1520">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1521">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1521">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1522">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1522">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1523">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1523">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1524">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1524">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1525">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1525">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1526">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1526">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1527">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1527">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1528">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1528">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1529">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1529">Required.</span>
          </span>
          <span data-ttu-id="b3575-1530">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1530">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1531">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1531">Required.</span>
          </span>
          <span data-ttu-id="b3575-1532">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1532">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1533">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1533">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1534">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1534">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1535">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1535">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1536">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1536">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1537">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1537">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1538">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1538">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1539">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1539">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1540">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1540">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1541">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1541">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1542">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1542">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1543">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1543">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1544">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1544">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1545">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1545">Random Mode</span></span>  
 <span data-ttu-id="b3575-1546">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1546">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1547">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1547">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1548">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1548">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1549">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1549">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1550">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1550">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1551">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1551">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1552">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1552">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1553">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1553">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1554">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1554">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1555">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1555">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1556">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1556">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1557">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1557">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1558">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1558">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1559">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1559">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1560">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1560">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1561">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1561">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1562">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1562">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1563">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1563">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1564">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1564">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1565">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1565">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1566">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1566">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1567">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1567">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1568">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1568">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1569">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1569">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1570">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1570">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1571">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1571">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1572">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1572">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1573">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1573">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1574">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1574">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1575">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1575">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1576">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1576">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1577">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1577">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1578">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1578">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1579">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1579">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1580">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1580">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1581">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1581">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1582">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1582">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1583">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1583">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1584">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1584">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1585">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1585">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1586">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1586">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1587">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1587">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1588">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1588">Required.</span>
          </span>
          <span data-ttu-id="b3575-1589">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1589">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1590">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1590">Required.</span>
          </span>
          <span data-ttu-id="b3575-1591">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1591">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1592">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1592">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1593">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1593">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1594">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1594">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1595">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1595">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1596">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1596">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1597">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1597">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1598">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1598">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1599">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1599">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1600">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1600">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1601">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1601">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1602">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1602">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1603">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1603">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1604">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1604">Random Mode</span></span>  
 <span data-ttu-id="b3575-1605">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1605">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1606">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1606">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1607">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1607">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1608">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1608">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1609">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1609">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1610">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1610">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1611">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1611">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1612">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1612">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1613">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1613">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1614">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1614">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1615">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1615">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1616">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1616">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1617">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1617">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1618">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1618">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1619">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1619">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1620">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1620">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1621">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1621">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1622">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1622">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1623">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1623">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1624">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1624">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1625">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1625">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1626">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1626">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1627">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1627">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1628">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1628">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1629">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1629">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1630">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1630">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1631">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1631">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1632">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1632">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1633">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1633">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1634">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1634">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1635">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1635">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1636">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1636">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1637">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1637">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1638">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1638">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1639">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1639">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1640">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1640">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1641">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1641">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1642">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1642">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1643">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1643">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1644">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1644">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1645">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1645">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1646">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1646">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1647">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1647">Required.</span>
          </span>
          <span data-ttu-id="b3575-1648">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1648">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1649">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1649">Required.</span>
          </span>
          <span data-ttu-id="b3575-1650">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1650">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1651">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1651">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1652">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1652">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1653">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1653">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1654">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1654">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1655">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1655">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1656">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1656">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1657">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1657">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1658">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1658">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1659">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1659">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1660">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1660">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1661">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1661">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1662">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1662">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1663">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1663">Random Mode</span></span>  
 <span data-ttu-id="b3575-1664">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1664">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1665">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1665">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1666">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1666">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1667">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1667">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1668">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1668">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1669">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1669">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1670">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1670">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1671">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1671">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1672">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1672">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1673">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1673">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1674">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1674">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1675">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1675">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1676">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1676">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1677">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1677">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1678">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1678">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1679">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1679">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1680">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1680">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1681">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1681">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1682">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1682">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1683">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1683">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1684">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1684">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1685">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1685">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1686">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1686">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1687">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1687">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1688">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1688">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1689">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1689">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1690">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1690">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1691">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1691">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1692">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1692">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1693">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1693">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1694">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1694">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1695">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1695">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1696">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1696">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1697">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1697">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1698">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1698">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1699">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1699">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1700">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1700">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1701">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1701">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1702">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1702">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1703">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1703">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1704">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1704">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1705">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1705">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1706">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1706">Required.</span>
          </span>
          <span data-ttu-id="b3575-1707">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1707">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1708">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1708">Required.</span>
          </span>
          <span data-ttu-id="b3575-1709">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1709">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1710">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1710">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1711">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1711">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1712">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1712">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1713">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1713">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1714">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1714">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1715">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1715">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1716">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1716">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1717">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1717">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1718">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1718">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1719">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1719">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1720">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1720">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1721">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1721">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1722">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1722">Random Mode</span></span>  
 <span data-ttu-id="b3575-1723">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1723">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1724">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel`RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1724">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1725">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1725">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1726">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1726">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1727">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1727">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1728">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1728">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1729">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1729">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1730">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1730">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1731">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1731">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1732">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1732">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1733">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1733">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1734">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1734">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1735">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1735">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1736">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1736">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1737">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1737">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1738">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1738">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1739">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1739">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1740">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1740">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1741">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1741">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1742">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1742">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1743">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1743">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1744">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1744">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1745">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1745">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1746">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1747">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1747">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1748">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1748">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1749">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1749">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1750">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1750">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1751">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1751">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1752">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1752">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1753">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1753">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1754">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1754">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1755">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1755">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1756">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1756">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1757">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1757">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1758">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1758">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1759">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1759">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1760">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1760">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1761">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1761">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1762">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1762">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1763">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1763">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1764">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1764">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1765">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1765">Required.</span>
          </span>
          <span data-ttu-id="b3575-1766">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1766">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1767">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1767">Required.</span>
          </span>
          <span data-ttu-id="b3575-1768">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1768">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1769">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1769">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1770">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1770">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1771">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1771">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1772">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1772">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1773">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1773">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1774">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1774">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1775">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1775">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1776">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1776">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1777">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1777">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1778">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1778">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1779">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1779">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1780">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1780">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1781">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1781">Random Mode</span></span>  
 <span data-ttu-id="b3575-1782">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1782">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1783">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1783">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1784">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1784">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1785">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1785">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1786">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1786">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1787">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1787">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1788">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1788">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1789">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1789">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1790">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1790">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1791">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1791">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1792">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1792">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1793">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1793">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1794">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1794">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1795">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1795">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1796">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1796">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1797">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1797">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1798">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1798">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1799">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1799">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1800">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1800">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1801">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1801">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1802">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1802">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1803">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1803">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1804">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1804">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1805">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1805">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1806">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1806">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1807">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1807">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1808">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1808">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1809">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1809">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1810">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1810">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1811">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1811">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1812">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1812">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1813">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1813">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1814">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1814">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1815">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1815">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1816">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1816">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1817">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1817">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1818">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1818">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1819">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1819">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1820">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1820">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1821">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1821">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1822">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1822">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1823">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1823">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1824">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1824">Required.</span>
          </span>
          <span data-ttu-id="b3575-1825">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1825">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1826">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1826">Required.</span>
          </span>
          <span data-ttu-id="b3575-1827">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1827">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1828">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1828">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1829">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1829">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="b3575-1830">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1830">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1831">Si applica solo durante la scrittura di una stringa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1831">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="b3575-1832">Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1832">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="b3575-1833">Il valore predefinito è <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1833">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1834">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1834">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1835">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1835">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1836">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1836">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1837">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1837">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1838">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1838">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1839">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1839">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1840">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1840">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1841">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1841">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1842">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1842">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1843">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1843">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1844">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1844">Random Mode</span></span>  
 <span data-ttu-id="b3575-1845">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1845">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1846">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1846">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1847">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1847">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1848">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1848">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1849">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1849">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1850">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1850">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1851">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1851">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1852">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1852">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1853">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1853">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1854">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1854">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1855">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1855">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1856">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1856">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1857">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1857">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1858">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1858">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1859">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1859">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1860">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1860">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1861">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1861">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1862">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1862">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1863">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1863">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1864">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1864">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1865">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1865">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1866">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1866">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1867">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1867">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1868">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1868">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1869">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1869">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1870">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1870">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1871">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1871">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1872">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1872">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1873">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1873">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1874">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1874">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1875">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1875">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1876">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1876">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1877">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1877">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1878">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1878">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1879">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1879">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1880">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1880">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1881">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1881">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1882">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1882">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1883">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1883">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1884">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1884">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1885">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1885">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1886">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1886">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1887">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1887">Required.</span>
          </span>
          <span data-ttu-id="b3575-1888">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1888">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1889">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1889">Required.</span>
          </span>
          <span data-ttu-id="b3575-1890">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1890">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1891">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1891">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1892">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1892">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="b3575-1893">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1893">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1894">Si applica solo durante la scrittura di una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1894">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="b3575-1895">Specifica se la matrice deve essere considerata dinamica e se deve essere scritto un descrittore di matrice per la stringa che descrive la lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1895">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="b3575-1896">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1896">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1897">Si applica solo durante la scrittura di una stringa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1897">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="b3575-1898">Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1898">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="b3575-1899">Il valore predefinito è <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1899">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1900">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1900">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1901">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1901">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="b3575-1902">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1902">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1903">`FilePut` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1903">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1904">I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1904">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="b3575-1905">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1905">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1906">Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` oppure `FilePut` funzione o a cui punta l'ultimo `Seek` funzione è scritta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1906">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="b3575-1907">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1907">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1908">`FilePut` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1908">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1909">Se si usa `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1909">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1910">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1910">Random Mode</span></span>  
 <span data-ttu-id="b3575-1911">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1911">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1912">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePut` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1912">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1913">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1913">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1914">Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1914">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1915">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` (funzione), verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1915">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1916">Se la variabile scritta è una stringa, `FilePut` scrive un descrittore a due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1916">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="b3575-1917">Pertanto, la lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1917">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="b3575-1918">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePut` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1918">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1919">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1919">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1920">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1920">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1921">Se un oggetto che contiene una stringa, la variabile scritta `FilePut` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1921">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1922">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1922">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1923">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1923">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1924">Se la variabile scritta è una matrice, è necessario scegliere di scrivere un descrittore per le dimensioni della matrice o meno.</span><span class="sxs-lookup"><span data-stu-id="b3575-1924">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="b3575-1925">Visual Basic 6.0 e versioni precedenti di scrivono il descrittore del file per una matrice dinamica, ma non per una matrice di dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="b3575-1925">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="b3575-1926">Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1926">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="b3575-1927">Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro per `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1927">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="b3575-1928">Quando si scrive la matrice, devono corrispondere il modo in cui che verrà letta la matrice. Se si leggeranno con il descrittore di, è necessario scrivere il descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1928">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="b3575-1929">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1929">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1930">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1930">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="b3575-1931">La lunghezza del record specificata per il `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati della matrice e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1931">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1932">Ad esempio, la dichiarazione di matrice seguente richiede 218 byte quando la matrice viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1932">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="b3575-1933">Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa a lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1933">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="b3575-1934">La lunghezza del record specificata dal `RecordLength` clausola nel `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1934">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="b3575-1935">`FilePut` scrive elementi di strutture come se fossero scritti singolarmente, ma non è disponibile alcun riempimento tra gli elementi.</span><span class="sxs-lookup"><span data-stu-id="b3575-1935">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="b3575-1936">Il `VBFixedString` attributo può essere applicato ai campi di stringhe nelle strutture per indicare la dimensione della stringa quando viene scritto su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-1936">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b3575-1937">Campi che hanno più byte rispetto a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,</span><span class="sxs-lookup"><span data-stu-id="b3575-1937">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1938">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1938">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1939">Per i file aperti `Binary` modalità, la maggior parte del `Random` si applicano le regole della modalità, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-1939">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="b3575-1940">Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:</span><span class="sxs-lookup"><span data-stu-id="b3575-1940">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="b3575-1941">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1941">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1942">`FilePut` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1942">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="b3575-1943">Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1943">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="b3575-1944">Viene scritto alcun descrittore.</span><span class="sxs-lookup"><span data-stu-id="b3575-1944">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="b3575-1945">`FilePut` Scrive stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1945">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="b3575-1946">Il numero di byte scritti è uguale al numero di caratteri nella stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1946">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="b3575-1947">Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:</span><span class="sxs-lookup"><span data-stu-id="b3575-1947">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="b3575-1948">La scrittura in un file usando il `FilePut` funzione richiede `Write` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1948">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1949">Questo esempio viene usato il `FilePut` funzione per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1949">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="b3575-1950">Cinque record della struttura `Person` vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1950">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-1951">
            <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1951">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-1952">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1952">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1953">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1953">Required.</span>
          </span>
          <span data-ttu-id="b3575-1954">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1954">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-1955">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1955">Required.</span>
          </span>
          <span data-ttu-id="b3575-1956">Nome di variabile valido che contiene i dati scritti su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1956">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="b3575-1957">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1957">Optional.</span>
          </span>
          <span data-ttu-id="b3575-1958">Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1958">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1959">Scrive dati da una variabile in un file del disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1959">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="b3575-1960">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePutObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1960">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span>
          </span>
          <span data-ttu-id="b3575-1961">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1961">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-1962">Il `FilePutObject` funzione viene usata invece di `FilePut` per evitare ambiguità in fase di compilazione se tipo `Object` viene passato anziché un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1962">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="b3575-1963">`FilePutObject` scrive e legge i descrittori che descrivono l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1963">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="b3575-1964">Se si prevede di scrivere la `Variant` tipo, `FilePutObject` è obbligatorio.</span><span class="sxs-lookup"><span data-stu-id="b3575-1964">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="b3575-1965">In caso di dubbi, se si usa un oggetto per il secondo parametro, è consigliabile usare sempre `FilePutObject` e `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1965">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="b3575-1966">`FilePutObject` è valido solo nei `Random` e `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1966">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-1967">I dati scritti con `FilePutObject` vengono in genere letti da un file usando `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1967">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="b3575-1968">Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte corrisponde alla posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-1968">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="b3575-1969">Se si omette `RecordNumber`, `FilePutObject` scriva il record o byte dopo l'ultimo `FileGetObject` oppure `FilePutObject` funzione (o il record o byte a cui punta l'ultimo `Seek` (funzione)).</span><span class="sxs-lookup"><span data-stu-id="b3575-1969">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="b3575-1970">Il `StringIsFixedLength` argomento consente di controllare se la funzione interpreta le stringhe a lunghezza fissa o variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1970">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="b3575-1971">`FilePutObject` non scrive il descrittore di lunghezza quando l'argomento è `True`.</span><span class="sxs-lookup"><span data-stu-id="b3575-1971">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="b3575-1972">Se si usa `StringIsFixedLength`  =  `True` con `FilePutObject`, è necessario eseguire la stessa operazione con `FileGetObject`, e assicurarsi che la stringa viene inizializzata alla lunghezza prevista.</span><span class="sxs-lookup"><span data-stu-id="b3575-1972">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="b3575-1973">Modalità casuale</span><span class="sxs-lookup"><span data-stu-id="b3575-1973">Random Mode</span></span>  
 <span data-ttu-id="b3575-1974">Per i file aperti `Random` modalità, applicano le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-1974">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="b3575-1975">Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, `FilePutObject` scrive i record successivi su limiti di lunghezza di record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1975">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="b3575-1976">Lo spazio tra l'inizio del record successivo e la fine di un record viene riempito con il contenuto del buffer di file esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-1976">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="b3575-1977">Poiché la quantità di dati di spaziatura interna non è possibile determinare in modo preciso, in genere è una buona idea per avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere.</span><span class="sxs-lookup"><span data-stu-id="b3575-1977">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="b3575-1978">Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b3575-1978">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="b3575-1979">Se un oggetto che contiene un tipo numerico, la variabile scritta `FilePutObject` scrive due byte che identifica il `VarType` dell'oggetto e quindi scrive la variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-1979">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="b3575-1980">Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePutObject` scrive byte sei: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro i byte che contengono i dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-1980">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="b3575-1981">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1981">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="b3575-1982">Se un oggetto che contiene una stringa, la variabile scritta `FilePutObject` scrive un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore a due byte che indica la lunghezza della stringa e quindi i dati della stringa.</span><span class="sxs-lookup"><span data-stu-id="b3575-1982">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="b3575-1983">La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte.</span><span class="sxs-lookup"><span data-stu-id="b3575-1983">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="b3575-1984">Se si desidera inserire una stringa senza il descrittore di, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve essere la lunghezza corretta.</span><span class="sxs-lookup"><span data-stu-id="b3575-1984">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="b3575-1985">Se la variabile scritta è una matrice, è necessario che la lunghezza del record specificata dalla clausola `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice.</span><span class="sxs-lookup"><span data-stu-id="b3575-1985">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="b3575-1986">Il descrittore specifica il numero di dimensioni di matrice, le dimensioni e i limiti inferiori per ogni priorità.</span><span class="sxs-lookup"><span data-stu-id="b3575-1986">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="b3575-1987">La lunghezza è uguale a 2 oltre a 8 volte il numero di dimensioni: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="b3575-1987">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="b3575-1988">Modalità binaria</span><span class="sxs-lookup"><span data-stu-id="b3575-1988">Binary Mode</span></span>  
 <span data-ttu-id="b3575-1989">Per i file aperti `Binary` modalità, tutti la `Random` si applicano le regole della modalità, ad eccezione di:</span><span class="sxs-lookup"><span data-stu-id="b3575-1989">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="b3575-1990">Il `RecordLength` clausola nel `FileOpen` funzione non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="b3575-1990">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="b3575-1991">`FilePutObject` Scrive tutte le variabili su disco in modo contiguo, vale a dire, senza spazi tra i record.</span><span class="sxs-lookup"><span data-stu-id="b3575-1991">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-1992">Questo esempio viene usato il `FilePutObject` funzione per scrivere una stringa in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-1992">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-1993">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1993">Required.</span>
          </span>
          <span data-ttu-id="b3575-1994">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1994">Any valid file number.</span>
          </span>
        </param>
        <param name="RecordWidth">
          <span data-ttu-id="b3575-1995">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1995">Required.</span>
          </span>
          <span data-ttu-id="b3575-1996">Espressione numerica compresa nell'intervallo tra 0 e 255 inclusi, che indica quanti caratteri devono comparire in una riga prima che venga iniziata una nuova riga.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1996">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span>
          </span>
          <span data-ttu-id="b3575-1997">Se <c>RecordWidth</c> è uguale a 0, non esiste alcun limite alla lunghezza della riga.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1997">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span>
          </span>
          <span data-ttu-id="b3575-1998">Il valore predefinito per <c>RecordWidth</c> è 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1998">The default value for <c>RecordWidth</c> is 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-1999">Assegna lo spessore della linea di output per un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-1999">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3575-2000">Questo esempio viene usato il `FileWidth` funzione per impostare la larghezza della riga di output per un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2000">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2001">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2001">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2002">Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2002">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2003">Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2003">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2004">Usare `FreeFile` per fornire un numero di file che non è già in uso.</span><span class="sxs-lookup"><span data-stu-id="b3575-2004">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2005">Questo esempio viene usato il `FreeFile` funzione per restituire il successivo numero di file disponibili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2005">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="b3575-2006">Cinque file aperti per l'output all'interno del ciclo e alcuni dati di esempio sono scritto per ognuno.</span><span class="sxs-lookup"><span data-stu-id="b3575-2006">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2007">Più di 255 file sono in uso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2007">More than 255 files are in use.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-2008">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2008">Required.</span>
          </span>
          <span data-ttu-id="b3575-2009">Espressione <see langword="String" /> che specifica un nome di file, directory o cartella.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2009">
              <see langword="String" /> expression that specifies a file, directory, or folder name.</span>
          </span>
          <span data-ttu-id="b3575-2010">Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2010">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2011">Restituisce un valore <see langword="FileAttribute" /> che rappresenta gli attributi di un file, di una directory o di una cartella.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2011">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span>
          </span>
          <span data-ttu-id="b3575-2012">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2012">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span>
          </span>
          <span data-ttu-id="b3575-2013">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2013">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2014">Il valore restituito dalla funzione <see langword="GetAttr" /> è la somma dei seguenti valori di enumerazione:</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2014">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span>
          </span>
          <span data-ttu-id="b3575-2015">
            <list type="table">
              <item>
                <term> Valore </term>
                <description> Costante </description>
                <description> Descrizione </description>
              </item>
              <item>
                <term>
                  <see langword="Normal" />
                </term>
                <description>
                  <see langword="vbNormal" />
                </description>
                <description> Normale.  </description>
              </item>
              <item>
                <term>
                  <see langword="ReadOnly" />
                </term>
                <description>
                  <see langword="vbReadOnly" />
                </description>
                <description> Sola lettura.  </description>
              </item>
              <item>
                <term>
                  <see langword="Hidden" />
                </term>
                <description>
                  <see langword="vbHidden" />
                </description>
                <description> Nascosto.  </description>
              </item>
              <item>
                <term>
                  <see langword="System" />
                </term>
                <description>
                  <see langword="vbSystem" />
                </description>
                <description> File di sistema.  </description>
              </item>
              <item>
                <term>
                  <see langword="Directory" />
                </term>
                <description>
                  <see langword="vbDirectory" />
                </description>
                <description> Directory o cartella.  </description>
              </item>
              <item>
                <term>
                  <see langword="Archive" />
                </term>
                <description>
                  <see langword="vbArchive" />
                </description>
                <description> Il file è stato modificato dopo l'ultimo backup.  </description>
              </item>
              <item>
                <term>
                  <see langword="Alias" />
                </term>
                <description>
                  <see langword="vbAlias" />
                </description>
                <description> Il file ha un nome diverso.  </description>
              </item>
            </list>
            <block subset="none" type="note">
              <para> Queste enumerazioni sono specificate dal linguaggio Visual Basic. I nomi possono essere usati in qualsiasi punto del codice in sostituzione dei valori effettivi. </para>
            </block>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2015">
              <list type="table">
                <item>
                  <term> Value  </term>
                  <description> Constant  </description>
                  <description> Description  </description>
                </item>
                <item>
                  <term>
                    <see langword="Normal" />
                  </term>
                  <description>
                    <see langword="vbNormal" />
                  </description>
                  <description> Normal.  </description>
                </item>
                <item>
                  <term>
                    <see langword="ReadOnly" />
                  </term>
                  <description>
                    <see langword="vbReadOnly" />
                  </description>
                  <description> Read-only.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Hidden" />
                  </term>
                  <description>
                    <see langword="vbHidden" />
                  </description>
                  <description> Hidden.  </description>
                </item>
                <item>
                  <term>
                    <see langword="System" />
                  </term>
                  <description>
                    <see langword="vbSystem" />
                  </description>
                  <description> System file.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Directory" />
                  </term>
                  <description>
                    <see langword="vbDirectory" />
                  </description>
                  <description> Directory or folder.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Archive" />
                  </term>
                  <description>
                    <see langword="vbArchive" />
                  </description>
                  <description> File has changed since last backup.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Alias" />
                  </term>
                  <description>
                    <see langword="vbAlias" />
                  </description>
                  <description> File has a different name.  </description>
                </item>
              </list>
              <block subset="none" type="note">
                <para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para>
              </block>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2016">Per determinare quali attributi sono impostati, usare il `And` operatore per eseguire un confronto bit per bit del valore restituito dal `GetAttr` (funzione) e il valore dell'attributo del file desiderato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2016">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="b3575-2017">Se il risultato non è zero, tale attributo è impostato per il file specificato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2017">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="b3575-2018">Ad esempio, il valore restituito di quanto segue `And` espressione è zero se il `Archive` attributo non è impostato:</span><span class="sxs-lookup"><span data-stu-id="b3575-2018">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="b3575-2019">Viene restituito un valore diverso da zero se il `Archive` attributo è impostato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2019">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2020">Questo esempio viene usato il `GetAttr` funzione per determinare gli attributi di file e directory o cartella.</span><span class="sxs-lookup"><span data-stu-id="b3575-2020">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2021">
            <paramref name="Pathname" /> non è valido o contiene caratteri jolly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2021">
              <paramref name="Pathname" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-2022">Il file di destinazione non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2022">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2023">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2023">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2024">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2024">Required.</span>
          </span>
          <span data-ttu-id="b3575-2025">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2025">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2026">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2026">Required.</span>
          </span>
          <span data-ttu-id="b3575-2027">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2027">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2028">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2028">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2029">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2029">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2030">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2030">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2031">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2031">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2032">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2032">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2033">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2033">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2034">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2034">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2035">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2035">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2036">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2036">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2037">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2037">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2038">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2038">Data</span></span>|<span data-ttu-id="b3575-2039">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2039">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2040">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2040">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2041">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2041">Empty</span></span>|  
|<span data-ttu-id="b3575-2042">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2042">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2043">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2043">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2044">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2044">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2045">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2045">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2046">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2046">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2047">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2047">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2048">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2048">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2049">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2049">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2050">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2050">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2051">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2051">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2052">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2052">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2053">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2053">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2054">Questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2054">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2055">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2055">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2056">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2056">Required.</span>
          </span>
          <span data-ttu-id="b3575-2057">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2057">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2058">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2058">Required.</span>
          </span>
          <span data-ttu-id="b3575-2059">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2059">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2060">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2060">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2061">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2061">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2062">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2062">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2063">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2063">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2064">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2064">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2065">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2065">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2066">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2066">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2067">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2067">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2068">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2068">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2069">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2069">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2070">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2070">Data</span></span>|<span data-ttu-id="b3575-2071">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2071">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2072">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2072">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2073">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2073">Empty</span></span>|  
|<span data-ttu-id="b3575-2074">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2074">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2075">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2075">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2076">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2076">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2077">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2077">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2078">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2078">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2079">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2079">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2080">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2080">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2081">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2081">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2082">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2082">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2083">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2083">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2084">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2084">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2085">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2085">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2086">Questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2086">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2087">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2087">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2088">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2088">Required.</span>
          </span>
          <span data-ttu-id="b3575-2089">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2089">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2090">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2090">Required.</span>
          </span>
          <span data-ttu-id="b3575-2091">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2091">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2092">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2092">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2093">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2093">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2094">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2094">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2095">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2095">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2096">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2096">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2097">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2097">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2098">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2098">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2099">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2099">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2100">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2100">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2101">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2101">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2102">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2102">Data</span></span>|<span data-ttu-id="b3575-2103">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2103">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2104">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2104">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2105">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2105">Empty</span></span>|  
|<span data-ttu-id="b3575-2106">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2106">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2107">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2107">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2108">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2108">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2109">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2109">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2110">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2110">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2111">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2111">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2112">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2112">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2113">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2113">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2114">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2114">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2115">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2115">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2116">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2116">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2117">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2117">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2118">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2118">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2119">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2119">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2120">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2120">Required.</span>
          </span>
          <span data-ttu-id="b3575-2121">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2121">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2122">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2122">Required.</span>
          </span>
          <span data-ttu-id="b3575-2123">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2123">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2124">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2124">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2125">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2125">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2126">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2126">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2127">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2127">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2128">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2128">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2129">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2129">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2130">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2130">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2131">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2131">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2132">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2132">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2133">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2133">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2134">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2134">Data</span></span>|<span data-ttu-id="b3575-2135">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2135">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2136">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2136">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2137">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2137">Empty</span></span>|  
|<span data-ttu-id="b3575-2138">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2138">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2139">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2139">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2140">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2140">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2141">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2141">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2142">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2142">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2143">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2143">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2144">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2144">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2145">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2145">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2146">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2146">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2147">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2147">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2148">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2148">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2149">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2149">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2150">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2150">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2151">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2151">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2152">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2152">Required.</span>
          </span>
          <span data-ttu-id="b3575-2153">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2153">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2154">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2154">Required.</span>
          </span>
          <span data-ttu-id="b3575-2155">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2155">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2156">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2156">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2157">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2157">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2158">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2158">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2159">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2159">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2160">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2160">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2161">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2161">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2162">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2162">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2163">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2163">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2164">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2164">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2165">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2165">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2166">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2166">Data</span></span>|<span data-ttu-id="b3575-2167">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2167">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2168">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2168">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2169">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2169">Empty</span></span>|  
|<span data-ttu-id="b3575-2170">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2170">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2171">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2171">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2172">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2172">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2173">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2173">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2174">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2174">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2175">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2175">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2176">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2176">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2177">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2177">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2178">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2178">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2179">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2179">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2180">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2180">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2181">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2181">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2182">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2182">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2183">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2183">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2184">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2184">Required.</span>
          </span>
          <span data-ttu-id="b3575-2185">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2185">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2186">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2186">Required.</span>
          </span>
          <span data-ttu-id="b3575-2187">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2187">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2188">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2188">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2189">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2189">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2190">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2190">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2191">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2191">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2192">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2192">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2193">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2193">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2194">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2194">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2195">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2195">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2196">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2196">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2197">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2197">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2198">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2198">Data</span></span>|<span data-ttu-id="b3575-2199">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2199">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2200">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2200">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2201">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2201">Empty</span></span>|  
|<span data-ttu-id="b3575-2202">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2202">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2203">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2203">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2204">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2204">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2205">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2205">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2206">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2206">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2207">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2207">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2208">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2208">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2209">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2209">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2210">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2210">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2211">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2211">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2212">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2212">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2213">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2213">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2214">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2214">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2215">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2215">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2216">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2216">Required.</span>
          </span>
          <span data-ttu-id="b3575-2217">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2217">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2218">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2218">Required.</span>
          </span>
          <span data-ttu-id="b3575-2219">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2219">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2220">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2220">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2221">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2221">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2222">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2222">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2223">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2223">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2224">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2224">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2225">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2225">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2226">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2226">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2227">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2227">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2228">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2228">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2229">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2229">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2230">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2230">Data</span></span>|<span data-ttu-id="b3575-2231">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2231">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2232">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2232">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2233">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2233">Empty</span></span>|  
|<span data-ttu-id="b3575-2234">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2234">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2235">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2235">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2236">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2236">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2237">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2237">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2238">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2238">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2239">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2239">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2240">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2240">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2241">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2241">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2242">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2242">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2243">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2243">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2244">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2244">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2245">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2245">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2246">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2246">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2247">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2247">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2248">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2248">Required.</span>
          </span>
          <span data-ttu-id="b3575-2249">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2249">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2250">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2250">Required.</span>
          </span>
          <span data-ttu-id="b3575-2251">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2251">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2252">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2252">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2253">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2253">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2254">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2254">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2255">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2255">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2256">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2256">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2257">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2257">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2258">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2258">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2259">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2259">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2260">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2260">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2261">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2261">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2262">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2262">Data</span></span>|<span data-ttu-id="b3575-2263">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2263">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2264">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2264">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2265">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2265">Empty</span></span>|  
|<span data-ttu-id="b3575-2266">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2266">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2267">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2267">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2268">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2268">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2269">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2269">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2270">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2270">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2271">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2271">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2272">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2272">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2273">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2273">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2274">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2274">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2275">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2275">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2276">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2276">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2277">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2277">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2278">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2278">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2279">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2279">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2280">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2280">Required.</span>
          </span>
          <span data-ttu-id="b3575-2281">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2281">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2282">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2282">Required.</span>
          </span>
          <span data-ttu-id="b3575-2283">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2283">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2284">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2284">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2285">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2285">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2286">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2286">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2287">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2287">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2288">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2288">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2289">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2289">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2290">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2290">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2291">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2291">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2292">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2292">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2293">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2293">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2294">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2294">Data</span></span>|<span data-ttu-id="b3575-2295">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2295">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2296">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2296">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2297">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2297">Empty</span></span>|  
|<span data-ttu-id="b3575-2298">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2298">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2299">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2299">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2300">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2300">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2301">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2301">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2302">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2302">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2303">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2303">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2304">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2304">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2305">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2305">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2306">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2306">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2307">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2307">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2308">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2308">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2309">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2309">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2310">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2310">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2311">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2311">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2312">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2312">Required.</span>
          </span>
          <span data-ttu-id="b3575-2313">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2313">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2314">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2314">Required.</span>
          </span>
          <span data-ttu-id="b3575-2315">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2315">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2316">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2316">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2317">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2317">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2318">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2318">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2319">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2319">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2320">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2320">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2321">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2321">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2322">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2322">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2323">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2323">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2324">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2324">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2325">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2325">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2326">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2326">Data</span></span>|<span data-ttu-id="b3575-2327">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2327">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2328">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2328">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2329">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2329">Empty</span></span>|  
|<span data-ttu-id="b3575-2330">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2330">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2331">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2331">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2332">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2332">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2333">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2333">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2334">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2334">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2335">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2335">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2336">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2336">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2337">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2337">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2338">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2338">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2339">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2339">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2340">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2340">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2341">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2341">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2342">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2342">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2343">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2343">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2344">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2344">Required.</span>
          </span>
          <span data-ttu-id="b3575-2345">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2345">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2346">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2346">Required.</span>
          </span>
          <span data-ttu-id="b3575-2347">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2347">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2348">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2348">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2349">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2349">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2350">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2350">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2351">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2351">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2352">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2352">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2353">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2353">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2354">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2354">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2355">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2355">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2356">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2356">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2357">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2357">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2358">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2358">Data</span></span>|<span data-ttu-id="b3575-2359">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2359">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2360">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2360">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2361">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2361">Empty</span></span>|  
|<span data-ttu-id="b3575-2362">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2362">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2363">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2363">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2364">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2364">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2365">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2365">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2366">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2366">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2367">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2367">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2368">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2368">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2369">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2369">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2370">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2370">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2371">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2371">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2372">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2372">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2373">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2373">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2374">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2374">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2375">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2375">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2376">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2376">Required.</span>
          </span>
          <span data-ttu-id="b3575-2377">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2377">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="b3575-2378">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2378">Required.</span>
          </span>
          <span data-ttu-id="b3575-2379">La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2379">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2380">Legge i dati da un file sequenziale aperto e li assegna a variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2380">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2381">Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2381">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2382">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2382">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2383">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2383">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2384">I dati letti tramite `Input` viene in genere scritti in un file mediante `Write`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2384">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="b3575-2385">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2385">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2386">Durante la lettura dai file, non prendere decisioni sui contenuti del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2386">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2387">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="b3575-2387">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="b3575-2388">Dopo la lettura, dati numerici o stringa standard viene assegnati a variabili senza alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b3575-2388">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="b3575-2389">Nella tabella seguente viene illustrato come vengono considerati altri dati di input.</span><span class="sxs-lookup"><span data-stu-id="b3575-2389">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="b3575-2390">Dati</span><span class="sxs-lookup"><span data-stu-id="b3575-2390">Data</span></span>|<span data-ttu-id="b3575-2391">Valore assegnato alla variabile</span><span class="sxs-lookup"><span data-stu-id="b3575-2391">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="b3575-2392">Eliminazione di virgola o riga vuota</span><span class="sxs-lookup"><span data-stu-id="b3575-2392">Delimiting comma or blank line</span></span>|<span data-ttu-id="b3575-2393">Empty</span><span class="sxs-lookup"><span data-stu-id="b3575-2393">Empty</span></span>|  
|<span data-ttu-id="b3575-2394">#NULL#</span><span class="sxs-lookup"><span data-stu-id="b3575-2394">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="b3575-2395">Per la compilazione di TRUE o FALSE # #</span><span class="sxs-lookup"><span data-stu-id="b3575-2395">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="b3575-2396">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="b3575-2396">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="b3575-2397">La data o ora rappresentato dall'espressione</span><span class="sxs-lookup"><span data-stu-id="b3575-2397">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="b3575-2398">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="b3575-2398">#ERROR `errornumber`#</span></span>|<span data-ttu-id="b3575-2399">`errornumber` (la variabile è un oggetto contrassegnato come errore)</span><span class="sxs-lookup"><span data-stu-id="b3575-2399">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="b3575-2400">Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestata e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2400">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2401">Il `Input` funzione non è localizzata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2401">The `Input` function is not localized.</span></span> <span data-ttu-id="b3575-2402">Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore variabile anziché come un separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2402">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2403">Lettura da un file usando il `Input` funzione richiede `Read` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2403">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2404">Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2404">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2405">Questo esempio viene usato il `Input` funzione per leggere i dati da un file in due variabili.</span><span class="sxs-lookup"><span data-stu-id="b3575-2405">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="b3575-2406">Questo esempio si presuppone che `TestFile` è un file con più righe di dati scritti tramite la `Write` funzioni, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="b3575-2406">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2407">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2407">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2408">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2408">Required.</span>
          </span>
          <span data-ttu-id="b3575-2409">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2409">Any valid file number.</span>
          </span>
        </param>
        <param name="CharCount">
          <span data-ttu-id="b3575-2410">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2410">Required.</span>
          </span>
          <span data-ttu-id="b3575-2411">Qualsiasi espressione numerica valida che specifica il numero di caratteri da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2411">Any valid numeric expression specifying the number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2412">Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2412">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="b3575-2413">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2413">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
          <span data-ttu-id="b3575-2414">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2414">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2415">Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2415">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="b3575-2416">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2416">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2417">Il `InputString` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2417">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2418">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2418">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2419">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2419">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2420">Dati letti con il `InputString` funzione viene in genere scritti in un file mediante `Print` o `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2420">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="b3575-2421">Usare questa funzione solo con i file aperti nel `Input` o `Binary` modalità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2421">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="b3575-2422">A differenza di `Input` funzione, il `InputString` funzione restituisce tutti i caratteri letti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2422">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="b3575-2423">Si tratta di virgole, ritorni a capo, avanzamento riga, racchiusi tra virgolette e spazi iniziali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2423">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="b3575-2424">Con i file aperti per `Binary` accedere, un tentativo di leggere i file usando il `InputString` funzionare fino al `EOF` restituisce `True` genera un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2424">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="b3575-2425">Usare la `LOF` e `Loc` funzioni anziché `EOF` quando la lettura di file binari tramite `InputString`, o usare `FileGet` quando si usa il `EOF` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-2425">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2426">Durante la lettura dai file, non prendere decisioni di protezione sul contenuto del file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2426">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="b3575-2427">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-2427">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2428">Questo esempio Usa la `InputString` funzione per leggere un carattere alla volta da un file ed eseguire la stampa per il `Output` finestra.</span><span class="sxs-lookup"><span data-stu-id="b3575-2428">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="b3575-2429">Questo esempio si presuppone che `MyFile` è un file di testo che presenta più righe di dati di esempio.</span><span class="sxs-lookup"><span data-stu-id="b3575-2429">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2430">
            <paramref name="FileNumber" /> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2430">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-2431">
            <paramref name="CharCount" /> &lt; 0 o &gt; 214.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2431">
              <paramref name="CharCount" /> &lt; 0 or &gt; 214.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-2432">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2432">Required.</span>
          </span>
          <span data-ttu-id="b3575-2433">Espressione <see langword="String" /> che specifica uno o più nomi file da eliminare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2433">
              <see langword="String" /> expression that specifies one or more file names to be deleted.</span>
          </span>
          <span data-ttu-id="b3575-2434">Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2434">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2435">Elimina i file da un disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2435">Deletes files from a disk.</span>
          </span>
          <span data-ttu-id="b3575-2436">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Kill" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2436">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span>
          </span>
          <span data-ttu-id="b3575-2437">Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2437">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2438">`Kill` supporta l'utilizzo di più caratteri (`*`) e carattere singolo (`?`) i caratteri jolly per specificare più file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2438">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="b3575-2439">**Nota sulla sicurezza** per eseguire, il `Kill` funzione richiede `Read` e `PathDiscovery` flag di <xref:System.Security.Permissions.FileIOPermission> da concedere al codice in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2439">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="b3575-2440">Per altre informazioni, vedere <xref:System.Security.SecurityException> [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="b3575-2440">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2441">Questo esempio viene usato il `Kill` funzione per eliminare un file da un disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-2441">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2442">File di destinazione aperti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2442">Target file(s) open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-2443">File di destinazione non trovati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2443">Target file(s) not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="b3575-2444">Autorizzazione negata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2444">Permission denied.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2445">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2445">Required.</span>
          </span>
          <span data-ttu-id="b3575-2446">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2446">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2447">Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2447">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2448">Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2448">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2449">Il `LineInput` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2449">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2450">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2450">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2451">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2451">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2452">I dati letti tramite `LineInput` viene in genere scritti in un file mediante `Print`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2452">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2453">Durante la lettura dai file, non prendere decisioni sul contenuto di un file in base all'estensione di nome file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2453">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="b3575-2454">Ad esempio, un file denominato Form1.vb potrebbe non essere un file di origine Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-2454">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="b3575-2455">Il `LineInput` funzione legge da un file di un carattere alla volta finché non viene rilevato un ritorno a capo (`Chr(13)`) o ritorno a capo/avanzamento riga (`Chr(13) + Chr(10)`) sequenza.</span><span class="sxs-lookup"><span data-stu-id="b3575-2455">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="b3575-2456">Le sequenze di feed di ritorno a capo/riga vengono ignorate invece di aggiunto alla stringa di caratteri.</span><span class="sxs-lookup"><span data-stu-id="b3575-2456">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2457">Lettura da un file usando il `LineInput` funzione richiede `Read` accedere dal <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2457">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2458">Questo esempio viene usato il `LineInput` funzione per leggere una riga da un file sequenziale e assegnarlo a una variabile.</span><span class="sxs-lookup"><span data-stu-id="b3575-2458">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="b3575-2459">Questo esempio si presuppone che `TestFile` è un file di testo che presenta più righe di dati di esempio.</span><span class="sxs-lookup"><span data-stu-id="b3575-2459">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="b3575-2460">Raggiunta la fine del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2460">End of file reached.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2461">
            <paramref name="FileNumber" /> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2461">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2462">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2462">Required.</span>
          </span>
          <span data-ttu-id="b3575-2463">Qualsiasi numero di file <see langword="Integer" /> valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2463">Any valid <see langword="Integer" /> file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2464">Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2464">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2465">Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2465">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2466">Il `Loc` funzione è in base zero, usarlo per recuperare il primo byte in un file, verrà restituito 0.</span><span class="sxs-lookup"><span data-stu-id="b3575-2466">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="b3575-2467">Il `Loc` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2467">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2468">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2468">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2469">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2469">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2470">Di seguito viene descritto il valore restituito per ogni modalità di accesso ai file:</span><span class="sxs-lookup"><span data-stu-id="b3575-2470">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="b3575-2471">Modalità</span><span class="sxs-lookup"><span data-stu-id="b3575-2471">Mode</span></span>|<span data-ttu-id="b3575-2472">Valore restituito</span><span class="sxs-lookup"><span data-stu-id="b3575-2472">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="b3575-2473">Numero dell'ultimo record di leggere o scrivere nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2473">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="b3575-2474">Posizione corrente di byte nel file diviso 128.</span><span class="sxs-lookup"><span data-stu-id="b3575-2474">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="b3575-2475">Tuttavia, le informazioni restituite dalla `Loc` per file sequenziali non viene utilizzata né necessaria.</span><span class="sxs-lookup"><span data-stu-id="b3575-2475">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="b3575-2476">Posizione dell'ultimo byte letti o scritti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2476">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2477">Questo esempio viene usato il `Loc` funzione per restituire la posizione di lettura/scrittura corrente in un file aperto.</span><span class="sxs-lookup"><span data-stu-id="b3575-2477">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="b3575-2478">Questo esempio si presuppone che `MyFile` è un file di testo che presenta più righe di dati di esempio.</span><span class="sxs-lookup"><span data-stu-id="b3575-2478">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2479">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2479">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2480">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2480">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2481">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2481">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2482">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2482">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2483">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2483">Required.</span>
          </span>
          <span data-ttu-id="b3575-2484">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2484">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2485">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2485">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2486">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2486">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2487">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2487">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2488">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2488">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2489">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2489">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2490">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2490">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2491">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2491">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2492">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2492">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2493">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2493">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2494">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2494">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2495">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2495">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2496">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2496">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2497">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2497">Required.</span>
          </span>
          <span data-ttu-id="b3575-2498">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2498">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="b3575-2499">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2499">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2500">Numero del record o byte da bloccare o sbloccare</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2500">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2501">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2501">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2502">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2502">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2503">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2503">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2504">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2504">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2505">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2505">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2506">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2506">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2507">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2507">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2508">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2508">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2509">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2509">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2510">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2510">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2511">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2511">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2512">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2512">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2513">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2513">Required.</span>
          </span>
          <span data-ttu-id="b3575-2514">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2514">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="b3575-2515">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2515">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2516">Numero del primo record o byte da bloccare o sbloccare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2516">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="b3575-2517">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2517">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2518">Numero dell'ultimo record o byte da bloccare o sbloccare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2518">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2519">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2519">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2520">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2520">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2521">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2521">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2522">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2522">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2523">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2523">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2524">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2524">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2525">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2525">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2526">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2526">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2527">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2527">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2528">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2528">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2529">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2529">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2530">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2530">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2531">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2531">Required.</span>
          </span>
          <span data-ttu-id="b3575-2532">
            <see langword="Integer" /> che contiene un numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2532">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2533">Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2533">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2534">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2534">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
          <span data-ttu-id="b3575-2535">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2535">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2536">Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2536">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2537">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2537">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2538">Usare il `FileLen` funzione per ottenere la lunghezza di un file che non è aperta.</span><span class="sxs-lookup"><span data-stu-id="b3575-2538">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2539">Questo esempio viene usato il `LOF` funzione per determinare le dimensioni di un file aperto.</span><span class="sxs-lookup"><span data-stu-id="b3575-2539">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="b3575-2540">Questo esempio si presuppone che `TestFile` è un file di testo che contiene i dati di esempio.</span><span class="sxs-lookup"><span data-stu-id="b3575-2540">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2541">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2541">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="b3575-2542">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2542">Required.</span>
          </span>
          <span data-ttu-id="b3575-2543">Espressione <see langword="String" /> che identifica la directory da creare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2543">
              <see langword="String" /> expression that identifies the directory to be created.</span>
          </span>
          <span data-ttu-id="b3575-2544">Il parametro <c>Path</c> può includere l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2544">The <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="b3575-2545">Se non viene specificata alcuna unità, <see langword="MkDir" /> crea la nuova directory nell'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2545">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2546">Crea una nuova directory.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2546">Creates a new directory.</span>
          </span>
          <span data-ttu-id="b3575-2547">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="MkDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2547">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span>
          </span>
          <span data-ttu-id="b3575-2548">Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2548">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2549">Questa funzione crea una nuova directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-2549">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2550">Questo esempio viene usato il `MkDir` funzione per creare una directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-2550">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="b3575-2551">Se l'unità non è specificato, viene creata nella nuova directory nell'unità corrente.</span><span class="sxs-lookup"><span data-stu-id="b3575-2551">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-2552">
            <paramref name="Path" /> non è specificato o è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2552">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="b3575-2553">Autorizzazione negata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2553">Permission denied.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2554">Directory già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2554">Directory already exists.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2555">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2555">Required.</span>
          </span>
          <span data-ttu-id="b3575-2556">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2556">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="b3575-2557">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2557">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2558">Zero o più espressioni con valori delimitati da virgole da scrivere in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2558">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="b3575-2559">Le impostazioni dell'argomento <c>Output</c> sono le seguenti:</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2559">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="b3575-2560">
            <see langword="T:System.IO.IOException" />: la modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2560">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="b3575-2561">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2561">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2562">Scrive i dati formattati per la visualizzazione in un file sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2562">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2563">Il `Print` e `PrintLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2563">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2564">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2564">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2565">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2565">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2566">`Print` non include una riga alla fine di una riga; del feed Tuttavia, `PrintLine` includono un avanzamento riga.</span><span class="sxs-lookup"><span data-stu-id="b3575-2566">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="b3575-2567">I dati scritti con `Print` viene in genere letti da un file mediante `LineInput` o `Input`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2567">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="b3575-2568">Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota al file; per `Print`, nulla è output.</span><span class="sxs-lookup"><span data-stu-id="b3575-2568">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="b3575-2569">Più espressioni separate da virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2569">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="b3575-2570">Per la `Boolean` dei dati, ad esempio `True` o `False` viene stampato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2570">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="b3575-2571">Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2571">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="b3575-2572">Dati relativi alla data viene scritto nel file usando il formato di data breve standard riconosciuto dal sistema.</span><span class="sxs-lookup"><span data-stu-id="b3575-2572">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="b3575-2573">Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2573">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="b3575-2574">Se non verranno scritti nel file `Output` dati sono vuoti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2574">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="b3575-2575">Tuttavia, se `Output` i dati elenco viene `DBNull`, `Null` viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2575">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="b3575-2576">Per la `Error` dei dati, l'output viene visualizzato come `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2576">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="b3575-2577">Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2577">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="b3575-2578">Tutti i dati scritti nel file usando `Print` internazionali; vale a dire i dati siano formattati correttamente usando il separatore decimale appropriato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2578">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="b3575-2579">Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2579">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="b3575-2580">La scrittura in un file usando il `Print` o `PrintLine` funzioni richiede `Write` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2580">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2581">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2581">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2582">Questo esempio Usa la `Print` e `PrintLine` funzioni per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2582">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2583">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2583">Required.</span>
          </span>
          <span data-ttu-id="b3575-2584">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2584">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="b3575-2585">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2585">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2586">Zero o più espressioni con valori delimitati da virgole da scrivere in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2586">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="b3575-2587">Le impostazioni dell'argomento <c>Output</c> sono le seguenti:</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2587">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="b3575-2588">
            <see langword="T:System.IO.IOException" />: la modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2588">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="b3575-2589">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2589">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2590">Scrive i dati formattati per la visualizzazione in un file sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2590">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2591">Il `Print` e `PrintLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2591">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2592">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2592">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2593">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2593">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2594">`Print` non include una riga alla fine di una riga; del feed Tuttavia,`PrintLine` includono un avanzamento riga.</span><span class="sxs-lookup"><span data-stu-id="b3575-2594">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="b3575-2595">I dati scritti con `Print` viene in genere letti da un file mediante `LineInput` o `Input`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2595">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="b3575-2596">Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota al file; per `Print`, nulla è output.</span><span class="sxs-lookup"><span data-stu-id="b3575-2596">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="b3575-2597">Più espressioni separate da virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2597">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="b3575-2598">Per la `Boolean` dei dati, ad esempio `True` o `False` viene stampato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2598">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="b3575-2599">Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2599">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="b3575-2600">Dati relativi alla data viene scritto nel file usando il formato di data breve standard riconosciuto dal sistema.</span><span class="sxs-lookup"><span data-stu-id="b3575-2600">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="b3575-2601">Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2601">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="b3575-2602">Se non verranno scritti nel file `Output` dati sono vuoti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2602">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="b3575-2603">Tuttavia, se `Output` i dati elenco viene `DBNull`, `Null` viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2603">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="b3575-2604">Per la `Error` dei dati, l'output viene visualizzato come `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2604">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="b3575-2605">Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2605">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="b3575-2606">Tutti i dati scritti nel file usando `Print` internazionali; vale a dire i dati siano formattati correttamente usando il separatore decimale appropriato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2606">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="b3575-2607">Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2607">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="b3575-2608">La scrittura in un file usando il `Print` o `PrintLine` funzioni richiede `Write` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2608">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2609">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2609">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2610">Questo esempio Usa la `Print` e `PrintLine` funzioni per scrivere dati in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2610">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">
          <span data-ttu-id="b3575-2611">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2611">Required.</span>
          </span>
          <span data-ttu-id="b3575-2612">Espressione <see langword="String" /> che specifica il nome file esistente e il relativo percorso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2612">
              <see langword="String" /> expression that specifies the existing file name and location.</span>
          </span>
          <span data-ttu-id="b3575-2613">Il parametro <c>OldPath</c> può includere la directory e l'unità del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2613">
              <c>OldPath</c> may include the directory, and drive, of the file.</span>
          </span>
        </param>
        <param name="NewPath">
          <span data-ttu-id="b3575-2614">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2614">Required.</span>
          </span>
          <span data-ttu-id="b3575-2615">Espressione <see langword="String" /> che specifica il nuovo nome file e il relativo percorso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2615">
              <see langword="String" /> expression that specifies the new file name and location.</span>
          </span>
          <span data-ttu-id="b3575-2616">Il parametro <c>NewPath</c> può includere la directory e l'unità del percorso di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2616">
              <c>NewPath</c> may include directory and drive of the destination location.</span>
          </span>
          <span data-ttu-id="b3575-2617">Il nome file specificato da <c>NewPath</c> non deve essere già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2617">The file name specified by <c>NewPath</c> cannot already exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2618">Rinomina un file o una directory su disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2618">Renames a disk file or directory.</span>
          </span>
          <span data-ttu-id="b3575-2619">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Rename" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2619">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span>
          </span>
          <span data-ttu-id="b3575-2620">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2620">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2621">Il`Rename` funzione Rinomina un file e spostarlo in una directory diversa, se necessario.</span><span class="sxs-lookup"><span data-stu-id="b3575-2621">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="b3575-2622">Il `Rename` funzione può spostare un file in unità, ma è possibile rinominare solo una directory esistente quando entrambe `NewPath` e `OldPath` si trovano nella stessa unità.</span><span class="sxs-lookup"><span data-stu-id="b3575-2622">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="b3575-2623">`Rename` non è possibile creare un nuovo file o directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-2623">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="b3575-2624">Uso di `Rename` funzione in un file aperto genera un errore.</span><span class="sxs-lookup"><span data-stu-id="b3575-2624">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="b3575-2625">È necessario chiudere un file aperto prima di rinominarlo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2625">You must close an open file before renaming it.</span></span> <span data-ttu-id="b3575-2626">`Rename` argomenti non possono includere più caratteri (\*) e caratteri jolly (?) di caratteri a singolo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2626">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3575-2627">Quando si usa `Rename` per copiare un file da un percorso non protetto in un percorso protetto, il file mantiene i diritti meno restrittivi.</span><span class="sxs-lookup"><span data-stu-id="b3575-2627">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="b3575-2628">Verifica per accertarsi che a non introdurre possibili rischi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="b3575-2628">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2629">Questo esempio viene usato il `Rename` funzione per rinominare un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2629">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="b3575-2630">Ai fini di questo esempio, si supponga che esistano le directory in cui siano già state specificate.</span><span class="sxs-lookup"><span data-stu-id="b3575-2630">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-2631">Il percorso non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2631">Path is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-2632">Il file <paramref name="OldPath" /> non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2632">
              <paramref name="OldPath" /> file does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2633">Impossibile rinominare con il nome di un'altro dispositivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2633">Cannot rename to different device.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2634">Chiude tutti i file su disco aperti mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2634">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2635">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Reset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2635">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span>
          </span>
          <span data-ttu-id="b3575-2636">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2636">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2637">Il `Reset` funzione chiude tutti i file aperti per il `FileOpen` funzione e ha la stessa funzione `FileClose()` senza parametri.</span><span class="sxs-lookup"><span data-stu-id="b3575-2637">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2638">Questo esempio viene usato il `Reset` (funzione) per chiudere tutti i file aperti e scrivere il contenuto di tutti i buffer di file su disco.</span><span class="sxs-lookup"><span data-stu-id="b3575-2638">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="b3575-2639">Si noti l'uso del `Object` variabile `FileNumber` come una stringa e un numero.</span><span class="sxs-lookup"><span data-stu-id="b3575-2639">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="b3575-2640">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2640">Required.</span>
          </span>
          <span data-ttu-id="b3575-2641">Espressione <see langword="String" /> che identifica la directory o la cartella da rimuovere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2641">
              <see langword="String" /> expression that identifies the directory or folder to be removed.</span>
          </span>
          <span data-ttu-id="b3575-2642">Il parametro <c>Path</c> può includere l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2642">
              <c>Path</c> can include the drive.</span>
          </span>
          <span data-ttu-id="b3575-2643">Se non viene specificata alcuna unità, <see langword="RmDir" /> rimuove la directory nell'unità corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2643">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2644">Rimuove una directory esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2644">Removes an existing directory.</span>
          </span>
          <span data-ttu-id="b3575-2645">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="RmDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2645">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span>
          </span>
          <span data-ttu-id="b3575-2646">Per ulteriori informazioni, vedere <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2646">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2647">Si verifica un errore se si prova a usare `RmDir` in una directory che contiene i file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2647">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="b3575-2648">Usare il `Kill` funzione eliminare tutti i file prima di provare a rimuovere una directory.</span><span class="sxs-lookup"><span data-stu-id="b3575-2648">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2649">Questo esempio viene usato il `RmDir` funzione per rimuovere una directory esistente.</span><span class="sxs-lookup"><span data-stu-id="b3575-2649">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-2650">
            <paramref name="Path" /> non è specificato o è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2650">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2651">La directory di destinazione contiene file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2651">Target directory contains files.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="b3575-2652">La directory non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2652">Directory does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2653">Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2653">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2654">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2654">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="b3575-2655">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2655">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2656">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2656">Required.</span>
          </span>
          <span data-ttu-id="b3575-2657">
            <see langword="Integer" /> che contiene un numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2657">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2658">Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2658">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2659">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="b3575-2660">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2661">Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2661">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2662">`Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.</span><span class="sxs-lookup"><span data-stu-id="b3575-2662">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="b3575-2663">Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:</span><span class="sxs-lookup"><span data-stu-id="b3575-2663">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="b3575-2664">Modalità</span><span class="sxs-lookup"><span data-stu-id="b3575-2664">Mode</span></span>|<span data-ttu-id="b3575-2665">Valore restituito</span><span class="sxs-lookup"><span data-stu-id="b3575-2665">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="b3575-2666">Numero del record successivo letto o scritto</span><span class="sxs-lookup"><span data-stu-id="b3575-2666">Number of the next record read or written</span></span>|  
|<span data-ttu-id="b3575-2667">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="b3575-2667">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="b3575-2668">Posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2668">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2669">Il primo byte in un file corrisponde alla posizione 1, il secondo byte è nella posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-2669">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2670">Questo esempio viene usato il `Seek` funzione per restituire la posizione corrente del file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2670">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="b3575-2671">Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2671">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="b3575-2672">Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2672">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="b3575-2673">Per i file aperti in modalità diverso da `Random` modalità `Seek` restituisce la posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2673">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2674">Si supponga `TestFile` è un file che contiene più righe di testo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2674">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="b3575-2675">Questo esempio viene usato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura e scrittura in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2675">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="b3575-2676">Per i file aperti in modalità diverso da `Random` modalità `Seek` imposta la posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2676">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2677">Si supponga `TestFile` è un file che contiene più righe di testo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2677">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2678">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2678">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2679">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2679">Required.</span>
          </span>
          <span data-ttu-id="b3575-2680">
            <see langword="Integer" /> che contiene un numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2680">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <param name="Position">
          <span data-ttu-id="b3575-2681">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2681">Required.</span>
          </span>
          <span data-ttu-id="b3575-2682">Numero compreso nell'intervallo da 1 a 2.147.483.647 inclusi, che indica dove deve aver luogo la successiva operazione di lettura/scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2682">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2683">Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2683">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2684">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2684">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="b3575-2685">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2685">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2686">`Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.</span><span class="sxs-lookup"><span data-stu-id="b3575-2686">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="b3575-2687">Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:</span><span class="sxs-lookup"><span data-stu-id="b3575-2687">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="b3575-2688">Modalità</span><span class="sxs-lookup"><span data-stu-id="b3575-2688">Mode</span></span>|<span data-ttu-id="b3575-2689">Valore restituito</span><span class="sxs-lookup"><span data-stu-id="b3575-2689">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="b3575-2690">Numero del record successivo letto o scritto</span><span class="sxs-lookup"><span data-stu-id="b3575-2690">Number of the next record read or written</span></span>|  
|<span data-ttu-id="b3575-2691">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="b3575-2691">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="b3575-2692">Posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2692">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2693">Il primo byte in un file corrisponde alla posizione 1, il secondo byte è nella posizione 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="b3575-2693">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2694">Questo esempio viene usato il `Seek` funzione per restituire la posizione corrente del file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2694">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="b3575-2695">Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2695">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="b3575-2696">Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2696">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="b3575-2697">Per i file aperti in modalità diverso da `Random` modalità `Seek` restituisce la posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2697">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2698">Si supponga `TestFile` è un file che contiene più righe di testo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2698">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="b3575-2699">Questo esempio viene usato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura e scrittura in un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2699">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="b3575-2700">Per i file aperti in modalità diverso da `Random` modalità `Seek` imposta la posizione di byte in corrispondenza del quale si verifica all'operazione successiva.</span><span class="sxs-lookup"><span data-stu-id="b3575-2700">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="b3575-2701">Si supponga `TestFile` è un file che contiene più righe di testo.</span><span class="sxs-lookup"><span data-stu-id="b3575-2701">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2702">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2702">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="b3575-2703">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2703">Required.</span>
          </span>
          <span data-ttu-id="b3575-2704">Espressione <see langword="String" /> che specifica un nome file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2704">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="b3575-2705">Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2705">
              <c>PathName</c> can include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Attributes">
          <span data-ttu-id="b3575-2706">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2706">Required.</span>
          </span>
          <span data-ttu-id="b3575-2707">Costante o espressione numerica la cui somma specifica attributi di file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2707">Constant or numeric expression, whose sum specifies file attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2708">Imposta le informazioni degli attributi per un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2708">Sets attribute information for a file.</span>
          </span>
          <span data-ttu-id="b3575-2709">La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="SetAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2709">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span>
          </span>
          <span data-ttu-id="b3575-2710">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2710">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2711">Se si prova a impostare gli attributi di un file aperto, si verifica un errore di run-time.</span><span class="sxs-lookup"><span data-stu-id="b3575-2711">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="b3575-2712">Il `Attributes` valori di enumerazione degli argomenti sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="b3575-2712">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="b3575-2713">Valore</span><span class="sxs-lookup"><span data-stu-id="b3575-2713">Value</span></span>|<span data-ttu-id="b3575-2714">Costante</span><span class="sxs-lookup"><span data-stu-id="b3575-2714">Constant</span></span>|<span data-ttu-id="b3575-2715">Descrizione</span><span class="sxs-lookup"><span data-stu-id="b3575-2715">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="b3575-2716">Normale (impostazione predefinita).</span><span class="sxs-lookup"><span data-stu-id="b3575-2716">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="b3575-2717">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="b3575-2717">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="b3575-2718">Nascosto.</span><span class="sxs-lookup"><span data-stu-id="b3575-2718">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="b3575-2719">File di sistema.</span><span class="sxs-lookup"><span data-stu-id="b3575-2719">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="b3575-2720">Etichetta del volume</span><span class="sxs-lookup"><span data-stu-id="b3575-2720">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="b3575-2721">Directory o cartella.</span><span class="sxs-lookup"><span data-stu-id="b3575-2721">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="b3575-2722">Il file è stato modificato dopo l'ultimo backup.</span><span class="sxs-lookup"><span data-stu-id="b3575-2722">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="b3575-2723">Il file ha un nome diverso.</span><span class="sxs-lookup"><span data-stu-id="b3575-2723">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2724">Queste enumerazioni sono specificate dal linguaggio Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3575-2724">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="b3575-2725">I nomi possono essere utilizzati ovunque nel codice anziché i valori effettivi.</span><span class="sxs-lookup"><span data-stu-id="b3575-2725">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2726">Questo esempio viene usato il `SetAttr` funzione per impostare gli attributi per un file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2726">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3575-2727">Tipo di <paramref name="Attribute" /> non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2727">
              <paramref name="Attribute" /> type is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">
          <span data-ttu-id="b3575-2728">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2728">Required.</span>
          </span>
          <span data-ttu-id="b3575-2729">Numero di spazi da inserire prima di visualizzare o stampare la successiva espressione di un elenco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2729">The number of spaces to insert before displaying or printing the next expression in a list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2730">Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2730">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2731">Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2731">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2732">Se `Count` è inferiore alla lunghezza della riga di output, la posizione successiva immediatamente segue il numero di spazi stampato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2732">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="b3575-2733">Se`Count` è maggiore della larghezza della riga di output, `SPC` calcolerà la posizione successiva usando la formula:</span><span class="sxs-lookup"><span data-stu-id="b3575-2733">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="b3575-2734">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="b3575-2734">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="b3575-2735">Ad esempio, se la posizione di stampa è 24, la larghezza della riga di output è 80 e si specifica `SPC(90)`, la stampa Avanti inizierà nella posizione di 34 (posizione di stampa corrente + la parte restante del 90/80).</span><span class="sxs-lookup"><span data-stu-id="b3575-2735">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="b3575-2736">Se la differenza tra la posizione di stampa e la larghezza della riga di output è inferiore a `Count` (o `Count` `Mod` *larghezza*), il `SPC` funzione passerà all'inizio della riga successiva e che genera l'errore è uguale a spazi `Count` – (*larghezza* – *currentprintposition*).</span><span class="sxs-lookup"><span data-stu-id="b3575-2736">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2737">Assicurarsi che le colonne di tabella sono sufficientemente ampia per consentire caratteri ampi.</span><span class="sxs-lookup"><span data-stu-id="b3575-2737">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2738">Questo esempio Usa il `SPC` per posizionare l'output in un file e in funzione il **Output** finestra.</span><span class="sxs-lookup"><span data-stu-id="b3575-2738">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2739">Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2739">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2740">Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2740">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2741">Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2741">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2742">Se la posizione di stampa corrente nella riga corrente è più grande `Column`, `TAB` passerà al valore di colonna uguale a `Column` nella successiva riga di output.</span><span class="sxs-lookup"><span data-stu-id="b3575-2742">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="b3575-2743">Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa per la colonna 1.</span><span class="sxs-lookup"><span data-stu-id="b3575-2743">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="b3575-2744">Se `Column` è maggiore della larghezza di riga di output, `TAB` calcolerà la posizione successiva usando la formula:</span><span class="sxs-lookup"><span data-stu-id="b3575-2744">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="b3575-2745">Larghezza della colonna Mod</span><span class="sxs-lookup"><span data-stu-id="b3575-2745">Column Mod width</span></span>  
  
 <span data-ttu-id="b3575-2746">Ad esempio, se *larghezza* 80 e specificazione `TAB(90)`, la stampa Avanti inizierà dalla colonna 10 (il resto pari a 80 o 90).</span><span class="sxs-lookup"><span data-stu-id="b3575-2746">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="b3575-2747">Se `Column` è minore della posizione corrente di stampa, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2747">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="b3575-2748">Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, stampa inizierà dalla calcolata stampa posizione sulla stessa riga.</span><span class="sxs-lookup"><span data-stu-id="b3575-2748">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="b3575-2749">La posizione più a sinistra di stampa in una riga di output è sempre 1.</span><span class="sxs-lookup"><span data-stu-id="b3575-2749">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="b3575-2750">Quando si usa la `Print` oppure `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-2750">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="b3575-2751">Il `TAB` funzione può essere usata anche con il `WriteLine` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-2751">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="b3575-2752">Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2752">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2753">Assicurarsi che le colonne di tabella sono sufficientemente ampia per contenere i caratteri wide.</span><span class="sxs-lookup"><span data-stu-id="b3575-2753">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2754">Questo esempio Usa il `TAB` per posizionare l'output in un file e in funzione il **Output** finestra.</span><span class="sxs-lookup"><span data-stu-id="b3575-2754">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">
          <span data-ttu-id="b3575-2755">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2755">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2756">Numero della colonna a cui passare prima di visualizzare o stampare la successiva espressione di un elenco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2756">The column number moved to before displaying or printing the next expression in a list.</span>
          </span>
          <span data-ttu-id="b3575-2757">In caso di omissione, <see langword="TAB" /> sposterà il punto di inserimento all'inizio della successiva area di stampa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2757">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2758">Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2758">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3575-2759">Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2759">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2760">Se la posizione di stampa nella riga corrente è maggiore `Column`, `TAB` passerà al valore di colonna uguale a `Column` nella successiva riga di output.</span><span class="sxs-lookup"><span data-stu-id="b3575-2760">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="b3575-2761">Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa per la colonna 1.</span><span class="sxs-lookup"><span data-stu-id="b3575-2761">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="b3575-2762">Se `Column` è maggiore della larghezza della riga di output, `TAB` calcolerà la posizione successiva usando la formula:</span><span class="sxs-lookup"><span data-stu-id="b3575-2762">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="b3575-2763">Larghezza della colonna Mod</span><span class="sxs-lookup"><span data-stu-id="b3575-2763">Column Mod width</span></span>  
  
 <span data-ttu-id="b3575-2764">Ad esempio, se *larghezza* 80 e specificazione `TAB(90)`, la stampa Avanti inizierà dalla colonna 10 (il resto pari a 80 o 90).</span><span class="sxs-lookup"><span data-stu-id="b3575-2764">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="b3575-2765">Se `Column` è minore della posizione corrente di stampa, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata.</span><span class="sxs-lookup"><span data-stu-id="b3575-2765">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="b3575-2766">Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, la stampa inizierà a calcolata stampa posizione sulla stessa riga.</span><span class="sxs-lookup"><span data-stu-id="b3575-2766">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="b3575-2767">La posizione più a sinistra di stampa in una riga di output è sempre 1.</span><span class="sxs-lookup"><span data-stu-id="b3575-2767">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="b3575-2768">Quando si usa la `Print` oppure `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-2768">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="b3575-2769">Il `TAB` funzione può essere usata anche con il `WriteLine` (funzione).</span><span class="sxs-lookup"><span data-stu-id="b3575-2769">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="b3575-2770">Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2770">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3575-2771">Assicurarsi che le colonne di tabella sono sufficientemente ampia per contenere i caratteri wide.</span><span class="sxs-lookup"><span data-stu-id="b3575-2771">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2772">Questo esempio Usa il `TAB` per posizionare l'output in un file e in funzione il **Output** finestra.</span><span class="sxs-lookup"><span data-stu-id="b3575-2772">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3575-2773">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2773">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2774">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2774">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2775">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2775">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2776">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2776">Required.</span>
          </span>
          <span data-ttu-id="b3575-2777">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2777">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2778">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2778">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2779">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2779">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2780">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2780">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2781">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2781">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2782">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2782">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2783">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2783">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2784">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2784">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2785">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2785">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2786">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2786">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2787">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2787">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2788">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2788">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2789">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2789">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2790">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2790">Required.</span>
          </span>
          <span data-ttu-id="b3575-2791">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2791">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="b3575-2792">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2792">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2793">Numero del record o byte da bloccare o sbloccare</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2793">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2794">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2794">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2795">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2795">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2796">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2796">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2797">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2797">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2798">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2798">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2799">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2799">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2800">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2800">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2801">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2801">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2802">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2802">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2803">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2803">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2804">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2804">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2805">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2805">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2806">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2806">Required.</span>
          </span>
          <span data-ttu-id="b3575-2807">Qualsiasi numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2807">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="b3575-2808">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2808">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2809">Numero del primo record o byte da bloccare o sbloccare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2809">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="b3575-2810">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2810">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2811">Numero dell'ultimo record o byte da bloccare o sbloccare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2811">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2812">Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2812">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="b3575-2813">Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2813">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="b3575-2814">Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2814">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2815">Il `Lock` e `Unlock` funzioni vengono utilizzate in ambienti in cui diversi processi potrebbe essere necessario l'accesso allo stesso file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2815">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="b3575-2816">`Lock` e `Unlock` funzioni vengono utilizzate sempre in coppia.</span><span class="sxs-lookup"><span data-stu-id="b3575-2816">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="b3575-2817">Gli argomenti `Lock` e `Unlock` devono essere identici.</span><span class="sxs-lookup"><span data-stu-id="b3575-2817">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="b3575-2818">Se `Record`, oppure `FromRecord` e `ToRecord` viene omesso, il blocco sarà per l'intero file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2818">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="b3575-2819">Se `Record` viene specificato solo il singolo record sia bloccato o sbloccato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2819">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="b3575-2820">Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2820">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2821">In questo esempio viene illustrato l'utilizzo dei `Lock` e `Unlock` funzioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2821">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="b3575-2822">Questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2822">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2823">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2823">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2824">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2824">Required.</span>
          </span>
          <span data-ttu-id="b3575-2825">Espressione <see langword="Integer" /> contenente un numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2825">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="b3575-2826">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2826">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2827">Una o più espressioni con valori delimitati da virgole da scrivere in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2827">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2828">Scrive dati in un file sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2828">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="b3575-2829">I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2829">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2830">Il `Write` e `WriteLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2830">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2831">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2831">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2832">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2832">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2833">Se si omette `Output`, una riga vuota viene stampata il file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2833">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="b3575-2834">Più espressioni possono essere separati da una virgola.</span><span class="sxs-lookup"><span data-stu-id="b3575-2834">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="b3575-2835">A differenza di `Print` funzione, il `Write` funzione inserisce le virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2835">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="b3575-2836">Non è necessario inserire delimitatori espliciti nell'elenco.</span><span class="sxs-lookup"><span data-stu-id="b3575-2836">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="b3575-2837">Quando `Write` consente di scrivere dati in un file, solo alfanumerici `Boolean`, data, null e `Error` sono supportati i formati di dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-2837">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="b3575-2838">I presupposti seguenti universali vengono seguiti in modo che i dati possono sempre essere letti e interpreta correttamente usando `Input`, indipendentemente dalle impostazioni locali:</span><span class="sxs-lookup"><span data-stu-id="b3575-2838">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="b3575-2839">Dati numerici vengono sempre scritti usando il punto come separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2839">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="b3575-2840">Per la `Boolean` dei dati, ad esempio `#TRUE#` o `#FALSE#` viene stampato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2840">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="b3575-2841">Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2841">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="b3575-2842">Le date vengono scritte nel file usando il formato della data universal.</span><span class="sxs-lookup"><span data-stu-id="b3575-2842">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="b3575-2843">Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2843">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="b3575-2844">Se non verranno scritti nel file `Output` dati sono vuoti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2844">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="b3575-2845">Tuttavia, per i dati null, `#NULL#` viene scritto.</span><span class="sxs-lookup"><span data-stu-id="b3575-2845">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="b3575-2846">Per la `Error` dei dati, l'output viene visualizzato come `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2846">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="b3575-2847">Il `Error` parola chiave non viene convertito, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2847">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="b3575-2848">`WriteLine` Inserisce un carattere di nuova riga (vale a dire, un ritorno a capo/avanzamento riga, oppure `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2848">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="b3575-2849">È possibile incorporare virgolette in una stringa con virgolette doppie, o "".</span><span class="sxs-lookup"><span data-stu-id="b3575-2849">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="b3575-2850">Ad esempio,</span><span class="sxs-lookup"><span data-stu-id="b3575-2850">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="b3575-2851">Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2851">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="b3575-2852">La scrittura in un file usando il `Write` o `WriteLine` funzioni richiede `Append` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2852">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2853">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2853">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2854">Questo esempio viene usato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2854">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b3575-2855">La modalità File non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2855">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="b3575-2856">Obbligatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2856">Required.</span>
          </span>
          <span data-ttu-id="b3575-2857">Espressione <see langword="Integer" /> contenente un numero di file valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2857">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="b3575-2858">Facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2858">Optional.</span>
          </span>
          <span data-ttu-id="b3575-2859">Una o più espressioni con valori delimitati da virgole da scrivere in un file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2859">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3575-2860">Scrive dati in un file sequenziale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2860">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="b3575-2861">I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3575-2861">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3575-2862">Il `Write` e `WriteLine` funzioni sono fornite per compatibilità con le versioni precedenti e può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="b3575-2862">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="b3575-2863">Per le applicazioni non legacy, il `My.Computer.FileSystem` oggetto offre prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="b3575-2863">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="b3575-2864">Per altre informazioni, vedere [accesso al File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="b3575-2864">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="b3575-2865">Se si omette `Output`, una riga vuota viene stampata il file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2865">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="b3575-2866">Più espressioni possono essere separati da una virgola.</span><span class="sxs-lookup"><span data-stu-id="b3575-2866">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="b3575-2867">A differenza di `Print` funzione, il `Write` funzione inserisce le virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2867">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="b3575-2868">Non è necessario inserire delimitatori espliciti nell'elenco.</span><span class="sxs-lookup"><span data-stu-id="b3575-2868">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="b3575-2869">Quando `Write` consente di scrivere dati in un file, solo alfanumerici `Boolean`, data, null e `Error` sono supportati i formati di dati.</span><span class="sxs-lookup"><span data-stu-id="b3575-2869">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="b3575-2870">I presupposti seguenti universali vengono seguiti in modo che i dati possono sempre essere letti e interpreta correttamente usando `Input`, indipendentemente dalle impostazioni locali:</span><span class="sxs-lookup"><span data-stu-id="b3575-2870">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="b3575-2871">Dati numerici vengono sempre scritti usando il punto come separatore decimale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2871">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="b3575-2872">Per la `Boolean` dei dati, ad esempio `#TRUE#` o `#FALSE#` viene stampato.</span><span class="sxs-lookup"><span data-stu-id="b3575-2872">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="b3575-2873">Il `True` e `False` parole chiave non vengono tradotti, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2873">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="b3575-2874">Le date vengono scritte nel file usando il formato della data universal.</span><span class="sxs-lookup"><span data-stu-id="b3575-2874">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="b3575-2875">Quando la data o il componente della fase è mancante o zero, solo la parte fornito viene scritto nel file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2875">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="b3575-2876">Se non verranno scritti nel file `Output` dati sono vuoti.</span><span class="sxs-lookup"><span data-stu-id="b3575-2876">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="b3575-2877">Tuttavia, per i dati null, `#NULL#` viene scritto.</span><span class="sxs-lookup"><span data-stu-id="b3575-2877">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="b3575-2878">Per la `Error` dei dati, l'output viene visualizzato come `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2878">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="b3575-2879">Il `Error` parola chiave non viene convertito, indipendentemente dalle impostazioni locali.</span><span class="sxs-lookup"><span data-stu-id="b3575-2879">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="b3575-2880">`WriteLine` Inserisce un carattere di nuova riga (vale a dire, un ritorno a capo/avanzamento riga, oppure `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.</span><span class="sxs-lookup"><span data-stu-id="b3575-2880">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="b3575-2881">È possibile incorporare virgolette in una stringa con virgolette doppie, o "".</span><span class="sxs-lookup"><span data-stu-id="b3575-2881">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="b3575-2882">Ad esempio,</span><span class="sxs-lookup"><span data-stu-id="b3575-2882">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="b3575-2883">Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="b3575-2883">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="b3575-2884">La scrittura in un file usando il `Write` o `WriteLine` funzioni richiede `Append` accedere dal `FileIOPermissionAccess` enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b3575-2884">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="b3575-2885">Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="b3575-2885">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3575-2886">Questo esempio viene usato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.</span><span class="sxs-lookup"><span data-stu-id="b3575-2886">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>