<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="588728944ca294baca2932f2aae0887dfd3ec4be" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351685" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il modulo <see langword="FileSystem" /> contiene le procedure utilizzate per eseguire operazioni su file, directory o cartelle e sistema. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto all'utilizzo del modulo <see langword="FileSystem" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo modulo supporta le parole chiave del linguaggio Visual Basic e membri di libreria run-time che accedono ai file e cartelle.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `GetAttr` funzione per determinare gli attributi di un file e directory o una cartella.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory o la cartella che diventa la nuova directory o cartella predefinita. L'elemento <c>Path</c> può includere l'unità. Se non viene specificata alcuna unità, <see langword="ChDir" /> cambia la directory o cartella predefinita dell'unità corrente.</param>
        <summary>Cambia la directory o cartella corrente. Nelle operazioni di I/O su file la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="ChDir" />. Per altre informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDir` funzione consente di modificare la directory predefinita, ma non l'unità predefinita. Ad esempio, se l'unità predefinita è di tipo C, l'istruzione seguente modifica la directory predefinita sull'unità D, ma C rimane l'unità predefinita:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 È possibile apportare relativo modifiche alla directory è necessario digitare due punti, come indicato di seguito:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Il `ChDir` funzione richiede l'autorizzazione di accesso al codice non gestito, che può influenzare l'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `ChDir` funzione per modificare la directory corrente o una cartella.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> è vuoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cambia l'unità corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Obbligatorio. Espressione String che specifica un'unità esistente. Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata. Se l'argomento <c>Drive</c> è una stringa a più caratteri, <see langword="ChDrive" /> usa solo la prima lettera.</param>
        <summary>Cambia l'unità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDrive` funzione richiede l'autorizzazione di accesso al codice non gestito, che può influenzare l'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `ChDrive` funzione per modificare l'unità corrente. La funzione genera un'eccezione se l'unità non esiste.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Obbligatorio. Espressione String che specifica un'unità esistente. Se viene fornita una stringa di lunghezza zero (""), l'unità corrente non verrà modificata. Se l'argomento <c>Drive</c> è una stringa a più caratteri, <see langword="ChDrive" /> usa solo la prima lettera.</param>
        <summary>Cambia l'unità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ChDrive` funzione richiede l'autorizzazione di accesso al codice non gestito, che può influenzare l'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `ChDrive` funzione per modificare l'unità corrente. La funzione genera un'eccezione se l'unità non esiste.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'unità specificata non è valida o non è disponibile.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Stringa che rappresenta il percorso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene utilizzato il `CurDir` funzione per restituire il percorso corrente.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Facoltativo. Espressione <see langword="Char" /> che specifica un'unità esistente. Se non si specifica alcuna unità, o se l'elemento <c>Drive</c> è una stringa di lunghezza zero (""), <see langword="CurDir" /> restituisce il percorso dell'unità corrente.</param>
        <summary>Restituisce una stringa che rappresenta il percorso corrente. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="CurDir" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Stringa che rappresenta il percorso corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene utilizzato il `CurDir` funzione per restituire il percorso corrente.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.  
  
 `VbVolume` Restituisce l'etichetta di volume dell'unità anziché un nome file specifico.  
  
 È necessario fornire un `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l'elemento successivo, è possibile eseguire chiamate successive al `Dir` funzione senza parametri.  
  
> [!IMPORTANT]
>  Per eseguire correttamente il `Dir` funzione richiede il <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> per essere concesso al codice in esecuzione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Il `Attributes` argomento valori di enumerazione sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbnormal`|Predefinita. Specifica i file senza attributi.|  
|`ReadOnly`|`vbReadOnly`|Specifica i file di sola lettura e file senza attributi.|  
|`Hidden`|`vbHidden`|Specifica i file nascosti e i file senza attributi.|  
|`System`|`vbSystem`|Specifica i file di sistema e file senza attributi.|  
|`Volume`|`vbVolume`|Specifica l'etichetta di volume. Se qualsiasi altro attributo viene specificato, `vbVolume` viene ignorato.|  
|`Directory`|`vbDirectory`|Specifica le directory o cartelle, nonché i file senza attributi.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni vengono specificate il linguaggio Visual Basic e possono essere utilizzate ovunque nel codice anziché i valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Dir` funzione per verificare l'esistenza di determinati file e directory.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Facoltativo. Espressione <see langword="String" /> che specifica un nome di file, directory o cartella o un'etichetta di volume di un'unità. Viene restituita una stringa di lunghezza zero (<see langword="&quot;&quot;" />) se l'elemento <c>PathName</c> non viene trovato.</param>
        <param name="Attributes">Facoltativo. Enumerazione o espressione numerica il cui valore specifica attributi di file. Se omesso, <see langword="Dir" /> restituisce file che corrispondono a <c>PathName</c> ma sono privi di attributi.</param>
        <summary>Restituisce una stringa che rappresenta il nome di un file, di una directory o di una cartella corrispondente a un criterio o a un attributo di file specificato oppure all'etichetta di volume di un'unità. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="Dir" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Stringa che rappresenta il nome di un file, una directory o una cartella corrispondente a un determinato attributo di file o modello, oppure l'etichetta di volume di un'unità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Dir` funzione supporta l'utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.  
  
 `VbVolume` Restituisce l'etichetta di volume dell'unità anziché un nome file specifico.  
  
 È necessario fornire un `PathName` la prima volta che si chiama il `Dir` (funzione). Per recuperare l'elemento successivo, è possibile eseguire chiamate successive al `Dir` funzione senza parametri.  
  
> [!IMPORTANT]
>  Per eseguire correttamente il `Dir` funzione richiede il <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flag di <xref:System.Security.Permissions.FileIOPermission> per essere concesso al codice in esecuzione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Il `Attributes` argomento valori di enumerazione sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbnormal`|Predefinita. Specifica i file senza attributi.|  
|`ReadOnly`|`vbReadOnly`|Specifica i file di sola lettura, oltre ai file senza attributi.|  
|`Hidden`|`vbHidden`|Specifica i file nascosti, oltre ai file senza attributi.|  
|`System`|`vbSystem`|Specifica il file di sistema, oltre ai file senza attributi.|  
|`Volume`|`vbVolume`|Specifica l'etichetta di volume. Se qualsiasi altro attributo viene specificato, `vbVolume` viene ignorato.|  
|`Directory`|`vbDirectory`|Specifica una directory o cartelle, oltre ai file senza attributi.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni vengono specificate il linguaggio Visual Basic e possono essere utilizzate ovunque nel codice al posto dei valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Dir` funzione per verificare l'esistenza di determinati file e directory.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene qualsiasi numero di file valido.</param>
        <summary>Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</summary>
        <returns>Restituisce un valore Boolean <see langword="True" /> quando viene raggiunta la fine di un file aperto per <see langword="Random" /> o <see langword="Input" /> sequenziale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare `EOF` per evitare l'errore generato dal tentativo di ottenere l'input oltre la fine di un file.  
  
 Il `EOF` risultato della funzione `False` fino a quando non è stata raggiunta la fine del file. Con i file aperti per `Random` o `Binary` accesso, `EOF` restituisce `False` fino all'ultima esecuzione `FileGet` funzione in grado di leggere un record completo.  
  
 Con i file aperti per `Binary` accedere, un tentativo di leggere il file utilizzando il `Input` funzione finché `EOF` restituisce `True` genera un errore. Utilizzare il `LOF` e `Loc` funzioni anziché `EOF` durante la lettura di file binari con `Input`, oppure utilizzare `Get` quando si utilizza il `EOF` (funzione). Con i file aperti per `Output`, `EOF` restituisce sempre `True`.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `EOF` (funzione) per individuare la fine di un file. In questo esempio si presuppone che `Testfile` è un file di testo che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" />. Qualsiasi numero di file valido.</param>
        <summary>Restituisce un'enumerazione che rappresenta la modalità di file per i file aperti utilizzando la funzione <see langword="FileOpen" />. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto alla funzione <see langword="FileAttr" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>La modalità di accesso al file è indicata dai seguenti valori di enumerazione:  
  
 <list type="table"><item><term> Valore  
  
 </term><description> Modalità  
  
 </description></item><item><term> 1  
  
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  
  
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  
  
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  
  
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa funzione restituisce un'enumerazione che rappresenta la modalità di file per i file aperti mediante il `FileOpen` (funzione).  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FileAttr` funzione per restituire la modalità file di un file aperto.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Facoltativo. Matrice di parametri di 0 o più canali da chiudere.</param>
        <summary>Conclude le operazioni di input/output (I/O) in un file aperto con la funzione <see langword="FileOpen" />. Nelle operazioni di I/O di file <see langword="My" /> garantisce produttività e prestazioni migliori. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileClose` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [come: Leggi testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), e [procedura dettagliata: modifica dei file e directory in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Se si omette `FileNumbers`, tutti i file attivi aperti con la `FileOpen` funzione vengono chiusi.  
  
 Quando si chiudono i file che sono state aperte per `Output` o `Append`, il buffer finale dell'output viene scritto nel buffer del sistema operativo per tale file. Tutti i buffer associato chiuso spazio file viene rilasciato.  
  
 Quando il `FileClose` funzione viene eseguita, l'associazione di un file con il relativo file di numero.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FileClose` funzione per chiudere un file aperto per `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Obbligatorio. Espressione <see langword="String" /> che specifica il nome del file da copiare. Il parametro <c>Source</c> può includere la directory o la cartella e l'unità del file di origine.</param>
        <param name="Destination">Obbligatorio. Espressione <see langword="String" /> che specifica il nome file di destinazione. Il parametro <c>Destination</c> può includere la directory o la cartella e l'unità del file di destinazione.</param>
        <summary>Copia un file. Nelle operazioni di I/O su file, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> garantisce produttività e prestazioni migliori rispetto a <see langword="FileCopy" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si tenta di utilizzare il `FileCopy` funzione su un file attualmente aperto, si verifica un errore.  
  
 `FileCopy` richiede l'attendibilità totale per funzionare nell'unità locale.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FileCopy` funzione per copiare un file a un altro. Ai fini di questo esempio, si supponga che `SrcFile` è un file che contiene dati.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> o <paramref name="Destination" /> non è valido o non è specificato.</exception>
        <exception cref="T:System.IO.IOException">Il file è già aperto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome file. Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="Date" /> che indica la data e l'ora della scrittura in un file. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileDateTime" />. Per altre informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          Valore <see langword="Date" /> che indica la data e l'ora di creazione o dell'ultima modifica di un file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene utilizzato il `FileDateTime` funzione per determinare la data e un'ora di un file è stato creato o dell'ultima modifica. Il formato della data e ora visualizzata è basato sulle impostazioni locali del sistema.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> non è valido o contiene caratteri jolly.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di destinazione non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il`FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore. Le dimensioni e i limiti della matrice passata in `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file con `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione`FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il`FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza. Il valore predefinito è <see langword="False" />.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <param name="ArrayIsDynamic">Facoltativo. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere considerata una matrice dinamica e se è necessario un descrittore della matrice che descrive le dimensioni e i limiti della matrice.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore a due byte per la stringa che descrive la lunghezza. Il valore predefinito è <see langword="False" />.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGet" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGet` vengono generalmente scritti in un file utilizzando `FilePut`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o dopo l'ultimo byte `FileGet` o `FilePut` funzione (o a cui fa riferimento l'ultima `Seek` (funzione)) è di lettura.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGet` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'avvio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Per impostazione predefinita, se la variabile in lettura è una stringa, `FileGet` legge un descrittore di due byte che contiene la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa. Quando è inserito in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in lettura è una matrice, è possibile scegliere se leggere un descrittore per le dimensioni della matrice. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Durante la lettura della matrice, è necessario corrispondere al modo in cui che è stata scritta la matrice. Se è stato scritto con il descrittore, è necessario leggere il descrittore. Se non viene utilizzato il descrittore, le dimensioni e i limiti della matrice passato `FileGet` determinare gli elementi da leggere.  
  
     Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     I byte 218 vengono distribuiti come segue:  
  
    -   18 byte per il descrittore: (2 + 8 * 2)  
  
    -   200 byte per i dati: (10 * 5 * 4).  
  
-   Se la variabile in lettura è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FileGet` legge solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da leggere.  
  
-   `FileGet` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePut`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi. Ciò include le matrici e i relativi descrittori. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione di una stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGet` legge in modo contiguo; tutte le variabili da disco vale a dire senza spaziatura tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGet` legge solo i dati. Nessun descrittore è di lettura.  
  
-   `FileGet` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
    > [!IMPORTANT]
    >  La lettura da un file utilizzando il `FileGet` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome valido della variabile in cui vengono letti i dati.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale viene avviata la lettura.</param>
        <summary>Legge i dati in una variabile da un file aperto sul disco.  La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileGetObject" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileGetObject` funzione viene utilizzata al posto di `FileGet` per evitare ambiguità in fase di compilazione se tipo `Object` viene restituito invece un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.  
  
 Se si intende scrivere il `Variant` tipo `FileGetObject` è obbligatorio. In caso di dubbi, se si utilizza un oggetto per il secondo parametro, è consigliabile utilizzare `FilePutObject` e `FileGetObject`.  
  
 `FileGetObject` è valido solo in `Random` e `Binary` modalità.  
  
 I dati letti con `FileGetObject` vengono in genere scritti con `FilePutObject`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, `FileGetObject` legge il record o byte dopo l'ultimo `FileGetObject` o `FilePutObject` funzione (o a cui fa riferimento l'ultima `Seek` funzione).  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati letti è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FileGetObject` legge i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché non è possibile stabilire con precisione la quantità di dati di spaziatura interna, è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da leggere.  
  
-   Se la variabile in lettura è una stringa, per impostazione predefinita `FileGetObject` legge un descrittore di due byte contenente la lunghezza della stringa e quindi legge i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola del `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte. Visual Basic 6.0 e versioni precedenti supportano stringhe di lunghezza fissa e durante la lettura in un file, il descrittore di lunghezza non viene scritta. Se si desidera leggere una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile in cui si legge è una matrice, è necessario che la lunghezza del record specificata dal parametro `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: 2 + 8 * NumberOfDimensions.  
  
     Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     I byte 218 distribuiti come segue: 18 byte per il descrittore (2 + 8 * 2) e 100 byte per i dati (10 * 5 * 4).  
  
-   `FileGetObject` legge gli elementi delle strutture come se fossero letti singolarmente, ad eccezione del fatto che non vi sia alcun riempimento tra gli elementi. Sul disco, una matrice dinamica di un tipo definito dall'utente (scritto con `FilePutObject`) è preceduto da un descrittore di lunghezza uguale a 2 + 8 volte il numero di dimensioni: 2 + 8 * NumberOfDimensions. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per la lettura dei singoli elementi, incluse le matrici e i descrittori. La <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe può essere applicata ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, tutti i `Random` vengono applicate regole, con le seguenti eccezioni:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FileGetObject` legge tutte le variabili dal disco in modo contiguo, vale a dire senza spaziatura interna tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FileGetObject` legge solo i dati. Nessun descrittore è di lettura.  
  
 `FileGetObject` legge le stringhe a lunghezza variabile che non sono elementi di strutture senza attendere il descrittore di lunghezza a due byte. Il numero di byte letti è uguale al numero di caratteri già nella stringa.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non può essere un file di origine Visual Basic.  
  
   
  
## Examples  
 Nell'esempio seguente legge un record in un file di test e in seguito viene recuperato.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un file. Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="Long" /> che specifica la lunghezza di un file in byte. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileLen" />. Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          Valore <see langword="Long" /> che specifica la lunghezza di un file in byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file specificato è aperto quando il `FileLen` funzione viene chiamata, il valore restituito rappresenta le dimensioni del file al momento è stato aperto.  
  
> [!NOTE]
>  Per ottenere la lunghezza corrente di un file aperto, usare il `LOF` (funzione).  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FileLen` funzione per restituire la lunghezza di un file in byte. Ai fini di questo esempio, si supponga che `TestFile` è un file che contiene alcuni dati.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il file non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido. Utilizza la funzione <see langword="FreeFile" /> per ottenere il successivo numero di file disponibile.</param>
        <param name="FileName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome di file. Può includere la directory o la cartella e l'unità.</param>
        <param name="Mode">Obbligatorio. Enumerazione che specifica la modalità per il file: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> o <see langword="Random" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Facoltativo. Enumerazione che specifica le operazioni autorizzate sul file aperto: <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />. Il valore predefinito è <see langword="ReadWrite" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Facoltativo. Enumerazione che specifica le operazioni non autorizzate sul file aperto da altri processi: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> e <see langword="Lock Read Write" />. Il valore predefinito è <see langword="Lock Read Write" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Facoltativo. Numero minore o uguale a 32.767 byte. Per i file aperti per l'accesso Random, questo valore rappresenta la lunghezza del record. Per i file sequenziali, questo valore rappresenta il numero di caratteri memorizzati nel buffer.</param>
        <summary>Apre un file per l'input o l'output. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileOpen" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FileOpen` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Prima di poter eseguire qualsiasi operazione dei / o su di esso, è necessario aprire un file. `FileOpen` Alloca un buffer dei / o al file e determina la modalità di accesso da utilizzare con il buffer.  
  
> [!IMPORTANT]
>  Quando si scrive in un file, un'applicazione potrebbe essere necessario creare un file, se il file a cui sta tentando di scrivere non esiste. A tale scopo, sono necessarie le autorizzazioni per la directory in cui viene creato il file. Tuttavia, se il file specificato da `FileName` esiste, l'applicazione deve `Write` autorizzazioni solo per il file stesso. Quando possibile, per migliorare la sicurezza, creare il file durante la distribuzione e concedere `Write` le autorizzazioni per tale file solo, anziché per l'intera directory. Per migliorare la sicurezza, scrivere dati nella directory dell'utente anziché nella directory radice o la directory dei file di programma.  
  
 Aprire il canale è reperibile tramite il `FreeFile()` (funzione).  
  
> [!IMPORTANT]
>  Il `FileOpen` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione, che potrebbe influire sulla relativa esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere l'enumerazione <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In questo esempio illustra vari usi del `FileOpen` funzione per abilitare l'input e output in un file.  
  
 Il codice seguente consente di aprire il file `TestFile` in `Input` modalità.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Nell'esempio viene aperto il file in `Binary` modalità per operazioni di sola scrittura.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Nell'esempio seguente viene aperto il file in `Random` modalità. Il file contiene record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Questo esempio di codice consente di aprire il file in `Output` modalità, le operazioni possono leggere o scrivere nel file.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Questo esempio di codice consente di aprire il file in `Binary` modalità per la lettura; Impossibile leggere il file ad altri processi.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Lunghezza del record negativa (e diversa da -1).</exception>
        <exception cref="T:System.IO.IOException">
          Il parametro <paramref name="FileName" /> è già aperto oppure <paramref name="FileName" /> non è valido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il`VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel`RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <param name="ArrayIsDynamic">Facoltativo. Si applica solo durante la scrittura di una matrice. Specifica se la matrice deve essere considerata dinamica e se deve essere scritto un descrittore di matrice per la stringa che descrive la lunghezza.</param>
        <param name="StringIsFixedLength">Facoltativo. Si applica solo durante la scrittura di una stringa. Specifica se scrivere un descrittore di lunghezza a due byte per la stringa nel file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive dati da una variabile in un file del disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePut" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePut` vengono in genere letti da un file usando `FileGet`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, il record o byte dopo l'ultimo `FileGet` o `FilePut` di funzione o a cui fa riferimento l'ultima `Seek` funzione viene scritto.  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePut` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePut`, è necessario eseguire la stessa operazione con `FileGet`, ed è necessario assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePut` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, verrà generata un'eccezione.  
  
-   Se la variabile scritta è una stringa, `FilePut` scriverà un descrittore di due byte che contiene la lunghezza della stringa e quindi scrive i dati nella variabile. Pertanto, la lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePut` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePut` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePut` scriverà un descrittore a due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è possibile scegliere di scrivere un descrittore per le dimensioni della matrice o meno. Visual Basic 6.0 e versioni precedenti di scrivere il descrittore del file per una matrice dinamica ma non per una matrice di dimensioni fisse. Visual Basic 2005 per impostazione predefinita non viene scritto il descrittore. Per scrivere il descrittore, impostare il `ArrayIsDynamic` parametro `True`. Quando si scrive la matrice, è necessario corrispondere al modo in cui che la matrice verrà letta. Se sarà possibile leggerla con il descrittore, è necessario scrivere il descrittore. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions). La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Ad esempio, la seguente dichiarazione di matrice richiede 218 byte quando la matrice viene scritto su disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se la variabile scritta è qualsiasi altro tipo di variabile (non una stringa di lunghezza variabile o oggetto), `FilePut` scrive solo i dati della variabile. La lunghezza del record specificata dal `RecordLength` clausola il `FileOpen` funzione deve essere maggiore o uguale alla lunghezza dei dati da scrivere.  
  
-   `FilePut` scrive gli elementi delle strutture come se fossero scritti individualmente, ad eccezione del fatto non è presente riempimento tra gli elementi. Il `VBFixedString` attributo può essere applicato ai campi stringa nelle strutture per indicare la dimensione della stringa quando viene scritta su disco.  
  
    > [!NOTE]
    >  Campi che il numero di byte a quanto specificato dalla stringa di `VBFixedString` attributo vengono troncati quando scritto su disco,  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` la maggior parte delle modalità di `Random` vengono applicate le regole della modalità, con alcune eccezioni. Le regole seguenti per i file aperti in `Binary` modalità differiscono dalle regole per `Random` modalità:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePut` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
-   Per qualsiasi matrice diverso da una matrice in una struttura, `FilePut` scrive solo i dati. Nessun descrittore viene scritto.  
  
-   `FilePut` Scrive le stringhe a lunghezza variabile che non sono elementi di strutture senza il descrittore di lunghezza a due byte. Il numero di byte scritti è uguale al numero di caratteri nella stringa. Le istruzioni seguenti, ad esempio, scrivere 11 byte nel file numero 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   La scrittura in un file mediante il `FilePut` funzione richiede `Write` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePut` funzione per scrivere dati in un file. Cinque record della struttura `Person` vengono scritti nel file.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e diverso da -1.</exception>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. Nome di variabile valido che contiene i dati scritti su disco.</param>
        <param name="RecordNumber">Facoltativo. Numero di record (file in modalità <see langword="Random" />) o numero di byte (file in modalità <see langword="Binary" />) in corrispondenza del quale inizia la scrittura.</param>
        <summary>Scrive dati da una variabile in un file del disco.  La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FilePutObject" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `FilePutObject` funzione viene utilizzata al posto di `FilePut` per evitare ambiguità in fase di compilazione se tipo `Object` invece viene passato un altro tipo, ad esempio `Integer`, `Long`, `Short`e così via.  
  
 `FilePutObject` scrive e legge i descrittori che descrivono l'oggetto. Se si intende scrivere il `Variant` tipo `FilePutObject` è obbligatorio. In caso di dubbi, se si utilizza un oggetto per il secondo parametro, è consigliabile utilizzare sempre `FilePutObject` e `FileGetObject`.  
  
 `FilePutObject` è valido solo in `Random` e `Binary` modalità.  
  
 I dati scritti con `FilePutObject` vengono in genere letti da un file usando `FileGetObject`.  
  
 Il primo record o byte in un file corrisponde alla posizione 1, il secondo record o byte in posizione 2 e così via. Se si omette `RecordNumber`, `FilePutObject` scrive un record o il byte successivo dopo l'ultimo `FileGetObject` o `FilePutObject` funzione (o il record o byte a cui fa riferimento l'ultima `Seek` funzione).  
  
 Il `StringIsFixedLength` argomento controlla se la funzione interpreta le stringhe a lunghezza fissa o variabile. `FilePutObject` Scrive il descrittore di lunghezza quando l'argomento è `True`. Se si utilizza `StringIsFixedLength`  =  `True` con `FilePutObject`, è necessario eseguire la stessa operazione con `FileGetObject`, e assicurarsi che la stringa venga inizializzata alla lunghezza prevista.  
  
## <a name="random-mode"></a>Modalità casuale  
 Per i file aperti `Random` modalità, le seguenti regole:  
  
-   Se la lunghezza dei dati da scrivere è minore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione `FilePutObject` scrive i record successivi nei limiti di lunghezza di record. Lo spazio tra la fine di un record e l'inizio del record successivo viene riempito con il contenuto esistente del buffer di file. Poiché la quantità di dati di spaziatura interna non è possibile determinare con precisione, in genere è consigliabile avere la lunghezza del record corrisponde alla lunghezza dei dati da scrivere. Se la lunghezza dei dati da scrivere è maggiore della lunghezza specificata nel `RecordLength` clausola del `FileOpen` funzione, viene generata un'eccezione.  
  
-   Se la variabile scritta è un oggetto che contiene un tipo numerico, `FilePutObject` scrive due byte che identificano il `VarType` dell'oggetto e quindi scrive la variabile. Ad esempio, quando si scrive un oggetto che contiene un numero intero, `FilePutObject` scrive sei byte: due byte che identificano l'oggetto come `VarType(3)` (`Integer`) e quattro byte che contengono i dati. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore del numero effettivo di byte necessari per archiviare la variabile di almeno due byte.  
  
-   Se la variabile scritta è un oggetto che contiene una stringa, `FilePutObject` scriverà un descrittore di due byte che identifica il `VarType(8)` dell'oggetto, un descrittore di due byte che indica la lunghezza della stringa e quindi i dati della stringa. La lunghezza del record specificata dal `RecordLength` parametro il `FileOpen` funzione deve essere maggiore della lunghezza effettiva della stringa di almeno quattro byte. Se si desidera inserire una stringa senza il descrittore, è necessario passare `True` per il `StringIsFixedLength` parametro e la stringa letta deve avere la lunghezza corretta.  
  
-   Se la variabile scritta è una matrice, è necessario che la lunghezza del record specificata dalla clausola `RecordLength` della funzione `FileOpen` sia superiore o uguale alla somma di tutti i byte necessari per scrivere i dati e il descrittore della matrice. Il descrittore specifica il numero di dimensioni della matrice, le dimensioni e i limiti inferiori per ogni classificazione. La lunghezza è uguale a 2 più 8 volte il numero di dimensioni: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Modalità binaria  
 Per i file aperti `Binary` modalità, tutti i `Random` si applicano le regole della modalità, ad eccezione di:  
  
-   Il `RecordLength` clausola il `FileOpen` funzione non ha alcun effetto. `FilePutObject` Scrive tutte le variabili su disco in successione, ovvero senza spazi tra i record.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FilePutObject` funzione per scrivere una stringa in un file.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="RecordWidth">Obbligatorio. Espressione numerica compresa nell'intervallo tra 0 e 255 inclusi, che indica quanti caratteri devono comparire in una riga prima che venga iniziata una nuova riga. Se <c>RecordWidth</c> è uguale a 0, non esiste alcun limite alla lunghezza della riga. Il valore predefinito per <c>RecordWidth</c> è 0.</param>
        <summary>Assegna lo spessore della linea di output per un file aperto mediante la funzione <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questo esempio viene utilizzato il `FileWidth` funzione per impostare la larghezza della riga di output di un file.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</summary>
        <returns>Restituisce un valore <see langword="Integer" /> che rappresenta il successivo numero di file che può essere utilizzato dalla funzione <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare `FreeFile` per fornire un numero di file che non è già in uso.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `FreeFile` funzione per restituire il successivo numero di file disponibili. Cinque file aperti per l'output all'interno del ciclo e in ognuno vengono scritti alcuni dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Più di 255 file sono in uso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome di file, directory o cartella. Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</param>
        <summary>Restituisce un valore <see langword="FileAttribute" /> che rappresenta gli attributi di un file, di una directory o di una cartella. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="FileAttribute" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Il valore restituito dalla funzione <see langword="GetAttr" /> è la somma dei seguenti valori di enumerazione:  
  
 <list type="table"><item><term> Valore  
  
 </term><description> Costante  
  
 </description><description> Descrizione  
  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normale.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Sola lettura.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Nascosto.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> File di sistema.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory o cartella.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Il file è stato modificato dopo l'ultimo backup.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Il file ha un nome diverso.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Queste enumerazioni sono specificate dal linguaggio Visual Basic. e possono essere utilizzate in qualsiasi punto del codice in sostituzione dei valori effettivi.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare quali attributi sono impostati, utilizzare il `And` operatore per eseguire un confronto bit per bit tra il valore restituito dal `GetAttr` funzione e il valore dell'attributo di file desiderato. Se il risultato è diverso da zero, tale attributo è impostato per il file denominato. Ad esempio, il valore restituito i seguenti `And` espressione è zero se la `Archive` attributo non è impostato:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Viene restituito un valore diverso da zero se la `Archive` attributo è impostato.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `GetAttr` funzione per determinare gli attributi di un file e directory o una cartella.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> non è valido o contiene caratteri jolly.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di destinazione non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con poche righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Value">Obbligatorio. La variabile cui sono assegnati i valori letti dal file non può essere una matrice o una variabile oggetto.</param>
        <summary>Legge i dati da un file sequenziale aperto e li assegna a variabili.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Input` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `Input` vengono generalmente scritti in un file utilizzando `Write`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni in merito al relativo contenuto in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic 2005.  
  
 Durante la lettura, la stringa standard o dati numerici viene assegnati a variabili senza modifica. Nella tabella seguente viene illustrato come vengano considerati altri dati di input.  
  
|Dati|Valore assegnato alla variabile|  
|-|-|  
|Virgola di delimitazione o riga vuota|Empty|  
|#NULL#|`DBNull`|  
|# TRUE o FALSE # #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data e/o dell'ora rappresentate dall'espressione|  
|#ERROR `errornumber`#|`errornumber` (la variabile è un oggetto contrassegnato come errore)|  
  
 Se si raggiunge la fine del file durante l'immissione di un elemento di dati, l'input viene arrestato e si verifica un errore.  
  
> [!NOTE]
>  Il `Input` funzione non è localizzata. Ad esempio, nella versione tedesca, se si immette 3,14159, verrà restituito solo 3, poiché viene considerata la virgola come separatore di variabile anziché come un separatore decimale.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `Input` funzione richiede `Read` tramite il `FileIOPermissionAccess` enumerazione. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Input` funzione per leggere dati da un file in due variabili. In questo esempio si presuppone che `TestFile` è un file con diverse righe di dati scritti tramite il `Write` funzione, ogni riga contiene una stringa tra virgolette e un numero separato da una virgola, ad esempio: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="CharCount">Obbligatorio. Qualsiasi espressione numerica valida che specifica il numero di caratteri da leggere.</param>
        <summary>Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce il valore <see langword="String" /> che contiene i caratteri di un file aperto in modalità <see langword="Input" /> o <see langword="Binary" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `InputString` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con il `InputString` funzione viene in genere scritti in un file mediante `Print` o `FilePut`. Utilizzare questa funzione solo con i file aperti `Input` o `Binary` modalità.  
  
 A differenza di `Input` funzione, il `InputString` funzione restituisce tutti i caratteri letti. Ciò include virgole, ritorni a capo, avanzamento riga, tra virgolette e gli spazi iniziali.  
  
 Con i file aperti per `Binary` accedere, un tentativo di leggere il file mediante il `InputString` funzione finché `EOF` restituisce `True` genera un errore. Utilizzare il `LOF` e `Loc` funzioni anziché `EOF` quando si legge i file binari in `InputString`, oppure utilizzare `FileGet` quando si utilizza il `EOF` (funzione).  
  
> [!NOTE]
>  Durante la lettura da file, non per prendere decisioni di protezione sul contenuto del file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non può essere un file di origine Visual Basic.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `InputString` funzione per leggere un carattere alla volta da un file e stampa per il `Output` finestra. In questo esempio si presuppone che `MyFile` è un file di testo con più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 o &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica uno o più nomi file da eliminare. Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</param>
        <summary>Elimina i file da un disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Kill" />. Per altre informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` supporta l'utilizzo di più caratteri (`*`) e caratteri a singolo (`?`) i caratteri jolly per specificare più file.  
  
 **Nota sulla sicurezza** per eseguire, il `Kill` funzione richiede `Read` e `PathDiscovery` flag di <xref:System.Security.Permissions.FileIOPermission> per essere concesso al codice in esecuzione. Per ulteriori informazioni, vedere <xref:System.Security.SecurityException> [le autorizzazioni di accesso di codice](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Kill` funzione per eliminare un file da un disco.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File di destinazione aperti.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File di destinazione non trovati.</exception>
        <exception cref="T:System.Security.SecurityException">Autorizzazione negata.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</summary>
        <returns>Legge una sola riga da un file sequenziale aperto e la assegna a una variabile <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `LineInput` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 I dati letti con `LineInput` vengono generalmente scritti in un file utilizzando `Print`.  
  
> [!IMPORTANT]
>  Durante la lettura da file, non per prendere decisioni sul contenuto di un file in base all'estensione di nome file. Ad esempio, un file denominato Form1. vb non sia un file di origine Visual Basic.  
  
 Il `LineInput` funzione legge da un file di un carattere alla volta finché incontra un ritorno a capo (`Chr(13)`) o un ritorno a capo/avanzamento riga (`Chr(13) + Chr(10)`) sequenza. Le sequenze di avanzamento di ritorno a capo/riga vengono ignorate anziché aggiunte alla stringa di caratteri.  
  
> [!IMPORTANT]
>  La lettura da un file utilizzando il `LineInput` funzione richiede `Read` tramite il <xref:System.Security.Permissions.FileIOPermissionAccess> enumerazione.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `LineInput` funzione per leggere una riga in un file sequenziale e assegnarlo a una variabile. In questo esempio si presuppone che `TestFile` è un file di testo con più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Raggiunta la fine del file.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file <see langword="Integer" /> valido.</param>
        <summary>Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</summary>
        <returns>Restituisce un valore <see langword="Long" /> che specifica la posizione corrente di lettura/scrittura in un file aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Loc` funzione è in base zero, utilizzarla per recuperare il primo byte in un file, verrà restituito 0.  
  
 Il `Loc` funzione viene fornito per compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Di seguito viene descritto il valore restituito per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero dell'ultimo record letto o scritto nel file.|  
|`Sequential`|Posizione corrente di byte nel file diviso per 128. Tuttavia, le informazioni restituite dalla `Loc` per file sequenziali è necessaria né utilizzato.|  
|`Binary`|Posizione dell'ultimo byte letti o scritti.|  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Loc` funzione per restituire la posizione di lettura/scrittura corrente in un file aperto. In questo esempio si presuppone che `MyFile` è un file di testo con più righe di dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Record">Facoltativo. Numero del record o byte da bloccare o sbloccare</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="FromRecord">Facoltativo. Numero del primo record o byte da bloccare o sbloccare.</param>
        <param name="ToRecord">Facoltativo. Numero dell'ultimo record o byte da bloccare o sbloccare.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <summary>Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce <see langword="Long" /> che rappresenta le dimensioni, in byte, di un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il `FileLen` funzione per ottenere la lunghezza di un file che non è aperta.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `LOF` funzione per determinare le dimensioni di un file aperto. In questo esempio si presuppone che `TestFile` è un file di testo che contiene i dati di esempio.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory da creare. Il parametro <c>Path</c> può includere l'unità. Se non viene specificata alcuna unità, <see langword="MkDir" /> crea la nuova directory nell'unità corrente.</param>
        <summary>Crea una nuova directory. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="MkDir" />. Per ulteriori informazioni, vedere <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa funzione crea una nuova directory.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `MkDir` funzione per creare una directory. Se l'unità non è specificato, viene creata nella nuova directory dell'unità corrente.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> non è specificato o è vuoto.</exception>
        <exception cref="T:System.Security.SecurityException">Autorizzazione negata.</exception>
        <exception cref="T:System.IO.IOException">Directory già esistente.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Output">Facoltativo. Zero o più espressioni con valori delimitati da virgole da scrivere in un file.  
  
 Le impostazioni dell'argomento <c>Output</c> sono le seguenti:  
  
 <see langword="T:System.IO.IOException" />: la modalità File non è valida.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> non esiste.</param>
        <summary>Scrive i dati formattati per la visualizzazione in un file sequenziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Print` e `PrintLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` non include una riga feed alla fine di una linea. Tuttavia, `PrintLine` includono un avanzamento riga.  
  
 I dati scritti con `Print` è in genere letti da un file mediante `LineInput` o `Input`.  
  
 Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota per il file, ad `Print`, niente è output. Più espressioni separate da una virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.  
  
 Per `Boolean` dati, ovvero `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.  
  
 Dati di data vengono scritti nel file utilizzando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.  
  
 Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` elenco dati `DBNull`, `Null` viene scritta nel file.  
  
 Per `Error` dati, l'output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.  
  
 Tutti i dati scritti nel file utilizzando `Print` internazionali; ovvero, i dati sia formattati correttamente utilizzando il separatore decimale appropriato. Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.  
  
 La scrittura in un file mediante il `Print` o `PrintLine` funzioni richiede `Write` tramite il `FileIOPermissionAccess` enumerazione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Print` e `PrintLine` funzioni per scrivere dati in un file.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Output">Facoltativo. Zero o più espressioni con valori delimitati da virgole da scrivere in un file.  
  
 Le impostazioni dell'argomento <c>Output</c> sono le seguenti:  
  
 <see langword="T:System.IO.IOException" />: la modalità File non è valida.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> non esiste.</param>
        <summary>Scrive i dati formattati per la visualizzazione in un file sequenziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Print` e `PrintLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` non include una riga feed alla fine di una linea. Tuttavia,`PrintLine` includono un avanzamento riga.  
  
 I dati scritti con `Print` è in genere letti da un file mediante `LineInput` o `Input`.  
  
 Se si omette `Output` per `PrintLine`, viene visualizzata una riga vuota per il file, ad `Print`, niente è output. Più espressioni separate da una virgola verranno allineate su limiti della scheda, ma la combinazione di virgole e `TAB` può causare risultati incoerenti.  
  
 Per `Boolean` dati, ovvero `True` o `False` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.  
  
 Dati di data vengono scritti nel file utilizzando il formato di data breve standard riconosciuto dal sistema. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.  
  
 Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, se `Output` elenco dati `DBNull`, `Null` viene scritta nel file.  
  
 Per `Error` dati, l'output viene visualizzato come `Error errorcode`. Il `Error` parola chiave non viene eseguita indipendentemente dalle impostazioni locali.  
  
 Tutti i dati scritti nel file utilizzando `Print` internazionali; ovvero, i dati sia formattati correttamente utilizzando il separatore decimale appropriato. Se l'utente desidera ottenere dati da utilizzare in più lingue, `Write` deve essere utilizzato.  
  
 La scrittura in un file mediante il `Print` o `PrintLine` funzioni richiede `Write` tramite il `FileIOPermissionAccess` enumerazione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Print` e `PrintLine` funzioni per scrivere dati in un file.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Obbligatorio. Espressione <see langword="String" /> che specifica il nome file esistente e il relativo percorso. Il parametro <c>OldPath</c> può includere la directory e l'unità del file.</param>
        <param name="NewPath">Obbligatorio. Espressione <see langword="String" /> che specifica il nuovo nome file e il relativo percorso. Il parametro <c>NewPath</c> può includere la directory e l'unità del percorso di destinazione. Il nome file specificato da <c>NewPath</c> non deve essere già esistente.</param>
        <summary>Rinomina un file o una directory su disco. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Rename" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il`Rename` funzione Rinomina un file e lo sposta in una directory diversa, se necessario. Il `Rename` funzione è possibile spostare un file in unità, ma è possibile rinominare solo una directory esistente quando entrambi `NewPath` e `OldPath` si trovano nella stessa unità. `Rename` non è possibile creare un nuovo file o directory.  
  
 Utilizzo di `Rename` funzione in un file aperto viene generato un errore. Prima di rinominarlo, è necessario chiudere un file aperto. `Rename` argomenti non possono includere più caratteri (*) e caratteri jolly (?) con caratteri a singolo.  
  
> [!IMPORTANT]
>  Quando si utilizza `Rename` per copiare un file da un percorso non protetto in un percorso protetto, il file manterrà i diritti meno restrittivi. Verifica per accertarsi di non introdurre possibili rischi di sicurezza.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Rename` funzione per rinominare un file. Ai fini di questo esempio, si supponga che esistano le directory che sono già specificate.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il file <paramref name="OldPath" /> non esiste.</exception>
        <exception cref="T:System.IO.IOException">Impossibile rinominare con il nome di un'altro dispositivo.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude tutti i file su disco aperti mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Reset" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Reset` funzione chiude tutti i file aperti per la `FileOpen` funzione e ha la stessa funzione `FileClose()` senza parametri.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Reset` funzione per chiudere tutti i file aperti e scrivere il contenuto di tutti i buffer di file su disco. Si noti l'uso del `Object` variabile `FileNumber` come stringa sia un numero.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obbligatorio. Espressione <see langword="String" /> che identifica la directory o la cartella da rimuovere. Il parametro <c>Path</c> può includere l'unità. Se non viene specificata alcuna unità, <see langword="RmDir" /> rimuove la directory nell'unità corrente.</param>
        <summary>Rimuove una directory esistente. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="RmDir" />. Per ulteriori informazioni, vedere <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si verifica un errore se si tenta di utilizzare `RmDir` in una directory che contiene i file. Utilizzare il `Kill` funzione eliminare tutti i file prima di tentare di rimuovere una directory.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `RmDir` funzione per rimuovere una directory esistente.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> non è specificato o è vuoto.</exception>
        <exception cref="T:System.IO.IOException">La directory di destinazione contiene file.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La directory non esiste.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.  
  
 Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero del record successivo letto o scritto|  
|`Binary`, `Input`, `Output`, `Append`|Posizione di byte in cui viene eseguita l'operazione successiva. È il primo byte in un file nella posizione 1, il secondo byte in posizione 2 e così via.|  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Seek` funzione per restituire la posizione corrente del file. Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Per i file aperti in modalità diversa da `Random` modalità `Seek` restituisce la posizione di byte in cui viene eseguita l'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Questo esempio viene utilizzato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura o scrittura in un file.  
  
 Per i file aperti in modalità diversa da `Random` modalità `Seek` imposta la posizione di byte in cui viene eseguita l'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. <see langword="Integer" /> che contiene un numero di file valido.</param>
        <param name="Position">Obbligatorio. Numero compreso nell'intervallo da 1 a 2.147.483.647 inclusi, che indica dove deve aver luogo la successiva operazione di lettura/scrittura.</param>
        <summary>Restituisce <see langword="Long" />, che specifica la posizione corrente di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />, o imposta la posizione per la successiva operazione di lettura/scrittura in un file aperto mediante la funzione <see langword="FileOpen" />. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="Seek" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Restituisce un valore compreso tra 1 e 2.147.483.647 (equivalente a 2 ^ 31-1), inclusi.  
  
 Di seguito vengono descritti i valori restituiti per ogni modalità di accesso ai file:  
  
|Modalità|Valore restituito|  
|-|-|  
|`Random`|Numero del record successivo letto o scritto|  
|`Binary`, `Input`, `Output`, `Append`|Posizione di byte in cui viene eseguita l'operazione successiva. È il primo byte in un file nella posizione 1, il secondo byte in posizione 2 e così via.|  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Seek` funzione per restituire la posizione corrente del file. Nell'esempio si presuppone `TestFile` è un file che contiene i record della struttura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Per i file aperti `Random` modalità `Seek` restituisce il numero di record successivo.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Per i file aperti in modalità diversa da `Random` modalità `Seek` restituisce la posizione di byte in cui viene eseguita l'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Questo esempio viene utilizzato il `Seek` funzione per impostare la posizione per la successiva operazione di lettura o scrittura in un file.  
  
 Per i file aperti in modalità diversa da `Random` modalità `Seek` imposta la posizione di byte in cui viene eseguita l'operazione successiva. Si supponga `TestFile` è un file che contiene più righe di testo.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. Espressione <see langword="String" /> che specifica un nome file. Il parametro <c>PathName</c> può includere la directory o la cartella e l'unità.</param>
        <param name="Attributes">Obbligatorio. Costante o espressione numerica la cui somma specifica attributi di file.</param>
        <summary>Imposta le informazioni degli attributi per un file. La funzionalità <see langword="My" /> offre un livello più elevato di produttività e prestazioni nelle operazioni di I/O dei file rispetto a <see langword="SetAttr" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si tenta di impostare gli attributi di un file aperto, si verifica un errore di run-time.  
  
 Il `Attributes` argomento valori di enumerazione sono i seguenti:  
  
|Valore|Costante|Descrizione|  
|-|-|-|  
|`Normal`|`vbNormal`|Normale (impostazione predefinita).|  
|`ReadOnly`|`vbReadOnly`|Sola lettura.|  
|`Hidden`|`vbHidden`|Nascosto.|  
|`System`|`vbSystem`|File di sistema.|  
|`Volume`|`vbVolume`|Etichetta del volume|  
|`Directory`|`vbDirectory`|Directory o cartella.|  
|`Archive`|`vbArchive`|Il file è stato modificato dopo l'ultimo backup.|  
|`Alias`|`vbAlias`|Il file ha un nome diverso.|  
  
> [!NOTE]
>  Queste enumerazioni sono specificate dal linguaggio Visual Basic. I nomi possono essere utilizzati in qualsiasi punto nel codice anziché i valori effettivi.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `SetAttr` funzione per impostare gli attributi di un file.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Tipo di <paramref name="Attribute" /> non valido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Obbligatorio. Numero di spazi da inserire prima di visualizzare o stampare la successiva espressione di un elenco.</param>
        <summary>Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</summary>
        <returns>Utilizzato con le funzioni <see langword="Print" /> o <see langword="PrintLine" /> per posizionare l'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Count` è minore della larghezza della riga di output, la posizione successiva immediatamente seguirà il numero di spazi stampati. Se`Count` è maggiore della larghezza della riga di output, `SPC` calcola la posizione successiva utilizzando la formula:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Ad esempio, se la posizione di stampa è 24, la larghezza della riga di output è 80 e si specifica `SPC(90)`, la stampa successiva inizierà dalla posizione 34 (posizione di stampa corrente + il resto di 90/80). Se la differenza tra la posizione di stampa e la larghezza della riga di output è minore di `Count` (o `Count` `Mod` *larghezza*), il `SPC` funzione passerà all'inizio della riga successiva e genera l'errore spazi uguale a `Count` – (*larghezza* – *currentprintposition*).  
  
> [!NOTE]
>  Verificare che le colonne di tabella sono sufficiente a consentire caratteri ampi.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `SPC` funzione per posizionare l'output in un file e nel **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
        <returns>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la posizione di stampa nella riga corrente è maggiore `Column`, `TAB` passerà al valore di colonna è uguale a `Column` nella riga successiva di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa alla colonna 1. Se `Column` è maggiore della larghezza di riga di output, `TAB` calcola la posizione successiva utilizzando la formula:  
  
 Larghezza della colonna Mod  
  
 Ad esempio, se *larghezza* è 80 e si specifica `TAB(90)`, la stampa successiva inizierà dalla colonna 10 (il resto di 90/80). Se `Column` è minore della posizione di stampa corrente, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, posizione di stampa la stampa inizierà dalla calcolata nella stessa riga.  
  
 La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si utilizza il `Print` o `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).  
  
 Il `TAB` funzione può essere utilizzata anche con il `WriteLine` (funzione). Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verificare che le colonne di tabella sono sufficiente a contenere i caratteri "wide".  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `TAB` funzione per posizionare l'output in un file e nel **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Facoltativo. Numero della colonna a cui passare prima di visualizzare o stampare la successiva espressione di un elenco. In caso di omissione, <see langword="TAB" /> sposterà il punto di inserimento all'inizio della successiva area di stampa.</param>
        <summary>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</summary>
        <returns>Viene utilizzata con la funzione <see langword="Print" /> o <see langword="PrintLine" /> per specificare la posizione dell'output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la posizione di stampa nella riga corrente è maggiore di `Column`, `TAB` passerà al valore di colonna è uguale a `Column` nella riga successiva di output. Se `Column` è minore di 1, `TAB` Sposta la posizione di stampa alla colonna 1. Se `Column` è maggiore della larghezza della riga di output, `TAB` calcola la posizione successiva utilizzando la formula:  
  
 Larghezza della colonna Mod  
  
 Ad esempio, se *larghezza* è 80 e si specifica `TAB(90)`, la stampa successiva inizierà dalla colonna 10 (il resto di 90/80). Se `Column` è minore della posizione di stampa corrente, la stampa inizierà nella riga successiva in corrispondenza della posizione di stampa calcolata. Se la posizione di stampa calcolata è maggiore della posizione corrente di stampa, posizione di stampa la stampa inizierà dalla calcolata nella stessa riga.  
  
 La posizione più a sinistra di stampa in una riga di output è sempre 1. Quando si utilizza il `Print` o `PrintLine` funzioni per la stampa su file, l'ultima posizione corrisponde alla larghezza corrente del file di output, è possibile impostare utilizzando il `FileWidth` (funzione).  
  
 Il `TAB` funzione può essere utilizzata anche con il `WriteLine` (funzione). Non può essere usato con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verificare che le colonne di tabella sono sufficiente a contenere i caratteri "wide".  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `TAB` funzione per posizionare l'output in un file e nel **Output** finestra.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="Record">Facoltativo. Numero del record o byte da bloccare o sbloccare</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Qualsiasi numero di file valido.</param>
        <param name="FromRecord">Facoltativo. Numero del primo record o byte da bloccare o sbloccare.</param>
        <param name="ToRecord">Facoltativo. Numero dell'ultimo record o byte da bloccare o sbloccare.</param>
        <summary>Controlla l'accesso da parte di altri processi a una parte o a tutto il file aperto mediante la funzione <see langword="Open" />. Nelle operazioni di I/O su file, la funzionalità <see langword="My" /> garantisce produttività e prestazioni migliori rispetto a <see langword="Lock" /> e <see langword="Unlock" />. Per ulteriori informazioni, vedere <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Lock` e `Unlock` vengono utilizzate in ambienti in cui più processi potrebbero richiedere l'accesso al file stesso.  
  
 `Lock` e `Unlock` vengono sempre utilizzate in coppia. Gli argomenti da `Lock` e `Unlock` devono essere identici.  
  
 Se `Record`, o `FromRecord` e `ToRecord` viene omesso, il blocco sia per l'intero file. Se `Record` viene specificato solo il record singolo sia bloccato o sbloccato.  
  
 Se il file è stato aperto per input o output, sequenziale `Lock` e `Unlock` interessano l'intero file, indipendentemente dall'intervallo specificato da `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 In questo esempio viene illustrato l'utilizzo del `Lock` e `Unlock` funzioni. In questo esempio si presuppone che `People.txt` è un file che contiene i record della struttura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Espressione <see langword="Integer" /> contenente un numero di file valido.</param>
        <param name="Output">Facoltativo. Una o più espressioni con valori delimitati da virgole da scrivere in un file.</param>
        <summary>Scrive dati in un file sequenziale. I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Write` e `WriteLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separate da una virgola.  
  
 A differenza di `Print` funzione, il `Write` funzione inserisce virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell'elenco. Quando `Write` viene utilizzato per scrivere dati in un file, solo numerico, `Boolean`, data, null e `Error` sono supportati i formati di dati. Le seguenti convenzioni universali in modo che i dati possono sempre essere letti e interpretati correttamente mediante `Input`, indipendentemente dalle impostazioni locali:  
  
-   Dati numerici vengono sempre scritti utilizzando il punto come separatore decimale.  
  
-   Per `Boolean` dati, ovvero `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.  
  
-   Le date vengono scritte nel file utilizzando il formato di data universale. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.  
  
-   Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.  
  
-   Per `Error` dati, l'output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene tradotta, indipendentemente dalle impostazioni locali.  
  
 `WriteLine` Inserisce un carattere di nuova riga (vale a dire un ritorno a capo/avanzamento riga, o `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.  
  
 È possibile incorporare in una stringa tra virgolette con virgolette doppie, o "". Ad esempio,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.  
  
 La scrittura in un file mediante il `Write` o `WriteLine` funzioni richiede `Append` tramite il `FileIOPermissionAccess` enumerazione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">La modalità File non è valida.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obbligatorio. Espressione <see langword="Integer" /> contenente un numero di file valido.</param>
        <param name="Output">Facoltativo. Una o più espressioni con valori delimitati da virgole da scrivere in un file.</param>
        <summary>Scrive dati in un file sequenziale. I dati scritti con <see langword="Write" /> vengono in genere letti da un file usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Write` e `WriteLine` funzioni vengono fornite per la compatibilità con le versioni precedenti e può influire sulle prestazioni. Per le applicazioni non preesistenti di `My.Computer.FileSystem` oggetto offre prestazioni migliori. Per ulteriori informazioni, vedere [accesso ai File con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se si omette `Output`, una riga vuota viene stampata il file. Più espressioni possono essere separate da una virgola.  
  
 A differenza di `Print` funzione, il `Write` funzione inserisce virgole tra gli elementi e le stringhe tra virgolette quando vengono scritti nel file. Non è necessario inserire delimitatori espliciti nell'elenco. Quando `Write` viene utilizzato per scrivere dati in un file, solo numerico, `Boolean`, data, null e `Error` sono supportati i formati di dati. Le seguenti convenzioni universali in modo che i dati possono sempre essere letti e interpretati correttamente mediante `Input`, indipendentemente dalle impostazioni locali:  
  
-   Dati numerici vengono sempre scritti utilizzando il punto come separatore decimale.  
  
-   Per `Boolean` dati, ovvero `#TRUE#` o `#FALSE#` viene stampato. Il `True` e `False` parole chiave non vengono convertite, indipendentemente dalle impostazioni locali.  
  
-   Le date vengono scritte nel file utilizzando il formato di data universale. Quando la data o il componente della fase manca o è zero, solo la parte fornito viene scritto nel file.  
  
-   Se non verranno scritti nel file `Output` dati sono vuoti. Tuttavia, per i dati null, `#NULL#` viene scritto.  
  
-   Per `Error` dati, l'output viene visualizzato come `#ERROR errorcode#`. Il `Error` parola chiave non viene tradotta, indipendentemente dalle impostazioni locali.  
  
 `WriteLine` Inserisce un carattere di nuova riga (vale a dire un ritorno a capo/avanzamento riga, o `Chr(13) + Chr(10)`), dopo l'ultimo carattere scritto `Output` al file.  
  
 È possibile incorporare in una stringa tra virgolette con virgolette doppie, o "". Ad esempio,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Restituisce una stringa con il valore di `Double quotation marks aren't "difficult" to handle`.  
  
 La scrittura in un file mediante il `Write` o `WriteLine` funzioni richiede `Append` tramite il `FileIOPermissionAccess` enumerazione. Per altre informazioni, vedere <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Questo esempio viene utilizzato il `Write` funzione per scrivere i dati non elaborati in un file sequenziale.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>