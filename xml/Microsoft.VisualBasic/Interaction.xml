<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13d82136b10de43106c6355f53080123e65ade7d" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52734955" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il modulo <see langword="Interaction" /> contiene procedure che consentono di interagire con oggetti, applicazioni e sistemi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo modulo supporta le parole chiave del linguaggio Visual Basic e membri delle librerie di runtime che eseguono altri programmi, chiamare un metodo o proprietà, un segnale acustico dal computer, forniscono una stringa della riga di comando, modificano gli oggetti COM e controllano le finestre di dialogo.  
  
   
  
## Examples  
 L'esempio seguente usa il `Shell` funzione per eseguire un'applicazione specificata dall'utente. Specifica di <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> come secondo argomento apre l'applicazione di dimensioni normali e gli assegna lo stato attivo.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">Riepilogo delle informazioni e dell'interazione</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Parole chiave (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attiva un'applicazione che è già in esecuzione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" /> che specifica il numero di ID di processo Win32 assegnato al processo. È possibile utilizzare l'ID restituito dalla <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, purché sia diverso da zero.</param>
        <summary>Attiva un'applicazione che è già in esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utilizza `AppActivate` per rendere attivo finestra attiva di un'applicazione. Potrebbe non disporre di un handle o riferimento alla finestra attiva oppure addirittura conoscere quale finestra è attiva in un determinato momento. In tal caso, è possibile usare il <xref:System.Windows.Forms.Control.Focus%2A> (metodo).  
  
 Il `AppActivate` funzione Cambia lo stato attivo per l'applicazione denominata o una finestra, ma non influisce sulla viene ingrandita o ridotta a icona. Lo stato attivo esce dalla finestra dell'applicazione attivata quando l'utente esegue un'azione che modifica lo stato attivo o chiudere la finestra. È possibile usare il `Shell` (funzione) per avviare un'applicazione e impostare lo stile della finestra.  
  
 Se si usa la `Title` parametro, `AppActivate` utilizza un confronto tra maiuscole e minuscole, ma in caso contrario, richiede una corrispondenza esatta con il contenuto della barra del titolo. Innanzitutto esaminato tramite finestre di primo livello e quindi le finestre figlio. Se non viene trovata una corrispondenza, viene generata un' <xref:System.ArgumentException>.  
  
 È possibile usare `AppActivate` solo con processi dotati di windows. La maggior parte delle applicazioni console non si sono proprietari windows, il che significa che non sono visualizzate nell'elenco dei processi `AppActivate` ricerche. Durante l'esecuzione da un'applicazione console, il sistema crea un processo separato per eseguire l'applicazione e restituisce l'output al processo di console. Di conseguenza, quando si richiede l'ID del processo corrente, si ottiene l'ID del processo di questo processo separato, anziché l'ID del processo. dell'applicazione console  
  
 In fase di esecuzione, il `AppActivate` funzione attiva qualsiasi applicazione in esecuzione con un titolo che corrisponde al `Title` o con un ID di processo che corrisponde a `ProcessId`. Se non è presente alcuna corrispondenza esatta, viene attivato qualsiasi applicazione in cui la stringa title termina con `Title`. Se è presente più di un'applicazione denominata `Title`, il `AppActivate` funzione attiverà una per l'attivazione.  
  
> [!NOTE]
>  Il `AppActivate` funzione richiede `UIPermission` nel <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> livello, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 In questo esempio illustra i vari utilizzi del `AppActivate` funzione per attivare una finestra dell'applicazione. Se un processo Notepad non è in esecuzione, l'esempio genera un <xref:System.ArgumentException>. Il `Shell` procedura presuppone che le applicazioni siano nei percorsi specificati.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">Espressione <see langword="String" /> che specifica il titolo presente nella barra del titolo dell'applicazione che si desidera attivare. È possibile utilizzare il titolo assegnato all'applicazione all'avvio.</param>
        <summary>Attiva un'applicazione che è già in esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utilizza `AppActivate` per rendere attivo finestra attiva di un'applicazione. Potrebbe non disporre di un handle o riferimento alla finestra attiva oppure addirittura conoscere quale finestra è attiva in un determinato momento. In tal caso, è possibile usare il <xref:System.Windows.Forms.Control.Focus%2A> (metodo).  
  
 Il `AppActivate` funzione Cambia lo stato attivo per l'applicazione denominata o una finestra, ma non influisce sulla viene ingrandita o ridotta a icona. Lo stato attivo esce dalla finestra dell'applicazione attivata quando l'utente esegue un'azione che modifica lo stato attivo o chiudere la finestra. È possibile usare il `Shell` (funzione) per avviare un'applicazione e impostare lo stile della finestra.  
  
 Se si usa la `Title` parametro, `AppActivate` utilizza un confronto tra maiuscole e minuscole, ma in caso contrario, richiede una corrispondenza esatta con il contenuto della barra del titolo. Innanzitutto esaminato tramite finestre di primo livello e quindi le finestre figlio. Se non viene trovata una corrispondenza, viene generata un' <xref:System.ArgumentException>.  
  
 È possibile usare `AppActivate` solo con processi dotati di windows. La maggior parte delle applicazioni console non si sono proprietari windows, il che significa che non sono visualizzate nell'elenco dei processi `AppActivate` ricerche. Durante l'esecuzione da un'applicazione console, il sistema crea un processo separato per eseguire l'applicazione e restituisce l'output al processo di console. Di conseguenza, quando si richiede l'ID del processo corrente, si ottiene l'ID del processo di questo processo separato, anziché l'ID del processo. dell'applicazione console  
  
 In fase di esecuzione, il `AppActivate` funzione attiva qualsiasi applicazione in esecuzione con un titolo che corrisponde al `Title` o con un ID di processo che corrisponde a `ProcessId`. Se non è presente alcuna corrispondenza esatta, viene attivato qualsiasi applicazione in cui la stringa title termina con `Title`. Se è presente più di un'applicazione denominata `Title`, il `AppActivate` funzione attiverà una per l'attivazione.  
  
> [!NOTE]
>  Il `AppActivate` funzione richiede `UIPermission` nel <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> livello, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedi <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 In questo esempio illustra i vari utilizzi del `AppActivate` funzione per attivare una finestra dell'applicazione. Se un processo Notepad non è in esecuzione, l'esempio genera un <xref:System.ArgumentException>. Il `Shell` procedura presuppone che le applicazioni siano nei percorsi specificati.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emette un segnale acustico tramite l'altoparlante del computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Passo e la durata del segnale acustico dipendono l'hardware e software del sistema e pertanto variare tra computer.  
  
> [!NOTE]
>  Il `Beep` funzione richiede `UIPermission` nel <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> livello, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 In questo esempio viene utilizzata la funzione `Beep` per l'emissione di un segnale acustico tramite l'altoparlante del computer.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">Riproduzione di suoni</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Obbligatorio. <see langword="Object" />. Puntatore all'oggetto che espone la proprietà o il metodo.</param>
        <param name="ProcName">Obbligatorio. <see langword="String" />. Espressione stringa contenente il nome della proprietà o del metodo dell'oggetto.</param>
        <param name="UseCallType">Obbligatorio. Membro di enumerazione di tipo <see cref="T:Microsoft.VisualBasic.CallType" /> che rappresenta il tipo di routine chiamato. Il valore di <see langword="CallType" /> può essere <see langword="Method" />, <see langword="Get" /> o <see langword="Set" />.</param>
        <param name="Args">Facoltativo. <see langword="ParamArray" />. Matrice di parametri contenente gli argomenti da passare alla proprietà o al metodo da chiamare.</param>
        <summary>Esegue un metodo in un oggetto oppure imposta o restituisce una proprietà in un oggetto.</summary>
        <returns>Esegue un metodo in un oggetto oppure imposta o restituisce una proprietà in un oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `CallByName` funzione viene utilizzata in fase di esecuzione per ottenere una proprietà, impostare una proprietà o richiamare un metodo.  
  
   
  
## Examples  
 Nell'esempio seguente usa la prima riga `CallByName` per impostare il `Text` proprietà di una casella di testo, la seconda riga recupera il valore della `Text` proprietà e la terza riga richiama il `Move` metodo per spostare la casella di testo.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 L'esempio seguente usa il `CallByName` funzione da richiamare il `Add` e `Item` metodi dell'oggetto collection.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Valore <paramref name="UseCallType" /> non valido. Deve essere <see langword="Method" />, <see langword="Get" /> o <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Matrici di parametri</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">Chiamata di una proprietà o di un metodo mediante un nome di stringa</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Obbligatorio. <see langword="Double" />. Espressione numerica che restituisce un valore compreso tra 1 e il numero di elementi passati nell'argomento <paramref name="Choice" />.</param>
        <param name="Choice">Obbligatorio. Matrice di parametri <see langword="Object" />. È possibile fornire una sola variabile o un'espressione che restituisce il tipo di dati <see langword="Object" /> a un elenco di variabili <see langword="Object" /> o espressioni separate da virgole oppure a una matrice unidimensionale di elementi <see langword="Object" />.</param>
        <summary>Seleziona e restituisce un valore da un elenco di argomenti.</summary>
        <returns>Seleziona e restituisce un valore da un elenco di argomenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Choose` funzione restituisce un membro dell'elenco passato `Choice()`, a seconda del valore di `Index`. Il primo membro dell'elenco è selezionato quando `Index` è 1. L'ultimo membro dell'elenco è selezionato quando `Index` viene `UBound`(`Choice()`). Se `Index` questi limiti, non rientra `Choose` restituisce `Nothing`.  
  
 Se `Index` non è un numero intero, viene arrotondato al numero intero più vicino prima di essere valutato.  
  
 È possibile usare `Choose` per cercare un valore in un elenco di possibilità.  
  
> [!NOTE]
>  Le espressioni nell'elenco di argomenti possono includere le chiamate di funzione. Come parte della preparazione all'elenco di argomenti per la chiamata a `Choose`, il compilatore Visual Basic chiama ogni funzione in tutte le espressioni. Ciò significa che non è possibile utilizzare una particolare funzione non viene chiamata se viene selezionata un'espressione diversa da `Index`.  
  
   
  
## Examples  
 Questo esempio Usa la `Choose` funzione per visualizzare il nome in risposta a un indice passato alla routine nel `Ind` parametro.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Istruzione Select...Case (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la parte argomento della riga di comando utilizzata per avviare Visual Basic o un programma eseguibile sviluppato con Visual Basic. La funzionalità <see langword="My" /> garantisce maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="Command" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Restituisce la parte argomento della riga di comando utilizzata per avviare Visual Basic o un programma eseguibile sviluppato con Visual Basic.  
  
La funzionalità <see langword="My" /> garantisce maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="Command" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo che vengono restituiti gli argomenti, è possibile cercare i delimitatori comuni, ad esempio spazi, barre avanti o indietro, trattini o tra virgolette, per dividere o cercare la stringa per i singoli parametri.  
  
 Per le applicazioni sviluppate con Visual Basic e compilate in un file .exe, il `Command` funzione restituisce tutti gli argomenti visualizzati dopo il nome dell'applicazione nella riga di comando, in questo formato: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Questo esempio viene usato il `Command` funzione per restituire gli argomenti della riga di comando in un oggetto che contiene una matrice.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Compilatore della riga di comando di Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Struttura di un programma Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Obbligatorio. <see langword="String" />. ID di programma dell'oggetto da creare.</param>
        <param name="ServerName">Facoltativo. <see langword="String" />. Nome del server di rete in cui verrà creato l'oggetto. Se <paramref name="ServerName" /> è una stringa vuota (""), viene utilizzato il computer locale.</param>
        <summary>Crea e restituisce un riferimento a un oggetto COM. Non è possibile utilizzare <see langword="CreateObject" /> per creare istanze di classi in Visual Basic a meno che tali classi non vengano esposte in modo esplicito come componenti COM.</summary>
        <returns>Crea e restituisce un riferimento a un oggetto COM. Non è possibile utilizzare <see langword="CreateObject" /> per creare istanze di classi in Visual Basic a meno che tali classi non vengano esposte in modo esplicito come componenti COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare un'istanza di un componente COM, assegnare l'oggetto restituito da `CreateObject` a una variabile oggetto:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Il tipo della variabile dell'oggetto che viene usato per archiviare l'oggetto restituito può influire sulle prestazioni dell'applicazione. Se una variabile oggetto dichiarata con la `As Object` clausola consente di creare una variabile che può contenere un riferimento a qualsiasi tipo di oggetto. Tuttavia, l'accesso all'oggetto tramite tale variabile viene *tardiva*, vale a dire, l'associazione si verifica quando viene eseguito il programma. Esistono molti motivi che è consigliabile evitare di associazione tardiva, tra cui riduzione delle prestazioni dell'applicazione.  
  
 È possibile creare una variabile oggetto che determina l'associazione anticipata, associazione, ovvero quando il programma viene compilato. A tale scopo, aggiungere un riferimento alla libreria dei tipi per l'oggetto dal **COM** scheda della finestra di **Aggiungi riferimento** nella finestra di dialogo il **progetto** menu. Quindi dichiarare la variabile di oggetto del tipo specifico dell'oggetto. Nella maggior parte dei casi, è preferibile usare il `Dim` istruzione e un assembly di interoperabilità primario per creare oggetti piuttosto che utilizzare il `CreateObject` (funzione).  
  
## <a name="interacting-with-unmanaged-code"></a>L'interazione con codice non gestito  
 Un altro problema è che gli oggetti COM usano il codice non gestito, ovvero il codice senza il vantaggio di common language runtime. Non prevede un certo grado di complessità si unisce il codice gestito di Visual Basic con codice non gestito da COM. Quando si aggiunge un riferimento a un oggetto COM, Visual Basic cerca un assembly di interoperabilità primario (PIA) per tale libreria. Se ne trova uno, quindi la utilizza. Se non viene trovato un assembly di interoperabilità primario, viene creato un assembly di interoperabilità che contiene le classi di interoperabilità locali per ogni classe della libreria COM. Per altre informazioni, vedere [interoperabilità COM nelle applicazioni .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 È consigliabile utilizzare oggetti fortemente associati e gli assembly di interoperabilità primari, laddove possibile. Gli esempi seguenti usano il `CreateObject` solo a scopo di funzione con gli oggetti di Microsoft Office a scopo dimostrativo. Tuttavia, questi oggetti sono più affidabili se usato con assembly di interoperabilità primario appropriato e facile da usare.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Creazione di un oggetto in un Computer remoto  
 È possibile creare un oggetto in un computer remoto in rete, passando il nome del computer da cui il `ServerName` argomento del `CreateObject` (funzione). Tale nome è quello utilizzato per la parte nome computer di un nome di condivisione: per una condivisione denominata "\\\MyServer\Public," `ServerName` è "MyServer".  
  
> [!NOTE]
>  Fare riferimento alla documentazione di COM (vedere la Microsoft Developer Network) per altre informazioni su come rendere un'applicazione accessibile in un computer remoto in rete. Si potrebbe essere necessario aggiungere una chiave del Registro di sistema per l'applicazione.  
  
 Il codice seguente restituisce il numero di versione di un'istanza di Excel in esecuzione in un computer remoto denominato `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Se il nome del server remoto non è corretto o se non è disponibile, si verifica un errore di run-time.  
  
> [!NOTE]
>  Usare `CreateObject` quando è presente alcuna istanza dell'oggetto corrente. Se un'istanza dell'oggetto è già in esecuzione, viene avviata una nuova istanza e viene creato un oggetto del tipo specificato. Per usare l'istanza corrente, o per avviare l'applicazione e caricare un file, usare il `GetObject` (funzione). Se un oggetto è stato registrato come un oggetto a istanza singola, solo un'istanza dell'oggetto viene creata, indipendentemente da come numero di volte `CreateObject` viene eseguita.  
  
## <a name="creating-framework-objects"></a>Creazione di oggetti di .NET Framework  
 È possibile usare il `CreateObject` funzione solo per creare un oggetto COM. Anche se non esiste un meccanismo equivalente esatto per la creazione di un oggetto .NET Framework, il <xref:System.Activator> nella <xref:System> dello spazio dei nomi contiene metodi per creare oggetti locali o remoti. In particolare, il <xref:System.Activator.CreateInstance%2A> metodo o il <xref:System.Activator.CreateInstanceFrom%2A> può risultare utile.  
  
> [!IMPORTANT]
>  Il `CreateObject` funzione richiede l'autorizzazione di accesso al codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L'esempio seguente usa il `CreateObject` funzione per creare un foglio di lavoro di Microsoft Excel e Salva il foglio di lavoro in un file. Per usare questo esempio, è necessario che Excel sia installato nel computer in cui viene eseguito il programma. Inoltre, è necessario aggiungere un riferimento alla libreria dei tipi dal **COM** scheda della finestra del **Aggiungi riferimento** nella finestra di dialogo il **progetto** menu. Il nome della libreria dei tipi varia a seconda della versione di Excel sia installato nel computer. Ad esempio, la libreria dei tipi per Microsoft Excel 2002 è denominata **libreria di oggetti di Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Server non disponibile.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non esiste alcun oggetto del tipo specificato.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Istruzione Dim (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">Interoperabilità COM nelle applicazioni .NET Framework</related>
        <related type="Article" href="~/docs/framework/interop/index.md">Interoperabilità con codice non gestito</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'applicazione o del progetto a cui fa riferimento la sezione o l'impostazione di chiave.</param>
        <param name="Section">Obbligatorio. Espressione <see langword="String" /> contenente il nome della sezione da cui si desidera eliminare l'impostazione di chiave. Se vengono specificati solo <paramref name="AppName" /> e <paramref name="Section" />, la sezione specificata viene eliminata insieme a tutte le impostazioni di chiave correlate.</param>
        <param name="Key">Facoltativo. Espressione <see langword="String" /> contenente il nome dell'impostazione di chiave da eliminare.</param>
        <summary>Elimina una sezione o un'impostazione di chiave dalla voce di un'applicazione nel Registro di sistema di Windows. Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="DeleteSetting" />. Per ulteriori informazioni, vedi <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se vengono forniti tutti gli argomenti, viene eliminato l'impostazione specificata. Si verifica un errore di runtime se si prova a usare `DeleteSetting` su una sezione non esistente o un'impostazione della chiave.  
  
 `DeleteSetting` richiede che un utente di essere eseguito l'accesso, perché opera il `HKEY_LOCAL_USER` chiave del Registro di sistema, che non è attivo fino a quando un utente accede in modo interattivo.  
  
 Le impostazioni del Registro di sistema che devono essere accessibili da un processo interattivo (ad esempio Mtx.exe) devono essere archiviate in presenza di una di `HKEY_LOCAL_MACHINE\Software\` o il `HKEY_USER\DEFAULT\Software` le chiavi del Registro di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente usa in primo luogo il `SaveSetting` procedure per semplificare le voci del Registro di sistema di Windows per il `MyApp` dell'applicazione e quindi Usa il `DeleteSetting` funzione per rimuoverli. Poiché nessun `Key` argomento è specificato, l'intero `Startup` sezione viene eliminata, incluso il nome della sezione e tutte le relative chiavi.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'utente non è connesso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce la stringa associata alla variabile di ambiente del sistema operativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Obbligatorio. Espressione che valuta una stringa contenente il nome di una variabile di ambiente oppure un intero corrispondente all'ordine numerico di una stringa di ambiente nella tabella della stringhe di ambiente.</param>
        <summary>Restituisce la stringa associata alla variabile di ambiente del sistema operativo.</summary>
        <returns>Restituisce la stringa associata alla variabile di ambiente del sistema operativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Expression` contiene una stringa, il <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione restituisce il testo assegnato alla stringa di ambiente specificate, vale a dire, il testo che segue il segno di uguale (=) nella tabella di stringhe di ambiente per tale variabile di ambiente. Se la stringa in `Expression` non è stata trovata nella tabella della stringa di ambiente, una stringa di lunghezza zero ("") viene restituito.  
  
 Se `Expression` contiene un numero intero, la stringa che occupa la posizione numerica nella tabella di stringhe di ambiente viene restituita. In questo caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> restituisce tutto il testo, incluso il nome della variabile di ambiente. Se viene individuata alcuna stringa di ambiente nella posizione specificata, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> restituisce una stringa di lunghezza zero.  
  
> [!IMPORTANT]
>  Il <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione richiede l'autorizzazione per l'ambiente, che possono influire sulla sua esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio Usa la <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione per specificare il numero di voce e la lunghezza del `PATH` istruzione dalla tabella di stringhe di ambiente.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> mancante.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Obbligatorio. Espressione che valuta una stringa contenente il nome di una variabile di ambiente oppure un intero corrispondente all'ordine numerico di una stringa di ambiente nella tabella della stringhe di ambiente.</param>
        <summary>Restituisce la stringa associata alla variabile di ambiente del sistema operativo.</summary>
        <returns>Restituisce la stringa associata alla variabile di ambiente del sistema operativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Expression` contiene una stringa, il <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione restituisce il testo assegnato alla stringa di ambiente specificate, vale a dire, il testo che segue il segno di uguale (=) nella tabella di stringhe di ambiente per tale variabile di ambiente. Se la stringa in `Expression` non è stata trovata nella tabella della stringa di ambiente, una stringa di lunghezza zero ("") viene restituito.  
  
 Se `Expression` contiene un numero intero, la stringa che occupa la posizione numerica nella tabella di stringhe di ambiente viene restituita. In questo caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> restituisce tutto il testo, incluso il nome della variabile di ambiente. Se viene individuata alcuna stringa di ambiente nella posizione specificata, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> restituisce una stringa di lunghezza zero.  
  
> [!IMPORTANT]
>  Il <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione richiede l'autorizzazione per l'ambiente, che possono influire sulla sua esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Questo esempio Usa la <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funzione per specificare il numero di voce e la lunghezza del `PATH` istruzione dalla tabella di stringhe di ambiente.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> mancante.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membri della libreria Run-Time Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'applicazione o del progetto di cui si richiedono le impostazioni di chiave.</param>
        <param name="Section">Obbligatorio. Espressione <see langword="String" /> contenente il nome della sezione di cui si richiedono le impostazioni di chiave. <see langword="GetAllSettings" /> restituisce un oggetto contenente una matrice di stringhe bidimensionale. Le stringhe contengono tutte le impostazioni di chiave della sezione specificata, più i valori corrispondenti.</param>
        <summary>Restituisce un elenco di impostazioni di chiavi e dei rispettivi valori (originariamente creati con <see langword="SaveSetting" />) dalla voce di un'applicazione nel Registro di sistema di Windows. Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="GetAllSettings" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Restituisce un elenco di impostazioni di chiavi e dei rispettivi valori (originariamente creati con <see langword="SaveSetting" />) dalla voce di un'applicazione nel Registro di sistema di Windows.  
  
Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="GetAllSettings" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Restituisce un valore non inizializzato `Object` se uno dei due `AppName` o `Section` non esiste.  
  
 Dal momento che opera la `HKEY_LOCAL_USER` chiave del Registro di sistema, che non è attivo fino a quando un utente accede in modo interattivo, `GetAllSettings` richiede che un utente di essere connesso.  
  
 Le impostazioni del Registro di sistema che devono essere accessibili da un processo interattivo (ad esempio Mtx.exe) devono essere archiviate in presenza di una di `HKEY_LOCAL_MACHINE\Software\` o il `HKEY_USER\DEFAULT\Software` le chiavi del Registro di sistema.  
  
   
  
## Examples  
 In questo esempio utilizza in primo luogo il `SaveSetting` funzione per rendere le voci del Registro di sistema di Windows per l'applicazione specificata come `AppName`, quindi Usa il `GetAllSettings` funzione per visualizzare le impostazioni. Prendere nota di tale applicazione nomi e `Section` i nomi non possono essere recuperati con `GetAllSettings`. Infine, il `DeleteSetting` funzione rimuove le voci dell'applicazione.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'utente non è connesso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lettura e scrittura nel Registro di sistema (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Facoltativo. <see langword="String" />. Percorso completo e nome del file contenente l'oggetto da recuperare. Se <paramref name="PathName" /> viene omesso, è necessario <paramref name="Class" />.</param>
        <param name="Class">Obbligatorio se non viene specificato <paramref name="PathName" />. <see langword="String" />. Stringa che rappresenta la classe dell'oggetto. Di seguito sono descritti la sintassi e le parti dell'argomento <paramref name="Class" />: 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
Parametro [1|1] 
Descrizione [1|2] 
[2|1] <c>appname</c>  
  
[2|2] richiesta. <see langword="String" />. Nome dell'applicazione che fornisce l'oggetto.  
  
[3|1] <c>objecttype</c>  
  
[3|2] richiesta. <see langword="String" />. Tipo o classe dell'oggetto da creare.</param>
        <summary>Restituisce un riferimento a un oggetto fornito da un componente COM.</summary>
        <returns>Restituisce un riferimento a un oggetto fornito da un componente COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il `GetObject` funzione per caricare un'istanza di un componente COM da un file. Questa condizione è illustrata nell'esempio seguente.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Quando si esegue questo codice, l'applicazione associata all'oggetto specificato `PathName` viene avviato e viene attivato l'oggetto nel file specificato.  
  
## <a name="default-cases"></a>Caso predefinito  
 Se `PathName` è una stringa di lunghezza zero (`""`), `GetObject` restituisce una nuova istanza dell'oggetto del tipo di classe specificato. Se il `PathName` viene omesso, `GetObject` restituisce un oggetto attivo del tipo di classe specificato nel `Class`. Se non esiste alcun oggetto del tipo specificato, si verifica un errore.  
  
## <a name="accessing-a-subobject"></a>L'accesso a un oggetto secondario  
 Alcune applicazioni consentono di attivare un oggetto secondario associato a un file. A questo scopo, aggiungere un punto esclamativo (`!`) alla fine del nome file e seguire con una stringa che identifica la parte del file si desidera attivare. Per informazioni su come creare questa stringa, vedere la documentazione per l'applicazione che ha creato l'oggetto.  
  
 In un'applicazione di disegno, ad esempio, potrebbe essere più livelli a un disegno archiviati in un file. È possibile usare il codice seguente per attivare un livello all'interno di un disegno denominato `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Specifica una classe  
 Se non si specifica l'oggetto `Class`, automazione determina l'applicazione da avviare e l'oggetto da attivare, in base al nome di file è fornire. Alcuni file, tuttavia, possono supportare più di una classe dell'oggetto. Ad esempio, un disegno potrebbe supportare tre tipi diversi di oggetti: un `Application` oggetti, una `Drawing` oggetto e un `Toolbar` oggetto, che fanno parte dello stesso file. Per specificare l'oggetto in un file a cui si desidera attivare, usare l'opzione facoltativa `Class` argomento. Questa condizione è illustrata nell'esempio seguente.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 Nell'esempio precedente, `Figment` è il nome di un'applicazione di disegno e `Drawing` è uno dei tipi di oggetto supportati.  
  
## <a name="using-the-object"></a>Utilizzando l'oggetto  
 Una volta che viene attivato un oggetto, farvi riferimento nel codice utilizzando la variabile oggetto dichiarata. Nell'esempio precedente, accedere alle proprietà e metodi del nuovo oggetto usando la variabile oggetto `drawObj`. Questa condizione è illustrata nell'esempio seguente.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Usare il `GetObject` utilizzata quando è presente un'istanza dell'oggetto corrente o se si desidera creare l'oggetto con un file caricato. Se non è presente alcuna istanza corrente, e non si desidera avviare l'oggetto con un file caricato, usare il <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> (funzione).  
>   
>  Se un oggetto viene registrato come oggetto ActiveX a istanza singola, solo un'istanza dell'oggetto viene creata, indipendentemente da come numero di volte `CreateObject` viene chiamato. Con un oggetto, a istanza singola `GetObject` restituisce sempre la stessa istanza quando viene chiamata con la stringa di lunghezza zero (`""`) la sintassi e causa un errore se il `PathName` viene omesso. Non è possibile usare `GetObject` per ottenere un riferimento a una classe creata con Visual Basic.  
  
> [!IMPORTANT]
>  Il `GetObject` funzione richiede l'autorizzazione di accesso al codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L'esempio seguente usa il `GetObject` funzione per ottenere un riferimento a un foglio di lavoro specifico di Microsoft Excel (`excelObj`). Usa il foglio di lavoro `Application` proprietà per rendere visibili, chiuderlo e per eseguire altre azioni di Excel. Con due chiamate all'API, il `detectExcel` procedure cerca Excel e, se è in esecuzione, lo inserisce nella tabella degli oggetti in esecuzione. La prima chiamata a `GetObject` provoca un errore se Excel non è già in esecuzione, che in questo esempio fa sì che il `excelWasNotRunning` flag verrà impostato su `True`. La seconda chiamata a `GetObject` specifica un file da aprire. Se Excel non è già in esecuzione, la seconda chiamata viene avviata e restituisce un riferimento al foglio di lavoro rappresentato dal file specificato, `test.xls`. Il file deve trovarsi nella posizione specificata. in caso contrario, Visual Basic genera un <xref:System.IO.FileNotFoundException>. Successivamente, nell'esempio di codice rende sia Excel e la finestra che contiene il foglio di lavoro specificato.  
  
 Questo esempio si presuppone `Option Strict Off` perché Usa l'associazione tardiva, in cui gli oggetti vengono assegnati alle variabili di tipo `Object`. È possibile specificare `Option Strict On` e dichiarare gli oggetti di tipi di oggetto specifico, se si aggiunge un riferimento alla libreria dei tipi di Excel dal **COM** scheda della finestra di **Aggiungi riferimento** della finestra di dialogo il  **Progetto** menu di Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Quando si chiama il `getExcel` funzione, viene effettuato un controllo per vedere se è già in esecuzione Excel. In caso contrario, viene creata un'istanza.  
  
> [!IMPORTANT]
>  Per semplicità, nell'esempio precedente si presuppone che qualsiasi finestra denominata `XLMAIN` appartiene a un'istanza di Microsoft Excel. Se un altro oggetto, possibilmente avviato tramite una manomissione, ha creato una finestra con lo stesso nome, riceverebbe tutti i messaggi destinati a Excel. In un'applicazione da utilizzare per la produzione, è necessario includere più rigorosi per verificare che `XLMAIN` appartenga davvero in Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Non esiste alcun oggetto con il tipo di classe specificato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non esiste alcun oggetto con il percorso e il nome di file specificati.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'applicazione o del progetto di cui si richiede l'impostazione di chiave.</param>
        <param name="Section">Obbligatorio. Espressione <see langword="String" /> contenente il nome della sezione in cui si trova l'impostazione di chiave.</param>
        <param name="Key">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'impostazione di chiave da restituire.</param>
        <param name="Default">Facoltativo. Espressione contenente il valore da restituire se nessun valore è impostato nell'impostazione di <paramref name="Key" />. Se omesso, si presuppone che <paramref name="Default" /> sia una stringa di lunghezza zero ("").</param>
        <summary>Restituisce il valore di un'impostazione di chiave dalla voce di un'applicazione nel Registro di sistema di Windows. Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="GetAllSettings" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Restituisce il valore di un'impostazione di chiave dalla voce di un'applicazione nel Registro di sistema di Windows.  
  
Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se gli elementi denominati nel `GetSetting` non esistono argomenti, `GetSetting` restituisce un valore di `Default`.  
  
 Dal momento che opera la `HKEY_LOCAL_USER` chiave del Registro di sistema, che non è attivo fino a quando un utente accede in modo interattivo, `GetSetting` richiede che un utente di essere connesso.  
  
 Le impostazioni del Registro di sistema che devono essere accessibili da un processo interattivo (ad esempio Mtx.exe) devono essere archiviate in presenza di una di `HKEY_LOCAL_MACHINE\Software\` o il `HKEY_USER\DEFAULT\Software` le chiavi del Registro di sistema.  
  
 `GetSetting` è necessario `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 In questo esempio utilizza in primo luogo il `SaveSetting` funzione per rendere le voci del Registro di sistema di Windows per l'applicazione specificata come `AppName`e quindi Usa il `GetSetting` funzione per visualizzare una delle impostazioni. Poiché il `Default` argomento specificato, è certo che un valore da restituire. Si noti che `Section` i nomi non possono essere recuperati con `GetSetting`. Infine, il `DeleteSetting` funzione rimuove tutte le voci dell'applicazione.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o più argomenti non sono espressioni <see langword="String" /> oppure l'utente non è connesso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lettura e scrittura nel Registro di sistema (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Obbligatorio. <see langword="Boolean" />. Espressione che si desidera valutare.</param>
        <param name="TruePart">Obbligatorio. <see langword="Object" />. Restituito se <paramref name="Expression" /> è <see langword="True" />.</param>
        <param name="FalsePart">Obbligatorio. <see langword="Object" />. Restituito se <paramref name="Expression" /> è <see langword="False" />.</param>
        <summary>Restituisce uno di due oggetti, a seconda della valutazione di un'espressione.</summary>
        <returns>Restituisce uno di due oggetti, a seconda della valutazione di un'espressione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `IIf` funzione fornisce un equivalente di ternary [operatore condizionale:?:](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) in Visual C++.  
  
   
  
## Examples  
 Questo esempio Usa la `IIf` funzione da valutare il `testMe` parametro del `checkIt` e restituisce parole "Grande" se la quantità è maggiore di 1000; in caso contrario, restituisce la parola "Small".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Si noti che se `Option Strict` viene `On`, è necessario utilizzare il `CStr` parola chiave da convertire in modo esplicito il valore restituito da `Object` a `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">CString</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">Istruzione If...Then...Else (Visual Basic) |</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Istruzione Select...Case (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Obbligatorio. Espressione <see langword="String" /> visualizzata come messaggio nella finestra di dialogo. La lunghezza massima di <paramref name="Prompt" /> è di circa 1024 caratteri, a seconda della larghezza dei caratteri utilizzati. Se <paramref name="Prompt" /> è costituito da più di una riga, è possibile separare le righe usando un carattere di ritorno a capo (<see langword="Chr(" />13<see langword=")" />), un carattere di avanzamento riga (<see langword="Chr(" />10<see langword=")" />) o una combinazione di ritorno a capo e avanzamento riga (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) tra ogni riga.</param>
        <param name="Title">Facoltativo. Espressione <see langword="String" /> visualizzata nella barra del titolo della finestra di dialogo. Se si omette <paramref name="Title" />, nella barra del titolo viene visualizzato il nome dell'applicazione.</param>
        <param name="DefaultResponse">Facoltativo. Espressione <see langword="String" /> visualizzata nella casella di testo come risposta predefinita se non viene specificato altro input. Se si omette <paramref name="DefaultResponse" />, la casella di testo visualizzata è vuota.</param>
        <param name="XPos">Facoltativo. Espressione numerica che specifica, in twip, la distanza del bordo sinistro della finestra di dialogo dal bordo sinistro dello schermo. Se si omette <paramref name="XPos" />, la finestra di dialogo viene centrata in senso orizzontale.</param>
        <param name="YPos">Facoltativo. Espressione numerica che specifica, in twip, la distanza del bordo superiore della finestra di dialogo dal bordo superiore dello schermo. Se si omette <paramref name="YPos" />, la finestra di dialogo viene collocata a circa un terzo dello schermo in senso verticale partendo dall'alto.</param>
        <summary>Visualizza una richiesta in una finestra di dialogo, attende che l'utente immetta il testo o faccia clic su un pulsante, quindi restituisce una stringa con il contenuto della casella di testo.</summary>
        <returns>Visualizza una richiesta in una finestra di dialogo, attende che l'utente immetta il testo o faccia clic su un pulsante, quindi restituisce una stringa con il contenuto della casella di testo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'utente sceglie **annullare**, viene restituita una stringa di lunghezza zero.  
  
 Per specificare più il primo argomento, è necessario usare il `InputBox` funzione in un'espressione. Se si omette un argomento di posizione, è necessario conservare la virgola di delimitazione corrispondente.  
  
> [!NOTE]
>  Il `InputBox` funzione richiede `UIPermission` nel <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> livello, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere e <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 In questo esempio illustra vari modi per usare il `InputBox` funzione per richiedere all'utente di immettere un valore. Se gli assi x e y vengono omesse le posizioni, la finestra di dialogo viene centrata automaticamente per i rispettivi assi. La variabile `MyValue` contiene il valore immesso dall'utente se l'utente fa clic su OK o preme il tasto INVIO.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Obbligatorio. Espressione <see langword="String" /> visualizzata come messaggio nella finestra di dialogo. La lunghezza massima di <paramref name="Prompt" /> è di circa 1024 caratteri, a seconda della larghezza dei caratteri utilizzati. Se <paramref name="Prompt" /> è costituito da più di una riga, è possibile separare le righe usando un carattere di ritorno a capo (<see langword="Chr(" />13<see langword=")" />), un carattere di avanzamento riga (<see langword="Chr(" />10<see langword=")" />) o una combinazione dei caratteri di ritorno a capo e avanzamento riga (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) tra ogni riga.</param>
        <param name="Buttons">Facoltativo. Espressione numerica che rappresenta la somma dei valori che specificano il numero e il tipo dei pulsanti da visualizzare, lo stile di icona da utilizzare, l'identità del pulsante predefinito e la modalità della finestra di messaggio. Se si omette <paramref name="Buttons" />, il valore predefinito è zero.</param>
        <param name="Title">Facoltativo. Espressione <see langword="String" /> visualizzata nella barra del titolo della finestra di dialogo. Se si omette <paramref name="Title" />, nella barra del titolo viene visualizzato il nome dell'applicazione.</param>
        <summary>Visualizza un messaggio in una finestra di dialogo, attende che l'utente faccia clic su un pulsante, quindi restituisce un intero che indica il pulsante scelto dall'utente.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Costante 
 </term>
              <description> Valore 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si omette un argomento di posizione, è necessario conservare la virgola di delimitazione corrispondente.  
  
 Se la finestra di dialogo consente di visualizzare una **annullare** pulsante, premendo il tasto ESC ha lo stesso effetto della selezione di **Annulla**  
  
 Se la finestra di dialogo contiene un **aiutare** pulsante, Guida sensibile al contesto viene fornita per la finestra di dialogo. Tuttavia, fino a quando non viene scelto uno degli altri pulsanti, non viene restituito alcun valore. Nelle applicazioni Windows Form, scegliendo la **aiutare** pulsante esegue la <xref:System.Windows.Forms.Control.HelpRequested> evento per il form.  
  
> [!NOTE]
>  Il `MsgBox` funzione richiede `UIPermission` nel <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> livello, che può influire sull'esecuzione in situazioni di attendibilità parziale. Per ulteriori informazioni, vedere <xref:System.Security.Permissions.UIPermission>.  
  
 Il `MsgBoxStyle` nella tabella seguente sono elencati i valori di enumerazione.  
  
|Member|Valore|Descrizione|  
|-|-|-|  
|Member|Valore|Descrizione|  
|`OKOnly`|0|Solo pulsante Visualizza OK.|  
|`OKCancel`|1|Consente di visualizzare OK e Cancel pulsanti.|  
|`AbortRetryIgnore`|2|Visualizza i pulsanti Interrompi, Riprova e Ignora.|  
|`YesNoCancel`|3|Viene visualizzato Sì, No e Annulla i pulsanti.|  
|`YesNo`|4|Non visualizza i pulsanti Sì e.|  
|`RetryCancel`|5|Visualizza i pulsanti Riprova e Annulla.|  
|`Critical`|16|Visualizza l'icona di messaggio critico.|  
|`Question`|32|Visualizza l'icona di Query di avviso.|  
|`Exclamation`|48|Visualizza l'icona di messaggio di avviso.|  
|`Information`|64|Visualizza l'icona di messaggio informativo.|  
|`DefaultButton1`|0|Il primo pulsante è quello predefinito.|  
|`DefaultButton2`|256|Il secondo pulsante è quello predefinito.|  
|`DefaultButton3`|512|Il terzo pulsante è quello predefinito.|  
|`ApplicationModal`|0|L'applicazione è modale. L'utente deve rispondere al database MessageBox prima di continuare a utilizzare l'applicazione corrente.|  
|`SystemModal`|4096|Il sistema è modale. Tutte le applicazioni vengono sospesi fino a quando l'utente risponde al database MessageBox.|  
|`MsgBoxSetForeground`|65536|Specifica la finestra di messaggio come la finestra di primo piano.|  
|`MsgBoxRight`|524288|Il testo è allineato a destra.|  
|`MsgBoxRtlReading`|1048576|Specifica testo dovrebbe essere visualizzato come destra a sinistra la lettura nei sistemi ebraico e arabo.|  
  
 Il primo gruppo di valori (da 0 a 5) descrive il numero e tipo dei pulsanti visualizzati nella finestra di dialogo. Il secondo gruppo (16, 32, 48, 64) descrive lo stile di icona. Il terzo gruppo (0, 256, 512) determina quale pulsante è quello predefinito. Il quarto gruppo (0, 4096) determina la modalità della finestra di messaggio e il quinto gruppo consente di specificare se la finestra di messaggio è la finestra di primo piano, nonché l'allineamento e la direzione del testo. Quando si sommano i numeri per creare un valore finale per il `Buttons` argomento, usare solo un numero di ogni gruppo.  
  
   
  
## Examples  
 Questo esempio viene usato il `MsgBox` funzione per visualizzare un messaggio di errore critico nella finestra di dialogo con i pulsanti Sì e No. Pulsante No viene specificato come la risposta predefinita. Questa operazione viene eseguita dalla combinazione di `MsgBox` valori costanti in un'espressione numerica. In questo caso, l'aggiunta di 4 (la combinazione di pulsanti Sì/No) a 16 (il **messaggio critico** finestra) e 256 (il secondo pulsante come pulsante predefinito) produce un totale di 276. Il valore restituito dal `MsgBox` funzione dipende dal pulsante scelto dall'utente: Sì restituisce un valore pari a 6; Non restituisce un valore pari a 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> non è un'espressione <see langword="String" /> oppure <paramref name="Title" /> non è valido.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo non viene eseguito in modo interattivo con l'utente.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Uno o più parametri non sono membri dell'enumerazione <see langword="MsgBoxResult" /> o <see langword="MsgBoxStyle" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Obbligatorio. <see langword="Long" />. Numero intero che si desidera individuare in uno degli intervalli calcolati.</param>
        <param name="Start">Obbligatorio. <see langword="Long" />. Numero intero che indica l'inizio del set di intervalli calcolati. <paramref name="Start" /> non può essere minore di 0.</param>
        <param name="Stop">Obbligatorio. <see langword="Long" />. Numero intero che indica la fine del set di intervalli calcolati. <paramref name="Stop" /> non può essere minore o uguale a <paramref name="Start" />.</param>
        <param name="Interval">Obbligatorio. <see langword="Long" />. Numero intero che indica le dimensioni di ogni intervallo calcolato tra i parametri <paramref name="Start" /> e <paramref name="Stop" />. <paramref name="Interval" /> non può essere minore di 1.</param>
        <summary>Restituisce una stringa che rappresenta l'intervallo calcolato che contiene un numero.</summary>
        <returns>Restituisce una stringa che rappresenta l'intervallo calcolato che contiene un numero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Partition` funzione calcola un set di intervalli numerici, ognuno dei quali contiene il numero di valori specificati da `Interval`. Il primo intervallo inizia `Start`, e l'ultimo intervallo termina `Stop`. Il `Partition` funzione identifica quindi l'intervallo contiene `Number` e restituisce una stringa che descrive tale intervallo. L'intervallo è rappresentato nella stringa come "*lowervalue*:*uppervalue*", dove l'estremità inferiore dell'intervallo (*lowervalue*) è separato dalla parte superiore ( *uppervalue*) da due punti (:).  
  
 Se necessario, il `Partition` funzione inserisce gli spazi iniziali prima *lowervalue* e *uppervalue* in modo che abbiano lo stesso numero di caratteri della rappresentazione di stringa del valore ( `Stop` + 1). Ciò garantisce che se si usa l'output del `Partition` funzione con valori diversi di `Number`, il testo risultante verrà gestito correttamente durante qualsiasi operazione di ordinamento successiva.  
  
 Nella tabella seguente vengono illustrate alcune stringhe di esempio per calcolato utilizzando tre set di intervalli di indirizzi `Start`, `Stop`, e `Interval`. Le colonne "Ultimo intervallo" e "Primo intervallo" mostrano gli intervalli minimo e massimo possibili in base ai valori della `Start` e `Stop`. Il "prima del primo intervallo" e "dopo l'ultimo intervallo" colonne contengono le stringhe restituite per i valori della `Number` minore `Start` e maggiore `Stop`, rispettivamente.  
  
|`Start`|`Stop`|`Interval`|Prima del primo intervallo|Primo intervallo|Ultimo intervallo|Dopo l'ultimo intervallo|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"  0:  4"|" 95: 99"|"100:   "|  
|20|199|10|"   : 19"|" 20: 29"|"190:199"|"200:   "|  
|100|1010|20|"    : 99"|" 100: 119"|"1000:1010"|"1011:    "|  
  
 Nella tabella precedente, la terza riga contiene il risultato quando `Start` e `Stop` definiscono un set di numeri che non possono essere diviso in modo uniforme per `Interval`. L'ultimo intervallo termina `Stop`, rendendolo 11 solo numeri, anche se `Interval` è 20.  
  
 Se `Interval` è 1, l'intervallo è "`Number`:`Number`", indipendentemente dal `Start` e `Stop` argomenti. Ad esempio, se `Number` è, 267 `Stop` è 1000, e `Interval` è 1, `Partition` restituisce "267: 267".  
  
 `Partition` può essere utile quando si creano query di database. È possibile creare una query SELECT che mostra il numero di ordini si verifica all'interno di intervalli di valori diversi, ad esempio con valori di fattura da 1 a 1000, 1001 a 2000 e così via.  
  
   
  
## Examples  
 Nell'esempio seguente imposta una serie di intervalli da decenni dal 1950 2049. Individua il valore di `year` all'interno dell'intervallo appropriato e restituisce un `String` valore che indica l'intervallo. Se `year` ha un valore di 1984, ad esempio, `Partition` restituisce "1980: 1989".  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" />, o <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'applicazione o del progetto a cui si applica l'impostazione.</param>
        <param name="Section">Obbligatorio. Espressione <see langword="String" /> contenente il nome della sezione in cui viene salvata l'impostazione di chiave.</param>
        <param name="Key">Obbligatorio. Espressione <see langword="String" /> contenente il nome dell'impostazione di chiave da salvare.</param>
        <param name="Setting">Obbligatorio. Espressione contenente il valore su cui viene impostato <paramref name="Key" />.</param>
        <summary>Salva o crea una voce di applicazione nel Registro di sistema di Windows. Per quanto riguarda le operazioni nel Registro di sistema, la funzionalità <see langword="My" /> garantisce una maggiore produttività e prestazioni migliori rispetto alla funzione <see langword="SaveSetting" />. Per ulteriori informazioni, vedere <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `SaveSetting` funzione aggiunge la chiave da `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Se l'impostazione della chiave non può essere salvato per qualsiasi motivo, si verifica un errore.  
  
 `SaveSetting` richiede che un utente di essere eseguito l'accesso, perché opera il `HKEY_LOCAL_USER` chiave del Registro di sistema, che non è attivo fino a quando un utente accede in modo interattivo.  
  
 Le impostazioni del Registro di sistema che devono essere accessibili da un processo interattivo (ad esempio Mtx.exe) devono essere archiviate in presenza di una di `HKEY_LOCAL_MACHINE\Software\` o il `HKEY_USER\DEFAULT\Software` le chiavi del Registro di sistema.  
  
 `SaveSetting` è necessario `Write` e `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Nell'esempio seguente usa in primo luogo il `SaveSetting` funzione per rendere le voci del Registro di sistema di Windows per il `MyApp` dell'applicazione e quindi Usa il `DeleteSetting` funzione per rimuoverli.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è stato possibile creare la chiave del Registro di sistema, oppure l'utente non è connesso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lettura e scrittura nel Registro di sistema (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (Pathname, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" />
      </Parameters>
      <Docs>
        <param name="PathName">Obbligatorio. <see langword="String" />. Nome del programma da eseguire, insieme a eventuali argomenti e opzioni della riga di comando necessari. L'oggetto <paramref name="PathName" /> può includere anche l'unità e il percorso della directory o la cartella.  
  
Se non si conosce il percorso del programma, è possibile utilizzare il <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> per trovarlo. Ad esempio, è possibile chiamare <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, che restituisce il percorso completo di ogni file denominato <c>testFile.txt</c> in un punto qualsiasi sull'unità C:\\.</param>
        <param name="Pathname">To be added.</param>
        <param name="Style">Facoltativo. <see langword="AppWinStyle" />. Valore scelto da <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> che specifica lo stile della finestra in cui deve essere eseguito il programma. Se <paramref name="Style" /> viene omesso, <see langword="Shell" /> utilizza <see langword="AppWinStyle.MinimizedFocus" />, che avvia il programma nella finestra ridotta a icona e con lo stato attivo.</param>
        <param name="Wait">Facoltativo. <see langword="Boolean" />. Valore indicante se la funzione <see langword="Shell" /> deve attendere il completamento del programma. Se <paramref name="Wait" /> viene omesso, <see langword="Shell" /> utilizza <see langword="False" />.</param>
        <param name="Timeout">Facoltativo. <see langword="Integer" />. Numero di millisecondi di attesa del completamento se <paramref name="Wait" /> è <see langword="True" />. Se <paramref name="Timeout" /> viene omesso, <see langword="Shell" /> utilizza -1, che significa che non vi è alcun timeout e <see langword="Shell" /> non termina finché il programma non finisce. Se, pertanto, si omette <paramref name="Timeout" /> o lo si imposta su -1, è possibile che <see langword="Shell" /> non restituisca mai il controllo al programma.</param>
        <summary>Esegue un programma eseguibile e restituisce un intero contenente l'ID di processo del programma, se è ancora in esecuzione.</summary>
        <returns>Esegue un programma eseguibile e restituisce un intero contenente l'ID di processo del programma, se è ancora in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito di `Shell` (funzione) dipende dal fatto che il programma denominato `PathName` è ancora in esecuzione quando `Shell` restituisce. Se si imposta `Wait` al `True` e il programma termina prima della scadenza del timeout, `Shell` restituisce zero. Se il timeout scade o se si omette `Wait` oppure impostare `False`, `Shell` restituisce l'ID del processo del programma. L'ID del processo è un numero univoco che identifica il programma in esecuzione.  
  
## <a name="failure-to-start"></a>Errore di avvio  
 Se il `Shell` funzione non è possibile avviare il programma specificato, un <xref:System.IO.FileNotFoundException> errore si verifica. Questa situazione può verificarsi, ad esempio, quando si prova a eseguire un programma di 16 bit, ad esempio `command.com`, da un'applicazione che usa <xref:System.Windows.Forms?displayProperty=nameWithType>. Per risolvere il problema, è possibile eseguire un programma a 32 bit che chiama il programma desiderato a 16 bit. Nel caso del `command.com`, è possibile eseguire `cmd.exe` alternativa.  
  
## <a name="waiting-for-completion"></a>In attesa del completamento  
 Per impostazione predefinita, il `Shell` funzione esegue il programma in modo asincrono. Ciò significa che un programma avviato con il `Shell` funzione potrebbe non terminare prima che le istruzioni che seguono il `Shell` funzione viene eseguita. Se si vuole attendere per il programma da completare prima di continuare, impostare `Wait` a `True`.  
  
## <a name="determining-the-exit-code"></a>Determinare il codice di uscita  
 Un processo può restituire un *il codice di uscita* quando termina. Tuttavia, è possibile usare `Shell` per recuperare il codice di uscita, in quanto `Shell` restituisce zero se l'attesa di chiusura e anche perché il processo viene eseguito in un oggetto diverso da `Shell`.  
  
 Per recuperare il codice di uscita da un processo, è necessario scrivere codice personalizzato per avviare il processo e attendere che la terminazione. Nell'esempio seguente viene illustrato come avviare un processo, attendere che venga terminare e recuperare il codice di uscita.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>La protezione specifica del File  
 È sempre deve racchiudere l'intero specifica del percorso e il file racchiuso tra virgolette, come illustrato nell'esempio seguente.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Ogni coppia di virgolette doppie adiacenti (`" "`) all'interno della stringa letterale viene interpretata come un'unica virgoletta doppia nella stringa. Pertanto, nell'esempio precedente viene presentata la stringa seguente per il `Shell` funzione:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Se non è stato il percorso racchiuso tra virgolette doppie, Windows cercherebbe un file denominato `Program.exe` nella directory c:\., invece di `display.exe` nella directory C:\Program Files.  
  
> [!IMPORTANT]
>  Se si non racchiude la specifica del percorso e il file racchiuso tra virgolette, è un rischio per la sicurezza se il nome del file o un nodo del percorso contiene spazi. Nell'esempio precedente, il nodo del percorso `\Program Files` include uno spazio. Se la specifica non fosse racchiusa tra virgolette e un programma denominato `Program.exe` è stato installato in c:\\, ad esempio tramite una manomissione, Windows eseguirà invece di `display.exe`.  
  
> [!IMPORTANT]
>  Il `Shell` funzione richiede l'autorizzazione di accesso al codice non gestito, che possono influire sull'esecuzione in situazioni di attendibilità parziale. Per altre informazioni, vedere <xref:System.Security.Permissions.SecurityPermission> e [le autorizzazioni di accesso di codice](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 L'esempio seguente usa il `Shell` funzione per eseguire un'applicazione specificata dall'utente. Specifica di <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> come secondo argomento apre l'applicazione di dimensioni normali e gli assegna lo stato attivo.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> non rientra nell'intervallo compreso tra 0 e 9, estremi inclusi.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> non è in grado di trovare il file <paramref name="PathName" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> è <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Obbligatorio. Matrice di parametri <see langword="Object" />. Il numero di elementi deve essere pari. È possibile specificare un elenco di variabili <see langword="Object" /> o espressioni separate da virgole oppure una matrice unidimensionale di elementi <see langword="Object" />.</param>
        <summary>Valuta un elenco di espressioni e restituisce un valore <see langword="Object" /> corrispondente alla prima espressione <see langword="True" /> dell'elenco.</summary>
        <returns>Valuta un elenco di espressioni e restituisce un valore <see langword="Object" /> corrispondente alla prima espressione <see langword="True" /> dell'elenco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'argomento fornito a `VarExpr` è costituito da valori ed espressioni associate. Il `Switch` funzione valuta le espressioni dispari dal più basso all'indice più alto nel `VarExpr`e restituisce il valore pari associato con la prima espressione che restituisca `True`. Ad esempio, se `VarExpr(0)` viene `True`, `Switch` restituisce `VarExpr(1)`e se `VarExpr(0)` viene `False` ma `VarExpr(2)` è `True`, `Switch` restituisce `VarExpr(3)`e così via.  
  
 Se non si fornisce il `VarExpr` argomento `Switch` restituisce `Nothing`.  
  
> [!NOTE]
>  Le espressioni nell'elenco di argomenti possono includere le chiamate di funzione. Come parte della preparazione all'elenco di argomenti per la chiamata a `Switch`, il compilatore Visual Basic chiama ogni funzione in tutte le espressioni. Ciò significa che non è possibile utilizzare una particolare funzione non viene chiamata se un'espressione in precedenza nell'elenco di argomenti `True`.  
  
   
  
## Examples  
 L'esempio seguente usa il `Switch` funzione per restituire il nome di una lingua che corrisponde al nome di una città. Si presuppone che `Option Strict` essere `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Poiché il <xref:System.Diagnostics> dello spazio dei nomi contiene inoltre una classe denominata <xref:System.Diagnostics.Switch>, una chiamata ai `Switch` funzione deve essere qualificata con il <xref:Microsoft.VisualBasic> dello spazio dei nomi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il numero degli argomenti è dispari.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Istruzione Select...Case (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Matrici di parametri</related>
      </Docs>
    </Member>
  </Members>
</Type>