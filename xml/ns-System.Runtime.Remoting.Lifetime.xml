<Namespace Name="System.Runtime.Remoting.Lifetime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5ac8c7510ea8c5026f390f2936bebfb8b315c4f4" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/10/2018" />
    <Meta Name="ms.locfileid" Value="30735635" />
  </Metadata>
  <Docs>
    <summary>Lo spazio dei nomi <see cref="N:System.Runtime.Remoting.Lifetime" /> contiene classi che gestiscono la durata degli oggetti remoti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, la garbage collection distribuita utilizza i conteggi dei riferimenti e il ping per il controllo della durata degli oggetti. Questo funziona bene quando sono presenti alcuni client per ogni servizio, ma non sono adattabili ai casi sono presenti migliaia di client per ogni servizio. Il servizio remoto di durata associa un lease di ciascun servizio e consente di eliminare un servizio quando scade la durata del lease. Il servizio di durata può assumere la funzione di un garbage collector distribuito tradizionali e regola anche anche in caso di aumento del numero di client per ogni server.  
  
 Ogni dominio dell'applicazione contiene un gestore di lease che è responsabile del controllo dei lease nel dominio. Tutti i lease vengono esaminati periodicamente per controllarne la scadenza. Se un lease è scaduto, uno o più sponsor richiamato e la possibilità di rinnovare il lease. Se nessuno degli sponsor decide di rinnovare il lease, il gestore di lease rimuove il lease e l'oggetto può essere raccolto dal garbage collector. Il gestore di lease mantiene un elenco con lease ordinati per tempo rimanente. I lease con il più breve tempo rimanente vengono archiviati nella parte superiore dell'elenco.  
  
 ]]></format>
    </remarks>
  </Docs>
</Namespace>