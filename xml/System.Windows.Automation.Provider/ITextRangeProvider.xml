<Type Name="ITextRangeProvider" FullName="System.Windows.Automation.Provider.ITextRangeProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5200d9e8e480597cbec54c5ce6eaa4ae458f388c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37526995" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ITextRangeProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITextRangeProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface ITextRangeProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class ITextRangeProvider" />
  <TypeSignature Language="F#" Value="type ITextRangeProvider = interface" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("5347ad7b-c355-46f8-aff5-909033582f63")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Espone metodi e proprietà per supportare l'accesso client di automazione interfaccia utente a un'estensione di testo continuo in un contenitore di testo che implementa <see cref="T:System.Windows.Automation.Provider.ITextProvider" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementato su un provider di automazione interfaccia utente che deve supportare il <xref:System.Windows.Automation.TextPattern> pattern di controllo.  
  
 Oggetto <xref:System.Windows.Automation.Text.TextPatternRange> può rappresentare un punto di inserimento, un subset o tutto il testo in un <xref:System.Windows.Automation.TextPattern> contenitore.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Text.TextPatternRange" />
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="abstract member AddToSelection : unit -&gt; unit" Usage="iTextRangeProvider.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiunge elementi alla raccolta di testo evidenziato in un contenitore di testo che supporta selezioni multiple non contigue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il punto di inserimento si sposta nell'area della nuova selezione.  
  
 Fornire un intervallo di testo degenere sposta il punto di inserimento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se il provider di testo non supporta le selezioni multiple non contigue (ovvero, <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> deve avere un valore pari a <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un nuovo oggetto <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> identico all'oggetto <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> originale che eredita tutte le proprietà dell'originale.</summary>
        <returns>Nuovo intervallo di testo. Un riferimento Null (<see langword="Nothing" /> in Visual Basic) non viene mai restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nuovo intervallo può essere modificato in modo indipendente dall'originale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Provider.ITextRangeProvider range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Compare(class System.Windows.Automation.Provider.ITextRangeProvider range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Compare(System.Windows.Automation.Provider.ITextRangeProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As ITextRangeProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Provider::ITextRangeProvider ^ range);" />
      <MemberSignature Language="F#" Value="abstract member Compare : System.Windows.Automation.Provider.ITextRangeProvider -&gt; bool" Usage="iTextRangeProvider.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
      </Parameters>
      <Docs>
        <param name="range">Intervallo di testo da confrontare</param>
        <summary>Restituisce un valore che indica se l'estensione (dall'endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> all'endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) di un intervallo di testo corrisponde a un altro intervallo di testo.</summary>
        <returns>
          <see langword="true" /> se l'ampiezza di entrambi gli intervalli di testo è identica; in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se l'intervallo confrontato non proviene dallo stesso provider di testo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="iTextRangeProvider.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del chiamante.</param>
        <param name="targetRange">Intervallo di destinazione per il confronto.</param>
        <param name="targetEndpoint">Endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> della destinazione.</param>
        <summary>Restituisce un valore che specifica se due intervalli di testo presentano endpoint identici.</summary>
        <returns>Restituisce un valore negativo se l'endpoint del chiamante si trova nel testo prima dell'endpoint di destinazione.  Restituisce zero se l'endpoint del chiamante è nella stessa posizione dell'endpoint di destinazione.  Restituisce un valore positivo se l'endpoint del chiamante si trova nel testo dopo l'endpoint di destinazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Se <paramref name="targetRange" /> proviene da un provider di testo diverso.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="abstract member ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="iTextRangeProvider.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Unità testuale.</param>
        <summary>Espande l'intervallo di testo all'unità di testo specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'intervallo è già una quantità esatta di unità di misura specificata e rimane invariato.  
  
 È disponibile una serie di passaggi coinvolti in background per consentire il <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> metodo venga eseguito correttamente.  
  
1.  L'intervallo di testo viene normalizzato, ovvero viene compresso in un intervallo degenerato all'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> . Ciò rende superfluo l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> . Questo passaggio è necessario rimuovere l'ambiguità nei casi in cui un intervallo di testo si estenda `unit` i limiti, ad esempio, "{l'U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) è incorporato nel testo" dove "{" e "}" rappresentano il testo endpoint dell'intervallo.  
  
2.  L'intervallo risultante viene spostato indietro in <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> all'inizio del limite `unit` richiesto.  
  
3.  L'intervallo viene spostato avanti o indietro in <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> per il numero richiesto di limiti `unit`.  
  
4.  L'intervallo viene quindi espanso dallo stato di intervallo degenerato spostando l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> di un limite `unit` richiesto.  
  
 ![Regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit")  
Esempi di regolazione di un intervallo di testo per Move() ed ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Questi passaggi sono necessari poiché è comune per la lettura dello schermo leggere un completa parola, frase o intero paragrafo al punto di inserimento o qualsiasi posizione del cursore virtuale.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> rispetta il testo nascosto sia visibile.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> rinvia al successivo più grande <xref:System.Windows.Automation.Text.TextUnit> supportato se il dato <xref:System.Windows.Automation.Text.TextUnit> non è supportata dal controllo.  
  
 L'ordine, da unità più piccolo al più grande, viene elencato di seguito.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindAttribute (int attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindAttribute(int32 attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(System.Int32,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As Integer, value As Object, backward As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindAttribute(int attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="abstract member FindAttribute : int * obj * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Attributo da cercare.</param>
        <param name="value">Valore dell'attributo da cercare. Questo valore deve corrispondere al tipo specificato per l'attributo.</param>
        <param name="backward">
          <see langword="true" /> se deve essere restituito l'ultimo intervallo di testo invece del primo; in caso contrario <see langword="false" />.</param>
        <summary>Restituisce un sottoinsieme di intervallo di testo che presenta il valore dell'attributo specificato.</summary>
        <returns>Intervallo di testo che presenta un attributo e un valore di attributo corrispondenti; in caso contrario, Null (<see langword="Nothing" /> in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna differenza tra il testo nascosto e visibile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As ITextRangeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::ITextRangeProvider ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member FindText : string * bool * bool -&gt; System.Windows.Automation.Provider.ITextRangeProvider" Usage="iTextRangeProvider.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Stringa di testo da cercare.</param>
        <param name="backward">
          <see langword="true" /> se deve essere restituito l'ultimo intervallo di testo invece del primo; in caso contrario <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> se è necessario ignorare la differenza tra maiuscole e minuscole; in caso contrario, <see langword="false" />.</param>
        <summary>Restituisce un sottoinsieme di intervallo di testo contenente il testo specificato.</summary>
        <returns>Intervallo di testo corrispondente al testo specificato; in caso contrario, Null (<see langword="Nothing" /> in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna differenza tra il testo nascosto e visibile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (int attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAttributeValue(int32 attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(int attribute);" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeValue : int -&gt; obj" Usage="iTextRangeProvider.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attribute">Attributo di testo.</param>
        <summary>Recupera il valore dell'attributo specificato nell'intervallo di testo.</summary>
        <returns>Recupera un oggetto che rappresenta il valore dell'attributo specificato. Ad esempio, <c>GetAttributeValue(TextPattern.FontNameAttribute)</c> restituirebbe una stringa che rappresenta il nome del tipo di carattere dell'intervallo di testo, mentre <c>GetAttributeValue (TextPattern.IsItalicAttribute)</c> restituirebbe un valore di tipo <see cref="T:System.Boolean" />.  Restituisce <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> se il valore dell'attributo specificato varia nell'intervallo di testo.  Restituisce <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> se l'attributo specificato non è supportato dal provider o dal controllo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna differenza tra il testo nascosto e visibile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se l'attributo specificato non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public double[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="abstract member GetBoundingRectangles : unit -&gt; double[]" Usage="iTextRangeProvider.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera una raccolta di rettangoli di delimitazione per ogni riga di testo completamente o parzialmente visibile in un intervallo di testo.</summary>
        <returns>Una matrice di rettangoli di delimitazione per ogni riga di testo completa o parziale in un intervallo di testo.  Matrice vuota per un intervallo degenere.  Matrice vuota per un intervallo di testo che presenta coordinate di schermo che lo collocano completamente fuori dello schermo, al di fuori della visualizzazione o nascosto da una finestra sovrapposta.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As IRawElementProviderSimple()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::Provider::IRawElementProviderSimple ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="abstract member GetChildren : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple[]" Usage="iTextRangeProvider.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera una raccolta di tutti gli oggetti incorporati che rientrano nell'intervallo di testo.</summary>
        <returns>Raccolta degli oggetti figlio che rientrano nell'intervallo. Nella raccolta verranno inclusi anche gli oggetti figlio che si sovrappongono all'intervallo di testo ma non vi sono racchiusi completamente.  Restituisce una raccolta vuota se non sono presenti oggetti figlio.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As IRawElementProviderSimple" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Provider::IRawElementProviderSimple ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="abstract member GetEnclosingElement : unit -&gt; System.Windows.Automation.Provider.IRawElementProviderSimple" Usage="iTextRangeProvider.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il controllo più interno che racchiude l'intervallo di testo.</summary>
        <returns>Controllo contenitore, in genere il provider di testo che fornisce l'intervallo di testo. Se tuttavia il provider di testo supporta elementi figlio, quali tabelle o collegamenti ipertestuali, l'elemento contenitore potrebbe essere un discendente del provider di testo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="abstract member GetText : int -&gt; string" Usage="iTextRangeProvider.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Lunghezza massima della stringa da restituire. Usare <c>-1</c> se non è richiesto alcun limite.</param>
        <summary>Recupera il testo normale dell'intervallo.</summary>
        <returns>Testo normale dell'intervallo di testo, probabilmente troncato all'oggetto <paramref name="maxLength" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> rispetta il testo nascosto sia visibile.  
  
 Se `maxLength` è maggiore della lunghezza dell'intervallo del testo del chiamante, la stringa restituita sarà il testo normale dell'intervallo di testo.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> non saranno interessati dall'ordine degli endpoint nel flusso di testo. restituirà sempre il testo tra gli endpoint di inizio e fine dell'intervallo di testo nell'ordine di flusso di testo logico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="maxLength" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Limite di unità di testo.</param>
        <param name="count">Numero di unità di testo da spostare.  Un valore positivo consente di spostare l'intervallo di testo in avanti, un valore negativo consente di spostare l'intervallo di testo indietro e 0 non ha effetto.</param>
        <summary>Sposta l'intervallo di testo di un numero specificato di unità di testo.</summary>
        <returns>Numero di unità effettivamente spostate. Può essere inferiore al numero richiesto se uno dei nuovi endpoint di intervallo di testo è maggiore o minore degli endpoint di <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando è necessario scorrere il contenuto di un intervallo di testo, per garantire una corretta esecuzione del metodo <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> è prevista una serie di passaggi dietro le quinte.  
  
1.  L'intervallo di testo viene normalizzato, ovvero viene compresso in un intervallo degenerato all'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> . Ciò rende superfluo l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> . Questo passaggio è necessario rimuovere l'ambiguità nei casi in cui un intervallo di testo si estenda `unit` i limiti, ad esempio, "{l'U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) è incorporato nel testo" dove "{" e "}" rappresentano il testo endpoint dell'intervallo.  
  
2.  L'intervallo risultante viene spostato indietro in <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> all'inizio del limite `unit` richiesto.  
  
3.  L'intervallo viene spostato avanti o indietro in <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> per il numero richiesto di limiti `unit`.  
  
4.  L'intervallo viene quindi espanso dallo stato di intervallo degenerato spostando l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> di un limite `unit` richiesto.  
  
 ![Regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit")  
Esempi di regolazione di un intervallo di testo per Move() ed ExpandToEnclosingUnit()  
  
 Il contenuto testuale (o testo interno) di un contenitore di testo o di un oggetto incorporato, ad esempio una cella di tabella o un collegamento ipertestuale, viene esposto come un flusso di testo continuo sia nella vista di controllo che nella visualizzazione del contenuto dell'albero di [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]. I limiti dell'oggetto vengono ignorati.  
  
 ![Intervalli di testo estesi da oggetti incorporati. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalli di testo estesi da oggetti incorporati.")  
Esempio di un flusso di testo con oggetti incorporati e le estensioni degli intervalli corrispondenti  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> rispetta il testo nascosto sia visibile.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> rinvia al successivo più grande <xref:System.Windows.Automation.Text.TextUnit> supportato se il dato <xref:System.Windows.Automation.Text.TextUnit> non è supportata dal controllo.  
  
 L'ordine, da unità più piccolo al più grande, viene elencato di seguito.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 Il testo non viene modificato in alcun modo, l'intervallo di testo appena si estende su una parte diversa del testo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As ITextRangeProvider, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Provider::ITextRangeProvider ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Provider.ITextRangeProvider * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="iTextRangeProvider.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Endpoint da spostare.</param>
        <param name="targetRange">Altro intervallo dallo stesso provider di testo.</param>
        <param name="targetEndpoint">Un endpoint nell'altro intervallo.</param>
        <summary>Sposta un endpoint di un intervallo di testo all'endpoint specificato di un secondo intervallo di testo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'endpoint da spostare supera l'altro endpoint dell'intervallo di testo stesso, l'altro endpoint viene spostato, inoltre, producendo un intervallo degenere e garantire l'ordinamento corretto degli endpoint (vale a dire <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> è sempre minore o uguale al <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="abstract member MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="iTextRangeProvider.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">Endpoint da spostare.</param>
        <param name="unit">Unità testuale per lo spostamento.</param>
        <param name="count">Numero di unità da spostare. Un valore positivo comporta lo spostamento in avanti dell'endpoint. Un valore negativo comporta lo spostamento indietro. Un valore pari a 0 non ha effetto.</param>
        <summary>Sposta un endpoint dell'intervallo di testo del numero specificato di unità di testo nell'intervallo del documento.</summary>
        <returns>Numero di unità effettivamente spostate, che può essere inferiore al numero richiesto se con lo spostamento degli endpoint si raggiunge l'inizio o la fine del documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando è necessario scorrere il contenuto di un intervallo di testo, per garantire una corretta esecuzione del metodo <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> è prevista una serie di passaggi dietro le quinte.  
  
1.  L'intervallo di testo viene normalizzato, ovvero viene compresso in un intervallo degenerato all'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> . Ciò rende superfluo l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> . Questo passaggio è necessario rimuovere l'ambiguità nei casi in cui un intervallo di testo si estenda `unit` i limiti, ad esempio, "{l'U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) è incorporato nel testo" dove "{" e "}" rappresentano il testo endpoint dell'intervallo.  
  
2.  L'intervallo risultante viene spostato indietro in <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> all'inizio del limite `unit` richiesto.  
  
3.  L'intervallo viene quindi espanso dallo stato di intervallo degenerato spostando l'endpoint <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> di un limite `unit` richiesto.  
  
 ![Regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "regolazioni di intervallo mediante Move ed ExpandToEnclosingUnit")  
Esempi di regolazione di un intervallo di testo per Move() ed ExpandToEnclosingUnit()  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A> rinvia al successivo più grande <xref:System.Windows.Automation.Text.TextUnit> supportato se il dato <xref:System.Windows.Automation.Text.TextUnit> non è supportata dal controllo.  
  
 L'ordine, da unità più piccolo al più grande, viene elencato di seguito.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFromSelection : unit -&gt; unit" Usage="iTextRangeProvider.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove una sezione evidenziata del testo, corrispondente agli endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del chiamante, dalla raccolta di testo evidenziato in un contenitore di testo che supporta selezioni multiple non contigue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il punto di inserimento passerà all'area di evidenziazione rimossa.  
  
 Fornire un intervallo di testo degenere sposterà il punto di inserimento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se il provider di testo non supporta le selezioni multiple non contigue (ad esempio, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve avere un valore pari a <see langword="Multiple" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="abstract member ScrollIntoView : bool -&gt; unit" Usage="iTextRangeProvider.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" /> se il controllo di testo deve essere spostato in modo che l'intervallo di testo sia allineato al margine superiore del riquadro di visualizzazione; <see langword="false" /> se deve essere allineato al margine inferiore del riquadro di visualizzazione.</param>
        <summary>Determina lo scorrimento verticale del controllo di testo fino a quando l'intervallo di testo non è visibile nel riquadro di visualizzazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A> rispetta il testo nascosto sia visibile.  
  
 Se l'intervallo di testo è nascosta, il controllo testo scorre solo se il testo nascosto ha un ancoraggio nel riquadro di visualizzazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="abstract member Select : unit -&gt; unit" Usage="iTextRangeProvider.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Evidenzia il testo nel controllo di testo corrispondente agli endpoint <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> dell'intervallo di testo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene specificato un intervallo di testo degenere, il punto di inserimento sposterà alla <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint dell'intervallo di testo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si verifica quando la selezione del testo non è supportata dal controllo del testo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>