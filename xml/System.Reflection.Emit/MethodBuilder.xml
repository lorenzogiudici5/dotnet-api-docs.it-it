<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7340649aca6e8cf6ed3ffde1f98df8cddd7e22ab" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48749560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo&#xA;    interface _MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce e rappresenta un metodo (o costruttore) di una classe dinamica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.MethodBuilder> classe viene utilizzata per descrivere completamente un metodo in Microsoft intermediate language (MSIL), incluso il corpo di nome, attributi, firma e metodo. Viene usato in combinazione con il <xref:System.Reflection.Emit.TypeBuilder> classe per creare le classi in fase di esecuzione.  
  
## <a name="global-methods-and-methods-as-type-members"></a>I metodi globali e i metodi come membri di tipo  
 È possibile usare la reflection emit per definire i metodi globali e per definire metodi come membri dei tipi. Le API che definiscono i metodi restituiscono <xref:System.Reflection.Emit.MethodBuilder> oggetti.  
  
### <a name="global-methods"></a>Metodi globali  
 Un metodo globale viene definito mediante il <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> metodo, che restituisce un **MethodBuilder** oggetto.  
  
 I metodi globali devono essere statici. Se un modulo dinamico contiene i metodi globali, la <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> metodo deve essere chiamato prima di renderli persistenti il modulo dinamico o l'assembly dinamico che contiene, perché common language runtime la correzione del modulo dinamico finché tutte le funzioni globali sono stati definiti.  
  
 Un metodo nativo globale viene definito usando la <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> (metodo). Platform invoke (PInvoke) metodi non devono essere dichiarati astratta o virtuale. I set di runtime il <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> attributo per una piattaforma metodo invoke.  
  
### <a name="methods-as-members-of-types"></a>Metodi come membri dei tipi  
 Un metodo è definito come un membro del tipo tramite il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo, che restituisce un <xref:System.Reflection.Emit.MethodBuilder> oggetto.  
  
 Il <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> metodo viene utilizzato per impostare gli attributi nome e il parametro di un parametro o del valore restituito. Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto restituito da questo metodo rappresenta un parametro o valore restituito. Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto può essere utilizzato per impostare il marshalling, impostare il valore costante e per applicare gli attributi personalizzati.  
  
## <a name="attributes"></a>Attributi  
 I membri del <xref:System.Reflection.MethodAttributes> enumerazione definire il carattere preciso di un metodo dinamico:  
  
-   I metodi statici vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> attributo.  
  
-   I metodi finali (che non può essere sottoposto a override) vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> attributo.  
  
-   Metodi virtuali vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> attributo.  
  
-   I metodi astratti vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> attributo.  
  
-   Diversi attributi determinano la visibilità di metodo. Vedere la descrizione del <xref:System.Reflection.MethodAttributes> enumerazione.  
  
-   I metodi che implementano gli operatori di overload è necessario impostare il <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attributo.  
  
-   I finalizzatori devono impostare il <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attributo.  
  
## <a name="known-issues"></a>Problemi noti  
  
-   Sebbene <xref:System.Reflection.Emit.MethodBuilder> deriva dal <xref:System.Reflection.MethodInfo>, alcuni dei metodi astratti definiti nel <xref:System.Reflection.MethodInfo> classe non sono completamente implementate in <xref:System.Reflection.Emit.MethodBuilder>. Questi <xref:System.Reflection.Emit.MethodBuilder> metodi generano la <xref:System.NotSupportedException>. Ad esempio il <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> metodo non è completamente implementato. È possibile riflettere su questi metodi mediante il recupero del tipo contenitore usando il <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodi.  
  
-   I modificatori personalizzati sono supportati a partire da .NET Framework versione 2.0. Non sono supportati nelle versioni precedenti.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.Emit.MethodBuilder> classe per creare un metodo all'interno di un tipo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="methodBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Azione di sicurezza da eseguire, ad esempio Demand, Assert e così via.</param>
        <param name="pset">Set di autorizzazioni a cui viene applicata l'azione.</param>
        <summary>Aggiunge sicurezza dichiarativa a questo metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> può essere chiamato più volte, specificando un'azione di sicurezza a ogni chiamata (ad esempio `Demand`, `Assert`, e `Deny`) e un set di autorizzazioni che si applica l'azione.  
  
> [!NOTE]
>  Nelle versioni .NET Framework 1.0, 1.1 e 2.0, gli attributi di sicurezza dichiarativa applicati a un metodo tramite la <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> metodo vengono archiviate nel vecchio formato XML dei metadati. Vedere Creazione di attributi di sicurezza dichiarativa.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo contestuale di `AddDeclarativeSecurity` per richiedere che il chiamante di un metodo per disporre di autorizzazioni senza restrizioni.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="action" /> non è valido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> e <see langword="RequestRefuse" /> non sono validi).</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Il set di autorizzazioni <paramref name="pset" /> contiene un'azione aggiunta in precedenza mediante <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera gli attributi per questo metodo.</summary>
        <value>Sola lettura. Recupera l'oggetto <see langword="MethodAttributes" /> per questo metodo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce la convenzione di chiamata del metodo.</summary>
        <value>Sola lettura. Convenzione di chiamata del metodo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Non supportato per questo tipo.</summary>
        <value>Non supportato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Reflection.Emit.MethodBuilder> rappresenta sempre una definizione di metodo generico e pertanto non può essere richiamata.  
  
 Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>. Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodBody : byte[] * int -&gt; unit" Usage="methodBuilder.CreateMethodBody (il, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">Matrice che contiene istruzioni MSIL valide. Se questo parametro è <see langword="null" />, il corpo del metodo viene cancellato.</param>
        <param name="count">Numero di byte validi nella matrice MSIL. Questo valore viene ignorato se MSIL è <see langword="null" />.</param>
        <summary>Crea il corpo del metodo usando una matrice di byte fornita di istruzioni Microsoft Intermediate Language (MSIL).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea il corpo del metodo da `il`, una matrice che contiene istruzioni MSIL come codici operativi. Il numero di byte di codice MSIL valido è dato dal conteggio.  
  
> [!NOTE]
>  Ciò non è completamente supportato. Non è possibile specificare il percorso del token correzioni e i gestori di eccezioni.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito, viene generato un metodo semplice che aggiunge due numeri interi tramite codice operativo usando `CreateMethodBody`.  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il <paramref name="count" /> non è compreso nell'intervallo di indici della matrice di istruzioni MSIL e <paramref name="il" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Questo metodo è stato chiamato in precedenza su questo <see langword="MethodBuilder" /> con un argomento <paramref name="il" /> che non era <see langword="null" />.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il tipo che dichiara il metodo.</summary>
        <value>Sola lettura. Tipo che dichiara il metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice seguente illustra l'uso del `Type` proprietà.  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="methodBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Matrice di stringhe che rappresentano i nomi dei parametri di tipo generico.</param>
        <summary>Imposta il numero dei parametri di tipo generico per il metodo corrente, specificandone i nomi, e restituisce una matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che possono essere usati per definire i vincoli.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo del metodo generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo rende il metodo corrente generico. Non è possibile annullare questa operazione. Chiamando questo metodo un secondo momento, un <xref:System.InvalidOperationException>.  
  
 I parametri di tipo del metodo generico possono essere recuperati in un secondo momento tramite il <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> (metodo).  
  
 Per convenzione, un nome di parametro di tipo è una singola lettera maiuscola.  
  
 Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un tipo dinamico, `DemoType`, che contiene il metodo generico dinamico `DemoMethod`. Questo metodo ha due parametri di tipo generico, una delle quali viene utilizzata come parametro e l'altro come tipo restituito.  
  
 Quando il codice viene eseguito, l'assembly dinamico viene salvato come DemoGenericMethod1.dll e può essere esaminato mediante lo strumento [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
> [!NOTE]
>  Questo esempio di codice genera il corpo di un metodo semplice che restituisce semplicemente un riferimento null. Per un esempio di codice con un corpo di un metodo completamente sviluppato più che crea e Usa i tipi generici, vedere [procedura: definire un metodo generico tramite Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parametri di tipo generico sono già stati definiti per questo metodo.  
  
oppure 
Il metodo è già stato completato.  
  
oppure 
Il metodo <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> è stato chiamato per il metodo corrente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> è <see langword="null" />.  
  
oppure 
Un elemento di <paramref name="names" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> è una matrice vuota.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="methodBuilder.DefineParameter (position, attributes, strParamName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Posizione del parametro nell'elenco dei parametri. I parametri vengono indicizzati a partire dal numero 1 per il primo parametro. Il numero 0 rappresenta il valore restituito del metodo.</param>
        <param name="attributes">Attributi del parametro.</param>
        <param name="strParamName">Nome del parametro. Il nome può essere rappresentato dalla stringa null.</param>
        <summary>Imposta gli attributi del parametro e il nome di un parametro di questo metodo oppure del valore restituito di questo metodo. Restituisce un oggetto ParameterBuilder che può essere usato per applicare attributi personalizzati.</summary>
        <returns>Restituisce un oggetto <see langword="ParameterBuilder" /> che rappresenta un parametro o il valore restituito di questo metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto restituito da questo metodo può essere utilizzato per impostare il valore predefinito per un parametro o per applicare gli attributi personalizzati.  
  
 Parametro la numerazione inizia da 1, pertanto `position` è 1 per il primo parametro. Se `position` è uguale a zero, questo metodo influisce sul valore restituito.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, viene generata un'eccezione se `position` è uguale a zero, pertanto questo metodo non può essere utilizzato per modificare gli attributi del valore restituito in queste versioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il metodo non ha parametri.  
  
oppure 
 <paramref name="position" /> è minore di zero.  
  
oppure 
 <paramref name="position" /> è maggiore del numero dei parametri del metodo.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con questa istanza di <see langword="MethodBuilder" />.</param>
        <summary>Determina se l'oggetto specificato è uguale a questa istanza.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see langword="MethodBuilder" /> ed è uguale a questo oggetto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'uguaglianza è determinata dall'aventi lo stesso nome, attributi e firma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'implementazione di base per un metodo.</summary>
        <returns>Implementazione di base di questo metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene sempre restituito corrente `MethodBuilder` oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce gli attributi personalizzati definiti per questo metodo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</param>
        <summary>Restituisce tutti gli attributi personalizzati definiti per questo metodo.</summary>
        <returns>Restituisce una matrice di oggetti che rappresentano tutti gli attributi personalizzati di questo metodo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo di attributo personalizzato.</param>
        <param name="inherit">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</param>
        <summary>Restituisce gli attributi personalizzati identificati dal tipo specificato.</summary>
        <returns>Restituisce una matrice di oggetti che rappresenta gli attributi del metodo di tipo <paramref name="attributeType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo del metodo, se è generico.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo, se il metodo è generico, oppure <see langword="null" /> se il metodo non è generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I parametri di tipo di un metodo generico vengono anche restituiti dai <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo utilizzato per definirle.  
  
 Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>. Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce questo metodo.</summary>
        <returns>L'istanza corrente di <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Reflection.Emit.MethodBuilder> non può essere usato per generare un metodo generico costruito direttamente. Il metodo creato è una definizione di metodo generico.  
  
 Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo corrente non è generico. Quindi la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> restituisce <see langword="false" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il codice hash per questo metodo.</summary>
        <returns>Codice hash per questo metodo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see langword="ILGenerator" /> per il metodo con una dimensione di flusso MSIL (Microsoft Intermediate Language) predefinita di 64 byte.</summary>
        <returns>Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra l'utilizzo contestuale del `GetILGenerator` metodo la creazione di un assembly dinamico che calcola il prodotto scalare di due punti nello spazio 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo non deve avere un corpo a causa del suo flag <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, ad esempio perché ha il flag <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
  
oppure 
Il metodo è un metodo generico, ma non una definizione di metodo generico. Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Dimensioni del flusso MSIL in byte.</param>
        <summary>Restituisce un oggetto <see langword="ILGenerator" /> per il metodo con le dimensioni del flusso MSIL (Microsoft Intermediate Language) specificate.</summary>
        <returns>Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra l'utilizzo contestuale del `GetILGenerator` metodo la creazione di un assembly dinamico che calcola il prodotto scalare di due punti nello spazio 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo non deve avere un corpo a causa del suo flag <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, ad esempio perché ha il flag <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
  
oppure 
Il metodo è un metodo generico, ma non una definizione di metodo generico. Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i flag di implementazione per il metodo.</summary>
        <returns>Restituisce i flag di implementazione per il metodo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="methodBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un riferimento al modulo che contiene questo metodo.</summary>
        <returns>Restituisce un riferimento al modulo che contiene questo metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice di esempio seguente viene illustrato l'utilizzo del `GetModule` metodo per recuperare informazioni su un modulo generato dinamicamente.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il parametro del metodo.</summary>
        <returns>Matrice di oggetti <see langword="ParameterInfo" /> che rappresentano i parametri del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra l'uso di `GetParameters` per individuare le informazioni sui parametri passati a un metodo generato dinamicamente.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see langword="GetParameters" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="methodBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see langword="MethodToken" /> che rappresenta il token per il metodo.</summary>
        <returns>Restituisce l'oggetto <see langword="MethodToken" /> del metodo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore booleano che specifica se le variabili locali in questo metodo sono inizializzate su zero. Il valore predefinito di questa proprietà è <see langword="true" />.</summary>
        <value>
          <see langword="true" /> se le variabili locali in questo metodo devono essere inizializzate su zero; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa proprietà è impostata su `true`, il codice MSIL generato include l'inizializzazione delle variabili locali. Se è impostato su `false`, variabili locali non inizializzate e il codice generato non è verificabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />. (Get o set).</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto su cui richiamare il metodo specificato. Se il metodo è statico, questo parametro verrà ignorato.</param>
        <param name="invokeAttr">È necessario che si tratti di un flag di bit richiamato dall'oggetto <see cref="T:System.Reflection.BindingFlags" />, ad esempio <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi, la chiamata dei membri e il recupero di oggetti MemberInfo tramite reflection. Se il gestore di associazione è <see langword="null" />, verrà utilizzato il gestore di associazione predefinito. Per informazioni dettagliate, vedere <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Elenco di argomenti. Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare. In assenza di parametri, deve essere <see langword="null" />.</param>
        <param name="culture">Istanza di <see cref="T:System.Globalization.CultureInfo" /> usata per regolare la coercizione dei tipi. Se è null, verrà utilizzato l'oggetto <see cref="T:System.Globalization.CultureInfo" /> per il thread corrente. Questo è necessario, ad esempio, per convertire un valore <see cref="T:System.String" /> che rappresenta 1000 in un valore <see cref="T:System.Double" />, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</param>
        <summary>Richiama dinamicamente il metodo ottenuto mediante reflection da questa istanza sull'oggetto indicato, passando i parametri specificati e con i vincoli del binder indicato.</summary>
        <returns>Restituisce un oggetto che contiene il valore restituito del metodo richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il metodo è statico, il `obj` parametro viene ignorato. Per i metodi non statici, `obj` deve essere un'istanza di una classe che eredita o dichiara il metodo e deve essere dello stesso tipo questa classe. Se il metodo non ha parametri, il valore di `parameters` deve essere `null`. In caso contrario, il numero, tipo e ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri per il metodo ottenuto mediante reflection da questa istanza.  
  
> [!NOTE]
>  Restrizioni di accesso vengono ignorate per il codice completamente attendibile. Vale a dire, proprietà, metodi, campi e i costruttori privati sono accessibili e richiamato tramite Reflection, ogni volta che il codice è completamente attendibile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="methodBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo di attributo personalizzato.</param>
        <param name="inherit">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</param>
        <summary>Controlla se il tipo di attributo personalizzato specificato è definito.</summary>
        <returns>
          <see langword="true" /> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è un metodo generico.</summary>
        <value>
          <see langword="true" /> se il metodo è generico; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un metodo è generico se contiene parametri di tipo. È possibile rendere un metodo generica chiamando il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per aggiungere parametri di tipo. Questa modifica non può essere annullata.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza lo stato di un metodo. Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> corrente rappresenta la definizione di un metodo generico.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> corrente rappresenta la definizione di un metodo generico; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Reflection.Emit.MethodBuilder> utilizzabile solo per creare definizioni di metodo generico; non può essere usato per creare un metodo generico costruito direttamente. Tuttavia, una sottoclasse di <xref:System.Reflection.Emit.MethodBuilder> potrebbe rappresentare un metodo generico costruito.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza lo stato di un metodo. Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</summary>
        <value>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare se un metodo in un assembly dinamico è critico per la sicurezza, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">In tutti i casi. Questa proprietà non è supportata in assembly dinamici.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</summary>
        <value>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare se un metodo in un assembly dinamico è security-safe-critical, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">In tutti i casi. Questa proprietà non è supportata in assembly dinamici.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</summary>
        <value>Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare se un metodo in un assembly dinamico è trasparente per la sicurezza, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">In tutti i casi. Questa proprietà non è supportata in assembly dinamici.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo per il metodo generico.</param>
        <summary>Restituisce un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti tipo generico specificati.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti di tipo generico specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si sta generando codice dinamico, potrebbe essere necessario generare una chiamata a un metodo costruito dalla definizione di metodo generico rappresentata da un <xref:System.Reflection.Emit.MethodBuilder>, prima che il tipo di inclusione è stato completato. È possibile usare la <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo per creare un <xref:System.Reflection.MethodInfo> per tale metodo costruito e utilizzare il <xref:System.Reflection.MethodInfo> nella chiamata generata.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo costruito da una definizione di metodo generico incompleti in un tipo incompleto.  
  
 L'esempio crea un assembly temporaneo e il modulo con un solo tipo, viene aggiunto un metodo `M`e rende il metodo generico tramite l'aggiunta di un tipo di parametro T usando il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo). Il parametro di tipo viene usato come tipo di parametro del metodo e anche come tipo restituito. La definizione di metodo generico non ha un corpo e il tipo di inclusione non è stato completato. Il <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo viene quindi utilizzato per creare il metodo costruito `M<String>` (`M(Of String)` in Visual Basic). Il codice di esempio dispone di alcun output, in quanto la sottoclasse di <xref:System.Reflection.MethodInfo> restituito dal <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo non consente la reflection sui relativi parametri.  
  
> [!NOTE]
>  Per un altro esempio di codice che usa <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, vedere <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> viene inoltre ampiamente usato quando si crea il codice che usa i tipi generici. Visualizzare [procedura: definire un metodo generico tramite Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera l'handle interno per il metodo. Questo handle consente di accedere all'handle dei metadati sottostanti.</summary>
        <value>Sola lettura. Handle interno per il metodo. Questo handle consente di accedere all'handle dei metadati sottostanti.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato. Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="P:System.Reflection.MethodBase.MethodHandle" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.MethodBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo in cui è definito il metodo corrente.</summary>
        <value>Classe <see cref="T:System.Reflection.Module" /> in cui viene definito il membro rappresentato dalla classe <see cref="T:System.Reflection.MemberInfo" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per praticità. È equivalente all'uso di <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> proprietà da ottenere il tipo in cui viene dichiarato il metodo e quindi chiamando il <xref:System.Type.Module%2A> proprietà dell'oggetto risultante <xref:System.Type> oggetto.  
  
 Questa proprietà è equivalente alla chiamata anche <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.MethodBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera il nome di questo metodo.</summary>
        <value>Sola lettura. Recupera una stringa che contiene il nome semplice di questo metodo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la classe usata nella reflection per ottenere l'oggetto.</summary>
        <value>Sola lettura. Tipo usato per ottenere questo metodo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.ParameterInfo" /> contenente informazioni sul tipo restituito dal metodo, ad esempio se il tipo restituito contiene modificatori personalizzati.</summary>
        <value>Oggetto <see cref="T:System.Reflection.ParameterInfo" /> contenente informazioni relative al tipo restituito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compilatore progettisti possono usare il <xref:System.Reflection.ParameterInfo> oggetto restituito da questa proprietà per individuare se personalizzato modificatori, ad esempio <xref:Microsoft.VisualC.IsConstModifier>, sono stati applicati al tipo restituito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo dichiarante non è stato creato.</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo restituito del metodo rappresentato da questo oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
        <value>Tipo restituito del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partire da .NET Framework 2.0 e .NET Compact Framework 2.0, questo membro viene ereditato dalla classe di base, <xref:System.Reflection.MethodInfo>. Vedere <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce gli attributi personalizzati del tipo restituito del metodo.</summary>
        <value>Sola lettura. Attributi personalizzati del tipo restituito del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce sempre `null`. Ottenere il <xref:System.Reflection.MethodInfo> dopo la contenente <xref:System.Type> è stato creato e richiamato <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> sul <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta un attributo personalizzato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="methodBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Un'istanza di una classe helper per descrivere l'attributo personalizzato.</param>
        <summary>Imposta un attributo personalizzato usando un generatore di attributi personalizzati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo può interagire con il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo quando i due metodi vengono usati in combinazione. Vedere la sezione Osservazioni del <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo per i dettagli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="methodBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Costruttore dell'attributo personalizzato.</param>
        <param name="binaryAttribute">BLOB di byte che rappresenta gli attributi.</param>
        <summary>Imposta un attributo personalizzato usando un BLOB di attributi personalizzati specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni dettagliate su come formattare `binaryAttribute`, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo può interagire con il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo quando i due metodi vengono usati in combinazione. Vedere la sezione Osservazioni del <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo per i dettagli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> o <paramref name="binaryAttribute" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="methodBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Flag di implementazione da impostare.</param>
        <summary>Imposta i flag di implementazione per il metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si usa il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo in combinazione con il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> (metodo), tenere presenti le interazioni potenziali. Ad esempio, usando il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo per aggiungere il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo anche set il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag. Se successivamente si chiama il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo, il <xref:System.Reflection.MethodImplAttributes.PreserveSig> flag viene sovrascritto. Esistono due modi per evitare questo problema:  
  
-   Chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo prima di chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> (metodo). Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo rispetta sempre flag di implementazione di metodo esistente.  
  
-   Quando si imposta flag di implementazione, chiamare il <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> metodo per recuperare i flag esistenti, usare OR bit per bit o per aggiungere il flag e quindi chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetImplementationFlags` metodo per descrivere l'implementazione di codice MSIL in un corpo del metodo.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberSignature Language="F#" Value="member this.SetMarshal : System.Reflection.Emit.UnmanagedMarshal -&gt; unit" Usage="methodBuilder.SetMarshal unmanagedMarshal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">Informazioni di marshalling per il tipo restituito del metodo.</param>
        <summary>Imposta le informazioni di marshalling per il tipo restituito del metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetMarshal` metodo per effettuare il marshalling i risultati di una chiamata al metodo come un tipo diverso.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="methodBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">Matrice che contiene istruzioni MSIL valide.</param>
        <param name="maxStack">Profondità massima di valutazione dello stack.</param>
        <param name="localSignature">Matrice di byte che contiene la struttura di variabile locale serializzata. Specifica <see langword="null" /> se il metodo non ha variabili locali.</param>
        <param name="exceptionHandlers">Raccolta contenente i gestori di eccezioni per il metodo. Specifica <see langword="null" /> se il metodo non ha gestori di eccezioni.</param>
        <param name="tokenFixups">Raccolta di valori che rappresentano gli offset in <c>il</c>, ciascuno dei quali specifica l'inizio di un token che può essere modificato. Specifica <see langword="null" /> se il metodo non ha token da modificare.</param>
        <summary>Crea il corpo del metodo usando una matrice di byte specificata di istruzioni Microsoft Intermediate Language (MSIL).</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="il" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStack" /> è negativo.  
  
oppure 
Uno degli oggetti <paramref name="exceptionHandlers" /> specifica un offset all'esterno di <paramref name="il" />.  
  
oppure 
Uno degli oggetti <paramref name="tokenFixups" /> specifica un offset all'esterno della matrice <paramref name="il" /> .</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo che lo contiene è stato creato in precedenza utilizzando il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Il metodo è stato chiamato in precedenza su questo oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.SetParameters : Type[] -&gt; unit" Usage="methodBuilder.SetParameters parameterTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i tipi di parametro.</param>
        <summary>Imposta il numero e i tipi di parametri per un metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il numero e tipi dei parametri sono noto quando il metodo è definito, possono essere impostate utilizzando un overload del <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo che accetta una matrice di tipi di parametro. Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito. Utilizzare questo metodo per impostare i tipi di parametro in questo caso.  
  
 Se il tipo restituito ha modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:System.Runtime.CompilerServices.IsConst>, usare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> overload del metodo.  
  
 Chiamare questo metodo sostituisce i tipi di parametri che sono stati impostati mediante il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per rendere un metodo generico. Il <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodo viene usato per assegnare il parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico. Il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> metodo viene usato per assegnare il metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico. Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberSignature Language="F#" Value="member this.SetReturnType : Type -&gt; unit" Usage="methodBuilder.SetReturnType returnType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo restituito del metodo.</param>
        <summary>Imposta il tipo restituito del metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per impostare il tipo restituito di un metodo generico, quando viene specificato il tipo restituito da uno dei parametri di tipo generico del metodo. Se il tipo restituito ha modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:System.Runtime.CompilerServices.IsConst>, usare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> overload del metodo.  
  
 Chiamare questo metodo sostituisce un tipo restituito stabilito utilizzando il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per rendere un metodo generico. Il <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodo viene usato per assegnare il parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico. Il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> metodo viene usato per assegnare il metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico. Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">Procedura: definire un metodo generico tramite reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.SetSignature : Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; unit" Usage="methodBuilder.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo restituito del metodo.</param>
        <param name="returnTypeRequiredCustomModifiers">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo. Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo. Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</param>
        <param name="parameterTypes">Tipi dei parametri del metodo.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matrice di matrici di tipi. Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi. Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matrice di matrici di tipi. Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi. Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</param>
        <summary>Imposta la firma del metodo, incluso il tipo restituito, i tipi di parametro e i modificatori personalizzati obbligatori e facoltativi del tipo restituito e dei tipi di parametro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il tipo restituito e il numero e tipi dei parametri sono noto quando viene definito il metodo, può essere stabilite utilizzando un overload del <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo che accetta una matrice di tipi di parametro. Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito. Utilizzare questo metodo per impostare i tipi di parametro in questo caso.  
  
 Se il tipo restituito né i tipi di parametro dispone di modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:Microsoft.VisualC.IsConstModifier>, è possibile usare il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> e <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodi.  
  
 Chiamare questo metodo sostituisce i parametri e tipo restituito stabilita utilizzando il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente contiene il codice sorgente per una classe generica denominato Sample con un parametro di tipo `T`. La classe dispone di un campo denominato `Field`, di tipo `T`e un metodo generico `GM` con il proprio parametro di tipo `U`. Metodo `GM` crea un'istanza di esempio, sostituendo il parametro di tipo `U` per il parametro di tipo di esempio e archivia il parametro di input in `Field`. Questo codice sorgente viene compilato ma non usato; è possibile visualizzarla con il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)e confrontarlo con il codice generato dalla classe `Example`.  
  
 Il codice nella classe `Example` viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> metodo per creare codice generico. Il `Main` metodo della classe `Example` crea un assembly dinamico che contiene una classe denominata `Sample`e Usa le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metodo per renderla generico aggiungendo un parametro di tipo denominato `T`. Un costruttore predefinito e un campo denominato `Field`, di tipo `T`, vengono aggiunti alla classe `Sample`. Un metodo `GM` viene aggiunto e trasformato in un metodo generico tramite le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo). Il parametro di tipo `GM` denominato `U`. Una volta definito il parametro di tipo, la firma dei `GM` venga aggiunto mediante il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> (metodo). È presente alcun tipo restituito e nessun modificatore obbligatorio o personalizzato, in modo che tutti i parametri del metodo siano `null` eccetto `parameterTypes`, che imposta il tipo dell'unico parametro del metodo; è impostato su parametro di tipo del metodo, `U`. Il corpo del metodo crea un'istanza del tipo costruito `Sample<U>` (`Sample(Of U)` in Visual Basic), assegna il parametro del metodo per `Field`e quindi stampato il valore di `Field`. Viene definito un tipo fittizio, per contenere il metodo del punto di ingresso `Main`. Nel corpo della `Main`, il metodo statico `GM` metodo viene richiamato sul tipo generico costruito `Sample<int>` (`Sample(Of Integer)` in Visual Basic), con il tipo <xref:System.String> sostituito `U`. Il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> metodo viene utilizzato per creare un <xref:System.Reflection.MethodInfo> per il metodo statico `GM` metodo del tipo generico costruito `Sample<U>`e il <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metodo viene quindi utilizzato per creare un <xref:System.Reflection.MethodInfo> che possono emessi in una chiamata al metodo.  
  
 Quando viene eseguito l'esempio di codice, Salva l'assembly generato come TypeBuilderGetFieldExample.exe. È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per confrontare il codice generato con il codice per il `Sample` classe che viene compilato nell'esempio di codice.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico. Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="methodBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'attributo personalizzato simbolico.</param>
        <param name="data">BLOB di byte che rappresenta il valore dell'attributo personalizzato simbolico.</param>
        <summary>Imposta un attributo personalizzato simbolico usando un BLOB.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'attributo personalizzato di metadati, questo attributo personalizzato è associato a un writer di simboli.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetSymCustomAttribute` metodo per impostare i valori di byte per il nome e la chiave di un attributo personalizzato associato a un metodo.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
oppure 
Il modulo che contiene il metodo non è un modulo di debug.  
  
oppure 
Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la firma del metodo.</summary>
        <value>Sola lettura. Oggetto String contenente la firma del metodo ottenuto mediante reflection dall'istanza di <see langword="MethodBase" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="methodBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce questa istanza di <see langword="MethodBuilder" /> come stringa.</summary>
        <returns>Restituisce una stringa che contiene il nome, gli attributi, la firma, le eccezioni e la firma locale del metodo, seguiti dal flusso MSIL (Microsoft Intermediate Language) corrente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>