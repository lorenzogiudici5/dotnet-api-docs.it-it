<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7340649aca6e8cf6ed3ffde1f98df8cddd7e22ab" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48749560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo&#xA;    interface _MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ebec6-101">Definisce e rappresenta un metodo (o costruttore) di una classe dinamica.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ebec6-101">Defines and represents a method (or constructor) on a dynamic class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-102">Il <xref:System.Reflection.Emit.MethodBuilder> classe viene utilizzata per descrivere completamente un metodo in Microsoft intermediate language (MSIL), incluso il corpo di nome, attributi, firma e metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-102">The <xref:System.Reflection.Emit.MethodBuilder> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</span></span> <span data-ttu-id="ebec6-103">Viene usato in combinazione con il <xref:System.Reflection.Emit.TypeBuilder> classe per creare le classi in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-103">It is used in conjunction with the <xref:System.Reflection.Emit.TypeBuilder> class to create classes at runtime.</span></span>  
  
## <a name="global-methods-and-methods-as-type-members"></a><span data-ttu-id="ebec6-104">I metodi globali e i metodi come membri di tipo</span><span class="sxs-lookup"><span data-stu-id="ebec6-104">Global methods and methods as type members</span></span>  
 <span data-ttu-id="ebec6-105">È possibile usare la reflection emit per definire i metodi globali e per definire metodi come membri dei tipi.</span><span class="sxs-lookup"><span data-stu-id="ebec6-105">You can use reflection emit to define global methods and to define methods as type members.</span></span> <span data-ttu-id="ebec6-106">Le API che definiscono i metodi restituiscono <xref:System.Reflection.Emit.MethodBuilder> oggetti.</span><span class="sxs-lookup"><span data-stu-id="ebec6-106">The APIs that define methods return <xref:System.Reflection.Emit.MethodBuilder> objects.</span></span>  
  
### <a name="global-methods"></a><span data-ttu-id="ebec6-107">Metodi globali</span><span class="sxs-lookup"><span data-stu-id="ebec6-107">Global methods</span></span>  
 <span data-ttu-id="ebec6-108">Un metodo globale viene definito mediante il <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> metodo, che restituisce un **MethodBuilder** oggetto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-108">A global method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> method, which returns a **MethodBuilder** object.</span></span>  
  
 <span data-ttu-id="ebec6-109">I metodi globali devono essere statici.</span><span class="sxs-lookup"><span data-stu-id="ebec6-109">Global methods must be static.</span></span> <span data-ttu-id="ebec6-110">Se un modulo dinamico contiene i metodi globali, la <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> metodo deve essere chiamato prima di renderli persistenti il modulo dinamico o l'assembly dinamico che contiene, perché common language runtime la correzione del modulo dinamico finché tutte le funzioni globali sono stati definiti.</span><span class="sxs-lookup"><span data-stu-id="ebec6-110">If a dynamic module contains global methods, the <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</span></span>  
  
 <span data-ttu-id="ebec6-111">Un metodo nativo globale viene definito usando la <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-111">A global native method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ebec6-112">Platform invoke (PInvoke) metodi non devono essere dichiarati astratta o virtuale.</span><span class="sxs-lookup"><span data-stu-id="ebec6-112">Platform invoke (PInvoke) methods must not be declared abstract or virtual.</span></span> <span data-ttu-id="ebec6-113">I set di runtime il <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> attributo per una piattaforma metodo invoke.</span><span class="sxs-lookup"><span data-stu-id="ebec6-113">The runtime sets the <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> attribute for a platform invoke method.</span></span>  
  
### <a name="methods-as-members-of-types"></a><span data-ttu-id="ebec6-114">Metodi come membri dei tipi</span><span class="sxs-lookup"><span data-stu-id="ebec6-114">Methods as members of types</span></span>  
 <span data-ttu-id="ebec6-115">Un metodo è definito come un membro del tipo tramite il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo, che restituisce un <xref:System.Reflection.Emit.MethodBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-115">A method is defined as a type member by using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.MethodBuilder> object.</span></span>  
  
 <span data-ttu-id="ebec6-116">Il <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> metodo viene utilizzato per impostare gli attributi nome e il parametro di un parametro o del valore restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-116">The <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> method is used to set the name and parameter attributes of a parameter, or of the return value.</span></span> <span data-ttu-id="ebec6-117">Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto restituito da questo metodo rappresenta un parametro o valore restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-117">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method represents a parameter or the return value.</span></span> <span data-ttu-id="ebec6-118">Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto può essere utilizzato per impostare il marshalling, impostare il valore costante e per applicare gli attributi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="ebec6-118">The <xref:System.Reflection.Emit.ParameterBuilder> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="ebec6-119">Attributi</span><span class="sxs-lookup"><span data-stu-id="ebec6-119">Attributes</span></span>  
 <span data-ttu-id="ebec6-120">I membri del <xref:System.Reflection.MethodAttributes> enumerazione definire il carattere preciso di un metodo dinamico:</span><span class="sxs-lookup"><span data-stu-id="ebec6-120">Members of the <xref:System.Reflection.MethodAttributes> enumeration define the precise character of a dynamic method:</span></span>  
  
-   <span data-ttu-id="ebec6-121">I metodi statici vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-121">Static methods are specified using the <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="ebec6-122">I metodi finali (che non può essere sottoposto a override) vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-122">Final methods (methods that cannot be overridden) are specified using the <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="ebec6-123">Metodi virtuali vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-123">Virtual methods are specified using the <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="ebec6-124">I metodi astratti vengono specificati utilizzando il <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-124">Abstract methods are specified using the <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="ebec6-125">Diversi attributi determinano la visibilità di metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-125">Several attributes determine method visibility.</span></span> <span data-ttu-id="ebec6-126">Vedere la descrizione del <xref:System.Reflection.MethodAttributes> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-126">See the description of the <xref:System.Reflection.MethodAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="ebec6-127">I metodi che implementano gli operatori di overload è necessario impostare il <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-127">Methods that implement overloaded operators must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="ebec6-128">I finalizzatori devono impostare il <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-128">Finalizers must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="ebec6-129">Problemi noti</span><span class="sxs-lookup"><span data-stu-id="ebec6-129">Known Issues</span></span>  
  
-   <span data-ttu-id="ebec6-130">Sebbene <xref:System.Reflection.Emit.MethodBuilder> deriva dal <xref:System.Reflection.MethodInfo>, alcuni dei metodi astratti definiti nel <xref:System.Reflection.MethodInfo> classe non sono completamente implementate in <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-130">Although <xref:System.Reflection.Emit.MethodBuilder> is derived from <xref:System.Reflection.MethodInfo>, some of the abstract methods defined in the <xref:System.Reflection.MethodInfo> class are not fully implemented in <xref:System.Reflection.Emit.MethodBuilder>.</span></span> <span data-ttu-id="ebec6-131">Questi <xref:System.Reflection.Emit.MethodBuilder> metodi generano la <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-131">These <xref:System.Reflection.Emit.MethodBuilder> methods throw the <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="ebec6-132">Ad esempio il <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> metodo non è completamente implementato.</span><span class="sxs-lookup"><span data-stu-id="ebec6-132">For example the <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> method is not fully implemented.</span></span> <span data-ttu-id="ebec6-133">È possibile riflettere su questi metodi mediante il recupero del tipo contenitore usando il <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="ebec6-133">You can reflect on these methods by retrieving the enclosing type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="ebec6-134">I modificatori personalizzati sono supportati a partire da .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="ebec6-134">Custom modifiers are supported starting with the .NET Framework version 2.0.</span></span> <span data-ttu-id="ebec6-135">Non sono supportati nelle versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="ebec6-135">They are not supported in earlier versions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-136">L'esempio seguente usa il <xref:System.Reflection.Emit.MethodBuilder> classe per creare un metodo all'interno di un tipo dinamico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-136">The following example uses the <xref:System.Reflection.Emit.MethodBuilder> class to create a method within a dynamic type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="methodBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="ebec6-137">Azione di sicurezza da eseguire, ad esempio Demand, Assert e così via.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-137">The security action to be taken (Demand, Assert, and so on).</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="ebec6-138">Set di autorizzazioni a cui viene applicata l'azione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-138">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-139">Aggiunge sicurezza dichiarativa a questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-139">Adds declarative security to this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> può essere chiamato più volte, specificando un'azione di sicurezza a ogni chiamata (ad esempio `Demand`, `Assert`, e `Deny`) e un set di autorizzazioni che si applica l'azione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> can be called several times, with each call specifying a security action (such as `Demand`, `Assert`, and `Deny`) and a set of permissions that the action applies to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-141">Nelle versioni .NET Framework 1.0, 1.1 e 2.0, gli attributi di sicurezza dichiarativa applicati a un metodo tramite la <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> metodo vengono archiviate nel vecchio formato XML dei metadati.</span><span class="sxs-lookup"><span data-stu-id="ebec6-141">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> method are stored in the old XML metadata format.</span></span> <span data-ttu-id="ebec6-142">Vedere Creazione di attributi di sicurezza dichiarativa.</span><span class="sxs-lookup"><span data-stu-id="ebec6-142">See Emitting Declarative Security Attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-143">Esempio di codice seguente viene illustrato l'utilizzo contestuale di `AddDeclarativeSecurity` per richiedere che il chiamante di un metodo per disporre di autorizzazioni senza restrizioni.</span><span class="sxs-lookup"><span data-stu-id="ebec6-143">The code sample below illustrates the contextual use of `AddDeclarativeSecurity` to require the caller of a method to have unrestricted permissions.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ebec6-144">Il parametro <paramref name="action" /> non è valido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> e <see langword="RequestRefuse" /> non sono validi).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-144">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-145">Il tipo contenitore è stato creato usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-145">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-146">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-146">-or-</span>
          </span>
          <span data-ttu-id="ebec6-147">Il set di autorizzazioni <paramref name="pset" /> contiene un'azione aggiunta in precedenza mediante <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-147">The permission set <paramref name="pset" /> contains an action that was added earlier by <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.</span>
          </span>
          <span data-ttu-id="ebec6-148">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-148">-or-</span>
          </span>
          <span data-ttu-id="ebec6-149">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-149">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ebec6-150">
            <paramref name="pset" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-150">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-151">Recupera gli attributi per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-151">Retrieves the attributes for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-152">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-152">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-153">Recupera l'oggetto <see langword="MethodAttributes" /> per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-153">Retrieves the <see langword="MethodAttributes" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-154">Restituisce la convenzione di chiamata del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-154">Returns the calling convention of the method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-155">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-155">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-156">Convenzione di chiamata del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-156">The calling convention of the method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-157">Non supportato per questo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-157">Not supported for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-158">Non supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-158">Not supported.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-159">Oggetto <xref:System.Reflection.Emit.MethodBuilder> rappresenta sempre una definizione di metodo generico e pertanto non può essere richiamata.</span><span class="sxs-lookup"><span data-stu-id="ebec6-159">A <xref:System.Reflection.Emit.MethodBuilder> always represents a generic method definition, and thus cannot be invoked.</span></span>  
  
 <span data-ttu-id="ebec6-160">Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-160">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ebec6-161">Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-161">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-162">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-162">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodBody : byte[] * int -&gt; unit" Usage="methodBuilder.CreateMethodBody (il, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">
          <span data-ttu-id="ebec6-163">Matrice che contiene istruzioni MSIL valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-163">An array containing valid MSIL instructions.</span>
          </span>
          <span data-ttu-id="ebec6-164">Se questo parametro è <see langword="null" />, il corpo del metodo viene cancellato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-164">If this parameter is <see langword="null" />, the method's body is cleared.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="ebec6-165">Numero di byte validi nella matrice MSIL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-165">The number of valid bytes in the MSIL array.</span>
          </span>
          <span data-ttu-id="ebec6-166">Questo valore viene ignorato se MSIL è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-166">This value is ignored if MSIL is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-167">Crea il corpo del metodo usando una matrice di byte fornita di istruzioni Microsoft Intermediate Language (MSIL).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-167">Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-168">Questo metodo crea il corpo del metodo da `il`, una matrice che contiene istruzioni MSIL come codici operativi.</span><span class="sxs-lookup"><span data-stu-id="ebec6-168">This method creates the method's body from `il`, an array containing MSIL instructions as opcodes.</span></span> <span data-ttu-id="ebec6-169">Il numero di byte di codice MSIL valido è dato dal conteggio.</span><span class="sxs-lookup"><span data-stu-id="ebec6-169">The number of bytes of valid MSIL is given by count.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-170">Ciò non è completamente supportato.</span><span class="sxs-lookup"><span data-stu-id="ebec6-170">This is currently not fully supported.</span></span> <span data-ttu-id="ebec6-171">Non è possibile specificare il percorso del token correzioni e i gestori di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="ebec6-171">The user cannot supply the location of token fix ups and exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-172">Nell'esempio riportato di seguito, viene generato un metodo semplice che aggiunge due numeri interi tramite codice operativo usando `CreateMethodBody`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-172">In the example provided below, a simple method that adds two integers is generated via opcode using `CreateMethodBody`.</span></span>  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ebec6-173">Il <paramref name="count" /> non è compreso nell'intervallo di indici della matrice di istruzioni MSIL e <paramref name="il" /> non è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-173">The <paramref name="count" /> is not within the range of indexes of the supplied MSIL instruction array and <paramref name="il" /> is not <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-174">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-174">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-175">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-175">-or-</span>
          </span>
          <span data-ttu-id="ebec6-176">Questo metodo è stato chiamato in precedenza su questo <see langword="MethodBuilder" /> con un argomento <paramref name="il" /> che non era <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-176">This method was called previously on this <see langword="MethodBuilder" /> with an <paramref name="il" /> argument that was not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ebec6-177">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-177">-or-</span>
          </span>
          <span data-ttu-id="ebec6-178">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-178">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-179">Restituisce il tipo che dichiara il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-179">Returns the type that declares this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-180">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-180">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-181">Tipo che dichiara il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-181">The type that declares this method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-182">Il codice seguente illustra l'uso del `Type` proprietà.</span><span class="sxs-lookup"><span data-stu-id="ebec6-182">The following code illustrates the use of the `Type` property.</span></span>  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="methodBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="ebec6-183">Matrice di stringhe che rappresentano i nomi dei parametri di tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-183">An array of strings that represent the names of the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-184">Imposta il numero dei parametri di tipo generico per il metodo corrente, specificandone i nomi, e restituisce una matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che possono essere usati per definire i vincoli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-184">Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-185">Matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo del metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-185">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters of the generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-186">La chiamata di <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo rende il metodo corrente generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-186">Calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method makes the current method generic.</span></span> <span data-ttu-id="ebec6-187">Non è possibile annullare questa operazione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-187">There is no way to undo this change.</span></span> <span data-ttu-id="ebec6-188">Chiamando questo metodo un secondo momento, un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-188">Calling this method a second time causes an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="ebec6-189">I parametri di tipo del metodo generico possono essere recuperati in un secondo momento tramite il <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-189">The type parameters of the generic method can be retrieved later by using the <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> method.</span></span>  
  
 <span data-ttu-id="ebec6-190">Per convenzione, un nome di parametro di tipo è una singola lettera maiuscola.</span><span class="sxs-lookup"><span data-stu-id="ebec6-190">By convention, a type parameter name is a single uppercase letter.</span></span>  
  
 <span data-ttu-id="ebec6-191">Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-191">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ebec6-192">Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-192">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-193">Esempio di codice seguente crea un tipo dinamico, `DemoType`, che contiene il metodo generico dinamico `DemoMethod`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-193">The following code example creates a dynamic type, `DemoType`, which contains the dynamic generic method `DemoMethod`.</span></span> <span data-ttu-id="ebec6-194">Questo metodo ha due parametri di tipo generico, una delle quali viene utilizzata come parametro e l'altro come tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-194">This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</span></span>  
  
 <span data-ttu-id="ebec6-195">Quando il codice viene eseguito, l'assembly dinamico viene salvato come DemoGenericMethod1.dll e può essere esaminato mediante lo strumento [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="ebec6-195">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-196">Questo esempio di codice genera il corpo di un metodo semplice che restituisce semplicemente un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="ebec6-196">This code example generates a simple method body that merely returns a null reference.</span></span> <span data-ttu-id="ebec6-197">Per un esempio di codice con un corpo di un metodo completamente sviluppato più che crea e Usa i tipi generici, vedere [procedura: definire un metodo generico tramite Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="ebec6-197">For a code example with a more fully developed method body that creates and uses generic types, see [How to: Define a Generic Method with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-198">Parametri di tipo generico sono già stati definiti per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-198">Generic type parameters have already been defined for this method.</span>
          </span>
          <span data-ttu-id="ebec6-199">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-199">-or-</span>
          </span>
          <span data-ttu-id="ebec6-200">Il metodo è già stato completato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-200">The method has been completed already.</span>
          </span>
          <span data-ttu-id="ebec6-201">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-201">-or-</span>
          </span>
          <span data-ttu-id="ebec6-202">Il metodo <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> è stato chiamato per il metodo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-202">The <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> method has been called for the current method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ebec6-203">
            <paramref name="names" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-203">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ebec6-204">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-204">-or-</span>
          </span>
          <span data-ttu-id="ebec6-205">Un elemento di <paramref name="names" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-205">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ebec6-206">
            <paramref name="names" /> è una matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-206">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-207">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-207">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="methodBuilder.DefineParameter (position, attributes, strParamName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="ebec6-208">Posizione del parametro nell'elenco dei parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-208">The position of the parameter in the parameter list.</span>
          </span>
          <span data-ttu-id="ebec6-209">I parametri vengono indicizzati a partire dal numero 1 per il primo parametro. Il numero 0 rappresenta il valore restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-209">Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="ebec6-210">Attributi del parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-210">The parameter attributes of the parameter.</span>
          </span>
        </param>
        <param name="strParamName">
          <span data-ttu-id="ebec6-211">Nome del parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-211">The name of the parameter.</span>
          </span>
          <span data-ttu-id="ebec6-212">Il nome può essere rappresentato dalla stringa null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-212">The name can be the null string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-213">Imposta gli attributi del parametro e il nome di un parametro di questo metodo oppure del valore restituito di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-213">Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</span>
          </span>
          <span data-ttu-id="ebec6-214">Restituisce un oggetto ParameterBuilder che può essere usato per applicare attributi personalizzati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-214">Returns a ParameterBuilder that can be used to apply custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-215">Restituisce un oggetto <see langword="ParameterBuilder" /> che rappresenta un parametro o il valore restituito di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-215">Returns a <see langword="ParameterBuilder" /> object that represents a parameter of this method or the return value of this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-216">Il <xref:System.Reflection.Emit.ParameterBuilder> oggetto restituito da questo metodo può essere utilizzato per impostare il valore predefinito per un parametro o per applicare gli attributi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="ebec6-216">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</span></span>  
  
 <span data-ttu-id="ebec6-217">Parametro la numerazione inizia da 1, pertanto `position` è 1 per il primo parametro.</span><span class="sxs-lookup"><span data-stu-id="ebec6-217">Parameter numbering begins with 1, so `position` is 1 for the first parameter.</span></span> <span data-ttu-id="ebec6-218">Se `position` è uguale a zero, questo metodo influisce sul valore restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-218">If `position` is zero, this method affects the return value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-219">Nelle versioni 1.0 e 1.1 di .NET Framework, viene generata un'eccezione se `position` è uguale a zero, pertanto questo metodo non può essere utilizzato per modificare gli attributi del valore restituito in queste versioni.</span><span class="sxs-lookup"><span data-stu-id="ebec6-219">In the .NET Framework versions 1.0 and 1.1, an exception is thrown if `position` is zero, so this method cannot be used to modify attributes of the return value in those versions.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ebec6-220">Il metodo non ha parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-220">The method has no parameters.</span>
          </span>
          <span data-ttu-id="ebec6-221">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-221">-or-</span>
          </span>
          <span data-ttu-id="ebec6-222">
            <paramref name="position" /> è minore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-222">
              <paramref name="position" /> is less than zero.</span>
          </span>
          <span data-ttu-id="ebec6-223">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-223">-or-</span>
          </span>
          <span data-ttu-id="ebec6-224">
            <paramref name="position" /> è maggiore del numero dei parametri del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-224">
              <paramref name="position" /> is greater than the number of the method's parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-225">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-225">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-226">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-226">-or-</span>
          </span>
          <span data-ttu-id="ebec6-227">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-227">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ebec6-228">Oggetto da confrontare con questa istanza di <see langword="MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-228">The object to compare with this <see langword="MethodBuilder" /> instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-229">Determina se l'oggetto specificato è uguale a questa istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-229">Determines whether the given object is equal to this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-230">
            <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see langword="MethodBuilder" /> ed è uguale a questo oggetto; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-230">
              <see langword="true" /> if <paramref name="obj" /> is an instance of <see langword="MethodBuilder" /> and is equal to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-231">L'uguaglianza è determinata dall'aventi lo stesso nome, attributi e firma.</span><span class="sxs-lookup"><span data-stu-id="ebec6-231">Equality is determined by having the same name, attributes, and signature.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-232">Restituisce l'implementazione di base per un metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-232">Return the base implementation for a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-233">Implementazione di base di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-233">The base implementation of this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-234">Viene sempre restituito corrente `MethodBuilder` oggetto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-234">This always returns the current `MethodBuilder` object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-235">Restituisce gli attributi personalizzati definiti per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-235">Returns the custom attributes defined for this method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="ebec6-236">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-236">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-237">Restituisce tutti gli attributi personalizzati definiti per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-237">Returns all the custom attributes defined for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-238">Restituisce una matrice di oggetti che rappresentano tutti gli attributi personalizzati di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-238">Returns an array of objects representing all the custom attributes of this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-239">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-239">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-240">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-240">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="ebec6-241">Tipo di attributo personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-241">The custom attribute type.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="ebec6-242">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-242">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-243">Restituisce gli attributi personalizzati identificati dal tipo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-243">Returns the custom attributes identified by the given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-244">Restituisce una matrice di oggetti che rappresenta gli attributi del metodo di tipo <paramref name="attributeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-244">Returns an array of objects representing the attributes of this method that are of type <paramref name="attributeType" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-245">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-245">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-246">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-246">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-247">Restituisce una matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo del metodo, se è generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-247">Returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that represent the type parameters of the method, if it is generic.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-248">Matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che rappresentano i parametri di tipo, se il metodo è generico, oppure <see langword="null" /> se il metodo non è generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-248">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters, if the method is generic, or <see langword="null" /> if the method is not generic.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-249">I parametri di tipo di un metodo generico vengono anche restituiti dai <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo utilizzato per definirle.</span><span class="sxs-lookup"><span data-stu-id="ebec6-249">The type parameters of a generic method also are returned by the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method that is used to define them.</span></span>  
  
 <span data-ttu-id="ebec6-250">Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-250">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ebec6-251">Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-251">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-252">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-252">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-253">Restituisce questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-253">Returns this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-254">L'istanza corrente di <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-254">The current instance of <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-255">Oggetto <xref:System.Reflection.Emit.MethodBuilder> non può essere usato per generare un metodo generico costruito direttamente.</span><span class="sxs-lookup"><span data-stu-id="ebec6-255">A <xref:System.Reflection.Emit.MethodBuilder> cannot be used to emit a constructed generic method directly.</span></span> <span data-ttu-id="ebec6-256">Il metodo creato è una definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-256">The emitted method is a generic method definition.</span></span>  
  
 <span data-ttu-id="ebec6-257">Per altre informazioni, vedere <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> e <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-257">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ebec6-258">Per informazioni su tipi generici, vedere <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-258">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-259">Il metodo corrente non è generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-259">The current method is not generic.</span>
          </span>
          <span data-ttu-id="ebec6-260">Quindi la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-260">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-261">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-261">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-262">Ottiene il codice hash per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-262">Gets the hash code for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-263">Codice hash per questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-263">The hash code for this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-264">Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-264">Returns an <see langword="ILGenerator" /> for this method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-265">Restituisce un oggetto <see langword="ILGenerator" /> per il metodo con una dimensione di flusso MSIL (Microsoft Intermediate Language) predefinita di 64 byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-265">Returns an <see langword="ILGenerator" /> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-266">Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-266">Returns an <see langword="ILGenerator" /> object for this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-267">Esempio di codice seguente illustra l'utilizzo contestuale del `GetILGenerator` metodo la creazione di un assembly dinamico che calcola il prodotto scalare di due punti nello spazio 3D.</span><span class="sxs-lookup"><span data-stu-id="ebec6-267">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-268">Il metodo non deve avere un corpo a causa del suo flag <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, ad esempio perché ha il flag <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-268">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span>
          </span>
          <span data-ttu-id="ebec6-269">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-269">-or-</span>
          </span>
          <span data-ttu-id="ebec6-270">Il metodo è un metodo generico, ma non una definizione di metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-270">The method is a generic method, but not a generic method definition.</span>
          </span>
          <span data-ttu-id="ebec6-271">Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-271">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">
          <span data-ttu-id="ebec6-272">Dimensioni del flusso MSIL in byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-272">The size of the MSIL stream, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-273">Restituisce un oggetto <see langword="ILGenerator" /> per il metodo con le dimensioni del flusso MSIL (Microsoft Intermediate Language) specificate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-273">Returns an <see langword="ILGenerator" /> for this method with the specified Microsoft intermediate language (MSIL) stream size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-274">Restituisce un oggetto <see langword="ILGenerator" /> per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-274">Returns an <see langword="ILGenerator" /> object for this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-275">Esempio di codice seguente illustra l'utilizzo contestuale del `GetILGenerator` metodo la creazione di un assembly dinamico che calcola il prodotto scalare di due punti nello spazio 3D.</span><span class="sxs-lookup"><span data-stu-id="ebec6-275">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-276">Il metodo non deve avere un corpo a causa del suo flag <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />, ad esempio perché ha il flag <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-276">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span>
          </span>
          <span data-ttu-id="ebec6-277">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-277">-or-</span>
          </span>
          <span data-ttu-id="ebec6-278">Il metodo è un metodo generico, ma non una definizione di metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-278">The method is a generic method, but not a generic method definition.</span>
          </span>
          <span data-ttu-id="ebec6-279">Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-279">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-280">Restituisce i flag di implementazione per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-280">Returns the implementation flags for the method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-281">Restituisce i flag di implementazione per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-281">Returns the implementation flags for the method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="methodBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-282">Restituisce un riferimento al modulo che contiene questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-282">Returns a reference to the module that contains this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-283">Restituisce un riferimento al modulo che contiene questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-283">Returns a reference to the module that contains this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-284">Il codice di esempio seguente viene illustrato l'utilizzo del `GetModule` metodo per recuperare informazioni su un modulo generato dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="ebec6-284">The sample code below illustrates the usage of the `GetModule` method to retrieve information about a dynamically-generated module.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-285">Restituisce il parametro del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-285">Returns the parameters of this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-286">Matrice di oggetti <see langword="ParameterInfo" /> che rappresentano i parametri del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-286">An array of <see langword="ParameterInfo" /> objects that represent the parameters of the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-287">Esempio di codice seguente illustra l'uso di `GetParameters` per individuare le informazioni sui parametri passati a un metodo generato dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="ebec6-287">The code sample below illustrates the use of `GetParameters` to discover information on the parameters passed to a dynamically-generated method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-288">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-288">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-289">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see langword="GetParameters" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-289">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see langword="GetParameters" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="methodBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-290">Restituisce l'oggetto <see langword="MethodToken" /> che rappresenta il token per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-290">Returns the <see langword="MethodToken" /> that represents the token for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-291">Restituisce l'oggetto <see langword="MethodToken" /> del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-291">Returns the <see langword="MethodToken" /> of this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-292">Ottiene o imposta un valore booleano che specifica se le variabili locali in questo metodo sono inizializzate su zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-292">Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</span>
          </span>
          <span data-ttu-id="ebec6-293">Il valore predefinito di questa proprietà è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-293">The default value of this property is <see langword="true" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-294">
            <see langword="true" /> se le variabili locali in questo metodo devono essere inizializzate su zero; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-294">
              <see langword="true" /> if the local variables in this method should be zero initialized; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-295">Se questa proprietà è impostata su `true`, il codice MSIL generato include l'inizializzazione delle variabili locali.</span><span class="sxs-lookup"><span data-stu-id="ebec6-295">If this property is set to `true`, the emitted MSIL includes initialization of local variables.</span></span> <span data-ttu-id="ebec6-296">Se è impostato su `false`, variabili locali non inizializzate e il codice generato non è verificabile.</span><span class="sxs-lookup"><span data-stu-id="ebec6-296">If it is set to `false`, local variables are not initialized and the generated code is unverifiable.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-297">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-297">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="ebec6-298">(Get o set).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-298">(Get or set.)</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ebec6-299">Oggetto su cui richiamare il metodo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-299">The object on which to invoke the specified method.</span>
          </span>
          <span data-ttu-id="ebec6-300">Se il metodo è statico, questo parametro verrà ignorato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-300">If the method is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="ebec6-301">È necessario che si tratti di un flag di bit richiamato dall'oggetto <see cref="T:System.Reflection.BindingFlags" />, ad esempio <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-301">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ebec6-302">Oggetto che consente l'associazione, la coercizione dei tipi, la chiamata dei membri e il recupero di oggetti MemberInfo tramite reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-302">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</span>
          </span>
          <span data-ttu-id="ebec6-303">Se il gestore di associazione è <see langword="null" />, verrà utilizzato il gestore di associazione predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-303">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="ebec6-304">Per informazioni dettagliate, vedere <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-304">For more details, see <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ebec6-305">Elenco di argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-305">An argument list.</span>
          </span>
          <span data-ttu-id="ebec6-306">Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-306">This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</span>
          </span>
          <span data-ttu-id="ebec6-307">In assenza di parametri, deve essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-307">If there are no parameters this should be <see langword="null" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="ebec6-308">Istanza di <see cref="T:System.Globalization.CultureInfo" /> usata per regolare la coercizione dei tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-308">An instance of <see cref="T:System.Globalization.CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="ebec6-309">Se è null, verrà utilizzato l'oggetto <see cref="T:System.Globalization.CultureInfo" /> per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-309">If this is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="ebec6-310">Questo è necessario, ad esempio, per convertire un valore <see cref="T:System.String" /> che rappresenta 1000 in un valore <see cref="T:System.Double" />, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-310">(Note that this is necessary to, for example, convert a <see cref="T:System.String" /> that represents 1000 to a <see cref="T:System.Double" /> value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-311">Richiama dinamicamente il metodo ottenuto mediante reflection da questa istanza sull'oggetto indicato, passando i parametri specificati e con i vincoli del binder indicato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-311">Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-312">Restituisce un oggetto che contiene il valore restituito del metodo richiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-312">Returns an object containing the return value of the invoked method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-313">Se il metodo è statico, il `obj` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="ebec6-313">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="ebec6-314">Per i metodi non statici, `obj` deve essere un'istanza di una classe che eredita o dichiara il metodo e deve essere dello stesso tipo questa classe.</span><span class="sxs-lookup"><span data-stu-id="ebec6-314">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="ebec6-315">Se il metodo non ha parametri, il valore di `parameters` deve essere `null`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-315">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="ebec6-316">In caso contrario, il numero, tipo e ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri per il metodo ottenuto mediante reflection da questa istanza.</span><span class="sxs-lookup"><span data-stu-id="ebec6-316">Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-317">Restrizioni di accesso vengono ignorate per il codice completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="ebec6-317">Access restrictions are ignored for fully-trusted code.</span></span> <span data-ttu-id="ebec6-318">Vale a dire, proprietà, metodi, campi e i costruttori privati sono accessibili e richiamato tramite Reflection, ogni volta che il codice è completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="ebec6-318">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-319">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-319">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-320">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-320">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="methodBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="ebec6-321">Tipo di attributo personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-321">The custom attribute type.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="ebec6-322">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-322">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-323">Controlla se il tipo di attributo personalizzato specificato è definito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-323">Checks if the specified custom attribute type is defined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-324">
            <see langword="true" /> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-324">
              <see langword="true" /> if the specified custom attribute type is defined; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-325">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-325">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-326">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-326">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-327">Ottiene un valore che indica se il metodo è un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-327">Gets a value indicating whether the method is a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-328">
            <see langword="true" /> se il metodo è generico; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-328">
              <see langword="true" /> if the method is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-329">Un metodo è generico se contiene parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-329">A method is generic if it has type parameters.</span></span> <span data-ttu-id="ebec6-330">È possibile rendere un metodo generica chiamando il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per aggiungere parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-330">You can make a method generic by calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to add type parameters.</span></span> <span data-ttu-id="ebec6-331">Questa modifica non può essere annullata.</span><span class="sxs-lookup"><span data-stu-id="ebec6-331">This change cannot be reversed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-332">Esempio di codice seguente visualizza lo stato di un metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-332">The following code example displays the status of a method.</span></span> <span data-ttu-id="ebec6-333">Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-333">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-334">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-334">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-335">Ottiene un valore che indica se l'oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> corrente rappresenta la definizione di un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-335">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-336">
            <see langword="true" /> se l'oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> corrente rappresenta la definizione di un metodo generico; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-336">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-337">Oggetto <xref:System.Reflection.Emit.MethodBuilder> utilizzabile solo per creare definizioni di metodo generico; non può essere usato per creare un metodo generico costruito direttamente.</span><span class="sxs-lookup"><span data-stu-id="ebec6-337">A <xref:System.Reflection.Emit.MethodBuilder> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</span></span> <span data-ttu-id="ebec6-338">Tuttavia, una sottoclasse di <xref:System.Reflection.Emit.MethodBuilder> potrebbe rappresentare un metodo generico costruito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-338">However, a subclass of <xref:System.Reflection.Emit.MethodBuilder> might represent a constructed generic method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-339">Esempio di codice seguente visualizza lo stato di un metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-339">The following code example displays the status of a method.</span></span> <span data-ttu-id="ebec6-340">Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-340">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-341">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-341">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-342">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-342">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-343">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-343">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-344">Per determinare se un metodo in un assembly dinamico è critico per la sicurezza, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-344">To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-345">In tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-345">In all cases.</span>
          </span>
          <span data-ttu-id="ebec6-346">Questa proprietà non è supportata in assembly dinamici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-346">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-347">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-347">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-348">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-348">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-349">Per determinare se un metodo in un assembly dinamico è security-safe-critical, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-349">To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-350">In tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-350">In all cases.</span>
          </span>
          <span data-ttu-id="ebec6-351">Questa proprietà non è supportata in assembly dinamici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-351">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-352">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-352">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-353">Genera un'eccezione <see cref="T:System.NotSupportedException" /> in tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-353">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-354">Per determinare se un metodo in un assembly dinamico è trasparente per la sicurezza, completare il tipo chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, chiamare il <xref:System.Type.GetMethod%2A> metodo sul tipo completata e get il <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> proprietà risultante <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-354">To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-355">In tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-355">In all cases.</span>
          </span>
          <span data-ttu-id="ebec6-356">Questa proprietà non è supportata in assembly dinamici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-356">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="ebec6-357">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo per il metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-357">An array of <see cref="T:System.Type" /> objects that represent the type arguments for the generic method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-358">Restituisce un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti tipo generico specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-358">Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-359">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti di tipo generico specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-359">A <see cref="T:System.Reflection.MethodInfo" /> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-360">Quando si sta generando codice dinamico, potrebbe essere necessario generare una chiamata a un metodo costruito dalla definizione di metodo generico rappresentata da un <xref:System.Reflection.Emit.MethodBuilder>, prima che il tipo di inclusione è stato completato.</span><span class="sxs-lookup"><span data-stu-id="ebec6-360">When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <xref:System.Reflection.Emit.MethodBuilder>, before the enclosing type has been completed.</span></span> <span data-ttu-id="ebec6-361">È possibile usare la <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo per creare un <xref:System.Reflection.MethodInfo> per tale metodo costruito e utilizzare il <xref:System.Reflection.MethodInfo> nella chiamata generata.</span><span class="sxs-lookup"><span data-stu-id="ebec6-361">You can use the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method to create a <xref:System.Reflection.MethodInfo> for such a constructed method, and use the <xref:System.Reflection.MethodInfo> in the emitted call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-362">Esempio di codice seguente crea un metodo costruito da una definizione di metodo generico incompleti in un tipo incompleto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-362">The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</span></span>  
  
 <span data-ttu-id="ebec6-363">L'esempio crea un assembly temporaneo e il modulo con un solo tipo, viene aggiunto un metodo `M`e rende il metodo generico tramite l'aggiunta di un tipo di parametro T usando il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-363">The example creates a transient assembly and module with a single type, adds a method `M`, and makes the method generic by adding a type parameter T using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="ebec6-364">Il parametro di tipo viene usato come tipo di parametro del metodo e anche come tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-364">The type parameter is used as the type of the method's parameter, and also as its return type.</span></span> <span data-ttu-id="ebec6-365">La definizione di metodo generico non ha un corpo e il tipo di inclusione non è stato completato.</span><span class="sxs-lookup"><span data-stu-id="ebec6-365">The generic method definition is not given a body, and the enclosing type is not completed.</span></span> <span data-ttu-id="ebec6-366">Il <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo viene quindi utilizzato per creare il metodo costruito `M<String>` (`M(Of String)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ebec6-366">The <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method is then used to make the constructed method `M<String>` (`M(Of String)` in Visual Basic).</span></span> <span data-ttu-id="ebec6-367">Il codice di esempio dispone di alcun output, in quanto la sottoclasse di <xref:System.Reflection.MethodInfo> restituito dal <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodo non consente la reflection sui relativi parametri.</span><span class="sxs-lookup"><span data-stu-id="ebec6-367">The example code has no output, because the subclass of <xref:System.Reflection.MethodInfo> returned by the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method does not allow reflection over its parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-368">Per un altro esempio di codice che usa <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, vedere <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-368">For another code example that uses <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, see <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>.</span></span> <span data-ttu-id="ebec6-369"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> viene inoltre ampiamente usato quando si crea il codice che usa i tipi generici.</span><span class="sxs-lookup"><span data-stu-id="ebec6-369"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> is also used extensively when emitting code that uses generic types.</span></span> <span data-ttu-id="ebec6-370">Visualizzare [procedura: definire un metodo generico tramite Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="ebec6-370">See [How to: Define a Generic Method with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-371">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-371">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-372">Recupera l'handle interno per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-372">Retrieves the internal handle for the method.</span>
          </span>
          <span data-ttu-id="ebec6-373">Questo handle consente di accedere all'handle dei metadati sottostanti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-373">Use this handle to access the underlying metadata handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-374">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-374">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-375">Handle interno per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-375">The internal handle for the method.</span>
          </span>
          <span data-ttu-id="ebec6-376">Questo handle consente di accedere all'handle dei metadati sottostanti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-376">Use this handle to access the underlying metadata handle.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ebec6-377">Questo metodo non è attualmente supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-377">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="ebec6-378">Recuperare il metodo usando <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> e chiamare <see cref="P:System.Reflection.MethodBase.MethodHandle" /> per l'oggetto <see cref="T:System.Reflection.MethodInfo" /> restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-378">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="P:System.Reflection.MethodBase.MethodHandle" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.MethodBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-379">Ottiene il modulo in cui è definito il metodo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-379">Gets the module in which the current method is being defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-380">Classe <see cref="T:System.Reflection.Module" /> in cui viene definito il membro rappresentato dalla classe <see cref="T:System.Reflection.MemberInfo" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-380">The <see cref="T:System.Reflection.Module" /> in which the member represented by the current <see cref="T:System.Reflection.MemberInfo" /> is being defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-381">Questa proprietà viene fornita per praticità.</span><span class="sxs-lookup"><span data-stu-id="ebec6-381">This property is provided as a convenience.</span></span> <span data-ttu-id="ebec6-382">È equivalente all'uso di <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> proprietà da ottenere il tipo in cui viene dichiarato il metodo e quindi chiamando il <xref:System.Type.Module%2A> proprietà dell'oggetto risultante <xref:System.Type> oggetto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-382">It is equivalent to using the <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> property to get the type in which the method is being declared, and then calling the <xref:System.Type.Module%2A> property of the resulting <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="ebec6-383">Questa proprietà è equivalente alla chiamata anche <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-383">This property is also equivalent to calling <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.MethodBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-384">Recupera il nome di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-384">Retrieves the name of this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-385">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-385">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-386">Recupera una stringa che contiene il nome semplice di questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-386">Retrieves a string containing the simple name of this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-387">Recupera la classe usata nella reflection per ottenere l'oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-387">Retrieves the class that was used in reflection to obtain this object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-388">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-388">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-389">Tipo usato per ottenere questo metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-389">The type used to obtain this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-390">Ottiene un oggetto <see cref="T:System.Reflection.ParameterInfo" /> contenente informazioni sul tipo restituito dal metodo, ad esempio se il tipo restituito contiene modificatori personalizzati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-390">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-391">Oggetto <see cref="T:System.Reflection.ParameterInfo" /> contenente informazioni relative al tipo restituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-391">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-392">Compilatore progettisti possono usare il <xref:System.Reflection.ParameterInfo> oggetto restituito da questa proprietà per individuare se personalizzato modificatori, ad esempio <xref:Microsoft.VisualC.IsConstModifier>, sono stati applicati al tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-392">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-393">Il tipo dichiarante non è stato creato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-393">The declaring type has not been created.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-394">Ottiene il tipo restituito del metodo rappresentato da questo oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-394">Gets the return type of the method represented by this <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-395">Tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-395">The return type of the method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ebec6-396">A partire da .NET Framework 2.0 e .NET Compact Framework 2.0, questo membro viene ereditato dalla classe di base, <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-396">Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="ebec6-397">Vedere <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-397">See <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-398">Restituisce gli attributi personalizzati del tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-398">Returns the custom attributes of the method's return type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-399">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-399">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-400">Attributi personalizzati del tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-400">The custom attributes of the method's return type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-401">Questo metodo restituisce sempre `null`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-401">This method always returns `null`.</span></span> <span data-ttu-id="ebec6-402">Ottenere il <xref:System.Reflection.MethodInfo> dopo la contenente <xref:System.Type> è stato creato e richiamato <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> sul <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="ebec6-402">Get the <xref:System.Reflection.MethodInfo> after the containing <xref:System.Type> has been created and invoked <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> on the <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-403">Imposta un attributo personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-403">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="methodBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="ebec6-404">Un'istanza di una classe helper per descrivere l'attributo personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-404">An instance of a helper class to describe the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-405">Imposta un attributo personalizzato usando un generatore di attributi personalizzati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-405">Sets a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-406">Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo può interagire con il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo quando i due metodi vengono usati in combinazione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-406">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="ebec6-407">Vedere la sezione Osservazioni del <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo per i dettagli.</span><span class="sxs-lookup"><span data-stu-id="ebec6-407">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ebec6-408">
            <paramref name="customBuilder" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-408">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-409">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-409">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="methodBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="ebec6-410">Costruttore dell'attributo personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-410">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="ebec6-411">BLOB di byte che rappresenta gli attributi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-411">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-412">Imposta un attributo personalizzato usando un BLOB di attributi personalizzati specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-412">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-413">Per informazioni dettagliate su come formattare `binaryAttribute`, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="ebec6-413">For details on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="ebec6-414">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="ebec6-414">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="ebec6-415">Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo può interagire con il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo quando i due metodi vengono usati in combinazione.</span><span class="sxs-lookup"><span data-stu-id="ebec6-415">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="ebec6-416">Vedere la sezione Osservazioni del <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo per i dettagli.</span><span class="sxs-lookup"><span data-stu-id="ebec6-416">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ebec6-417">
            <paramref name="con" /> o <paramref name="binaryAttribute" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-417">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-418">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-418">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="methodBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="ebec6-419">Flag di implementazione da impostare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-419">The implementation flags to set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-420">Imposta i flag di implementazione per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-420">Sets the implementation flags for this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-421">Quando si usa il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo in combinazione con il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> (metodo), tenere presenti le interazioni potenziali.</span><span class="sxs-lookup"><span data-stu-id="ebec6-421">When you use the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method in combination with the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method, be aware of potential interactions.</span></span> <span data-ttu-id="ebec6-422">Ad esempio, usando il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo per aggiungere il <xref:System.Runtime.InteropServices.DllImportAttribute> attributo anche set il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="ebec6-422">For example, using the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method to add the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute also sets the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ebec6-423">Se successivamente si chiama il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo, il <xref:System.Reflection.MethodImplAttributes.PreserveSig> flag viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="ebec6-423">If you subsequently call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method, the <xref:System.Reflection.MethodImplAttributes.PreserveSig> flag is overwritten.</span></span> <span data-ttu-id="ebec6-424">Esistono due modi per evitare questo problema:</span><span class="sxs-lookup"><span data-stu-id="ebec6-424">There are two ways to avoid this:</span></span>  
  
-   <span data-ttu-id="ebec6-425">Chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metodo prima di chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-425">Call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method before you call the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method.</span></span> <span data-ttu-id="ebec6-426">Il <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metodo rispetta sempre flag di implementazione di metodo esistente.</span><span class="sxs-lookup"><span data-stu-id="ebec6-426">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method always respects existing method implementation flags.</span></span>  
  
-   <span data-ttu-id="ebec6-427">Quando si imposta flag di implementazione, chiamare il <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> metodo per recuperare i flag esistenti, usare OR bit per bit o per aggiungere il flag e quindi chiamare il <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-427">When you set implementation flags, call the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-428">Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetImplementationFlags` metodo per descrivere l'implementazione di codice MSIL in un corpo del metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-428">The code sample below illustrates the contextual use of the `SetImplementationFlags` method to describe the implementation of MSIL in a method body.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-429">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-429">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-430">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-430">-or-</span>
          </span>
          <span data-ttu-id="ebec6-431">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-431">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberSignature Language="F#" Value="member this.SetMarshal : System.Reflection.Emit.UnmanagedMarshal -&gt; unit" Usage="methodBuilder.SetMarshal unmanagedMarshal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">
          <span data-ttu-id="ebec6-432">Informazioni di marshalling per il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-432">Marshaling information for the return type of this method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-433">Imposta le informazioni di marshalling per il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-433">Sets marshaling information for the return type of this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ebec6-434">Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetMarshal` metodo per effettuare il marshalling i risultati di una chiamata al metodo come un tipo diverso.</span><span class="sxs-lookup"><span data-stu-id="ebec6-434">The code sample below illustrates the contextual usage of the `SetMarshal` method to marshal the results of a method call as a different type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-435">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-435">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-436">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-436">-or-</span>
          </span>
          <span data-ttu-id="ebec6-437">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-437">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="methodBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">
          <span data-ttu-id="ebec6-438">Matrice che contiene istruzioni MSIL valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-438">An array that contains valid MSIL instructions.</span>
          </span>
        </param>
        <param name="maxStack">
          <span data-ttu-id="ebec6-439">Profondità massima di valutazione dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-439">The maximum stack evaluation depth.</span>
          </span>
        </param>
        <param name="localSignature">
          <span data-ttu-id="ebec6-440">Matrice di byte che contiene la struttura di variabile locale serializzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-440">An array of bytes that contain the serialized local variable structure.</span>
          </span>
          <span data-ttu-id="ebec6-441">Specifica <see langword="null" /> se il metodo non ha variabili locali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-441">Specify <see langword="null" /> if the method has no local variables.</span>
          </span>
        </param>
        <param name="exceptionHandlers">
          <span data-ttu-id="ebec6-442">Raccolta contenente i gestori di eccezioni per il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-442">A collection that contains the exception handlers for the method.</span>
          </span>
          <span data-ttu-id="ebec6-443">Specifica <see langword="null" /> se il metodo non ha gestori di eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-443">Specify <see langword="null" /> if the method has no exception handlers.</span>
          </span>
        </param>
        <param name="tokenFixups">
          <span data-ttu-id="ebec6-444">Raccolta di valori che rappresentano gli offset in <c>il</c>, ciascuno dei quali specifica l'inizio di un token che può essere modificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-444">A collection of values that represent offsets in <c>il</c>, each of which specifies the beginning of a token that may be modified.</span>
          </span>
          <span data-ttu-id="ebec6-445">Specifica <see langword="null" /> se il metodo non ha token da modificare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-445">Specify <see langword="null" /> if the method has no tokens that have to be modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-446">Crea il corpo del metodo usando una matrice di byte specificata di istruzioni Microsoft Intermediate Language (MSIL).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-446">Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ebec6-447">
            <paramref name="il" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-447">
              <paramref name="il" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ebec6-448">
            <paramref name="maxStack" /> è negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-448">
              <paramref name="maxStack" /> is negative.</span>
          </span>
          <span data-ttu-id="ebec6-449">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-449">-or-</span>
          </span>
          <span data-ttu-id="ebec6-450">Uno degli oggetti <paramref name="exceptionHandlers" /> specifica un offset all'esterno di <paramref name="il" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-450">One of <paramref name="exceptionHandlers" /> specifies an offset outside of <paramref name="il" />.</span>
          </span>
          <span data-ttu-id="ebec6-451">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-451">-or-</span>
          </span>
          <span data-ttu-id="ebec6-452">Uno degli oggetti <paramref name="tokenFixups" /> specifica un offset all'esterno della matrice <paramref name="il" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-452">One of <paramref name="tokenFixups" /> specifies an offset that is outside the <paramref name="il" /> array.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-453">Il tipo che lo contiene è stato creato in precedenza utilizzando il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-453">The containing type was previously created using the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
          <span data-ttu-id="ebec6-454">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-454">-or-</span>
          </span>
          <span data-ttu-id="ebec6-455">Il metodo è stato chiamato in precedenza su questo oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-455">This method was called previously on this <see cref="T:System.Reflection.Emit.MethodBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.SetParameters : Type[] -&gt; unit" Usage="methodBuilder.SetParameters parameterTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">
          <span data-ttu-id="ebec6-456">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i tipi di parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-456">An array of <see cref="T:System.Type" /> objects representing the parameter types.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-457">Imposta il numero e i tipi di parametri per un metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-457">Sets the number and types of parameters for a method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-458">Se il numero e tipi dei parametri sono noto quando il metodo è definito, possono essere impostate utilizzando un overload del <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo che accetta una matrice di tipi di parametro.</span><span class="sxs-lookup"><span data-stu-id="ebec6-458">If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="ebec6-459">Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-459">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="ebec6-460">Utilizzare questo metodo per impostare i tipi di parametro in questo caso.</span><span class="sxs-lookup"><span data-stu-id="ebec6-460">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="ebec6-461">Se il tipo restituito ha modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:System.Runtime.CompilerServices.IsConst>, usare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-461">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="ebec6-462">Chiamare questo metodo sostituisce i tipi di parametri che sono stati impostati mediante il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-462">Calling this method replaces any parameter types that were set using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-463">Il codice seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per rendere un metodo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-463">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="ebec6-464">Il <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodo viene usato per assegnare il parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-464">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="ebec6-465">Il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> metodo viene usato per assegnare il metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-465">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="ebec6-466">Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-466">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-467">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-467">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="ebec6-468">Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-468">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-469">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-469">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberSignature Language="F#" Value="member this.SetReturnType : Type -&gt; unit" Usage="methodBuilder.SetReturnType returnType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">
          <span data-ttu-id="ebec6-470">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-470">A <see cref="T:System.Type" /> object that represents the return type of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-471">Imposta il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-471">Sets the return type of the method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-472">Usare questo metodo per impostare il tipo restituito di un metodo generico, quando viene specificato il tipo restituito da uno dei parametri di tipo generico del metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-472">Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</span></span> <span data-ttu-id="ebec6-473">Se il tipo restituito ha modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:System.Runtime.CompilerServices.IsConst>, usare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-473">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="ebec6-474">Chiamare questo metodo sostituisce un tipo restituito stabilito utilizzando il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-474">Calling this method replaces a return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-475">Il codice seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodo per rendere un metodo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-475">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="ebec6-476">Il <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodo viene usato per assegnare il parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-476">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="ebec6-477">Il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> metodo viene usato per assegnare il metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-477">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="ebec6-478">Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-478">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-479">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-479">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="ebec6-480">Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-480">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">
          <span data-ttu-id="ebec6-481">Procedura: definire un metodo generico tramite reflection emit</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-481">How to: Define a Generic Method with Reflection Emit</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.SetSignature : Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; unit" Usage="methodBuilder.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">
          <span data-ttu-id="ebec6-482">Tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-482">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="ebec6-483">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-483">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="ebec6-484">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-484">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="ebec6-485">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-485">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="ebec6-486">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-486">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="ebec6-487">Tipi dei parametri del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-487">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="ebec6-488">Matrice di matrici di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-488">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="ebec6-489">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-489">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="ebec6-490">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-490">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="ebec6-491">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-491">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="ebec6-492">Matrice di matrici di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-492">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="ebec6-493">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-493">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="ebec6-494">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-494">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="ebec6-495">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-495">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-496">Imposta la firma del metodo, incluso il tipo restituito, i tipi di parametro e i modificatori personalizzati obbligatori e facoltativi del tipo restituito e dei tipi di parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-496">Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-497">Se il tipo restituito e il numero e tipi dei parametri sono noto quando viene definito il metodo, può essere stabilite utilizzando un overload del <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodo che accetta una matrice di tipi di parametro.</span><span class="sxs-lookup"><span data-stu-id="ebec6-497">If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="ebec6-498">Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-498">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="ebec6-499">Utilizzare questo metodo per impostare i tipi di parametro in questo caso.</span><span class="sxs-lookup"><span data-stu-id="ebec6-499">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="ebec6-500">Se il tipo restituito né i tipi di parametro dispone di modificatori personalizzati obbligatori o facoltativi, ad esempio <xref:Microsoft.VisualC.IsConstModifier>, è possibile usare il <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> e <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="ebec6-500">If neither the return type nor the parameter types have optional or required custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, you can use the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> and <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> methods.</span></span>  
  
 <span data-ttu-id="ebec6-501">Chiamare questo metodo sostituisce i parametri e tipo restituito stabilita utilizzando il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-501">Calling this method replaces the parameters and return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-502">Esempio di codice seguente contiene il codice sorgente per una classe generica denominato Sample con un parametro di tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-502">The following code example contains source code for a generic class named Sample that has a type parameter `T`.</span></span> <span data-ttu-id="ebec6-503">La classe dispone di un campo denominato `Field`, di tipo `T`e un metodo generico `GM` con il proprio parametro di tipo `U`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-503">The class has a field named `Field`, of type `T`, and a generic method `GM` with its own type parameter, `U`.</span></span> <span data-ttu-id="ebec6-504">Metodo `GM` crea un'istanza di esempio, sostituendo il parametro di tipo `U` per il parametro di tipo di esempio e archivia il parametro di input in `Field`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-504">Method `GM` creates an instance of Sample, substituting its own type parameter `U` for the type parameter of Sample, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="ebec6-505">Questo codice sorgente viene compilato ma non usato; è possibile visualizzarla con il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)e confrontarlo con il codice generato dalla classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-505">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="ebec6-506">Il codice nella classe `Example` viene illustrato come utilizzare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> metodo per creare codice generico.</span><span class="sxs-lookup"><span data-stu-id="ebec6-506">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method in emitting generic code.</span></span> <span data-ttu-id="ebec6-507">Il `Main` metodo della classe `Example` crea un assembly dinamico che contiene una classe denominata `Sample`e Usa le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metodo per renderla generico aggiungendo un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-507">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="ebec6-508">Un costruttore predefinito e un campo denominato `Field`, di tipo `T`, vengono aggiunti alla classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-508">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="ebec6-509">Un metodo `GM` viene aggiunto e trasformato in un metodo generico tramite le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-509">A method `GM` is added, and turned into a generic method using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="ebec6-510">Il parametro di tipo `GM` denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-510">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="ebec6-511">Una volta definito il parametro di tipo, la firma dei `GM` venga aggiunto mediante il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="ebec6-511">Once the type parameter is defined, the signature of `GM` is added, using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method.</span></span> <span data-ttu-id="ebec6-512">È presente alcun tipo restituito e nessun modificatore obbligatorio o personalizzato, in modo che tutti i parametri del metodo siano `null` eccetto `parameterTypes`, che imposta il tipo dell'unico parametro del metodo; è impostato su parametro di tipo del metodo, `U`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-512">There is no return type, and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`, which sets the type of the only parameter of the method; this is set to the method's type parameter, `U`.</span></span> <span data-ttu-id="ebec6-513">Il corpo del metodo crea un'istanza del tipo costruito `Sample<U>` (`Sample(Of U)` in Visual Basic), assegna il parametro del metodo per `Field`e quindi stampato il valore di `Field`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-513">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="ebec6-514">Viene definito un tipo fittizio, per contenere il metodo del punto di ingresso `Main`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-514">A dummy type is defined, to hold the entry point method `Main`.</span></span> <span data-ttu-id="ebec6-515">Nel corpo della `Main`, il metodo statico `GM` metodo viene richiamato sul tipo generico costruito `Sample<int>` (`Sample(Of Integer)` in Visual Basic), con il tipo <xref:System.String> sostituito `U`.</span><span class="sxs-lookup"><span data-stu-id="ebec6-515">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="ebec6-516">Il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> metodo viene utilizzato per creare un <xref:System.Reflection.MethodInfo> per il metodo statico `GM` metodo del tipo generico costruito `Sample<U>`e il <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metodo viene quindi utilizzato per creare un <xref:System.Reflection.MethodInfo> che possono emessi in una chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-516">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="ebec6-517">Quando viene eseguito l'esempio di codice, Salva l'assembly generato come TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="ebec6-517">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="ebec6-518">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per confrontare il codice generato con il codice per il `Sample` classe che viene compilato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="ebec6-518">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-519">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-519">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="ebec6-520">Questo significa che la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-520">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="methodBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ebec6-521">Nome dell'attributo personalizzato simbolico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-521">The name of the symbolic custom attribute.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="ebec6-522">BLOB di byte che rappresenta il valore dell'attributo personalizzato simbolico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-522">The byte blob that represents the value of the symbolic custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-523">Imposta un attributo personalizzato simbolico usando un BLOB.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-523">Set a symbolic custom attribute using a blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-524">A differenza dell'attributo personalizzato di metadati, questo attributo personalizzato è associato a un writer di simboli.</span><span class="sxs-lookup"><span data-stu-id="ebec6-524">Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ebec6-525">Esempio di codice seguente viene illustrato l'utilizzo contestuale del `SetSymCustomAttribute` metodo per impostare i valori di byte per il nome e la chiave di un attributo personalizzato associato a un metodo.</span><span class="sxs-lookup"><span data-stu-id="ebec6-525">The code sample below illustrates the contextual usage of the `SetSymCustomAttribute` method to set the byte values for the name and key of a custom attribute attached to a method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ebec6-526">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-526">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="ebec6-527">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-527">-or-</span>
          </span>
          <span data-ttu-id="ebec6-528">Il modulo che contiene il metodo non è un modulo di debug.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-528">The module that contains this method is not a debug module.</span>
          </span>
          <span data-ttu-id="ebec6-529">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-529">-or-</span>
          </span>
          <span data-ttu-id="ebec6-530">Per il metodo corrente la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> è <see langword="true" />, ma la proprietà <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-530">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-531">Recupera la firma del metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-531">Retrieves the signature of the method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ebec6-532">Sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-532">Read-only.</span>
          </span>
          <span data-ttu-id="ebec6-533">Oggetto String contenente la firma del metodo ottenuto mediante reflection dall'istanza di <see langword="MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-533">A String containing the signature of the method reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="ebec6-534">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-534">Reserved for future use.</span>
          </span>
          <span data-ttu-id="ebec6-535">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-535">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="ebec6-536">Matrice di nomi passata di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-536">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="ebec6-537">Conteggio dei nomi di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-537">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ebec6-538">Contesto delle impostazioni locali in cui interpretare i nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-538">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="ebec6-539">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-539">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-540">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-540">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-541">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-541">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ebec6-542">Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ebec6-542">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ebec6-543">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-543">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="ebec6-544">Informazioni sul tipo da restituire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-544">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ebec6-545">Identificatore delle impostazioni locali per le informazioni sul tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-545">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="ebec6-546">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-546">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-547">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-547">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-548">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-548">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ebec6-549">Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ebec6-549">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ebec6-550">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-550">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="ebec6-551">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-551">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-552">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-552">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-553">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-553">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ebec6-554">Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ebec6-554">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ebec6-555">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-555">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="ebec6-556">Identifica il membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-556">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="ebec6-557">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-557">Reserved for future use.</span>
          </span>
          <span data-ttu-id="ebec6-558">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-558">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="ebec6-559">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-559">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="ebec6-560">Flag che descrivono il contesto della chiamata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-560">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="ebec6-561">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-561">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="ebec6-562">Puntatore alla posizione in cui deve essere archiviato il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-562">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="ebec6-563">Puntatore a una struttura contenente informazioni sull'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-563">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="ebec6-564">Indice del primo argomento che contiene un errore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-564">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ebec6-565">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-565">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ebec6-566">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="ebec6-566">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ebec6-567">Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ebec6-567">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="ebec6-568">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-568">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="methodBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ebec6-569">Restituisce questa istanza di <see langword="MethodBuilder" /> come stringa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-569">Returns this <see langword="MethodBuilder" /> instance as a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ebec6-570">Restituisce una stringa che contiene il nome, gli attributi, la firma, le eccezioni e la firma locale del metodo, seguiti dal flusso MSIL (Microsoft Intermediate Language) corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ebec6-570">Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>