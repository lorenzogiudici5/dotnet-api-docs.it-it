<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBuilder.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c93c1a358d5c177a5835b41cbeaeae252a6af730.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c93c1a358d5c177a5835b41cbeaeae252a6af730</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Defines and represents a method (or constructor) on a dynamic class.</source>
          <target state="translated">Definisce e rappresenta un metodo (o costruttore) di una classe dinamica.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> classe viene utilizzata per descrivere un metodo in Microsoft intermediate language (MSIL), incluso il corpo del metodo, gli attributi, firma e nome.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>It is used in conjunction with the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class to create classes at runtime.</source>
          <target state="translated">Viene utilizzato in combinazione con la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe per creare le classi in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods and methods as type members</source>
          <target state="translated">I metodi globali e i metodi come membri di tipo</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can use reflection emit to define global methods and to define methods as type members.</source>
          <target state="translated">È possibile usare la reflection emit per definire i metodi globali e per definire i metodi come membri di tipo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The APIs that define methods return <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objects.</source>
          <target state="translated">Le API che definiscono i metodi restituiscono <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods</source>
          <target state="translated">Metodi globali</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> object.</source>
          <target state="translated">Un metodo globale viene definito mediante il <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> metodo, che restituisce un <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> oggetto.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods must be static.</source>
          <target state="translated">I metodi globali devono essere statici.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>If a dynamic module contains global methods, the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</source>
          <target state="translated">Se un modulo dinamico contiene metodi globali, il <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> metodo deve essere chiamato prima di persistere il modulo dinamico o dell'assembly dinamico, perché common language runtime la correzione del modulo dinamico, fino a quando tutte le funzioni globali sono stati definiti.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global native method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">È definito un metodo globale nativo tramite il <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Platform invoke (PInvoke) methods must not be declared abstract or virtual.</source>
          <target state="translated">Platform invoke (PInvoke) metodi non devono essere dichiarati astratti o virtuali.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The runtime sets the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> attribute for a platform invoke method.</source>
          <target state="translated">I set di runtime di <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> attributo per un platform invoke (metodo).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods as members of types</source>
          <target state="translated">Metodi come membri dei tipi</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A method is defined as a type member by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object.</source>
          <target state="translated">Un metodo è definito come un membro del tipo utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo, che restituisce un <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> method is used to set the name and parameter attributes of a parameter, or of the return value.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> metodo viene utilizzato per impostare gli attributi nome e il parametro di un parametro o del valore restituito.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method represents a parameter or the return value.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> oggetto restituito da questo metodo rappresenta un parametro o valore restituito.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> oggetto può essere utilizzato per impostare il marshalling, impostare il valore costante e per applicare gli attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Attributes</source>
          <target state="translated">Attributi</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Members of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration define the precise character of a dynamic method:</source>
          <target state="translated">I membri del <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumerazione definire il carattere preciso di un metodo dinamico:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Static methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">I metodi statici vengono specificati utilizzando il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Final methods (methods that cannot be overridden) are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">I metodi finali (che non può essere sottoposto a override) vengono specificati utilizzando il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Virtual methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Metodi virtuali vengono specificati utilizzando il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Abstract methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">I metodi astratti sono specificati mediante il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Several attributes determine method visibility.</source>
          <target state="translated">La visibilità di metodo è determinata da diversi attributi.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration.</source>
          <target state="translated">Vedere la descrizione del <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods that implement overloaded operators must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">I metodi che implementano gli operatori di overload è necessario impostare il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Finalizers must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">I finalizzatori devono impostare la <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Known Issues</source>
          <target state="translated">Problemi noti</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class are not fully implemented in <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">Sebbene <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> è derivato da <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, alcuni dei metodi astratti definiti nel <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> non sono implementati completamente in <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>These <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> methods throw the <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Questi <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> metodi generano il <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>For example the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> method is not fully implemented.</source>
          <target state="translated">Ad esempio il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> metodo non è completamente implementato.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can reflect on these methods by retrieving the enclosing type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Può riflettere su questi metodi recuperando il tipo contenitore usando il <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Custom modifiers are supported starting with the .NET Framework version 2.0.</source>
          <target state="translated">I modificatori personalizzati sono supportati a partire da .NET Framework versione 2.0.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>They are not supported in earlier versions.</source>
          <target state="translated">Non sono supportate nelle versioni precedenti.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class to create a method within a dynamic type.</source>
          <target state="translated">Nell'esempio seguente viene utilizzata la <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> classe per creare un metodo all'interno di un tipo dinamico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken (Demand, Assert, and so on).</source>
          <target state="translated">Azione di sicurezza da eseguire, ad esempio Demand, Assert e così via.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Set di autorizzazioni a cui viene applicata l'azione.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this method.</source>
          <target state="translated">Aggiunge sicurezza dichiarativa a questo metodo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> can be called several times, with each call specifying a security action (such as <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, and <ph id="ph4">`Deny`</ph>) and a set of permissions that the action applies to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> può essere chiamato più volte, con ogni chiamata specifica un'azione di sicurezza (ad esempio <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, e <ph id="ph4">`Deny`</ph>) e un set di autorizzazioni che si applica l'azione.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> method are stored in the old XML metadata format.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0, 1.1 e 2.0, gli attributi di sicurezza dichiarativa applicati a un metodo tramite il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> metodo vengono archiviati nel formato di metadati XML precedente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>See Emitting Declarative Security Attributes.</source>
          <target state="translated">Vedere Creazione di attributi di sicurezza dichiarativa.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The code sample below illustrates the contextual use of <ph id="ph1">`AddDeclarativeSecurity`</ph> to require the caller of a method to have unrestricted permissions.</source>
          <target state="translated">L'esempio di codice riportato di seguito è illustrato l'utilizzo contestuale di <ph id="ph1">`AddDeclarativeSecurity`</ph> per richiedere al chiamante di un metodo disponga di autorizzazioni illimitate.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="action" /&gt;</ph> non è valido (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> e <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> non sono validi).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</source>
          <target state="translated">Il set di autorizzazioni <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contiene un'azione aggiunta in precedenza mediante <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the attributes for this method.</source>
          <target state="translated">Recupera gli attributi per questo metodo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> for this method.</source>
          <target state="translated">Recupera l'oggetto <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> per questo metodo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Returns the calling convention of the method.</source>
          <target state="translated">Restituisce la convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>The calling convention of the method.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported for this type.</source>
          <target state="translated">Non supportato per questo tipo.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported.</source>
          <target state="translated">Non supportato.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> always represents a generic method definition, and thus cannot be invoked.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> rappresenta sempre una definizione di metodo generico e pertanto non può essere richiamata.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per informazioni sui tipi generici, vedere <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Il metodo richiamato non è supportato nella classe base.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>An array containing valid MSIL instructions.</source>
          <target state="translated">Matrice che contiene istruzioni MSIL valide.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>If this parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the method's body is cleared.</source>
          <target state="translated">Se questo parametro è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, il corpo del metodo viene cancellato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of valid bytes in the MSIL array.</source>
          <target state="translated">Numero di byte validi nella matrice MSIL.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This value is ignored if MSIL is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questo valore viene ignorato se MSIL è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Crea il corpo del metodo usando una matrice di byte fornita di istruzioni Microsoft Intermediate Language (MSIL).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method creates the method's body from <ph id="ph1">`il`</ph>, an array containing MSIL instructions as opcodes.</source>
          <target state="translated">Questo metodo crea il corpo del metodo da <ph id="ph1">`il`</ph>, una matrice che contiene istruzioni MSIL come codici operativi.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of bytes of valid MSIL is given by count.</source>
          <target state="translated">Viene indicato il numero di byte del codice MSIL valido dal conteggio.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This is currently not fully supported.</source>
          <target state="translated">Questo non è completamente supportato.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The user cannot supply the location of token fix ups and exception handlers.</source>
          <target state="translated">Non è possibile specificare il percorso di correzioni token e gestori di eccezioni.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>In the example provided below, a simple method that adds two integers is generated via opcode using <ph id="ph1">`CreateMethodBody`</ph>.</source>
          <target state="translated">Nell'esempio fornito di seguito, viene generato un metodo semplice che somma due interi tramite codici operativi utilizzando <ph id="ph1">`CreateMethodBody`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> is not within the range of indexes of the supplied MSIL instruction array and <ph id="ph2">&lt;paramref name="il" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;paramref name="count" /&gt;</ph> non è compreso nell'intervallo di indici della matrice di istruzioni MSIL e <ph id="ph2">&lt;paramref name="il" /&gt;</ph> non è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method was called previously on this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> with an <ph id="ph2">&lt;paramref name="il" /&gt;</ph> argument that was not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questo metodo è stato chiamato in precedenza su questo <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> con un argomento <ph id="ph2">&lt;paramref name="il" /&gt;</ph> che non era <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Returns the type that declares this method.</source>
          <target state="translated">Restituisce il tipo che dichiara il metodo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The type that declares this method.</source>
          <target state="translated">Tipo che dichiara il metodo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The following code illustrates the use of the <ph id="ph1">`Type`</ph> property.</source>
          <target state="translated">Il codice seguente viene illustrato l'utilizzo del <ph id="ph1">`Type`</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of strings that represent the names of the generic type parameters.</source>
          <target state="translated">Matrice di stringhe che rappresentano i nomi dei parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define their constraints.</source>
          <target state="translated">Imposta il numero dei parametri di tipo generico per il metodo corrente, specificandone i nomi, e restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che possono essere usati per definire i vincoli.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters of the generic method.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che rappresentano i parametri di tipo del metodo generico.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method makes the current method generic.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo rende il metodo corrente è generico.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>There is no way to undo this change.</source>
          <target state="translated">Non è possibile annullare questa modifica.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method a second time causes an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Quando si chiama questo metodo una seconda volta, un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The type parameters of the generic method can be retrieved later by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">I parametri di tipo del metodo generico possono essere recuperati in un secondo momento tramite il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>By convention, a type parameter name is a single uppercase letter.</source>
          <target state="translated">Per convenzione, un nome di parametro di tipo è una singola lettera maiuscola.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per informazioni sui tipi generici, vedere <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a dynamic type, <ph id="ph1">`DemoType`</ph>, which contains the dynamic generic method <ph id="ph2">`DemoMethod`</ph>.</source>
          <target state="translated">Esempio di codice seguente crea un tipo dinamico, <ph id="ph1">`DemoType`</ph>, che contiene il metodo dinamico generico <ph id="ph2">`DemoMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</source>
          <target state="translated">Questo metodo presenta due parametri di tipo generico, una delle quali viene utilizzata come parametro e l'altro come tipo restituito.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Quando il codice viene eseguito, l'assembly dinamico viene salvato come DemoGenericMethod1.dll e può essere esaminato mediante lo strumento <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This code example generates a simple method body that merely returns a null reference.</source>
          <target state="translated">Questo esempio di codice genera il corpo di un metodo semplice che restituisce semplicemente un riferimento null.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For a code example with a more fully developed method body that creates and uses generic types, see <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Per un esempio di codice con un corpo del metodo completamente sviluppato più che crea e utilizza i tipi generici, vedere <bpt id="p1">[</bpt>procedura: definire un metodo generico tramite Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this method.</source>
          <target state="translated">Parametri di tipo generico sono già stati definiti per questo metodo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The method has been completed already.</source>
          <target state="translated">Il metodo è già stato completato.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> method has been called for the current method.</source>
          <target state="translated">Il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> è stato chiamato per il metodo corrente.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="names" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> è una matrice vuota.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">Posizione del parametro nell'elenco dei parametri.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</source>
          <target state="translated">I parametri vengono indicizzati a partire dal numero 1 per il primo parametro. Il numero 0 rappresenta il valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The parameter attributes of the parameter.</source>
          <target state="translated">Attributi del parametro.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">Nome del parametro.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be the null string.</source>
          <target state="translated">Il nome può essere rappresentato dalla stringa null.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</source>
          <target state="translated">Imposta gli attributi del parametro e il nome di un parametro di questo metodo oppure del valore restituito di questo metodo.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a ParameterBuilder that can be used to apply custom attributes.</source>
          <target state="translated">Restituisce un oggetto ParameterBuilder che può essere usato per applicare attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> object that represents a parameter of this method or the return value of this method.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> che rappresenta un parametro o il valore restituito di questo metodo.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> oggetto restituito da questo metodo può essere utilizzato per impostare il valore predefinito per un parametro o applicare attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameter numbering begins with 1, so <ph id="ph1">`position`</ph> is 1 for the first parameter.</source>
          <target state="translated">Parametro la numerazione inizia con 1, pertanto <ph id="ph1">`position`</ph> è 1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is zero, this method affects the return value.</source>
          <target state="translated">Se <ph id="ph1">`position`</ph> è zero, questo metodo influisce sul valore restituito.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>In the .NET Framework versions 1.0 and 1.1, an exception is thrown if <ph id="ph1">`position`</ph> is zero, so this method cannot be used to modify attributes of the return value in those versions.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, viene generata un'eccezione se <ph id="ph1">`position`</ph> è zero, pertanto questo metodo può essere utilizzato per modificare gli attributi del valore restituito in tali versioni.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">Il metodo non ha parametri.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> è maggiore del numero dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>The object to compare with this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance.</source>
          <target state="translated">Oggetto da confrontare con questa istanza di <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Determines whether the given object is equal to this instance.</source>
          <target state="translated">Determina se l'oggetto specificato è uguale a questa istanza.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> and is equal to this object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> è un'istanza di <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> ed è uguale a questo oggetto; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Equality is determined by having the same name, attributes, and signature.</source>
          <target state="translated">L'uguaglianza è determinata dal con lo stesso nome, attributi e firma.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>Return the base implementation for a method.</source>
          <target state="translated">Restituisce l'implementazione di base per un metodo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>The base implementation of this method.</source>
          <target state="translated">Implementazione di base di questo metodo.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>This always returns the current <ph id="ph1">`MethodBuilder`</ph> object.</source>
          <target state="translated">Restituisce sempre corrente <ph id="ph1">`MethodBuilder`</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns the custom attributes defined for this method.</source>
          <target state="translated">Restituisce gli attributi personalizzati definiti per questo metodo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this method.</source>
          <target state="translated">Restituisce tutti gli attributi personalizzati definiti per questo metodo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this method.</source>
          <target state="translated">Restituisce una matrice di oggetti che rappresentano tutti gli attributi personalizzati di questo metodo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">Tipo di attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes identified by the given type.</source>
          <target state="translated">Restituisce gli attributi personalizzati identificati dal tipo specificato.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of objects representing the attributes of this method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Restituisce una matrice di oggetti che rappresenta gli attributi del metodo di tipo <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that represent the type parameters of the method, if it is generic.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che rappresentano i parametri di tipo del metodo, se è generico.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters, if the method is generic, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method is not generic.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che rappresentano i parametri di tipo, se il metodo è generico, oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se il metodo non è generico.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>The type parameters of a generic method also are returned by the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method that is used to define them.</source>
          <target state="translated">I parametri di tipo di un metodo generico vengono restituiti anche dal <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo utilizzato per definirli.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per informazioni sui tipi generici, vedere <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>Returns this method.</source>
          <target state="translated">Restituisce questo metodo.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">L'istanza corrente di <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> cannot be used to emit a constructed generic method directly.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> non può essere utilizzata per generare un metodo generico costruito direttamente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The emitted method is a generic method definition.</source>
          <target state="translated">Il metodo generato è una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per informazioni sui tipi generici, vedere <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current method is not generic.</source>
          <target state="translated">Il metodo corrente non è generico.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Quindi la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>Gets the hash code for this method.</source>
          <target state="translated">Ottiene il codice hash per questo metodo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>The hash code for this method.</source>
          <target state="translated">Codice hash per questo metodo.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> per il metodo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> per il metodo con una dimensione di flusso MSIL (Microsoft Intermediate Language) predefinita di 64 byte.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> per il metodo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">Esempio di codice seguente illustra l'uso di scelta rapida del <ph id="ph1">`GetILGenerator`</ph> metodo la creazione di un assembly dinamico per calcola il prodotto scalare di due punti nello spazio 3D.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">Il metodo non deve avere un corpo a causa del suo flag <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, ad esempio perché ha il flag <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">Il metodo è un metodo generico, ma non una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Questo significa che la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">Dimensioni del flusso MSIL in byte.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with the specified Microsoft intermediate language (MSIL) stream size.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> per il metodo con le dimensioni del flusso MSIL (Microsoft Intermediate Language) specificate.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> per il metodo.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">Esempio di codice seguente illustra l'uso di scelta rapida del <ph id="ph1">`GetILGenerator`</ph> metodo la creazione di un assembly dinamico per calcola il prodotto scalare di due punti nello spazio 3D.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">Il metodo non deve avere un corpo a causa del suo flag <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, ad esempio perché ha il flag <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">Il metodo è un metodo generico, ma non una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Questo significa che la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Restituisce i flag di implementazione per il metodo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Restituisce i flag di implementazione per il metodo.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Restituisce un riferimento al modulo che contiene questo metodo.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Restituisce un riferimento al modulo che contiene questo metodo.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>The sample code below illustrates the usage of the <ph id="ph1">`GetModule`</ph> method to retrieve information about a dynamically-generated module.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`GetModule`</ph> metodo per recuperare informazioni su un modulo generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Returns the parameters of this method.</source>
          <target state="translated">Restituisce il parametro del metodo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>An array of <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> objects that represent the parameters of the method.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> che rappresentano i parametri del metodo.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>The code sample below illustrates the use of <ph id="ph1">`GetParameters`</ph> to discover information on the parameters passed to a dynamically-generated method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo di <ph id="ph1">`GetParameters`</ph> per individuare informazioni sui parametri passati a un metodo generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> that represents the token for this method.</source>
          <target state="translated">Restituisce l'oggetto <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> che rappresenta il token per il metodo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> of this method.</source>
          <target state="translated">Restituisce l'oggetto <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> del metodo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</source>
          <target state="translated">Ottiene o imposta un valore booleano che specifica se le variabili locali in questo metodo sono inizializzate su zero.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>The default value of this property is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito di questa proprietà è <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in this method should be zero initialized; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se le variabili locali in questo metodo devono essere inizializzate su zero; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted MSIL includes initialization of local variables.</source>
          <target state="translated">Se questa proprietà è impostata su <ph id="ph1">`true`</ph>, il codice MSIL generato include l'inizializzazione delle variabili locali.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">Se è impostato su <ph id="ph1">`false`</ph>, variabili locali non inizializzate e il codice generato non è verificabile.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>(Get or set.)</source>
          <target state="translated">(Get o set).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified method.</source>
          <target state="translated">Oggetto su cui richiamare il metodo specificato.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, this parameter is ignored.</source>
          <target state="translated">Se il metodo è statico, questo parametro verrà ignorato.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit richiamato dall'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, ad esempio <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi, la chiamata dei membri e il recupero di oggetti MemberInfo tramite reflection.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se il gestore di associazione è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà utilizzato il gestore di associazione predefinito.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">Elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">In assenza di parametri, deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Istanza di <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> usata per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se è null, verrà utilizzato l'oggetto <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> per il thread corrente.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(Note that this is necessary to, for example, convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">Questo è necessario, ad esempio, per convertire un valore <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> che rappresenta 1000 in un valore <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</source>
          <target state="translated">Richiama dinamicamente il metodo ottenuto mediante reflection da questa istanza sull'oggetto indicato, passando i parametri specificati e con i vincoli del binder indicato.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Returns an object containing the return value of the invoked method.</source>
          <target state="translated">Restituisce un oggetto che contiene il valore restituito del metodo richiamato.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Se il metodo è statico, il <ph id="ph1">`obj`</ph> parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Per i metodi non statici <ph id="ph1">`obj`</ph> deve essere un'istanza di una classe che eredita o dichiara il metodo e deve essere dello stesso tipo di questa classe.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Se il metodo non ha parametri, il valore di <ph id="ph1">`parameters`</ph> deve essere <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">In caso contrario, il numero, tipo e l'ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri per il metodo ottenuto mediante reflection da questa istanza.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">Le restrizioni di accesso vengono ignorate per il codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</source>
          <target state="translated">Ovvero, proprietà, metodi, campi e costruttori privati accessibili e richiamato mediante Reflection.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">Tipo di attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Specifica se cercare gli attributi personalizzati nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Checks if the specified custom attribute type is defined.</source>
          <target state="translated">Controlla se il tipo di attributo personalizzato specificato è definito.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>Gets a value indicating whether the method is a generic method.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è un metodo generico.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is generic; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo è generico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>A method is generic if it has type parameters.</source>
          <target state="translated">Un metodo è generico, se ha parametri di tipo.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>You can make a method generic by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to add type parameters.</source>
          <target state="translated">È possibile rendere un metodo generico chiamando il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo per aggiungere parametri di tipo.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This change cannot be reversed.</source>
          <target state="translated">Questa modifica non può essere annullata.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare lo stato di un metodo.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method.</source>
          <target state="translated">Ottiene un valore che indica se l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> corrente rappresenta la definizione di un metodo generico.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> corrente rappresenta la definizione di un metodo generico; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> può essere utilizzato solo per creare definizioni di metodo generico; non può essere utilizzato per creare direttamente un metodo generico costruito.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>However, a subclass of <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> might represent a constructed generic method.</source>
          <target state="translated">Tuttavia, una sottoclasse di <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> potrebbe rappresentare un metodo generico costruito.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare lo stato di un metodo.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Per determinare se un metodo in un assembly dinamico è critico per la sicurezza, completare il tipo chiamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chiamare il <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> metodo sul tipo completato e get di <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>In all cases.</source>
          <target state="translated">In tutti i casi.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Questa proprietà non è supportata in assembly dinamici.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Per determinare se un metodo in un assembly dinamico è sicurezza SecuritySafeCritical, completare il tipo chiamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chiamare il <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> metodo sul tipo completato e get di <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>In all cases.</source>
          <target state="translated">In tutti i casi.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Questa proprietà non è supportata in assembly dinamici.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in tutti i casi.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Per determinare se un metodo in un assembly dinamico è trasparente per la sicurezza, completare il tipo chiamando <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, chiamare il <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> metodo sul tipo completato e get di <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>In all cases.</source>
          <target state="translated">In tutti i casi.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Questa proprietà non è supportata in assembly dinamici.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments for the generic method.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo per il metodo generico.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Restituisce un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti tipo generico specificati.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta un metodo generico costruito dalla definizione di metodo generico corrente usando gli argomenti di tipo generico specificati.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, before the enclosing type has been completed.</source>
          <target state="translated">Quando si sta generando codice dinamico, è necessario generare una chiamata a un metodo costruito dalla definizione di metodo generico, rappresentata da un <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, prima che il tipo di inclusione è stato completato.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for such a constructed method, and use the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the emitted call.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> metodo per creare un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> per tale metodo costruito e utilizzare il <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> nella chiamata generata.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</source>
          <target state="translated">Esempio di codice seguente crea un metodo costruito da una definizione di metodo generica incompleta in un tipo incompleto.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example creates a transient assembly and module with a single type, adds a method <ph id="ph1">`M`</ph>, and makes the method generic by adding a type parameter T using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene creato un assembly temporaneo e un modulo con un solo tipo, viene aggiunto un metodo <ph id="ph1">`M`</ph>e rende il metodo generico tramite l'aggiunta di un tipo di parametro T usando il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The type parameter is used as the type of the method's parameter, and also as its return type.</source>
          <target state="translated">Il parametro di tipo viene utilizzato come tipo di parametro del metodo, nonché come tipo restituito.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The generic method definition is not given a body, and the enclosing type is not completed.</source>
          <target state="translated">La definizione di metodo generico non ha un corpo e il tipo di inclusione non è stato completato.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method is then used to make the constructed method <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> in Visual Basic).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> metodo viene quindi utilizzato per creare il metodo costruito <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example code has no output, because the subclass of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method does not allow reflection over its parameters.</source>
          <target state="translated">Nell'esempio di codice non ha un output, in quanto la sottoclasse di <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> restituito dal <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> metodo non consente la reflection sui relativi parametri.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>For another code example that uses <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, see <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</source>
          <target state="translated">Per un altro esempio di codice che usa <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, vedere <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> is also used extensively when emitting code that uses generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> è ampiamente utilizzato anche quando si genera codice che utilizza tipi generici.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>See <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt>procedura: definire un metodo generico tramite Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieves the internal handle for the method.</source>
          <target state="translated">Recupera l'handle interno per il metodo.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Questo handle consente di accedere all'handle dei metadati sottostanti.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>The internal handle for the method.</source>
          <target state="translated">Handle interno per il metodo.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Questo handle consente di accedere all'handle dei metadati sottostanti.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Recuperare il metodo usando <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> per l'oggetto <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>Gets the module in which the current method is being defined.</source>
          <target state="translated">Ottiene il modulo in cui è definito il metodo corrente.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in which the member represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is being defined.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in cui viene definito il membro rappresentato dalla classe <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Questa proprietà viene fornita per praticità.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>It is equivalent to using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> property to get the type in which the method is being declared, and then calling the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property of the resulting <ph id="ph3">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Equivale all'utilizzo di <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> proprietà per ottenere il tipo in cui viene dichiarato il metodo e quindi chiamando il <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> proprietà dell'oggetto risultante <ph id="ph3">&lt;xref:System.Type&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is also equivalent to calling <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</source>
          <target state="translated">Questa proprietà è equivalente alla chiamata anche <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves the name of this method.</source>
          <target state="translated">Recupera il nome di questo metodo.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves a string containing the simple name of this method.</source>
          <target state="translated">Recupera una stringa che contiene il nome semplice di questo metodo.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Retrieves the class that was used in reflection to obtain this object.</source>
          <target state="translated">Recupera la classe usata nella reflection per ottenere l'oggetto.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>The type used to obtain this method.</source>
          <target state="translated">Tipo usato per ottenere questo metodo.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> contenente informazioni sul tipo restituito dal metodo, ad esempio se il tipo restituito contiene modificatori personalizzati.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> contenente informazioni relative al tipo restituito.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Finestre di progettazione del compilatore è possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> oggetto restituito da questa proprietà per determinare se personalizzato modificatori, ad esempio <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, sono stati applicati al tipo restituito.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>The declaring type has not been created.</source>
          <target state="translated">Il tipo dichiarante non è stato creato.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Gets the return type of the method represented by this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">Ottiene il tipo restituito del metodo rappresentato da questo oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>The return type of the method.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">A partire da .NET Framework 2.0 e .NET Compact Framework 2.0, questo membro viene ereditato dalla classe di base, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Returns the custom attributes of the method's return type.</source>
          <target state="translated">Restituisce gli attributi personalizzati del tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>The custom attributes of the method's return type.</source>
          <target state="translated">Attributi personalizzati del tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>This method always returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Questo metodo restituisce sempre <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Get the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> after the containing <ph id="ph2">&lt;xref:System.Type&gt;</ph> has been created and invoked <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> on the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Ottenere il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> dopo che la contiene <ph id="ph2">&lt;xref:System.Type&gt;</ph> è stato creato e richiamato <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> sul <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Imposta un attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to describe the custom attribute.</source>
          <target state="translated">Un'istanza di una classe helper per descrivere l'attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Sets a custom attribute using a custom attribute builder.</source>
          <target state="translated">Imposta un attributo personalizzato usando un generatore di attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> metodo può interagire con il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo quando i due metodi vengono utilizzati in combinazione.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">Vedere la sezione Note del <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo per i dettagli.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Costruttore dell'attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">BLOB di byte che rappresenta gli attributi.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Imposta un attributo personalizzato usando un BLOB di attributi personalizzati specificato.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For details on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Per informazioni dettagliate su come formattare <ph id="ph1">`binaryAttribute`</ph>, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "partizione II: metadati definizione e la semantica".</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> metodo può interagire con il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo quando i due metodi vengono utilizzati in combinazione.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">Vedere la sezione Note del <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo per i dettagli.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> o <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The implementation flags to set.</source>
          <target state="translated">Flag di implementazione da impostare.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Sets the implementation flags for this method.</source>
          <target state="translated">Imposta i flag di implementazione per il metodo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method, be aware of potential interactions.</source>
          <target state="translated">Quando si utilizza il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo in combinazione con il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> (metodo), tenere presente le potenziali interazioni.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For example, using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method to add the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute also sets the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Ad esempio, usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> metodo per aggiungere il <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> set di attributi anche il <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>If you subsequently call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> flag is overwritten.</source>
          <target state="translated">Se si chiama successivamente il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> (metodo), il <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> flag viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>There are two ways to avoid this:</source>
          <target state="translated">Esistono due modi per evitare questo problema:</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method before you call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo prima di chiamare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method always respects existing method implementation flags.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> metodo rispetta sempre i flag di implementazione di metodo esistente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you set implementation flags, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">Quando si impostano i flag di implementazione, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> metodo per recuperare i flag esistenti, utilizzare un bit per bit o per aggiungere il flag e quindi chiamare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The code sample below illustrates the contextual use of the <ph id="ph1">`SetImplementationFlags`</ph> method to describe the implementation of MSIL in a method body.</source>
          <target state="translated">L'esempio di codice riportato di seguito è illustrato l'utilizzo contestuale del <ph id="ph1">`SetImplementationFlags`</ph> per descrivere l'implementazione del codice MSIL in un corpo del metodo.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Marshaling information for the return type of this method.</source>
          <target state="translated">Informazioni di marshalling per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Sets marshaling information for the return type of this method.</source>
          <target state="translated">Imposta le informazioni di marshalling per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetMarshal`</ph> method to marshal the results of a method call as a different type.</source>
          <target state="translated">L'esempio di codice riportato di seguito è illustrato l'utilizzo contestuale del <ph id="ph1">`SetMarshal`</ph> metodo per effettuare il marshalling i risultati di una chiamata al metodo come un tipo diverso.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array that contains valid MSIL instructions.</source>
          <target state="translated">Matrice che contiene istruzioni MSIL valide.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The maximum stack evaluation depth.</source>
          <target state="translated">Profondità massima di valutazione dello stack.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array of bytes that contain the serialized local variable structure.</source>
          <target state="translated">Matrice di byte che contiene la struttura di variabile locale serializzata.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no local variables.</source>
          <target state="translated">Specifica <ph id="ph1">&lt;see langword="null" /&gt;</ph> se il metodo non ha variabili locali.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection that contains the exception handlers for the method.</source>
          <target state="translated">Raccolta contenente i gestori di eccezioni per il metodo.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no exception handlers.</source>
          <target state="translated">Specifica <ph id="ph1">&lt;see langword="null" /&gt;</ph> se il metodo non ha gestori di eccezioni.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection of values that represent offsets in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, each of which specifies the beginning of a token that may be modified.</source>
          <target state="translated">Raccolta di valori che rappresentano gli offset in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, ciascuno dei quali specifica l'inizio di un token che può essere modificato.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no tokens that have to be modified.</source>
          <target state="translated">Specifica <ph id="ph1">&lt;see langword="null" /&gt;</ph> se il metodo non ha token da modificare.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Crea il corpo del metodo usando una matrice di byte specificata di istruzioni Microsoft Intermediate Language (MSIL).</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="il" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="il" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> è negativo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifies an offset outside of <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</source>
          <target state="translated">Uno degli oggetti <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifica un offset all'esterno di <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifies an offset that is outside the <ph id="ph2">&lt;paramref name="il" /&gt;</ph> array.</source>
          <target state="translated">Uno degli oggetti <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifica un offset all'esterno della matrice <ph id="ph2">&lt;paramref name="il" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The containing type was previously created using the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Il tipo che lo contiene è stato creato in precedenza utilizzando il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>This method was called previously on this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Il metodo è stato chiamato in precedenza su questo oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the parameter types.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano i tipi di parametro.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Sets the number and types of parameters for a method.</source>
          <target state="translated">Imposta il numero e i tipi di parametri per un metodo.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Se il numero e tipi dei parametri sono noti quando il metodo è definito, possono essere impostate utilizzando un overload del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo che accetta una matrice di tipi di parametro.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Utilizzare questo metodo per impostare i tipi di parametro in questo caso.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Se il tipo restituito contiene modificatori personalizzati obbligatori o facoltativi, ad esempio <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Calling this method replaces any parameter types that were set using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chiamare questo metodo sostituisce i tipi di parametri che sono stati impostati utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">Nell'esempio di codice viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo per rendere un metodo generico.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> metodo viene utilizzato per assegnare al parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> metodo viene utilizzato per assegnare al metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Questo significa che la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the return type of the method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Sets the return type of the method.</source>
          <target state="translated">Imposta il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</source>
          <target state="translated">Utilizzare questo metodo per impostare il tipo restituito di un metodo generico, quando viene specificato il tipo restituito da uno dei parametri di tipo generico del metodo.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Se il tipo restituito contiene modificatori personalizzati obbligatori o facoltativi, ad esempio <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Calling this method replaces a return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chiamare questo metodo sostituisce un tipo restituito stabilito tramite la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">Nell'esempio di codice viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo per rendere un metodo generico.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> metodo viene utilizzato per assegnare al parametro di un metodo, il cui tipo verrà specificato dal primo parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> metodo viene utilizzato per assegnare al metodo di un tipo restituito, specificato dal secondo parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Questo significa che la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</source>
          <target state="translated">Imposta la firma del metodo, incluso il tipo restituito, i tipi di parametro e i modificatori personalizzati obbligatori e facoltativi del tipo restituito e dei tipi di parametro.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Se il tipo restituito e il numero e i tipi dei parametri sono noti quando il metodo è definito, può essere stabilite utilizzando un overload del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo che accetta una matrice di tipi di parametro.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">Tuttavia, un metodo generico può avere parametri i cui tipi sono specificati da uno o più dei propri parametri di tipo generico, non è possibile definire fino a dopo il metodo è stato definito.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Utilizzare questo metodo per impostare i tipi di parametro in questo caso.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If neither the return type nor the parameter types have optional or required custom modifiers, such as <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, you can use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> methods.</source>
          <target state="translated">Se il tipo restituito né i tipi di parametro contengono modificatori personalizzati obbligatori o facoltativi, ad esempio <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, è possibile utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Calling this method replaces the parameters and return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chiamare questo metodo sostituisce i parametri e tipo restituito stabilito tramite la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata Sample che dispone di un parametro di tipo <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method <ph id="ph3">`GM`</ph> with its own type parameter, <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La classe dispone di un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>e un metodo generico <ph id="ph3">`GM`</ph> con un parametro di tipo <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of Sample, substituting its own type parameter <ph id="ph2">`U`</ph> for the type parameter of Sample, and stores its input parameter in <ph id="ph3">`Field`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`GM`</ph> crea un'istanza di esempio, sostituendo il parametro di tipo <ph id="ph2">`U`</ph> per il parametro di tipo di esempio e archivia il relativo parametro di input in <ph id="ph3">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Questo codice sorgente viene compilato ma non è utilizzato; è possibile visualizzare con il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>e confrontarla con il codice generato dalla classe <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method in emitting generic code.</source>
          <target state="translated">Il codice nella classe <ph id="ph1">`Example`</ph> viene illustrato come utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> metodo per creare codice generico.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`Main`</ph> metodo della classe <ph id="ph2">`Example`</ph> crea un assembly dinamico che contiene una classe denominata <ph id="ph3">`Sample`</ph>e utilizza il <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> metodo per renderlo generico aggiungendo un parametro di tipo denominato <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un costruttore predefinito e un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>, vengono aggiunti alla classe <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A method <ph id="ph1">`GM`</ph> is added, and turned into a generic method using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Un metodo <ph id="ph1">`GM`</ph> è aggiunto e attivata in un metodo generico utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Il parametro di tipo <ph id="ph1">`GM`</ph> denominato <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Once the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added, using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method.</source>
          <target state="translated">Una volta definito il parametro di tipo, la firma di <ph id="ph1">`GM`</ph> venga aggiunto mediante il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>There is no return type, and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>, which sets the type of the only parameter of the method; this is set to the method's type parameter, <ph id="ph3">`U`</ph>.</source>
          <target state="translated">Vi è alcun tipo restituito e i modificatori non obbligatori o personalizzati, in modo che siano tutti i parametri di questo metodo <ph id="ph1">`null`</ph> tranne <ph id="ph2">`parameterTypes`</ph>, che imposta il tipo dell'unico parametro del metodo; è impostato su parametro di tipo del metodo, <ph id="ph3">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Il corpo del metodo crea un'istanza del tipo costruito <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assegna il parametro del metodo per <ph id="ph3">`Field`</ph>e quindi stampato il valore di <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A dummy type is defined, to hold the entry point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Viene definito un tipo fittizio per contenere il metodo del punto di ingresso <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Nel corpo di <ph id="ph1">`Main`</ph>, statica <ph id="ph2">`GM`</ph> metodo viene richiamato nel tipo generico costruito <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), con il tipo <ph id="ph5">&lt;xref:System.String&gt;</ph> sostituito con <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> metodo viene utilizzato per creare un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> per statica <ph id="ph3">`GM`</ph> metodo del tipo generico costruito <ph id="ph4">`Sample&lt;U&gt;`</ph>e <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> metodo viene quindi utilizzato per creare un <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che possono emessi in una chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Quando si esegue l'esempio di codice, come TypeBuilderGetFieldExample.exe salva l'assembly generato.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per confrontare il codice generato con il codice per la <ph id="ph1">`Sample`</ph> classe che viene compilato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Il metodo corrente è un metodo generico, ma non una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Questo significa che la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the symbolic custom attribute.</source>
          <target state="translated">Nome dell'attributo personalizzato simbolico.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The byte blob that represents the value of the symbolic custom attribute.</source>
          <target state="translated">BLOB di byte che rappresenta il valore dell'attributo personalizzato simbolico.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Set a symbolic custom attribute using a blob.</source>
          <target state="translated">Imposta un attributo personalizzato simbolico usando un BLOB.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</source>
          <target state="translated">A differenza dell'attributo personalizzato di metadati, questo attributo personalizzato è associato a un writer di simboli.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetSymCustomAttribute`</ph> method to set the byte values for the name and key of a custom attribute attached to a method.</source>
          <target state="translated">L'esempio di codice riportato di seguito è illustrato l'utilizzo contestuale del <ph id="ph1">`SetSymCustomAttribute`</ph> per impostare i valori di byte per il nome e la chiave di un attributo personalizzato associato a un metodo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The module that contains this method is not a debug module.</source>
          <target state="translated">Il modulo che contiene il metodo non è un modulo di debug.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il metodo corrente la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Retrieves the signature of the method.</source>
          <target state="translated">Recupera la firma del metodo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>A String containing the signature of the method reflected by this <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Oggetto String contenente la firma del metodo ottenuto mediante reflection dall'istanza di <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matrice di nomi passata di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Conteggio dei nomi di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contesto delle impostazioni locali in cui interpretare i nomi.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informazioni sul tipo da restituire.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificatore delle impostazioni locali per le informazioni sul tipo.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica il membro.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flag che descrivono il contesto della chiamata.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntatore alla posizione in cui deve essere archiviato il risultato.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntatore a una struttura contenente informazioni sull'eccezione.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indice del primo argomento che contiene un errore.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::Invoke`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance as a string.</source>
          <target state="translated">Restituisce questa istanza di <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> come stringa.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</source>
          <target state="translated">Restituisce una stringa che contiene il nome, gli attributi, la firma, le eccezioni e la firma locale del metodo, seguiti dal flusso MSIL (Microsoft Intermediate Language) corrente.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>