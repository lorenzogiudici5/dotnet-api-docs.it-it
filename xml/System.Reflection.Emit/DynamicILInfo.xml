<Type Name="DynamicILInfo" FullName="System.Reflection.Emit.DynamicILInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f003344e2bc089bdad2d02073169a363261e857" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469744" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicILInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicILInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicILInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicILInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicILInfo" />
  <TypeSignature Language="F#" Value="type DynamicILInfo = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce supporto per utilizzare metodi alternativi per generare codice MSIL (Microsoft Intermediate Language) e metadati per un metodo dinamico, inclusi metodi per la creazione di token e per l'inserimento di codice, gestione delle eccezioni e blob di firma per le variabili locali.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicILInfo> classe consente agli sviluppatori di scrivere i propri generatori MSIL anziché <xref:System.Reflection.Emit.ILGenerator>.  
  
 Per creare istanze di altri tipi, chiamare i metodi e così via, il codice MSIL generato deve includere i token per le entità. Il <xref:System.Reflection.Emit.DynamicILInfo> classe fornisce numerosi overload del <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> metodo, che restituiscono token validi nell'ambito dell'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo>. Se, ad esempio, è necessario chiamare un overload del <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metodo, è possibile ottenere un <xref:System.RuntimeMethodHandle> per l'overload e passarlo al <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> metodo per ottenere un token da incorporare nel codice MSIL.  
  
 Dopo aver creato <xref:System.Byte> array per la firma della variabile locale, le eccezioni e il corpo di codice, è possibile usare il <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, e <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> metodi per inserirli nel <xref:System.Reflection.Emit.DynamicMethod> associato il <xref:System.Reflection.Emit.DynamicILInfo> oggetto.  
  
 La generazione di metadati e MSIL personalizzati richiede una certa familiarità con la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica" e "Partizione III: CIL Instruction Set". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
> [!NOTE]
>  Non utilizzare <xref:System.Reflection.Emit.DynamicILInfo> per generare il codice che crea un delegato a un altro metodo dinamico chiamando direttamente il costruttore di delegato. In alternativa, usare il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo per creare il delegato. Un delegato che viene creato con il costruttore di delegato non presenta un riferimento al metodo dinamico di destinazione. Il metodo dinamico può essere recuperato tramite garbage collection, mentre il delegato è ancora in uso.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="DynamicMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Emit.DynamicMethod DynamicMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicMethod As DynamicMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::DynamicMethod ^ DynamicMethod { System::Reflection::Emit::DynamicMethod ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicMethod : System.Reflection.Emit.DynamicMethod" Usage="System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicMethod</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il metodo dinamico il cui corpo viene generato dall'istanza corrente.</summary>
        <value>Oggetto <see cref="T:System.Reflection.Emit.DynamicMethod" /> che rappresenta il metodo dinamico per il quale l'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente genera il codice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Reflection.Emit.DynamicILInfo> oggetto è sempre associato a un metodo dinamico. Lo scopo del <xref:System.Reflection.Emit.DynamicILInfo> classe consiste nello specificare un altro modo per inserire il flusso MSIL, la gestione delle eccezioni e firma della variabile locale in un metodo dinamico, per gli sviluppatori che desiderano generano codice MSIL senza utilizzare il <xref:System.Reflection.Emit.ILGenerator> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTokenFor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta una stringa, un campo, un metodo, un tipo o una firma nel flusso MSIL per il metodo dinamico associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (signature As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : byte[] -&gt; int" Usage="dynamicILInfo.GetTokenFor signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="signature">Matrice che contiene la firma.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta la firma per il metodo dinamico associato.</summary>
        <returns>Un token può essere incorporato nei metadati e nel flusso MSIL per il metodo dinamico associato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sui blob di firma, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(class System.Reflection.Emit.DynamicMethod method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As DynamicMethod) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::Reflection::Emit::DynamicMethod ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : System.Reflection.Emit.DynamicMethod -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Emit.DynamicMethod" />
      </Parameters>
      <Docs>
        <param name="method">Metodo dinamico da chiamare.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un metodo dinamico da chiamare dal metodo associato.</summary>
        <returns>Un token può essere incorporato nel flusso MSIL per il metodo dinamico associato, come destinazione di un'istruzione MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token restituito da questo overload del metodo consente di chiamare un metodo dinamico dal metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Per chiamare il metodo dinamico associato in modo ricorsivo, passare il valore della <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="field">Campo al quale accedere.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un campo a cui accedere dal metodo dinamico associato.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che accede ai campi nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario ottenere un token per qualsiasi campo cui si accederà dal metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Usare la <xref:System.Type.GetField%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.FieldInfo> per il campo che si desidera accedere, quindi utilizzare il <xref:System.Reflection.FieldInfo.FieldHandle%2A> proprietà da ottenere la <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metodo al quale accedere.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un metodo dinamico a cui accedere dal metodo dinamico associato.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che accede ai metodi, ad esempio <see cref="F:System.Reflection.Emit.OpCodes.Call" /> o <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario ottenere un token per qualsiasi metodo di cui è necessario accedere con il metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Usare la <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.MethodInfo> per il metodo che si desidera accedere e quindi usare il <xref:System.Reflection.MethodBase.MethodHandle%2A> proprietà da ottenere la <xref:System.RuntimeMethodHandle>.  
  
> [!NOTE]
>  Per un metodo che appartiene a un tipo generico, usare il <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29> metodo di overload e specificare un <xref:System.RuntimeTypeHandle> per il tipo generico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (type As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Tipo da utilizzare.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un tipo da utilizzare nel metodo dinamico associato.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che richiede un tipo nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token restituito da questo overload del metodo consente di definire un tipo di variabile locale e generare codice MSIL per creare un'istanza di un tipo del metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto.  
  
 Per ottenere un <xref:System.RuntimeTypeHandle> che rappresenta un tipo, usare il <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (string literal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(string literal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (literal As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::String ^ literal);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : string -&gt; int" Usage="dynamicILInfo.GetTokenFor literal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="literal" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="literal">Stringa da utilizzare.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta una stringa letterale da utilizzare nel metodo dinamico associato.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che richiede una stringa nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (field, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="field">Campo al quale accedere.</param>
        <param name="contextType">Tipo generico a cui appartiene il campo.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un campo a cui accedere dal metodo dinamico associato; il campo si trova sul tipo generico specificato.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che accede ai campi nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario ottenere un token per qualsiasi campo cui si accederà dal metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Usare la <xref:System.Type.GetField%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.FieldInfo> per il campo che si desidera accedere e quindi usare il <xref:System.Reflection.FieldInfo.FieldHandle%2A> proprietà da ottenere la <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (method, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metodo.</param>
        <param name="contextType">Il tipo generico a cui appartiene il metodo.</param>
        <summary>Ottiene un token, valido nell'ambito della classe <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente, che rappresenta un metodo in un tipo generico.</summary>
        <returns>Token che può essere utilizzato come operando di un'istruzione MSIL che accede ai metodi, ad esempio <see cref="F:System.Reflection.Emit.OpCodes.Call" /> o <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, nell'ambito dell'oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario ottenere un token per qualsiasi metodo che verrà chiamato dal metodo dinamico associato all'oggetto corrente <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Usare la <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.MethodInfo> per il metodo da chiamare e quindi usare il <xref:System.Reflection.MethodBase.MethodHandle%2A> proprietà da ottenere la <xref:System.RuntimeMethodHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta il corpo del codice del metodo dinamico associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte[] code, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8[] code, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCode (code As Byte(), maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(cli::array &lt;System::Byte&gt; ^ code, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : byte[] * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte[]" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Matrice contenente il flusso MSIL.</param>
        <param name="maxStackSize">Numero massimo di elementi nello stack di operandi durante l'esecuzione del metodo.</param>
        <summary>Imposta il corpo del codice del metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene eseguito alcun controllo di validità del flusso MSIL.  
  
 Chiamare questo metodo una seconda volta sostituisce il primo flusso MSIL con il secondo.  
  
 La generazione di metadati e MSIL personalizzati richiede una certa familiarità con la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica" e "Partizione III: CIL Instruction Set". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8* code, int32 codeSize, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(System::Byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : nativeptr&lt;byte&gt; * int * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, codeSize, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte*" />
        <Parameter Name="codeSize" Type="System.Int32" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Puntatore a una matrice di byte contenente il flusso MSIL.</param>
        <param name="codeSize">Numero di byte nel flusso MSIL.</param>
        <param name="maxStackSize">Numero massimo di elementi nello stack di operandi durante l'esecuzione del metodo.</param>
        <summary>Imposta il corpo del codice del metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene eseguito alcun controllo di validità del flusso MSIL.  
  
 Chiamare questo metodo una seconda volta sostituisce il primo flusso MSIL con il secondo.  
  
 La generazione di metadati e MSIL personalizzati richiede una certa familiarità con la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica" e "partizione III: Set di istruzioni CIL." La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="code" /> è <see langword="null" /> e <paramref name="codeSize" /> è maggiore di 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codeSize" /> è minore di 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetExceptions">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta i metadati delle eccezioni del metodo dinamico associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte[] exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8[] exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetExceptions (exceptions As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(cli::array &lt;System::Byte&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : byte[] -&gt; unit" Usage="dynamicILInfo.SetExceptions exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="exceptions">Matrice contenente i metadati delle eccezioni.</param>
        <summary>Imposta i metadati delle eccezioni del metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metadati di eccezione per un metodo definiscono la posizione e dimensioni di tutti i `try`, `catch`, `finally`, filtro e blocchi di errori. Per informazioni sul layout dei metadati, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8* exceptions, int32 exceptionsSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(System::Byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetExceptions (exceptions, exceptionsSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte*" />
        <Parameter Name="exceptionsSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exceptions">Puntatore a una matrice di byte contenente i metadati delle eccezioni.</param>
        <param name="exceptionsSize">Numero di byte dei metadati delle eccezioni.</param>
        <summary>Imposta i metadati delle eccezioni del metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metadati di eccezione per un metodo definiscono la posizione e dimensioni di tutti i `try`, `catch`, `finally`, filtro e blocchi di errori. Per informazioni sul layout dei metadati, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica" e "Partizione III: CIL Instruction Set". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptions" /> è <see langword="null" /> e <paramref name="exceptionSize" /> è maggiore di 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exceptionSize" /> è minore di 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetLocalSignature">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta la firma delle variabili locali che descrive il layout delle variabili locali per il metodo dinamico associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte[] localSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8[] localSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLocalSignature (localSignature As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(cli::array &lt;System::Byte&gt; ^ localSignature);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : byte[] -&gt; unit" Usage="dynamicILInfo.SetLocalSignature localSignature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="localSignature">Matrice contenente il layout delle variabili locali per l'oggetto <see cref="T:System.Reflection.Emit.DynamicMethod" /> associato.</param>
        <summary>Imposta la firma delle variabili locali che descrive il layout delle variabili locali per il metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma della variabile locale descrive il layout delle variabili locali del metodo. Per semplificare la costruzione di firma della variabile locale, usare il `static` (`Shared` in Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.Emit.SignatureHelper> per la firma locale.  
  
 Per informazioni sulle firme di variabile locale, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte* localSignature, int signatureSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8* localSignature, int32 signatureSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(System::Byte* localSignature, int signatureSize);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetLocalSignature (localSignature, signatureSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte*" />
        <Parameter Name="signatureSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localSignature">Matrice contenente il layout delle variabili locali per l'oggetto <see cref="T:System.Reflection.Emit.DynamicMethod" /> associato.</param>
        <param name="signatureSize">Il numero di byte nella firma.</param>
        <summary>Imposta la firma delle variabili locali che descrive il layout delle variabili locali per il metodo dinamico associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma della variabile locale descrive il layout delle variabili locali del metodo. Per semplificare la costruzione di firma della variabile locale, usare il `static` (`Shared` in Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Reflection.Emit.SignatureHelper> per la firma locale.  
  
 Per informazioni sulle firme di variabile locale, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: metadati definizione e la semantica". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localSignature" /> è <see langword="null" /> e <paramref name="signatureSize" /> è maggiore di 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="signatureSize" /> è minore di 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
  </Members>
</Type>