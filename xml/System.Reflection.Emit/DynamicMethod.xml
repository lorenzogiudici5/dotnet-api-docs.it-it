<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27f229b19693e5f93b88f14817c1ac384a6931af" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48701187" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce e rappresenta un metodo dinamico che può essere compilato, eseguito e annullato. I metodi annullati possono essere sottoposti a Garbage Collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Reflection.Emit.DynamicMethod> classe da generare ed eseguire un metodo in fase di esecuzione senza la necessità di generare un assembly dinamico e un tipo dinamico che contenga il metodo. Il codice eseguibile creato dal compilatore just-in-time (JIT) viene recuperato quando la <xref:System.Reflection.Emit.DynamicMethod> oggetto venga recuperato. I metodi dinamici sono il modo più efficiente per generare ed eseguire piccole quantità di codice.  
  
 Un metodo dinamico può essere ospitato in modo anonimo, o può essere associato in modo logico con un modulo o con un tipo.  
  
-   Se il metodo dinamico è ospitato in modo anonimo, si trova in un assembly fornito dal sistema e pertanto è isolata dal resto del codice. Per impostazione predefinita, non ha accesso a tutti i dati non pubblici. Un metodo dinamico ospitato anonimamente può avere una limitata capacità di ignorare i controlli di visibilità del compilatore JIT, se è stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag. Il livello di attendibilità dell'assembly i cui membri non pubblici sono accessibili dal metodo dinamico deve essere uguale o è un subset di, il livello di attendibilità dello stack di chiamate che ha generato il metodo dinamico. Per altre informazioni sui metodi dinamici ospitati anonimamente, vedere [procedura dettagliata: creazione di codice in scenari di attendibilità parziale](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Se il metodo dinamico è associato a un modulo specificato, il metodo dinamico è globale per tale modulo. Può accedere a tutti i tipi nel modulo e tutte `internal` (`Friend` in Visual Basic) membri dei tipi. È possibile associare una dinamica metodo con tutti i moduli, indipendentemente dal fatto se si ha creato il modulo, a condizione che una richiesta per il <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag può essere soddisfatte tramite lo stack di chiamate che include il codice. Se il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag è incluso nella concessione, il metodo dinamico è possibile ignorare i controlli di visibilità del compilatore JIT e accedere ai dati privati di tutti i tipi dichiarati nel modulo o in qualsiasi altro modulo nell'assembly.  
  
    > [!NOTE]
    >  Quando si specifica il modulo a cui è associato un metodo dinamico, tale modulo non deve essere nell'assembly fornito dal sistema che viene usato per l'hosting anonimo.  
  
-   Se il metodo dinamico è associato a un tipo specificato, ha accesso a tutti i membri del tipo, indipendentemente dal livello di accesso. Inoltre, i controlli di visibilità JIT possono essere ignorati. In questo modo il metodo dinamico può accedere ai dati privati di altri tipi dichiarati nel modulo stesso o in qualsiasi altro modulo nell'assembly. È possibile associare un metodo dinamico con qualsiasi tipo, ma il codice deve essere concesso <xref:System.Security.Permissions.ReflectionPermission> con entrambe le <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> e <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.  
  
 La tabella seguente illustra i tipi e membri sono accessibili a un metodo dinamico ospitato anonimamente, con e senza controlli di visibilità JIT, a seconda che <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag viene concessa.  
  
||Senza <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Con <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Senza ignorare i controlli di visibilità JIT|Membri pubblici dei tipi pubblici nell'assembly.|Membri pubblici dei tipi pubblici nell'assembly.|  
|JIT di ignorare i controlli di visibilità, con restrizioni|Membri pubblici dei tipi pubblici nell'assembly.|Tutti i membri di tutti i tipi, solo negli assembly di cui livelli di attendibilità sono uguale o inferiore rispetto al livello di attendibilità dell'assembly che ha generato il metodo dinamico.|  
  
> [!NOTE]
>  Nelle versioni precedenti per il [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], creazione di codice richiedeva <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. Questa autorizzazione è inclusa per impostazione predefinita nel set di autorizzazioni denominati LocalIntranet e FullTrust, ma non nel set di autorizzazioni Internet. Pertanto, nelle versioni precedenti del [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] una libreria può essere utilizzata con autorizzazioni Internet solo se ha il <xref:System.Security.SecurityCriticalAttribute> dell'attributo e anche l'esecuzione di un' <xref:System.Security.PermissionSet.Assert%2A> per <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Tali librerie richiedono un'attenta revisione della sicurezza perché eventuali errori nel codice potrebbe produrre delle vulnerabilità. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] consente di generare codice in scenari con attendibilità parziale senza creare alcuna richiesta di sicurezza, poiché la generazione di codice non è implicitamente un'operazione con privilegi. Ovvero, il codice generato non dispone di ulteriori autorizzazioni rispetto all'assembly che lo genera. Questo consente alle librerie che generano il codice di essere SecurityTransparent ed elimina la necessità di asserire <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, che semplifica l'attività di scrittura di una libreria protetta. Per usare questa funzionalità, l'applicazione deve avere come destinazione il [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 Nella tabella seguente vengono descritti tipi e membri sono accessibili a un metodo dinamico è associato a un modulo o con un tipo in un modulo.  
  
||Associato al modulo|Associata al tipo|  
|-|-|-|  
|Senza ignorare i controlli di visibilità JIT|Membri pubblici e interni dei tipi pubblici, interni e privati nel modulo.<br /><br /> Membri pubblici dei tipi pubblici nell'assembly.|Tutti i membri del tipo associato. Membri pubblici e interni di tutti gli altri tipi nel modulo.<br /><br /> Membri pubblici dei tipi pubblici nell'assembly.|  
|Controlli di visibilità JIT verrà ignorati|Tutti i membri di tutti i tipi nell'assembly.|Tutti i membri di tutti i tipi nell'assembly.|  
  
 Un metodo dinamico associato a un modulo ha le autorizzazioni di tale modulo. Un metodo dinamico associato a un tipo ha le autorizzazioni del modulo contenente il tipo.  
  
 I metodi dinamici e i relativi parametri non deve essere denominato, ma è possibile specificare nomi per facilitare il debug. Gli attributi personalizzati non sono supportati i metodi dinamici o i relativi parametri.  
  
 Anche se sono i metodi dinamici `static` metodi (`Shared` metodi in Visual Basic), l'assoluta regole per associazione di delegati introdotte nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] consentono un metodo dinamico deve essere associato a un oggetto, in modo che funga da un metodo di istanza quando chiamata mediante l'istanza del delegato. Un esempio di questa procedura è disponibile per il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo.  
  
> [!NOTE]
>  Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], i metodi dinamici non supportano le informazioni sui simboli, ovvero, i nomi delle variabili locali e il mapping del numero di riga. Questa limitazione potrebbe essere rimossa in una versione futura. È possibile usare <xref:System.Reflection.Emit.AssemblyBuilder> durante lo sviluppo per semplificare il debug generato Microsoft intermedio language (MSIL) e quindi passare ai metodi dinamici durante la distribuzione finale, perché il <xref:System.Reflection.Emit.ILGenerator> chiamate siano uguali in entrambi i casi.  
  
## <a name="verification"></a>Verifica  
 Nell'elenco seguente vengono riepilogate le condizioni in base alle quali i metodi dinamici possono contenere codice non verificabile. (Ad esempio, un metodo dinamico non è verificabile se relativi <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> è impostata su `false`.)  
  
-   Un metodo dinamico associato a un assembly critico per la sicurezza è anche SecurityCritical e possibile ignorare la verifica. Ad esempio, un assembly senza attributi di sicurezza che viene eseguito come un'applicazione desktop viene considerato come SecurityCritical dal runtime. Se si associa un metodo dinamico con l'assembly, il metodo dinamico può contenere codice non verificabile.  
  
-   Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con trasparenza di livello 1, il compilatore JIT just-in-time inserisce una richiesta di sicurezza. La richiesta ha esito positivo solo se il metodo dinamico viene eseguito da codice completamente attendibile. Visualizzare [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con la trasparenza di livello 2 (ad esempio mscorlib. dll), genera un'eccezione (inserita dal compilatore JIT) invece di effettuare una richiesta di sicurezza. Visualizzare [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Un metodo dinamico ospitato anonimamente che contiene sempre il codice non verificabile genera un'eccezione. Non è possibile ignorare la verifica, anche se viene creata ed eseguita da codice completamente attendibile.  
  
 L'eccezione generata per il codice non verificabile varia a seconda del modo in cui che viene richiamato il metodo dinamico. Se si richiama un metodo dinamico usando un delegato restituito dal <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo, un <xref:System.Security.VerificationException> viene generata un'eccezione. Se si richiama il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo, una <xref:System.Reflection.TargetInvocationException> generata con inner <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. L'esempio emette il corpo di una funzione semplice che stampa il primo parametro nella console e l'esempio Usa il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo).  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Procedura dettagliata: creazione di codice in scenari di attendibilità parziale</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un metodo dinamico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <summary>Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito e i tipi di parametro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo. L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice. Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito dal codice parzialmente attendibile.  
  
 Questo costruttore viene specificato che just-in-time (JIT) i controlli di visibilità saranno imposte per Microsoft intermedio language (MSIL) del metodo dinamico. Vale a dire, il codice del metodo dinamico ha accesso ai metodi pubblici delle classi pubbliche. Le eccezioni vengono generate se il metodo tenta di accedere a tipi o membri che sono `private`, `protected`, o `internal` (`Friend` in Visual Basic). Per creare un metodo dinamico con possibilità di ignorare i controlli di visibilità JIT limitate, usare il <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> costruttore.  
  
 Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso. Quando viene richiamato il metodo, le autorizzazioni di concessioni dell'assembly sono utilizzate invece le autorizzazioni del chiamante effettivo. Di conseguenza, non è possibile eseguire il metodo dinamico a un livello di privilegi superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Questo costruttore è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Procedura dettagliata: creazione di codice in scenari di attendibilità parziale</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri a cui accede il linguaggio MSIL del metodo dinamico, con questa restrizione: il livello di attendibilità degli assembly che contengono questi tipi e membri deve essere uguale o minore di quello dello stack di chiamata che genera il metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito, i tipi di parametro e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo. L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice. Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito dal codice parzialmente attendibile.  
  
 Metodi dinamici ospitati anonimamente non hanno accesso automatico a tutti i tipi o membri che corrispondono `private`, `protected`, o `internal` (`Friend` in Visual Basic). Questo è diverso da metodi dinamici associati a un tipo esistente o un modulo, che dispongono dell'accesso ai membri nascosti nel proprio ambito associato.  
  
 Specificare `true` per `restrictedSkipVisibility` se il metodo dinamico deve accedere a tipi o membri che vengono `private`, `protected`, o `internal`. In questo modo il metodo dinamico limitato l'accesso a questi membri. Vale a dire, i membri sono accessibili solo se vengono soddisfatte le condizioni seguenti:  
  
-   I membri di destinazione appartengono a un assembly con un livello di attendibilità uguale o minore di stack di chiamate che genera il metodo dinamico.  
  
-   Lo stack di chiamate che genera il metodo dinamico viene concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag. Ciò vale sempre quando viene eseguito il codice con attendibilità totale. Per codice parzialmente attendibile, è vero solo se l'host concede in modo esplicito l'autorizzazione.  
  
    > [!IMPORTANT]
    >  Se non è stato concesso l'autorizzazione, viene generata un'eccezione di sicurezza quando <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> viene chiamato o quando viene richiamato il metodo dinamico, non quando viene chiamato questo costruttore. Non speciali sono necessarie autorizzazioni per generare il metodo dinamico.  
  
 Ad esempio, un metodo dinamico che viene creato con `restrictedSkipVisibility` impostato su `true` può accedere a un membro privato di qualsiasi assembly nello stack di chiamate se lo stack di chiamate è stato concesso l'accesso limitato al membro. Se il metodo dinamico viene creato con codice parzialmente attendibile nello stack di chiamate, non è possibile accedere a un membro privato di un tipo in un [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] assembly, poiché tali assembly sono completamente attendibili.  
  
 Se `restrictedSkipVisibility` è `false`, vengono applicati i controlli di visibilità JIT. Il codice del metodo dinamico ha accesso ai metodi pubblici delle classi pubbliche e le eccezioni vengono generate se tenta di accedere a tipi o membri che sono `private`, `protected`, o `internal`.  
  
 Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso. Quando viene richiamato il metodo, le autorizzazioni dello stack di chiamate emissione sono utilizzate invece le autorizzazioni del chiamante effettivo. Di conseguenza, non è possibile eseguire il metodo dinamico a un livello di privilegi superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Questo costruttore è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Procedura dettagliata: creazione di codice in scenari di attendibilità parziale</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">Oggetto <see cref="T:System.Reflection.Module" /> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</param>
        <summary>Crea un metodo dinamico che è globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametro e il modulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e non ignora i controlli di visibilità just-in-time (JIT).  
  
 Il metodo dinamico creato con questo costruttore può accedere a public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi di contenuto nel modulo `m`.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `m` è un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. L'esempio emette il corpo di una funzione semplice che stampa il primo parametro nella console e l'esempio Usa il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> (metodo).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="m" /> è un modulo che fornisce hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i parametri di tipo e il tipo a cui il metodo dinamico è associato dal punto di vista logico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore può accedere a tutti i membri del tipo `owner`e su pubblico e `internal` (`Friend` in Visual Basic) membri di tutti gli altri tipi nel modulo che contiene `owner`.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e non ignora i controlli di visibilità just-in-time (JIT).  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `owner` di un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Reflection.Emit.DynamicMethod> associato in modo logico con un tipo. Questa associazione fornisce l'accesso ai membri privati di quel tipo.  
  
 L'esempio di codice definisce una classe denominata `Example` con un campo privato, una classe denominata `DerivedFromxample` che deriva dalla classe di primo, un tipo delegato denominato `UseLikeStatic` che restituisce <xref:System.Int32> contenente i parametri di tipo `Example` e<xref:System.Int32>e un tipo delegato denominato `UseLikeInstance` che restituisce <xref:System.Int32> e ha un parametro di tipo <xref:System.Int32>.  
  
 Il codice di esempio crea quindi una <xref:System.Reflection.Emit.DynamicMethod> che modifica il campo privato di un'istanza di `Example` e restituisce il valore precedente.  
  
> [!NOTE]
>  In generale, modificando i campi interni di classi non buona procedura di codifica basato sugli oggetti.  
  
 Il codice di esempio crea un'istanza di `Example` e quindi crea due delegati. Il primo è di tipo `UseLikeStatic`, che ha gli stessi parametri del metodo dinamico. Il secondo JE typu `UseLikeInstance`, che non è presente il primo parametro (di tipo `Example`). Questo delegato viene creato utilizzando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo; il secondo parametro di tale overload del metodo è un'istanza di `Example`, in questo caso l'istanza appena creato, che è associato al delegato appena creato. Ogni volta che il delegato viene richiamato, il metodo dinamico agisce sull'istanza associata di `Example`.  
  
> [!NOTE]
>  Questo è un esempio delle regole di tipo "relaxed" per associazione di delegati introdotte nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], insieme ai nuovi overload del <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> (metodo). Per altre informazioni, vedere la classe <xref:System.Delegate>.  
  
 Il `UseLikeStatic` delegato viene richiamato, passando l'istanza del `Example` associato ai `UseLikeInstance` delegare. L'oggetto `UseLikeInstance` delegato viene richiamato, in modo che entrambi i delegati agiscono sulla stessa istanza di `Example`. Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata. Infine, un `UseLikeInstance` delegato è associato a un'istanza di `DerivedFromxample`, e vengono ripetute di chiamate al delegato.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è <see langword="null" /> o è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">Oggetto <see cref="T:System.Reflection.Module" /> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT su tipi e membri a cui accede il linguaggio MSIL del metodo dinamico.</param>
        <summary>Crea un metodo dinamico globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametri e il modulo e indicando se deve essere ignorato il controllo di visibilità JIT per i tipi e i membri del metodo dinamico a cui accede MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 Il metodo dinamico creato con questo costruttore può accedere a public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi contenuti nel modulo `m`. Controlli di visibilità del compilatore verrà ignorato il compilatore JIT consente il metodo dinamico accedere ai membri privati e protetti anche tutti gli altri tipi. Ciò è utile, ad esempio, quando si scrive codice per serializzare oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `m` è un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="m" /> è un modulo che fornisce hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore può accedere a tutti i membri del tipo `owner`e su pubblico e `internal` (`Friend` in Visual Basic) membri di tutti gli altri tipi nel modulo che contiene `owner`. Controlli di visibilità del compilatore verrà ignorato il compilatore JIT consente il metodo dinamico accedere ai membri privati e protetti anche tutti gli altri tipi. Ciò è utile, ad esempio, quando si scrive codice per serializzare oggetti.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `owner` di un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è <see langword="null" /> o è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.MethodAttributes" /> che specifica gli attributi del metodo dinamico. L'unica combinazione consentita è <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convenzione di chiamata per il metodo dinamico. Deve essere <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico globale per un metodo, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il modulo e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore può accedere a public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi pubblici e interni contenuti nel modulo `m`.  
  
 Controlli di visibilità del compilatore verrà ignorato il compilatore JIT consente il metodo dinamico accedere ai membri privati e protetti tutti gli altri tipi nel modulo e in tutti gli altri assembly. Ciò è utile, ad esempio, quando si scrive codice per serializzare oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `m` è un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="m" /> è un modulo che fornisce hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> è una combinazione di flag diversa da <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
oppure 
 <paramref name="callingConvention" /> non è <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
oppure 
 <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.MethodAttributes" /> che specifica gli attributi del metodo dinamico. L'unica combinazione consentita è <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convenzione di chiamata per il metodo dinamico. Deve essere <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico è globale per il modulo che contiene il tipo `owner`. Dispone dell'accesso a tutti i membri del tipo `owner`.  
  
 Il metodo dinamico creato con questo costruttore può accedere a tutti i membri del tipo `owner`e su pubblico e `internal` (`Friend` in Visual Basic) membri di tutti i tipi inclusi nel modulo che contiene `owner`. Controlli di visibilità del compilatore verrà ignorato il compilatore JIT consente il metodo dinamico accedere ai membri privati e protetti anche tutti gli altri tipi. Ciò è utile, ad esempio, quando si scrive codice per serializzare oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambe true: `owner` di un modulo ad eccezione del modulo chiamante e la domanda del <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  
  
oppure 
 <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
oppure 
 <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> è una combinazione di flag diversa da <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
oppure 
 <paramref name="callingConvention" /> non è <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
oppure 
 <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi specificati quando il metodo dinamico è stato creato.</summary>
        <value>Combinazione bit per bit dei valori <see cref="T:System.Reflection.MethodAttributes" /> che rappresentano gli attributi relativi al metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, gli attributi del metodo per un metodo dinamico sono sempre <xref:System.Reflection.MethodAttributes.Public> e <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza gli attributi del metodo di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la convenzione di chiamata specificata durante la creazione del metodo dinamico.</summary>
        <value>Uno dei valori di <see cref="T:System.Reflection.CallingConventions" /> che indica la convenzione di chiamata del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, la convenzione di chiamata per un metodo dinamico è sempre <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare la convenzione di chiamata di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo delegato la cui firma corrisponde a quella del metodo dinamico.</param>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</summary>
        <returns>Delegato del tipo specificato, che può essere usato per eseguire il metodo dinamico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiama il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo o il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo viene completato il metodo dinamico. Qualsiasi ulteriore prova a modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o emissione più Microsoft intermediate language (MSIL), viene ignorato; viene generata alcuna eccezione.  
  
 Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodo per ottenere un <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Se non hai un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodo per ottenere un <xref:System.Reflection.Emit.ILGenerator> oggetto che può essere utilizzato per generare il corpo del metodo.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. L'esempio emette il corpo di una funzione semplice che stampa il primo parametro nella console e l'esempio Usa il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non contiene alcun corpo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> contiene un numero errato di parametri o tipi di parametro non validi.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo delegato la cui firma corrisponde a quella del metodo dinamico, meno il primo parametro.</param>
        <param name="target">Oggetto a cui il delegato è associato. Deve essere dello stesso tipo del primo parametro del metodo dinamico.</param>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo, specificando il tipo di delegato e l'oggetto a cui il delegato è associato.</summary>
        <returns>Delegato del tipo specificato, che si può usare per eseguire il metodo dinamico con l'oggetto di destinazione specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo crea un delegato associato a un determinato oggetto. Tale delegato viene definito per essere chiuso al primo argomento. Anche se il metodo è statico, agisce come se fosse un metodo di istanza. l'istanza è `target`.  
  
 Questo overload del metodo richiede `target` per essere dello stesso tipo del primo parametro del metodo dinamico oppure per essere assegnabile al tipo (ad esempio, una classe derivata).  La firma di `delegateType` dispone di tutti i parametri del metodo dinamico ad eccezione della prima. Ad esempio, se il metodo dinamico ha i parametri <xref:System.String>, <xref:System.Int32>, e <xref:System.Byte>, quindi `delegateType` contenente i parametri <xref:System.Int32> e <xref:System.Byte>; `target` JE typu <xref:System.String>.  
  
 Chiama il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo o il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo viene completato il metodo dinamico. Qualsiasi ulteriore prova a modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o emissione più Microsoft intermediate language (MSIL), viene ignorato; viene generata alcuna eccezione.  
  
 Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodo per ottenere un <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Se non hai un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodo per ottenere un <xref:System.Reflection.Emit.ILGenerator> oggetto che può essere utilizzato per generare il corpo del metodo.  
  
   
  
## Examples  
 Esempio di codice seguente crea delegato che associa un <xref:System.Reflection.Emit.DynamicMethod> a un'istanza di un tipo, in modo che il metodo opera sulla stessa istanza ogni volta che viene richiamato.  
  
 L'esempio di codice definisce una classe denominata `Example` con un campo privato, una classe denominata `DerivedFromxample` che deriva dalla classe di primo, un tipo delegato denominato `UseLikeStatic` che restituisce <xref:System.Int32> contenente i parametri di tipo `Example` e<xref:System.Int32>e un tipo delegato denominato `UseLikeInstance` che restituisce <xref:System.Int32> e ha un parametro di tipo <xref:System.Int32>.  
  
 Il codice di esempio crea quindi una <xref:System.Reflection.Emit.DynamicMethod> che modifica il campo privato di un'istanza di `Example` e restituisce il valore precedente.  
  
> [!NOTE]
>  In generale, modificando i campi interni di classi non buona procedura di codifica basato sugli oggetti.  
  
 Il codice di esempio crea un'istanza di `Example` e quindi crea due delegati. Il primo è di tipo `UseLikeStatic`, che ha gli stessi parametri del metodo dinamico. Il secondo JE typu `UseLikeInstance`, che non è presente il primo parametro (di tipo `Example`). Questo delegato viene creato utilizzando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo; il secondo parametro di tale overload del metodo è un'istanza di `Example`, in questo caso l'istanza appena creato, che è associato al delegato appena creato. Ogni volta che il delegato viene richiamato, il metodo dinamico agisce sull'istanza associata di `Example`.  
  
> [!NOTE]
>  Questo è un esempio delle regole di tipo "relaxed" per associazione di delegati introdotte nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], insieme ai nuovi overload del <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> (metodo). Per altre informazioni, vedere la classe <xref:System.Delegate>.  
  
 Il `UseLikeStatic` delegato viene richiamato, passando l'istanza del `Example` associato ai `UseLikeInstance` delegare. L'oggetto `UseLikeInstance` delegato viene richiamato, in modo che entrambi i delegati agiscono sulla stessa istanza di `Example`. Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata. Infine, un `UseLikeInstance` delegato è associato a un'istanza di `DerivedFromxample`, e vengono ripetute di chiamate al delegato.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non contiene alcun corpo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> non è dello stesso tipo del primo parametro del metodo dinamico e non è assegnabile al tipo.  
  
oppure 
 <paramref name="delegateType" /> contiene un numero errato di parametri o tipi di parametro non validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo che dichiara il metodo, che è sempre <see langword="null" /> per i metodi dinamici.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per metodi dinamici. Anche quando un metodo dinamico è associato in modo logico con un tipo, non è dichiarato dal tipo.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza il tipo dichiarante di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Posizione del parametro nell'elenco dei parametri. I parametri sono indicizzati a partire da 1 per il primo parametro.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.ParameterAttributes" /> che specifica gli attributi del parametro.</param>
        <param name="parameterName">Nome del parametro. Il nome può essere una stringa di lunghezza zero.</param>
        <summary>Definisce un parametro del metodo dinamico.</summary>
        <returns>Restituisce sempre <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `position` è 0, il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo fa riferimento al valore restituito. Impostazione delle informazioni sul parametro ha effetto sul valore restituito.  
  
 Se il metodo dinamico è già stato completato, chiamando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oppure <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo, il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo non ha alcun effetto. Non viene generata alcuna eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come definire le informazioni sui parametri per un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il metodo non ha parametri.  
  
oppure 
 <paramref name="position" /> è minore di 0.  
  
oppure 
 <paramref name="position" /> è maggiore del numero dei parametri del metodo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'implementazione di base per il metodo.</summary>
        <returns>Implementazione di base del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce sempre l'attuale `DynamicMethod` oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce gli attributi personalizzati applicati al metodo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Restituisce tutti gli attributi personalizzati definiti per il metodo.</summary>
        <returns>Matrice di oggetti che rappresentano tutti gli attributi personalizzati del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` perché il metodo non è dichiarato in un tipo non ha alcun effetto.  
  
> [!NOTE]
>  Gli attributi personalizzati non sono attualmente supportati in metodi dinamici. L'unico attributo restituito è <xref:System.Runtime.CompilerServices.MethodImplAttribute>; è possibile ottenere i flag di implementazione più facilmente usando le <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Classe <see cref="T:System.Type" /> che rappresenta il tipo di attributo personalizzato da restituire.</param>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Restituisce gli attributi personalizzati del tipo specificato che sono stati applicati al metodo.</summary>
        <returns>Matrice di oggetti che rappresentano gli attributi del metodo di tipo <paramref name="attributeType" /> o derivano dal tipo <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` perché il metodo non è dichiarato in un tipo non ha alcun effetto.  
  
> [!NOTE]
>  Gli attributi personalizzati non sono attualmente supportati in metodi dinamici. L'unico attributo restituito è <xref:System.Runtime.CompilerServices.MethodImplAttribute>; è possibile ottenere i flag di implementazione più facilmente usando le <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL (Microsoft Intermediate Language).</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicILInfo> classe ha lo scopo di supportare la generazione di codice non gestito.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per eseguire il codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un generatore MSIL che è possibile usare per generare un corpo per il metodo dinamico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con una dimensione di flusso MSIL predefinita di 64 byte.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.ILGenerator" /> per il metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo che un metodo dinamico è stato completato, chiamando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato. Non viene generata alcuna eccezione.  
  
> [!NOTE]
>  Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità. Vedere la sezione "Verifica" nelle note per <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. L'esempio emette il corpo di una funzione semplice che stampa il primo parametro nella console e l'esempio Usa il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo).  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Dimensioni del flusso MSIL in byte.</param>
        <summary>Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con le dimensioni del flusso MSIL specificate.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.ILGenerator" /> per il metodo, con le dimensioni del flusso MSIL specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo che un metodo dinamico è stato completato, chiamando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato. Non viene generata alcuna eccezione.  
  
> [!NOTE]
>  Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità. Vedere la sezione "Verifica" nelle note per <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra questo overload del metodo. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Procedura: definire ed eseguire metodi dinamici</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i flag di implementazione per il metodo.</summary>
        <returns>Combinazione bit per bit dei valori <see cref="T:System.Reflection.MethodImplAttributes" /> che rappresentano i flag di implementazione relativi al metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, gli attributi di implementazione di metodo per i metodi dinamici sono sempre <xref:System.Reflection.MethodImplAttributes.IL> e <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i parametri del metodo dinamico.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.ParameterInfo" /> che rappresentano i parametri del metodo dinamico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.ParameterInfo> gli oggetti restituiti da questo metodo sono solo a scopo informativo. Usare il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo per impostare o modificare le caratteristiche dei parametri.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare i parametri di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le variabili locali nel metodo sono inizializzate su zero.</summary>
        <value>
          <see langword="true" /> se le variabili locali nel metodo vengono inizializzate su zero; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa proprietà è impostata su `true`, emessa Microsoft intermediate language (MSIL) include l'inizializzazione delle variabili locali. Se è impostato su `false`, variabili locali non inizializzate e il codice generato non è verificabile.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> proprietà di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Questo parametro viene ignorato per i metodi dinamici, in quanto sono statici. Specificare <see langword="null" />.</param>
        <param name="invokeAttr">Combinazione bit per bit di valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Oggetto <see cref="T:System.Reflection.Binder" /> che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito. Per informazioni dettagliate, vedere <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Elenco di argomenti. Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare. In assenza di parametri, questo parametro deve essere <see langword="null" />.</param>
        <param name="culture">Istanza di <see cref="T:System.Globalization.CultureInfo" /> usata per regolare la coercizione dei tipi. Se è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />. Queste informazioni sono necessarie, ad esempio, per convertire in modo corretto un valore <see cref="T:System.String" /> che rappresenta 1000 in un valore <see cref="T:System.Double" />, in quanto 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</param>
        <summary>Richiama il metodo dinamico usando i parametri specificati, con i vincoli del binder specificato e le informazioni sulle impostazioni cultura specificate.</summary>
        <returns>Un valore <see cref="T:System.Object" /> che contiene il valore restituito del metodo richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre che le eccezioni elencate, il codice chiamante deve essere preparato per rilevare eventuali eccezioni generate dal metodo dinamico.  
  
 L'esecuzione di un metodo dinamico con un delegato creato per il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo è più efficiente rispetto all'esecuzione con il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo).  
  
 Chiama il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo o il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo viene completato il metodo dinamico. Qualsiasi ulteriore prova a modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o emissione più Microsoft intermediate language (MSIL), viene ignorato; viene generata alcuna eccezione.  
  
 Tutti i metodi dinamici sono statici, pertanto la `obj` parametro viene sempre ignorato. Per considerare un metodo dinamico come se fosse un metodo di istanza, utilizzare il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload che accetta un'istanza dell'oggetto.  
  
 Se il metodo dinamico ha alcun parametro, il valore di `parameters` deve essere `null`. In caso contrario, il numero, tipo e ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri del metodo dinamico.  
  
> [!NOTE]
>  Questo overload del metodo viene chiamato il <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> overload del metodo ereditato dal <xref:System.Reflection.MethodBase> classe, in modo che le note precedenti si applicano a entrambi gli overload.  
  
 Questo metodo non richiede le autorizzazioni direttamente, ma richiama il metodo dinamico può comportare la richiesta di sicurezza, a seconda del metodo. Ad esempio, non viene effettuata per i metodi dinamici ospitati anonimamente creati con la `restrictedSkipVisibility` parametro è impostato su `false`. D'altra parte, se si crea un metodo con `restrictedSkipVisibility` impostata su `true` in modo che possa accedere un membro nascosto di un assembly di destinazione, il metodo genererà una richiesta per le autorizzazioni dell'assembly di destinazione più <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
> [!NOTE]
>  Nelle versioni precedenti al [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo richiedeva <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.  
  
   
  
## Examples  
 Esempio di codice seguente richiama un metodo dinamico con associazione esatto, usando le impostazioni cultura inglese Americano. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La convenzione di chiamata <see cref="F:System.Reflection.CallingConventions.VarArgs" /> non è supportata.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Il numero di elementi in <paramref name="parameters" /> non corrisponde al numero dei parametri del metodo dinamico.</exception>
        <exception cref="T:System.ArgumentException">Il tipo di uno o più elementi di <paramref name="parameters" /> non corrisponde al tipo del parametro corrispondente del metodo dinamico.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo dinamico è associato a un modulo, non è contenuto anonimamente ed è costruito con <paramref name="skipVisibility" /> impostato su <see langword="false" />, ma il metodo dinamico accede a membri che non sono <see langword="public" /> o <see langword="internal" /> (<see langword="Friend" /> in Visual Basic).  
  
oppure 
Il metodo dinamico è contenuto anonimamente ed è costruito con <paramref name="skipVisibility" /> impostato su <see langword="false" />, ma accede a membri che non sono <see langword="public" />.  
  
oppure 
Il metodo dinamico contiene codice non verificabile. Vedere la sezione "Verifica" nelle note per <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Classe <see cref="T:System.Type" /> che rappresenta il tipo di attributo personalizzato da ricercare.</param>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Indica se il tipo di attributo personalizzato specificato è definito.</summary>
        <returns>
          <see langword="true" /> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` non ha alcun effetto. I metodi dinamici è presente alcuna catena di ereditarietà.  
  
> [!NOTE]
>  Gli attributi personalizzati non sono attualmente supportati in metodi dinamici.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente e può pertanto eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico corrente è critico per la sicurezza o security-safe-critical; <see langword="false" /> se è trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico a quanto determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che cui è associato. Se il metodo dinamico è associato un tipo anziché a un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici non hanno le annotazioni di sicurezza, pertanto vengono assegnati la trasparenza predefinito per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente vengono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico associato a un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critici|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo che si trova in mscorlib. dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System. dll, non consente l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (vale a dire un'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico associato a un assembly parzialmente attendibile dipende dal modo in cui l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, nonché i metodi dinamici, vengono considerati come trasparenti. Il runtime presta attenzione alle annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinito per i metodi in base alle annotazioni dell'assembly.  
  
 Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerazioni sulla sicurezza in relazione alla reflection</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifiche della sicurezza in .NET Framework 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Codice SecurityTransparent, livello 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Codice SecurityTransparent, livello 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico è security-safe-critical al livello di attendibilità corrente; <see langword="false" /> se è critico per la sicurezza o trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico a quanto determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che cui è associato. Se il metodo dinamico è associato un tipo anziché a un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici non hanno le annotazioni di sicurezza, pertanto vengono assegnati la trasparenza predefinito per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente vengono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico associato a un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critici|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo che si trova in mscorlib. dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System. dll, non consente l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (vale a dire un'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico associato a un assembly parzialmente attendibile dipende dal modo in cui l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, nonché i metodi dinamici, vengono considerati come trasparenti. Il runtime presta attenzione alle annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinito per i metodi in base alle annotazioni dell'assembly.  
  
 Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerazioni sulla sicurezza in relazione alla reflection</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifiche della sicurezza in .NET Framework 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Codice SecurityTransparent, livello 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Codice SecurityTransparent, livello 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è trasparente al livello di attendibilità corrente e pertanto non può eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico è SecurityTrasparent al livello di attendibilità corrente; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico a quanto determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che cui è associato. Se il metodo dinamico è associato un tipo anziché a un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici non hanno le annotazioni di sicurezza, pertanto vengono assegnati la trasparenza predefinito per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente vengono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico associato a un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critici|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo che si trova in mscorlib. dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System. dll, non consente l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (vale a dire un'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico associato a un assembly parzialmente attendibile dipende dal modo in cui l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, nonché i metodi dinamici, vengono considerati come trasparenti. Il runtime presta attenzione alle annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinito per i metodi in base alle annotazioni dell'assembly.  
  
 Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemi di sicurezza nella reflection emit</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considerazioni sulla sicurezza in relazione alla reflection</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifiche della sicurezza in .NET Framework 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Codice SecurityTransparent, livello 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Codice SecurityTransparent, livello 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Non supportato per metodi dinamici.</summary>
        <value>Non supportato per metodi dinamici.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non consentito per metodi dinamici.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo a cui il metodo dinamico è associato in modo logico.</summary>
        <value>Classe <see cref="T:System.Reflection.Module" /> a cui è associato il metodo dinamico corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un modulo è stato specificato quando è stato creato il metodo dinamico, questa proprietà restituisce tale modulo. Se è stato specificato un tipo come proprietario quando il metodo dinamico è stato creato, questa proprietà restituisce il modulo che contiene tale tipo.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.Module%2A> proprietà di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del metodo dinamico.</summary>
        <value>Nome semplice del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Non è necessario per i metodi dinamici di nome.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza il nome di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classe usata nella reflection per ottenere il metodo.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per metodi dinamici.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il tipo riflesso di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il parametro restituito del metodo dinamico.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per metodi dinamici.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di valore restituito per il metodo dinamico.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore restituito del metodo corrente; <see cref="T:System.Void" /> se il metodo non contiene tipi restituiti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `null` è stato specificato per il tipo restituito quando il metodo dinamico è stato creato, questa proprietà restituisce <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il tipo restituito di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi personalizzati del tipo restituito per il metodo dinamico.</summary>
        <value>Interfaccia <see cref="T:System.Reflection.ICustomAttributeProvider" /> che rappresenta gli attributi personalizzati del tipo restituito per il metodo dinamico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli attributi personalizzati non sono supportati nel tipo restituito di un metodo dinamico, pertanto la matrice di attributi personalizzati restituita dal <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> metodo è sempre vuoto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare gli attributi personalizzati del tipo restituito di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la firma del metodo, rappresentata come stringa.</summary>
        <returns>Stringa che rappresenta la firma del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La firma include solo i tipi e il nome del metodo, se presente. I nomi dei parametri non sono inclusi.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> metodo di un metodo dinamico. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>