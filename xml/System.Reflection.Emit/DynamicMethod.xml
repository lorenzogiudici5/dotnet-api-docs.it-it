<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DynamicMethod.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">037e736f-f76f-422a-bcb7-5d2d599f851d5517d541bfb277537dc0cfe80b1fb8f689bcf6d4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5517d541bfb277537dc0cfe80b1fb8f689bcf6d4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fc53860cd2661bb7bde6e4b2858fcda4ec4c889</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/10/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,xamarinandroid-7.1,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Defines and represents a dynamic method that can be compiled, executed, and discarded.</source>
          <target state="translated">Definisce e rappresenta un metodo dinamico che può essere compilato, eseguito e annullato.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Discarded methods are available for garbage collection.</source>
          <target state="translated">I metodi annullati possono essere sottoposti a Garbage Collection.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class to generate and execute a method at run time, without having to generate a dynamic assembly and a dynamic type to contain the method.</source>
          <target state="translated">È possibile utilizzare la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe per generare ed eseguire un metodo in fase di esecuzione senza la necessità di generare un assembly dinamico e un tipo dinamico per contenere il metodo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The executable code created by the just-in-time (JIT) compiler is reclaimed when the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> object is reclaimed.</source>
          <target state="translated">Il codice eseguibile creato dal compilatore just-in-time (JIT) viene recuperato quando la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> oggetto venga recuperato.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods are the most efficient way to generate and execute small amounts of code.</source>
          <target state="translated">I metodi dinamici sono il modo più efficiente per generare ed eseguire piccole quantità di codice.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method can be anonymously hosted, or it can be logically associated with a module or with a type.</source>
          <target state="translated">Un metodo dinamico può essere ospitato in modo anonimo, o può essere logicamente associato a un modulo o a un tipo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is anonymously hosted, it is located in a system-provided assembly, and therefore is isolated from other code.</source>
          <target state="translated">Se il metodo dinamico è ospitato in modo anonimo, si trova in un assembly fornito dal sistema e pertanto è isolata da altro codice.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>By default, it does not have access to any non-public data.</source>
          <target state="translated">Per impostazione predefinita, non ha accesso a tutti i dati non pubblici.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method can have restricted ability to skip the JIT compiler's visibility checks, if it has been granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Un metodo dinamico ospitato anonimamente può avere una limitata capacità di ignorare i controlli di visibilità del compilatore JIT, se è stata concessa <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The trust level of the assembly whose non-public members are accessed by the dynamic method must be equal to, or a subset of, the trust level of the call stack that emitted the dynamic method.</source>
          <target state="translated">Il livello di attendibilità dell'assembly i cui membri non pubblici sono accessibili dal metodo dinamico deve essere uguale o è un subset del livello di attendibilità dello stack di chiamate che ha generato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For more information about anonymously hosted dynamic methods, see <bpt id="p1">[</bpt>Walkthrough: Emitting Code in Partial Trust Scenarios<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sui metodi dinamici ospitati anonimamente, vedere <bpt id="p1">[</bpt>procedura dettagliata: creazione di codice in scenari di attendibilità parziale<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a module that you specify, the dynamic method is effectively global to that module.</source>
          <target state="translated">Se il metodo dinamico è associato a un modulo specificato, il metodo dinamico è globale per tale modulo.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can access all types in the module and all <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of the types.</source>
          <target state="translated">Può accedere a tutti i tipi nel modulo e tutte <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) membri dei tipi.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any module, regardless of whether you created the module, provided that a demand for <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag can be satisfied by the call stack that includes your code.</source>
          <target state="translated">È possibile associare un dinamico (metodo) con qualsiasi modulo, indipendentemente dal fatto è stato creato il modulo, a condizione che la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag possono essere soddisfatte tramite lo stack di chiamate che include il codice.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag is included in the grant, the dynamic method can skip the JIT compiler's visibility checks and access the private data of all types declared in the module or in any other module in any assembly.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag è incluso nell'autorizzazione, il metodo dinamico è possibile ignorare i controlli di visibilità del compilatore JIT e accedere ai dati di tutti i tipi dichiarati nel modulo o in qualsiasi altro modulo in qualsiasi assembly privati.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>When you specify the module with which a dynamic method is associated, that module must not be in the system-provided assembly that is used for anonymous hosting.</source>
          <target state="translated">Quando si specifica il modulo a cui è associato un metodo dinamico, è possibile che tale modulo non deve essere nell'assembly fornito dal sistema che viene utilizzato per l'hosting anonimo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a type that you specify, it has access to all members of the type, regardless of access level.</source>
          <target state="translated">Se il metodo dinamico è associato un tipo specificato, ha accesso a tutti i membri del tipo, indipendentemente dal livello di accesso.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In addition, JIT visibility checks can be skipped.</source>
          <target state="translated">Inoltre, i controlli di visibilità JIT possono essere ignorati.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This gives the dynamic method access to the private data of other types declared in the same module or in any other module in any assembly.</source>
          <target state="translated">In questo modo il metodo dinamico può accedere ai dati privati di altri tipi dichiarati nel modulo stesso o in qualsiasi altro modulo in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any type, but your code must be granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with both the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flags.</source>
          <target state="translated">È possibile associare un metodo dinamico con qualsiasi tipo, ma debba essere concesse al codice <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con entrambi i <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to an anonymously hosted dynamic method, with and without JIT visibility checks, depending on whether <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag is granted.</source>
          <target state="translated">Nella tabella seguente vengono descritti tipi e membri sono accessibili da un metodo dinamico ospitato anonimamente, con e senza controlli di visibilità JIT, a seconda che <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag viene concessa.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated">Senza <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>With <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated">Con <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">Senza ignorare i controlli di visibilità JIT</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Membri pubblici di tipi pubblici in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Membri pubblici di tipi pubblici in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks, with restrictions</source>
          <target state="translated">JIT di ignorare i controlli di visibilità, con restrizioni</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Membri pubblici di tipi pubblici in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types, only in assemblies whose trust levels are equal to or less than the trust level of the assembly that emitted the dynamic method.</source>
          <target state="translated">Tutti i membri di tutti i tipi, solo in assembly i cui livelli di attendibilità sono uguale o inferiore a livello di attendibilità dell'assembly che ha generato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, emitting code required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Nelle versioni precedenti al <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, la creazione di codice necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This permission is included by default in the FullTrust and LocalIntranet named permission sets, but not in the Internet permission set.</source>
          <target state="translated">Questa autorizzazione è inclusa per impostazione predefinita in FullTrust e LocalIntranet set di autorizzazioni denominati, ma non nel set di autorizzazioni Internet.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Therefore, in earlier versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> a library can be used with Internet permissions only if it has the <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute and also executes an <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.</source>
          <target state="translated">Pertanto, nelle versioni precedenti del <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> una libreria può essere utilizzata con autorizzazioni Internet solo se è stato il <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attributo ed esegue un <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> per <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Such libraries require careful security review because coding errors could result in security holes.</source>
          <target state="translated">Tali librerie richiedono un'attenta revisione della sicurezza perché eventuali errori nel codice potrebbe produrre delle vulnerabilità.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph> allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph> consente di generare codice in scenari con attendibilità parziale senza creare alcuna richiesta di sicurezza, poiché la generazione di codice non è implicitamente un'operazione con privilegi.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>That is, the generated code has no more permissions than the assembly that emits it.</source>
          <target state="translated">Ovvero, il codice generato non dispone di ulteriori autorizzazioni rispetto all'assembly che lo genera.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This allows libraries that emit code to be security transparent and removes the need to assert <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>, which simplifies the task of writing a secure library.</source>
          <target state="translated">Questo consente alle librerie che generano il codice di essere SecurityTransparent ed elimina la necessità di asserire <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>, che semplifica l'attività di scrittura di una libreria protetta.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>To use this feature, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Per utilizzare questa funzionalità, l'applicazione deve essere destinata la <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to a dynamic method that is associated with a module or with a type in a module.</source>
          <target state="translated">Nella tabella seguente vengono descritti tipi e membri sono accessibili a un metodo dinamico è associato a un modulo o a un tipo in un modulo.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with module</source>
          <target state="translated">Associato al modulo</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with type</source>
          <target state="translated">Associata al tipo</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">Senza ignorare i controlli di visibilità JIT</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of public, internal, and private types in the module.</source>
          <target state="translated">Membri pubblici e interni dei tipi pubblici, interni e privati nel modulo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Membri pubblici di tipi pubblici in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of the associated type.</source>
          <target state="translated">Tutti i membri del tipo associato.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of all the other types in the module.</source>
          <target state="translated">Membri pubblici e interni di tutti gli altri tipi nel modulo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Membri pubblici di tipi pubblici in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks</source>
          <target state="translated">Ignorare i controlli di visibilità JIT</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">Tutti i membri di tutti i tipi in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">Tutti i membri di tutti i tipi in qualsiasi assembly.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a module has the permissions of that module.</source>
          <target state="translated">Un metodo dinamico è associato un modulo dispone delle autorizzazioni di tale modulo.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a type has the permissions of the module containing that type.</source>
          <target state="translated">Un metodo dinamico è associato un tipo dispone delle autorizzazioni del modulo contenente il tipo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods and their parameters do not have to be named, but you can specify names to assist in debugging.</source>
          <target state="translated">Metodi dinamici e i relativi parametri non deve essere denominato, ma è possibile specificare nomi per facilitare il debug.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Custom attributes are not supported on dynamic methods or their parameters.</source>
          <target state="translated">Attributi personalizzati non sono supportati i metodi dinamici o i relativi parametri.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Although dynamic methods are <ph id="ph1">`static`</ph> methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic), the relaxed rules for delegate binding introduced in the <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> allow a dynamic method to be bound to an object, so that it acts like an instance method when called using that delegate instance.</source>
          <target state="translated">Sebbene i metodi dinamici sono <ph id="ph1">`static`</ph> metodi (<ph id="ph2">`Shared`</ph> metodi in Visual Basic), le regole relaxed per associazione di delegati introdotte nel <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> consentono un metodo dinamico associato a un oggetto, in modo che agisca come un metodo di istanza quando chiamato utilizzando l'istanza del delegato.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An example that demonstrates this is provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload.</source>
          <target state="translated">Un esempio che illustra questa operazione è disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, dynamic methods do not support symbol information, that is, local variable names and line-number mapping.</source>
          <target state="translated">Nel <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, i metodi dinamici non supportano informazioni sui simboli, ovvero, i nomi delle variabili locali e mapping del numero di riga.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This limitation might be removed in a future version.</source>
          <target state="translated">Questa limitazione potrebbe venire rimosso in una versione futura.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> during development to simplify debugging the generated Microsoft intermediate language (MSIL), and then switch to dynamic methods during final deployment, because the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> calls are the same in both cases.</source>
          <target state="translated">È possibile utilizzare <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> durante lo sviluppo per semplificare il debug generato Microsoft intermedio language (MSIL) e quindi passare ai metodi dinamici durante la distribuzione finale, perché il <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> chiamate sono gli stessi in entrambi i casi.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Verification</source>
          <target state="translated">Verifica</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following list summarizes the conditions under which dynamic methods can contain unverifiable code.</source>
          <target state="translated">Nell'elenco seguente vengono riepilogate le condizioni in cui i metodi dinamici possono contenere codice non verificabile.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>(For example, a dynamic method is unverifiable if its <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.)</source>
          <target state="translated">(Ad esempio, un metodo dinamico non è verificabile se relativo <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> è impostata su <ph id="ph2">`false`</ph>.)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a security-critical assembly is also security-critical, and can skip verification.</source>
          <target state="translated">Un metodo dinamico è associato a un assembly critico per la sicurezza è critico per la sicurezza e può ignorare la verifica.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For example, an assembly without security attributes that is run as a desktop application is treated as security-critical by the runtime.</source>
          <target state="translated">Ad esempio, un assembly senza gli attributi di sicurezza che viene eseguito come un'applicazione desktop viene trattato come SecurityCritical dal runtime.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you associate a dynamic method with the assembly, the dynamic method can contain unverifiable code.</source>
          <target state="translated">Se si associa un metodo dinamico con l'assembly, il metodo dinamico può contenere codice non verificabile.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 1 transparency, the just-in-time (JIT) compiler injects a security demand.</source>
          <target state="translated">Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con la trasparenza di livello 1, il compilatore di just-in-time (JIT) inserisce una richiesta di sicurezza.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The demand succeeds only if the dynamic method is executed by fully trusted code.</source>
          <target state="translated">La richiesta ha esito positivo solo se il metodo dinamico viene eseguito da codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt>codice SecurityTransparent, livello 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 2 transparency (such as mscorlib.dll), it throws an exception (injected by the JIT compiler) instead of making a security demand.</source>
          <target state="translated">Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con la trasparenza di livello 2 (ad esempio mscorlib. dll), genera un'eccezione (inserita dal compilatore JIT) anziché eseguire una richiesta di sicurezza.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt>codice SecurityTransparent, livello 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method that contains unverifiable code always throws an exception.</source>
          <target state="translated">Un metodo dinamico ospitato anonimamente che contiene sempre il codice non verificabile genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can never skip verification, even if it is created and executed by fully trusted code.</source>
          <target state="translated">Non è possibile ignorare la verifica, anche se viene creato ed eseguito da codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The exception that is thrown for unverifiable code varies depending on the way the dynamic method is invoked.</source>
          <target state="translated">Eccezione generata per il codice non verificabile varia a seconda della modalità in cui che viene richiamato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke a dynamic method by using a delegate returned from the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> is thrown.</source>
          <target state="translated">Se si richiama un metodo dinamico tramite un delegato restituito dal <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> (metodo), un <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke the dynamic method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> is thrown with an inner <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>.</source>
          <target state="translated">Se si richiama il metodo dinamico usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> (metodo), un <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> viene generata un'eccezione con un inner <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">Esempio di codice seguente crea un metodo dinamico che accetta due parametri.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Creates a dynamic method.</source>
          <target state="translated">Crea un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, and parameter types.</source>
          <target state="translated">Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito e i tipi di parametro.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies that just-in-time (JIT) visibility checks will be enforced for the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Questo costruttore viene specificato che just-in-time (JIT) i controlli di visibilità saranno imposte per Microsoft intermedio language (MSIL) del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>That is, the code in the dynamic method has access to public methods of public classes.</source>
          <target state="translated">Ovvero, il codice del metodo dinamico ha accesso a metodi pubblici delle classi pubbliche.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Exceptions are thrown if the method tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Vengono generate eccezioni se il metodo tenta di accedere a tipi o membri che sono <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, o <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>To create a dynamic method that has restricted ability to skip JIT visibility checks, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Per creare un metodo dinamico con possibilità di ignorare i controlli di visibilità JIT limitate, usare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When the method is invoked, the permissions of the emitting assembly are used instead of the permissions of the actual caller.</source>
          <target state="translated">Quando viene richiamato il metodo, vengono utilizzate le autorizzazioni di concessioni dell'assembly anziché le autorizzazioni del chiamante effettivo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">Di conseguenza, il metodo dinamico non è possibile eseguire a un livello di privilegio superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>e la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Questo costruttore è stato introdotto nel <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method, with this restriction: the trust level of the assemblies that contain those types and members must be equal to or less than the trust level of the call stack that emits the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare i controlli di visibilità JIT sui tipi e i membri a cui accede il linguaggio MSIL del metodo dinamico, con questa restrizione: il livello di attendibilità degli assembly che contengono questi tipi e membri deve essere uguale o minore di quello dello stack di chiamata che genera il metodo dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, parameter types, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito, i tipi di parametro e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Anonymously hosted dynamic methods do not have automatic access to any types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Metodi dinamici ospitati anonimamente non dispone dell'accesso automatico per i tipi o membri che sono <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, o <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is different from dynamic methods that are associated with an existing type or module, which have access to hidden members in their associated scope.</source>
          <target state="translated">Questa è diversa dai metodi dinamici associati a un tipo esistente o un modulo, che dispongono dell'accesso ai membri nascosti nel proprio ambito associato.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`restrictedSkipVisibility`</ph> if your dynamic method has to access types or members that are <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, or <ph id="ph5">`internal`</ph>.</source>
          <target state="translated">Specificare <ph id="ph1">`true`</ph> per <ph id="ph2">`restrictedSkipVisibility`</ph> se il metodo dinamico deve accedere a tipi o membri che sono <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, o <ph id="ph5">`internal`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This gives the dynamic method restricted access to these members.</source>
          <target state="translated">In questo modo il metodo dinamico con restrizioni di accedere a questi membri.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>That is, the members can be accessed only if the following conditions are met:</source>
          <target state="translated">Ovvero, i membri accessibili solo se vengono soddisfatte le condizioni seguenti:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The target members belong to an assembly that has a level of trust equal to or lower than the call stack that emits the dynamic method.</source>
          <target state="translated">I membri di destinazione appartengono a un assembly con un livello di attendibilità uguale o inferiore a stack di chiamate che genera il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The call stack that emits the dynamic method is granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Lo stack di chiamate che genera il metodo dinamico è concesso <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is always true when the code is executed with full trust.</source>
          <target state="translated">Questo è sempre vero quando viene eseguito il codice con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For partially trusted code, it is true only if the host explicitly grants the permission.</source>
          <target state="translated">Per codice parzialmente attendibile, è true solo se l'host in modo esplicito concede l'autorizzazione.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the permission has not been granted, a security exception is thrown when <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> is called or when the dynamic method is invoked, not when this constructor is called.</source>
          <target state="translated">Se non è stato concesso l'autorizzazione, viene generata un'eccezione di sicurezza quando <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> viene chiamato o quando viene richiamato il metodo dinamico, non quando viene chiamato questo costruttore.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>No special permissions are required to emit the dynamic method.</source>
          <target state="translated">Non speciali sono necessarie autorizzazioni per generare il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For example, a dynamic method that is created with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> can access a private member of any assembly on the call stack if the call stack has been granted restricted member access.</source>
          <target state="translated">Ad esempio, un metodo dinamico creato con <ph id="ph1">`restrictedSkipVisibility`</ph> impostato su <ph id="ph2">`true`</ph> può accedere a un membro privato di qualsiasi assembly nello stack di chiamate se lo stack di chiamate è stato concesso l'accesso al membro.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the dynamic method is created with partially trusted code on the call stack, it cannot access a private member of a type in a <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> assembly, because such assemblies are fully trusted.</source>
          <target state="translated">Se il metodo dinamico è stato creato con codice parzialmente attendibile nello stack di chiamate, non può accedere a un membro privato di un tipo in un <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> assembly, poiché tali assembly sono completamente attendibili.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If <ph id="ph1">`restrictedSkipVisibility`</ph> is <ph id="ph2">`false`</ph>, JIT visibility checks are enforced.</source>
          <target state="translated">Se <ph id="ph1">`restrictedSkipVisibility`</ph> è <ph id="ph2">`false`</ph>, vengono applicati i controlli di visibilità JIT.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The code in the dynamic method has access to public methods of public classes, and exceptions are thrown if it tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph>.</source>
          <target state="translated">Il codice del metodo dinamico ha accesso a metodi pubblici delle classi pubbliche e le eccezioni vengono generate se tenta di accedere a tipi o membri che sono <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, o <ph id="ph3">`internal`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When the method is invoked, the permissions of the emitting call stack are used instead of the permissions of the actual caller.</source>
          <target state="translated">Quando viene richiamato il metodo, vengono utilizzate le autorizzazioni dello stack di chiamate che genera anziché le autorizzazioni del chiamante effettivo.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">Di conseguenza, il metodo dinamico non è possibile eseguire a un livello di privilegio superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>e la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Questo costruttore è stato introdotto nel <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, and module.</source>
          <target state="translated">Crea un metodo dinamico che è globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametro e il modulo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>e non ignora i controlli di visibilità just-in-time (JIT).</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) membri di tutti i tipi di contenuto nel modulo <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`m`</ph> è un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">Esempio di codice seguente crea un metodo dinamico che accetta due parametri.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è un modulo che fornisce hosting anonimo per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a cui il metodo dinamico è associato in modo logico.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Il metodo dinamico ha accesso a tutti i membri del tipo.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, and the type with which the dynamic method is logically associated.</source>
          <target state="translated">Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i parametri di tipo e il tipo a cui il metodo dinamico è associato dal punto di vista logico.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo <ph id="ph1">`owner`</ph>e al ruolo public e <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) di tutti gli altri tipi nel modulo che contiene i membri <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>e non ignora i controlli di visibilità just-in-time (JIT).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`owner`</ph> in un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The following code example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that is logically associated with a type.</source>
          <target state="translated">L'esempio di codice seguente crea un <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> logicamente associato a un tipo.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This association gives it access to the private members of that type.</source>
          <target state="translated">Questa associazione fornisce accesso ai membri privati di quel tipo.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">L'esempio di codice definisce una classe denominata <ph id="ph1">`Example`</ph> con un campo privato, una classe denominata <ph id="ph2">`DerivedFromxample`</ph> che deriva dalla prima classe, un tipo delegato denominato <ph id="ph3">`UseLikeStatic`</ph> che restituisce <ph id="ph4">&lt;xref:System.Int32&gt;</ph> e dispone di parametri di tipo <ph id="ph5">`Example`</ph> e <ph id="ph6">&lt;xref:System.Int32&gt;</ph>e un tipo delegato denominato <ph id="ph7">`UseLikeInstance`</ph> che restituisce <ph id="ph8">&lt;xref:System.Int32&gt;</ph> e ha un parametro di tipo <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">Nell'esempio di codice crea quindi un <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> che modifica il campo privato di un'istanza di <ph id="ph2">`Example`</ph> e restituisce il valore precedente.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">In generale, la modifica dei campi interni delle classi non è valida orientata agli oggetti scrittura di codice.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">Nell'esempio di codice crea un'istanza di <ph id="ph1">`Example`</ph> e crea quindi due delegati.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">Il primo è di tipo <ph id="ph1">`UseLikeStatic`</ph>, che ha gli stessi parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">Il secondo è di tipo <ph id="ph1">`UseLikeInstance`</ph>, che non è presente il primo parametro (di tipo <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">Questo delegato viene creato utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload del metodo; il secondo parametro di questo overload è un'istanza di <ph id="ph2">`Example`</ph>in questo caso, l'istanza appena creata, che è associato al delegato appena creato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Ogni volta che il delegato viene chiamato, il metodo dinamico agisce sull'istanza associata di <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo è un esempio di regole relaxed per associazione di delegati introdotte nel <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, insieme ai nuovi overload di <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">Per altre informazioni, vedere la classe <ph id="ph1">&lt;xref:System.Delegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">`UseLikeStatic`</ph> delegato viene richiamato, passando l'istanza di <ph id="ph2">`Example`</ph> associato per il <ph id="ph3">`UseLikeInstance`</ph> delegato.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`UseLikeInstance`</ph> delegato viene richiamato in modo che entrambi i delegati possano agiscono sulla stessa istanza di <ph id="ph2">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">Infine, un <ph id="ph1">`UseLikeInstance`</ph> delegato è associato a un'istanza di <ph id="ph2">`DerivedFromxample`</ph>, e vengono ripetute le chiamate al delegato.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o è un tipo per cui <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare i controlli di visibilità JIT su tipi e membri a cui accede il linguaggio MSIL del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Crea un metodo dinamico globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametri e il modulo e indicando se deve essere ignorato il controllo di visibilità JIT per i tipi e i membri del metodo dinamico a cui accede MSIL (Microsoft Intermediate Language).</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>e la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types in contained module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) membri di tutti i tipi contenuti nel modulo <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`m`</ph> è un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è un modulo che fornisce hosting anonimo per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a cui il metodo dinamico è associato in modo logico.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Il metodo dinamico ha accesso a tutti i membri del tipo.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo <ph id="ph1">`owner`</ph>e al ruolo public e <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) di tutti gli altri tipi nel modulo che contiene i membri <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo costruttore consente di specificare gli attributi del metodo <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>e la convenzione di chiamata <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`owner`</ph> in un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o è un tipo per cui <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">Combinazione bit per bit di valori di <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> che specifica gli attributi del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">L'unica combinazione consentita è <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> e <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">Convenzione di chiamata per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated">Deve essere <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, attributes, calling convention, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Crea un metodo dinamico globale per un metodo, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il modulo e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the public and internal types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) membri di tutti i tipi pubblici e interni contenuti nel modulo <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types in the module and in all other assemblies as well.</source>
          <target state="translated">JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi nel modulo e in tutti gli altri assembly.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`m`</ph> è un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è un modulo che fornisce hosting anonimo per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> è una combinazione di flag diversa da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> e <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Può essere una stringa di lunghezza zero, ma non può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">Combinazione bit per bit di valori di <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> che specifica gli attributi del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">L'unica combinazione consentita è <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> e <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">Convenzione di chiamata per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated">Deve essere <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica il tipo restituito del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esiste alcun tipo restituito.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che specifica i tipi dei parametri del metodo dinamico oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se per il metodo non esistono parametri.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> a cui il metodo dinamico è associato in modo logico.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Il metodo dinamico ha accesso a tutti i membri del tipo.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, attributes, calling convention, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Crea un metodo dinamico, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method is global to the module that contains the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">Il metodo dinamico è globale per il modulo che contiene il tipo <ph id="ph1">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>It has access to all members of the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">Dispone dell'accesso a tutti i membri del tipo <ph id="ph1">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the types contained in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo <ph id="ph1">`owner`</ph>e al ruolo public e <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) di tutti i tipi contenuti nel modulo che contiene i membri <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag se le condizioni seguenti sono entrambi true: <ph id="ph3">`owner`</ph> in un modulo diverso dal modulo chiamante e la richiesta di <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag non è riuscita.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Se la richiesta di <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> ha esito positivo, l'operazione è consentita.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> è una combinazione di flag diversa da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> e <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> non è <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> è un tipo per cui <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> restituisce <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Gets the attributes specified when the dynamic method was created.</source>
          <target state="translated">Ottiene gli attributi specificati quando il metodo dinamico è stato creato.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values representing the attributes for the method.</source>
          <target state="translated">Combinazione bit per bit dei valori <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> che rappresentano gli attributi relativi al metodo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Currently, the method attributes for a dynamic method are always <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>.</source>
          <target state="translated">Attualmente, gli attributi per un metodo dinamico sono sempre <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>The following code example displays the method attributes of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare gli attributi di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Gets the calling convention specified when the dynamic method was created.</source>
          <target state="translated">Ottiene la convenzione di chiamata specificata durante la creazione del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> values that indicates the calling convention of the method.</source>
          <target state="translated">Uno dei valori di <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> che indica la convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Currently, the calling convention for a dynamic method is always <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>.</source>
          <target state="translated">Attualmente, la convenzione di chiamata per un metodo dinamico è sempre <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>The following code example displays the calling convention of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare la convenzione di chiamata di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate type whose signature matches that of the dynamic method.</source>
          <target state="translated">Tipo delegato la cui firma corrisponde a quella del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method.</source>
          <target state="translated">Delegato del tipo specificato, che può essere usato per eseguire il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> metodo o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo completa il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> per ottenere un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">Se non si dispone di un generatore MSIL, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> per ottenere un <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> oggetto che può essere usato per generare il corpo del metodo.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">Esempio di codice seguente crea un metodo dinamico che accetta due parametri.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">Il metodo dinamico non contiene alcun corpo.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> contiene un numero errato di parametri o tipi di parametro non validi.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate type whose signature matches that of the dynamic method, minus the first parameter.</source>
          <target state="translated">Tipo delegato la cui firma corrisponde a quella del metodo dinamico, meno il primo parametro.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>An object the delegate is bound to.</source>
          <target state="translated">Oggetto a cui il delegato è associato.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Must be of the same type as the first parameter of the dynamic method.</source>
          <target state="translated">Deve essere dello stesso tipo del primo parametro del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it, specifying the delegate type and an object the delegate is bound to.</source>
          <target state="translated">Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo, specificando il tipo di delegato e l'oggetto a cui il delegato è associato.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method with the specified target object.</source>
          <target state="translated">Delegato del tipo specificato, che si può usare per eseguire il metodo dinamico con l'oggetto di destinazione specificato.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload creates a delegate bound to a particular object.</source>
          <target state="translated">Overload di questo metodo crea un delegato associato a un oggetto specifico.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Such a delegate is said to be closed over its first argument.</source>
          <target state="translated">Questo tipo un delegato per essere chiuso al primo argomento.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Although the method is static, it acts as if it were an instance method; the instance is <ph id="ph1">`target`</ph>.</source>
          <target state="translated">Anche se il metodo è statico, agisce come se fosse un metodo di istanza. l'istanza è <ph id="ph1">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload requires <ph id="ph1">`target`</ph> to be of the same type as the first parameter of the dynamic method, or to be assignable to that type (for example, a derived class).</source>
          <target state="translated">Overload di questo metodo richiede <ph id="ph1">`target`</ph> per essere dello stesso tipo del primo parametro del metodo dinamico oppure per essere assegnabile al tipo (ad esempio, una classe derivata).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The signature of <ph id="ph1">`delegateType`</ph> has all the parameters of the dynamic method except the first.</source>
          <target state="translated">La firma di <ph id="ph1">`delegateType`</ph> dispone di tutti i parametri del metodo dinamico, ad eccezione del primo.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For example, if the dynamic method has the parameters <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, then <ph id="ph4">`delegateType`</ph> has the parameters <ph id="ph5">&lt;xref:System.Int32&gt;</ph> and <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> is of type <ph id="ph8">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Ad esempio, se il metodo dinamico ha i parametri <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, e <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, quindi <ph id="ph4">`delegateType`</ph> contenente i parametri <ph id="ph5">&lt;xref:System.Int32&gt;</ph> e <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> è di tipo <ph id="ph8">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> metodo o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo completa il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> per ottenere un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">Se non si dispone di un generatore MSIL, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> per ottenere un <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> oggetto che può essere usato per generare il corpo del metodo.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The following code example creates delegate that binds a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> to an instance of a type, so that the method acts on the same instance each time it is invoked.</source>
          <target state="translated">Esempio di codice seguente crea delegato che associa un <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> a un'istanza di un tipo, in modo che il metodo di agire sulla stessa istanza ogni volta che viene chiamato.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">L'esempio di codice definisce una classe denominata <ph id="ph1">`Example`</ph> con un campo privato, una classe denominata <ph id="ph2">`DerivedFromxample`</ph> che deriva dalla prima classe, un tipo delegato denominato <ph id="ph3">`UseLikeStatic`</ph> che restituisce <ph id="ph4">&lt;xref:System.Int32&gt;</ph> e dispone di parametri di tipo <ph id="ph5">`Example`</ph> e <ph id="ph6">&lt;xref:System.Int32&gt;</ph>e un tipo delegato denominato <ph id="ph7">`UseLikeInstance`</ph> che restituisce <ph id="ph8">&lt;xref:System.Int32&gt;</ph> e ha un parametro di tipo <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">Nell'esempio di codice crea quindi un <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> che modifica il campo privato di un'istanza di <ph id="ph2">`Example`</ph> e restituisce il valore precedente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">In generale, la modifica dei campi interni delle classi non è valida orientata agli oggetti scrittura di codice.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">Nell'esempio di codice crea un'istanza di <ph id="ph1">`Example`</ph> e crea quindi due delegati.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">Il primo è di tipo <ph id="ph1">`UseLikeStatic`</ph>, che ha gli stessi parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">Il secondo è di tipo <ph id="ph1">`UseLikeInstance`</ph>, che non è presente il primo parametro (di tipo <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">Questo delegato viene creato utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload del metodo; il secondo parametro di questo overload è un'istanza di <ph id="ph2">`Example`</ph>in questo caso, l'istanza appena creata, che è associato al delegato appena creato.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Ogni volta che il delegato viene chiamato, il metodo dinamico agisce sull'istanza associata di <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo è un esempio di regole relaxed per associazione di delegati introdotte nel <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, insieme ai nuovi overload di <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">Per altre informazioni, vedere la classe <ph id="ph1">&lt;xref:System.Delegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">`UseLikeStatic`</ph> delegato viene richiamato, passando l'istanza di <ph id="ph2">`Example`</ph> associato per il <ph id="ph3">`UseLikeInstance`</ph> delegato.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`UseLikeInstance`</ph> delegato viene richiamato in modo che entrambi i delegati possano agiscono sulla stessa istanza di <ph id="ph2">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">Infine, un <ph id="ph1">`UseLikeInstance`</ph> delegato è associato a un'istanza di <ph id="ph2">`DerivedFromxample`</ph>, e vengono ripetute le chiamate al delegato.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">Il metodo dinamico non contiene alcun corpo.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not the same type as the first parameter of the dynamic method, and is not assignable to that type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> non è dello stesso tipo del primo parametro del metodo dinamico e non è assegnabile al tipo.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> contiene un numero errato di parametri o tipi di parametro non validi.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Gets the type that declares the method, which is always <ph id="ph1">&lt;see langword="null" /&gt;</ph> for dynamic methods.</source>
          <target state="translated">Ottiene il tipo che dichiara il metodo, che è sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph> per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Questa proprietà restituisce sempre <ph id="ph1">`null`</ph> per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Even when a dynamic method is logically associated with a type, it is not declared by the type.</source>
          <target state="translated">Anche quando un metodo dinamico è associato in modo logico con un tipo, non è dichiarato dal tipo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>The following code example displays the declaring type of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare il tipo dichiarante di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">Posizione del parametro nell'elenco dei parametri.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter.</source>
          <target state="translated">I parametri sono indicizzati a partire da 1 per il primo parametro.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph> values that specifies the attributes of the parameter.</source>
          <target state="translated">Combinazione bit per bit di valori di <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph> che specifica gli attributi del parametro.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">Nome del parametro.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be a zero-length string.</source>
          <target state="translated">Il nome può essere una stringa di lunghezza zero.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Defines a parameter of the dynamic method.</source>
          <target state="translated">Definisce un parametro del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Always returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Restituisce sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is 0, the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method refers to the return value.</source>
          <target state="translated">Se <ph id="ph1">`position`</ph> è 0, il <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> metodo fa riferimento al valore restituito.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Setting parameter information has no effect on the return value.</source>
          <target state="translated">Impostazione delle informazioni sul parametro ha effetto sul valore restituito.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If the dynamic method has already been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, the <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method has no effect.</source>
          <target state="translated">Se il metodo dinamico è già stato completato, chiamando la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> (metodo), il <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> metodo non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The following code example shows how to define parameter information for a dynamic method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come definire le informazioni sui parametri per un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">Il metodo non ha parametri.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> è maggiore del numero dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>Returns the base implementation for the method.</source>
          <target state="translated">Restituisce l'implementazione di base per il metodo.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>The base implementation of the method.</source>
          <target state="translated">Implementazione di base del metodo.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>This method always returns the current <ph id="ph1">`DynamicMethod`</ph> object.</source>
          <target state="translated">Questo metodo restituisce sempre l'attuale <ph id="ph1">`DynamicMethod`</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns the custom attributes applied to the method.</source>
          <target state="translated">Restituisce gli attributi personalizzati applicati al metodo.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per verificare solo il metodo corrente.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for the method.</source>
          <target state="translated">Restituisce tutti gli attributi personalizzati definiti per il metodo.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>An array of objects representing all the custom attributes of the method.</source>
          <target state="translated">Matrice di oggetti che rappresentano tutti gli attributi personalizzati del metodo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">Per i metodi dinamici, specificando <ph id="ph1">`true`</ph> per <ph id="ph2">`inherit`</ph> perché il metodo non è dichiarato in un tipo non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Attributi personalizzati non sono attualmente supportati sui metodi dinamici.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">L'unico attributo restituito è <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; è possibile ottenere i flag di implementazione più facilmente utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to return.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo di attributo personalizzato da restituire.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per verificare solo il metodo corrente.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes of the specified type that have been applied to the method.</source>
          <target state="translated">Restituisce gli attributi personalizzati del tipo specificato che sono stati applicati al metodo.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects representing the attributes of the method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> or derive from type <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Matrice di oggetti che rappresentano gli attributi del metodo di tipo <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> o derivano dal tipo <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">Per i metodi dinamici, specificando <ph id="ph1">`true`</ph> per <ph id="ph2">`inherit`</ph> perché il metodo non è dichiarato in un tipo non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Attributi personalizzati non sono attualmente supportati sui metodi dinamici.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">L'unico attributo restituito è <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; è possibile ottenere i flag di implementazione più facilmente utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and Microsoft intermediate language (MSIL) streams.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL (Microsoft Intermediate Language).</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and MSIL streams.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> class is provided to support unmanaged code generation.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> classe viene fornita per supportare la generazione di codice non gestito.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>to execute unmanaged code.</source>
          <target state="translated">Per eseguire codice non gestito.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns an MSIL generator that can be used to emit a body for the dynamic method.</source>
          <target state="translated">Restituisce un generatore MSIL che è possibile usare per generare un corpo per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with a default MSIL stream size of 64 bytes.</source>
          <target state="translated">Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con una dimensione di flusso MSIL predefinita di 64 byte.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> per il metodo.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">Dopo un metodo dinamico è stato completato, chiamando la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità totale.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated">Vedere la sezione "Verifica" nelle note per <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">Esempio di codice seguente crea un metodo dinamico che accetta due parametri.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">Dimensioni del flusso MSIL in byte.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with the specified MSIL stream size.</source>
          <target state="translated">Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con le dimensioni del flusso MSIL specificate.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method, with the specified MSIL stream size.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> per il metodo, con le dimensioni del flusso MSIL specificate.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">Dopo un metodo dinamico è stato completato, chiamando la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità totale.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated">Vedere la sezione "Verifica" nelle note per <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The following code example demonstrates this method overload.</source>
          <target state="translated">Esempio di codice seguente viene illustrato questo overload del metodo.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Restituisce i flag di implementazione per il metodo.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> values representing the implementation flags for the method.</source>
          <target state="translated">Combinazione bit per bit dei valori <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> che rappresentano i flag di implementazione relativi al metodo.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Currently, method implementation attributes for dynamic methods are always <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>.</source>
          <target state="translated">Attualmente, gli attributi di implementazione di metodo per i metodi dinamici sono sempre <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Returns the parameters of the dynamic method.</source>
          <target state="translated">Restituisce i parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> objects that represent the parameters of the dynamic method.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> che rappresentano i parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> objects returned by this method are for information only.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> gli oggetti restituiti da questo metodo sono solo a scopo informativo.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method to set or change the characteristics of the parameters.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> metodo per impostare o modificare le caratteristiche dei parametri.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The following code example displays the parameters of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente mostra i parametri di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>Gets or sets a value indicating whether the local variables in the method are zero-initialized.</source>
          <target state="translated">Ottiene o imposta un valore che indica se le variabili locali nel metodo sono inizializzate su zero.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in the method are zero-initialized; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se le variabili locali nel metodo vengono inizializzate su zero; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito è <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted Microsoft intermediate language (MSIL) includes initialization of local variables.</source>
          <target state="translated">Se questa proprietà è impostata su <ph id="ph1">`true`</ph>, generato Microsoft intermedio language (MSIL) include l'inizializzazione delle variabili locali.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">Se è impostato su <ph id="ph1">`false`</ph>, variabili locali non inizializzate e il codice generato non è verificabile.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene visualizza la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> proprietà di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This parameter is ignored for dynamic methods, because they are static.</source>
          <target state="translated">Questo parametro viene ignorato per i metodi dinamici, in quanto sono statici.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values.</source>
          <target state="translated">Combinazione bit per bit di valori di <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite la reflection.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">Elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this parameter should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">In assenza di parametri, questo parametro deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Istanza di <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> usata per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, this information is needed to correctly convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, because 1000 is represented differently by different cultures.</source>
          <target state="translated">Queste informazioni sono necessarie, ad esempio, per convertire in modo corretto un valore <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> che rappresenta 1000 in un valore <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>, in quanto 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the dynamic method using the specified parameters, under the constraints of the specified binder, with the specified culture information.</source>
          <target state="translated">Richiama il metodo dinamico usando i parametri specificati, con i vincoli del binder specificato e le informazioni sulle impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> containing the return value of the invoked method.</source>
          <target state="translated">Un valore <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> che contiene il valore restituito del metodo richiamato.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>In addition to the listed exceptions, the calling code should be prepared to catch any exceptions thrown by the dynamic method.</source>
          <target state="translated">Oltre alle eccezioni elencate, il codice chiamante deve essere preparato per intercettare le eccezioni generate dal metodo dinamico.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Executing a dynamic method with a delegate created by the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method is more efficient than executing it with the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">L'esecuzione di un metodo dinamico con un delegato creato dal <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> metodo è più efficiente rispetto all'esecuzione con il <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">La chiamata di <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> metodo o <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> metodo completa il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>All dynamic methods are static, so the <ph id="ph1">`obj`</ph> parameter is always ignored.</source>
          <target state="translated">Tutti i metodi dinamici sono statici, pertanto la <ph id="ph1">`obj`</ph> parametro viene sempre ignorato.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To treat a dynamic method as if it were an instance method, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload that takes an object instance.</source>
          <target state="translated">Per considerare un metodo dinamico, come se fosse un metodo di istanza, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload che accetta un'istanza dell'oggetto.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the dynamic method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Se il metodo dinamico ha alcun parametro, il valore di <ph id="ph1">`parameters`</ph> deve essere <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters of the dynamic method.</source>
          <target state="translated">In caso contrario, il numero, tipo e l'ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method overload is called by the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> method overload inherited from the <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> class, so the preceding remarks apply to both overloads.</source>
          <target state="translated">Overload di questo metodo viene chiamato dal <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> overload del metodo ereditato dalla <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> classe, per le note precedenti si applicano a entrambi gli overload.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method does not demand permissions directly, but invoking the dynamic method can result in security demands, depending on the method.</source>
          <target state="translated">Questo metodo non richiedere autorizzazioni direttamente, ma il richiamo del metodo dinamico può causare richieste di sicurezza, a seconda del metodo.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, no demands are made for anonymously hosted dynamic methods that are created with the <ph id="ph1">`restrictedSkipVisibility`</ph> parameter set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Ad esempio, non viene effettuata per metodi dinamici ospitati anonimamente vengono creati con il <ph id="ph1">`restrictedSkipVisibility`</ph> parametro impostato su <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if you create a method with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> so it can access a hidden member of a target assembly, the method will cause a demand for the permissions of the target assembly plus <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">D'altra parte, se si crea un metodo con <ph id="ph1">`restrictedSkipVisibility`</ph> impostato su <ph id="ph2">`true`</ph> in modo che possa accedere a un membro nascosto di un assembly di destinazione, il metodo provocherà una richiesta per le autorizzazioni dell'assembly di destinazione più <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flag.</source>
          <target state="translated">Nelle versioni precedenti al <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo metodo richiesto <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following code example invokes a dynamic method with exact binding, using the US-English culture.</source>
          <target state="translated">Esempio di codice seguente richiama un metodo dinamico con associazione esatta, utilizzando le impostazioni cultura inglese Stati Uniti.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> calling convention is not supported.</source>
          <target state="translated">La convenzione di chiamata <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> non è supportata.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the number of parameters in the dynamic method.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non corrisponde al numero dei parametri del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of one or more elements of <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the type of the corresponding parameter of the dynamic method.</source>
          <target state="translated">Il tipo di uno o più elementi di <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non corrisponde al tipo del parametro corrispondente del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is associated with a module, is not anonymously hosted, and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but the dynamic method accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph> or <ph id="ph4">&lt;see langword="internal" /&gt;</ph> (<ph id="ph5">&lt;see langword="Friend" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il metodo dinamico è associato a un modulo, non è contenuto anonimamente ed è costruito con <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> impostato su <ph id="ph2">&lt;see langword="false" /&gt;</ph>, ma il metodo dinamico accede a membri che non sono <ph id="ph3">&lt;see langword="public" /&gt;</ph> o <ph id="ph4">&lt;see langword="internal" /&gt;</ph> (<ph id="ph5">&lt;see langword="Friend" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is anonymously hosted and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but it accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph>.</source>
          <target state="translated">Il metodo dinamico è contenuto anonimamente ed è costruito con <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> impostato su <ph id="ph2">&lt;see langword="false" /&gt;</ph>, ma accede a membri che non sono <ph id="ph3">&lt;see langword="public" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method contains unverifiable code.</source>
          <target state="translated">Il metodo dinamico contiene codice non verificabile.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">Vedere la sezione "Verifica" nelle note per <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to search for.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo di attributo personalizzato da ricercare.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per verificare solo il metodo corrente.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether the specified custom attribute type is defined.</source>
          <target state="translated">Indica se il tipo di attributo personalizzato specificato è definito.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect.</source>
          <target state="translated">Per i metodi dinamici, specificando <ph id="ph1">`true`</ph> per <ph id="ph2">`inherit`</ph> non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Dynamic methods have no inheritance chain.</source>
          <target state="translated">Metodi dinamici non hanno alcuna catena di ereditarietà.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Attributi personalizzati non sono attualmente supportati sui metodi dinamici.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente e può pertanto eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current dynamic method is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo dinamico corrente è critico per la sicurezza o security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è trasparente.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">La trasparenza di un metodo dinamico dipende dal modulo che è associato.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Assembly annotation</source>
          <target state="translated">Annotazione di assembly</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 1 transparency</source>
          <target state="translated">Trasparenza di livello 1</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 2 transparency</source>
          <target state="translated">Trasparenza di livello 2</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully transparent</source>
          <target state="translated">Completamente trasparente</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully critical</source>
          <target state="translated">Completamente critico</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Mixed transparency</source>
          <target state="translated">Trasparenza mista</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security-agnostic</source>
          <target state="translated">Indipendente dalla sicurezza</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Per informazioni sui livelli di trasparenza, vedere <bpt id="p1">[</bpt>codice SecurityTransparent, livello 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> e <bpt id="p2">[</bpt>codice SecurityTransparent, livello 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando viene chiamato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">Il metodo dinamico non dispone di un corpo del metodo.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo dinamico è security-safe-critical al livello di attendibilità corrente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è critico per la sicurezza o trasparente.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">La trasparenza di un metodo dinamico dipende dal modulo che è associato.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Assembly annotation</source>
          <target state="translated">Annotazione di assembly</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 1 transparency</source>
          <target state="translated">Trasparenza di livello 1</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 2 transparency</source>
          <target state="translated">Trasparenza di livello 2</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully transparent</source>
          <target state="translated">Completamente trasparente</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully critical</source>
          <target state="translated">Completamente critico</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Mixed transparency</source>
          <target state="translated">Trasparenza mista</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security-agnostic</source>
          <target state="translated">Indipendente dalla sicurezza</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Per informazioni sui livelli di trasparenza, vedere <bpt id="p1">[</bpt>codice SecurityTransparent, livello 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> e <bpt id="p2">[</bpt>codice SecurityTransparent, livello 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando viene chiamato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">Il metodo dinamico non dispone di un corpo del metodo.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current dynamic method is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il metodo dinamico corrente è trasparente al livello di attendibilità corrente e pertanto non può eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo dinamico è SecurityTrasparent al livello di attendibilità corrente; in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">La trasparenza di un metodo dinamico dipende dal modulo che è associato.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Assembly annotation</source>
          <target state="translated">Annotazione di assembly</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 1 transparency</source>
          <target state="translated">Trasparenza di livello 1</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 2 transparency</source>
          <target state="translated">Trasparenza di livello 2</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully transparent</source>
          <target state="translated">Completamente trasparente</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully critical</source>
          <target state="translated">Completamente critico</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Mixed transparency</source>
          <target state="translated">Trasparenza mista</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security-agnostic</source>
          <target state="translated">Indipendente dalla sicurezza</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Per informazioni sui livelli di trasparenza, vedere <bpt id="p1">[</bpt>codice SecurityTransparent, livello 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> e <bpt id="p2">[</bpt>codice SecurityTransparent, livello 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando viene chiamato il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">Il metodo dinamico non dispone di un corpo del metodo.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">Non supportato per metodi dinamici.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">Non supportato per metodi dinamici.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not allowed for dynamic methods.</source>
          <target state="translated">Non consentito per metodi dinamici.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>Gets the module with which the dynamic method is logically associated.</source>
          <target state="translated">Ottiene il modulo a cui il metodo dinamico è associato in modo logico.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> with which the current dynamic method is associated.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> a cui è associato il metodo dinamico corrente.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a module was specified when the dynamic method was created, this property returns that module.</source>
          <target state="translated">Se un modulo è stato specificato quando il metodo dinamico è stato creato, questa proprietà restituisce tale modulo.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a type was specified as the owner when the dynamic method was created, this property returns the module which contains that type.</source>
          <target state="translated">Se è stato specificato un tipo come proprietario quando il metodo dinamico è stato creato, questa proprietà restituisce il modulo che contiene tale tipo.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene visualizza la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> proprietà di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>Gets the name of the dynamic method.</source>
          <target state="translated">Ottiene il nome del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The simple name of the method.</source>
          <target state="translated">Nome semplice del metodo.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>It is not necessary to name dynamic methods.</source>
          <target state="translated">Non è necessario per metodi dinamici di nome.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The following code example displays the name of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente visualizza il nome di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>This code example is part of a larger example provided for  the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Gets the class that was used in reflection to obtain the method.</source>
          <target state="translated">Ottiene la classe usata nella reflection per ottenere il metodo.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Questa proprietà restituisce sempre <ph id="ph1">`null`</ph> per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>The following code example displays the reflected type of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare il tipo riflesso di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Gets the return parameter of the dynamic method.</source>
          <target state="translated">Ottiene il parametro restituito del metodo dinamico.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Questa proprietà restituisce sempre <ph id="ph1">`null`</ph> per i metodi dinamici.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>Gets the type of return value for the dynamic method.</source>
          <target state="translated">Ottiene il tipo di valore restituito per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of the return value of the current method; <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo di valore restituito del metodo corrente; <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph> se il metodo non contiene tipi restituiti.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>If <ph id="ph1">`null`</ph> was specified for the return type when the dynamic method was created, this property returns <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`null`</ph> è stato specificato per il tipo restituito quando il metodo dinamico è stato creato, questa proprietà restituisce <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>The following code example displays the return type of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare il tipo restituito di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">Ottiene gli attributi personalizzati del tipo restituito per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph> representing the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">Interfaccia <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph> che rappresenta gli attributi personalizzati del tipo restituito per il metodo dinamico.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Custom attributes are not supported on the return type of a dynamic method, so the array of custom attributes returned by the <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> method is always empty.</source>
          <target state="translated">Attributi personalizzati non sono supportati sul tipo restituito di un metodo dinamico, pertanto ha restituito una matrice di attributi personalizzati di <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> metodo è sempre vuoto.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>The following code example shows how to display the custom attributes of the return type of a dynamic method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come visualizzare gli attributi personalizzati del tipo restituito di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Returns the signature of the method, represented as a string.</source>
          <target state="translated">Restituisce la firma del metodo, rappresentata come stringa.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>A string representing the method signature.</source>
          <target state="translated">Stringa che rappresenta la firma del metodo.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The signature includes only types and the method name, if any.</source>
          <target state="translated">La firma include solo i tipi e il nome del metodo, se presente.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Parameter names are not included.</source>
          <target state="translated">I nomi dei parametri non sono inclusi.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> method of a dynamic method.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene visualizza la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> metodo di un metodo dinamico.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> classe.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>