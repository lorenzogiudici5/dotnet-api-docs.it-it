<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2d2648e46890987df7b96cd4787aa5d57de2433b" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34285353" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce e rappresenta un metodo dinamico che può essere compilato, eseguito e annullato. I metodi annullati possono essere sottoposti a Garbage Collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare la <xref:System.Reflection.Emit.DynamicMethod> classe per generare ed eseguire un metodo in fase di esecuzione senza la necessità di generare un assembly dinamico e un tipo dinamico per contenere il metodo. Il codice eseguibile creato dal compilatore just-in-time (JIT) viene recuperato quando la <xref:System.Reflection.Emit.DynamicMethod> oggetto venga recuperato. I metodi dinamici sono il modo più efficiente per generare ed eseguire piccole quantità di codice.  
  
 Un metodo dinamico può essere ospitato in modo anonimo, o può essere logicamente associato a un modulo o a un tipo.  
  
-   Se il metodo dinamico è ospitato in modo anonimo, si trova in un assembly fornito dal sistema e pertanto è isolata da altro codice. Per impostazione predefinita, non ha accesso a tutti i dati non pubblici. Un metodo dinamico ospitato anonimamente può avere una limitata capacità di ignorare i controlli di visibilità del compilatore JIT, se è stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag. Il livello di attendibilità dell'assembly i cui membri non pubblici sono accessibili dal metodo dinamico deve essere uguale o è un subset del livello di attendibilità dello stack di chiamate che ha generato il metodo dinamico. Per ulteriori informazioni sui metodi dinamici ospitati anonimamente, vedere [procedura dettagliata: creazione di codice in scenari di attendibilità parziale](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Se il metodo dinamico è associato a un modulo specificato, il metodo dinamico è globale per tale modulo. Può accedere a tutti i tipi nel modulo e tutte `internal` (`Friend` in Visual Basic) membri dei tipi. È possibile associare un dinamico (metodo) con qualsiasi modulo, indipendentemente dal fatto è stato creato il modulo, a condizione che la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag possono essere soddisfatte tramite lo stack di chiamate che include il codice. Se il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag è incluso nell'autorizzazione, il metodo dinamico è possibile ignorare i controlli di visibilità del compilatore JIT e accedere ai dati di tutti i tipi dichiarati nel modulo o in qualsiasi altro modulo in qualsiasi assembly privati.  
  
    > [!NOTE]
    >  Quando si specifica il modulo a cui è associato un metodo dinamico, è possibile che tale modulo non deve essere nell'assembly fornito dal sistema che viene utilizzato per l'hosting anonimo.  
  
-   Se il metodo dinamico è associato un tipo specificato, ha accesso a tutti i membri del tipo, indipendentemente dal livello di accesso. Inoltre, i controlli di visibilità JIT possono essere ignorati. In questo modo il metodo dinamico può accedere ai dati privati di altri tipi dichiarati nel modulo stesso o in qualsiasi altro modulo in qualsiasi assembly. È possibile associare un metodo dinamico con qualsiasi tipo, ma debba essere concesse al codice <xref:System.Security.Permissions.ReflectionPermission> con entrambi i <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> e <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.  
  
 Nella tabella seguente vengono descritti tipi e membri sono accessibili da un metodo dinamico ospitato anonimamente, con e senza controlli di visibilità JIT, a seconda che <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag viene concessa.  
  
||Senza <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Con <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Senza ignorare i controlli di visibilità JIT|Membri pubblici di tipi pubblici in qualsiasi assembly.|Membri pubblici di tipi pubblici in qualsiasi assembly.|  
|JIT di ignorare i controlli di visibilità, con restrizioni|Membri pubblici di tipi pubblici in qualsiasi assembly.|Tutti i membri di tutti i tipi, solo in assembly i cui livelli di attendibilità sono uguale o inferiore a livello di attendibilità dell'assembly che ha generato il metodo dinamico.|  
  
> [!NOTE]
>  Nelle versioni precedenti al [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], la creazione di codice necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. Questa autorizzazione è inclusa per impostazione predefinita in FullTrust e LocalIntranet set di autorizzazioni denominati, ma non nel set di autorizzazioni Internet. Pertanto, nelle versioni precedenti del [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] una libreria può essere utilizzata con autorizzazioni Internet solo se è stato il <xref:System.Security.SecurityCriticalAttribute> attributo ed esegue un <xref:System.Security.PermissionSet.Assert%2A> per <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Tali librerie richiedono un'attenta revisione della sicurezza perché eventuali errori nel codice potrebbe produrre delle vulnerabilità. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] consente di generare codice in scenari con attendibilità parziale senza creare alcuna richiesta di sicurezza, poiché la generazione di codice non è implicitamente un'operazione con privilegi. Ovvero, il codice generato non dispone di ulteriori autorizzazioni rispetto all'assembly che lo genera. Questo consente alle librerie che generano il codice di essere SecurityTransparent ed elimina la necessità di asserire <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, che semplifica l'attività di scrittura di una libreria protetta. Per utilizzare questa funzionalità, l'applicazione deve essere destinata la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 Nella tabella seguente vengono descritti tipi e membri sono accessibili a un metodo dinamico è associato a un modulo o a un tipo in un modulo.  
  
||Associato al modulo|Associata al tipo|  
|-|-|-|  
|Senza ignorare i controlli di visibilità JIT|Membri pubblici e interni dei tipi pubblici, interni e privati nel modulo.<br /><br /> Membri pubblici di tipi pubblici in qualsiasi assembly.|Tutti i membri del tipo associato. Membri pubblici e interni di tutti gli altri tipi nel modulo.<br /><br /> Membri pubblici di tipi pubblici in qualsiasi assembly.|  
|Ignorare i controlli di visibilità JIT|Tutti i membri di tutti i tipi in qualsiasi assembly.|Tutti i membri di tutti i tipi in qualsiasi assembly.|  
  
 Un metodo dinamico è associato un modulo dispone delle autorizzazioni di tale modulo. Un metodo dinamico è associato un tipo dispone delle autorizzazioni del modulo contenente il tipo.  
  
 Metodi dinamici e i relativi parametri non deve essere denominato, ma è possibile specificare nomi per facilitare il debug. Attributi personalizzati non sono supportati i metodi dinamici o i relativi parametri.  
  
 Sebbene i metodi dinamici sono `static` metodi (`Shared` metodi in Visual Basic), le regole relaxed per associazione di delegati introdotte nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] consentono un metodo dinamico associato a un oggetto, in modo che agisca come un metodo di istanza quando chiamato utilizzando l'istanza del delegato. Un esempio che illustra questa operazione è disponibile per il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo.  
  
> [!NOTE]
>  Nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], i metodi dinamici non supportano informazioni sui simboli, ovvero, i nomi delle variabili locali e mapping del numero di riga. Questa limitazione potrebbe venire rimosso in una versione futura. È possibile utilizzare <xref:System.Reflection.Emit.AssemblyBuilder> durante lo sviluppo per semplificare il debug generato Microsoft intermedio language (MSIL) e quindi passare ai metodi dinamici durante la distribuzione finale, perché il <xref:System.Reflection.Emit.ILGenerator> chiamate sono gli stessi in entrambi i casi.  
  
## <a name="verification"></a>Verifica  
 Nell'elenco seguente vengono riepilogate le condizioni in cui i metodi dinamici possono contenere codice non verificabile. (Ad esempio, un metodo dinamico non è verificabile se relativo <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> è impostata su `false`.)  
  
-   Un metodo dinamico è associato a un assembly critico per la sicurezza è critico per la sicurezza e può ignorare la verifica. Ad esempio, un assembly senza gli attributi di sicurezza che viene eseguito come un'applicazione desktop viene trattato come SecurityCritical dal runtime. Se si associa un metodo dinamico con l'assembly, il metodo dinamico può contenere codice non verificabile.  
  
-   Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con la trasparenza di livello 1, il compilatore di just-in-time (JIT) inserisce una richiesta di sicurezza. La richiesta ha esito positivo solo se il metodo dinamico viene eseguito da codice completamente attendibile. Vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Se un metodo dinamico che contiene codice non verificabile è associato a un assembly con la trasparenza di livello 2 (ad esempio mscorlib. dll), genera un'eccezione (inserita dal compilatore JIT) anziché eseguire una richiesta di sicurezza. Vedere [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Un metodo dinamico ospitato anonimamente che contiene sempre il codice non verificabile genera un'eccezione. Non è possibile ignorare la verifica, anche se viene creato ed eseguito da codice completamente attendibile.  
  
 Eccezione generata per il codice non verificabile varia a seconda della modalità in cui che viene richiamato il metodo dinamico. Se si richiama un metodo dinamico tramite un delegato restituito dal <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> (metodo), un <xref:System.Security.VerificationException> viene generata un'eccezione. Se si richiama il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), un <xref:System.Reflection.TargetInvocationException> viene generata un'eccezione con un inner <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un metodo dinamico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <summary>Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito e i tipi di parametro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo. L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice. Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito da codice parzialmente attendibile.  
  
 Questo costruttore viene specificato che just-in-time (JIT) i controlli di visibilità saranno imposte per Microsoft intermedio language (MSIL) del metodo dinamico. Ovvero, il codice del metodo dinamico ha accesso a metodi pubblici delle classi pubbliche. Vengono generate eccezioni se il metodo tenta di accedere a tipi o membri che sono `private`, `protected`, o `internal` (`Friend` in Visual Basic). Per creare un metodo dinamico con possibilità di ignorare i controlli di visibilità JIT limitate, usare il <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> costruttore.  
  
 Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso. Quando viene richiamato il metodo, vengono utilizzate le autorizzazioni di concessioni dell'assembly anziché le autorizzazioni del chiamante effettivo. Di conseguenza, il metodo dinamico non è possibile eseguire a un livello di privilegio superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Questo costruttore è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri a cui accede il linguaggio MSIL del metodo dinamico, con questa restrizione: il livello di attendibilità degli assembly che contengono questi tipi e membri deve essere uguale o minore di quello dello stack di chiamata che genera il metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza un metodo dinamico ospitato anonimamente, specificando il nome del metodo, il tipo restituito, i tipi di parametro e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico che viene creato da questo costruttore è associato a un assembly anonimo anziché un tipo esistente o un modulo. L'assembly anonimo esiste solo per fornire un ambiente sandbox per i metodi dinamici, vale a dire, per isolarli da altro codice. Questo ambiente rende sicuro per il metodo dinamico a essere generato ed eseguito da codice parzialmente attendibile.  
  
 Metodi dinamici ospitati anonimamente non dispone dell'accesso automatico per i tipi o membri che sono `private`, `protected`, o `internal` (`Friend` in Visual Basic). Questa è diversa dai metodi dinamici associati a un tipo esistente o un modulo, che dispongono dell'accesso ai membri nascosti nel proprio ambito associato.  
  
 Specificare `true` per `restrictedSkipVisibility` se il metodo dinamico deve accedere a tipi o membri che sono `private`, `protected`, o `internal`. In questo modo il metodo dinamico con restrizioni di accedere a questi membri. Ovvero, i membri accessibili solo se vengono soddisfatte le condizioni seguenti:  
  
-   I membri di destinazione appartengono a un assembly con un livello di attendibilità uguale o inferiore a stack di chiamate che genera il metodo dinamico.  
  
-   Lo stack di chiamate che genera il metodo dinamico è concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag. Questo è sempre vero quando viene eseguito il codice con attendibilità totale. Per codice parzialmente attendibile, è true solo se l'host in modo esplicito concede l'autorizzazione.  
  
    > [!IMPORTANT]
    >  Se non è stato concesso l'autorizzazione, viene generata un'eccezione di sicurezza quando <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> viene chiamato o quando viene richiamato il metodo dinamico, non quando viene chiamato questo costruttore. Non speciali sono necessarie autorizzazioni per generare il metodo dinamico.  
  
 Ad esempio, un metodo dinamico creato con `restrictedSkipVisibility` impostato su `true` può accedere a un membro privato di qualsiasi assembly nello stack di chiamate se lo stack di chiamate è stato concesso l'accesso al membro. Se il metodo dinamico è stato creato con codice parzialmente attendibile nello stack di chiamate, non può accedere a un membro privato di un tipo in un [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] assembly, poiché tali assembly sono completamente attendibili.  
  
 Se `restrictedSkipVisibility` è `false`, vengono applicati i controlli di visibilità JIT. Il codice del metodo dinamico ha accesso a metodi pubblici delle classi pubbliche e le eccezioni vengono generate se tenta di accedere a tipi o membri che sono `private`, `protected`, o `internal`.  
  
 Quando viene creato un metodo dinamico ospitato anonimamente, lo stack di chiamate di concessioni dell'assembly è incluso. Quando viene richiamato il metodo, vengono utilizzate le autorizzazioni dello stack di chiamate che genera anziché le autorizzazioni del chiamante effettivo. Di conseguenza, il metodo dinamico non è possibile eseguire a un livello di privilegio superiore rispetto a quello dell'assembly che ha generato, anche se viene passato a ed eseguita da un assembly con un livello di attendibilità superiore.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Questo costruttore è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">Oggetto <see cref="T:System.Reflection.Module" /> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</param>
        <summary>Crea un metodo dinamico che è globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametro e il modulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e non ignora i controlli di visibilità just-in-time (JIT).  
  
 Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi di contenuto nel modulo `m`.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `m` è un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> metodo.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="m" /> è un modulo che offre hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i parametri di tipo e il tipo a cui il metodo dinamico è associato dal punto di vista logico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo `owner`e al ruolo public e `internal` (`Friend` in Visual Basic) di tutti gli altri tipi nel modulo che contiene i membri `owner`.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>e non ignora i controlli di visibilità just-in-time (JIT).  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `owner` in un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Reflection.Emit.DynamicMethod> logicamente associato a un tipo. Questa associazione fornisce accesso ai membri privati di quel tipo.  
  
 L'esempio di codice definisce una classe denominata `Example` con un campo privato, una classe denominata `DerivedFromxample` che deriva dalla prima classe, un tipo delegato denominato `UseLikeStatic` che restituisce <xref:System.Int32> e dispone di parametri di tipo `Example` e <xref:System.Int32>e un tipo delegato denominato `UseLikeInstance` che restituisce <xref:System.Int32> e ha un parametro di tipo <xref:System.Int32>.  
  
 Nell'esempio di codice crea quindi un <xref:System.Reflection.Emit.DynamicMethod> che modifica il campo privato di un'istanza di `Example` e restituisce il valore precedente.  
  
> [!NOTE]
>  In generale, la modifica dei campi interni delle classi non è valida orientata agli oggetti scrittura di codice.  
  
 Nell'esempio di codice crea un'istanza di `Example` e crea quindi due delegati. Il primo è di tipo `UseLikeStatic`, che ha gli stessi parametri del metodo dinamico. Il secondo è di tipo `UseLikeInstance`, che non è presente il primo parametro (di tipo `Example`). Questo delegato viene creato utilizzando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo; il secondo parametro di questo overload è un'istanza di `Example`in questo caso, l'istanza appena creata, che è associato al delegato appena creato. Ogni volta che il delegato viene chiamato, il metodo dinamico agisce sull'istanza associata di `Example`.  
  
> [!NOTE]
>  Questo è un esempio di regole relaxed per associazione di delegati introdotte nel [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], insieme ai nuovi overload di <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metodo. Per altre informazioni, vedere la classe <xref:System.Delegate>.  
  
 Il `UseLikeStatic` delegato viene richiamato, passando l'istanza di `Example` associato per il `UseLikeInstance` delegato. Il `UseLikeInstance` delegato viene richiamato in modo che entrambi i delegati possano agiscono sulla stessa istanza di `Example`. Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata. Infine, un `UseLikeInstance` delegato è associato a un'istanza di `DerivedFromxample`, e vengono ripetute le chiamate al delegato.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è <see langword="null" /> o è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">Oggetto <see cref="T:System.Reflection.Module" /> che rappresenta il modulo a cui il metodo dinamico deve essere associato in modo logico.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT su tipi e membri a cui accede il linguaggio MSIL del metodo dinamico.</param>
        <summary>Crea un metodo dinamico globale per un modulo, specificando il nome del metodo, il tipo restituito, i tipi di parametri e il modulo e indicando se deve essere ignorato il controllo di visibilità JIT per i tipi e i membri del metodo dinamico a cui accede MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi contenuti nel modulo `m`. JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi. Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `m` è un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="m" /> è un modulo che offre hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo `owner`e al ruolo public e `internal` (`Friend` in Visual Basic) di tutti gli altri tipi nel modulo che contiene i membri `owner`. JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi. Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.  
  
 Questo costruttore consente di specificare gli attributi del metodo <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> e <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>e la convenzione di chiamata <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `owner` in un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> è <see langword="null" /> o è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.MethodAttributes" /> che specifica gli attributi del metodo dinamico. L'unica combinazione consentita è <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convenzione di chiamata per il metodo dinamico. Deve essere <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico globale per un metodo, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il modulo e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico creato con questo costruttore ha accesso al ruolo public e `internal` (`Friend` in Visual Basic) membri di tutti i tipi pubblici e interni contenuti nel modulo `m`.  
  
 JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi nel modulo e in tutti gli altri assembly. Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `m` è un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="m" /> è un modulo che offre hosting anonimo per i metodi dinamici.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="m" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> è una combinazione di flag diversa da <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  - oppure - <paramref name="callingConvention" /> non è <see cref="F:System.Reflection.CallingConventions.Standard" />.  - oppure - <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome del metodo dinamico. Può essere una stringa di lunghezza zero, ma non può essere <see langword="null" />.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.MethodAttributes" /> che specifica gli attributi del metodo dinamico. L'unica combinazione consentita è <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Convenzione di chiamata per il metodo dinamico. Deve essere <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> che specifica il tipo restituito del metodo dinamico oppure <see langword="null" /> se per il metodo non esiste alcun tipo restituito.</param>
        <param name="parameterTypes">Matrice di oggetti <see cref="T:System.Type" /> che specifica i tipi dei parametri del metodo dinamico oppure <see langword="null" /> se per il metodo non esistono parametri.</param>
        <param name="owner">Oggetto <see cref="T:System.Type" /> a cui il metodo dinamico è associato in modo logico. Il metodo dinamico ha accesso a tutti i membri del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> per ignorare i controlli di visibilità JIT sui tipi e i membri cui accede il linguaggio MSIL del metodo dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un metodo dinamico, specificando il nome del metodo, gli attributi, la convenzione di chiamata, il tipo restituito, i tipi di parametro, il tipo a cui il metodo dinamico è associato in modo logico e se i controlli di visibilità JIT possono essere ignorati per i tipi e i membri cui accede il linguaggio MSIL (Microsoft Intermediate Language) del metodo dinamico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dinamico è globale per il modulo che contiene il tipo `owner`. Dispone dell'accesso a tutti i membri del tipo `owner`.  
  
 Il metodo dinamico creato con questo costruttore ha accesso a tutti i membri del tipo `owner`e al ruolo public e `internal` (`Friend` in Visual Basic) di tutti i tipi contenuti nel modulo che contiene i membri `owner`. JIT di ignorare i controlli di visibilità del compilatore consente il metodo dinamico accedere ai membri privati e protetti di tutti gli altri tipi. Questo è utile, ad esempio, quando si scrive codice per la serializzazione di oggetti.  
  
> [!NOTE]
>  Per garantire la compatibilità con le versioni precedenti, questo costruttore richiede <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag se le condizioni seguenti sono entrambi true: `owner` in un modulo diverso dal modulo chiamante e la richiesta di <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag non è riuscita. Se la richiesta di <xref:System.Security.Permissions.SecurityPermission> ha esito positivo, l'operazione è consentita.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento di <paramref name="parameterTypes" /> è <see langword="null" /> o <see cref="T:System.Void" />.  - oppure - <paramref name="owner" /> è un'interfaccia, una matrice, un tipo generico aperto o un parametro di tipo di un tipo o un metodo generico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  - oppure - <paramref name="owner" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> è una combinazione di flag diversa da <see cref="F:System.Reflection.MethodAttributes.Public" /> e <see cref="F:System.Reflection.MethodAttributes.Static" />.  - oppure - <paramref name="callingConvention" /> non è <see cref="F:System.Reflection.CallingConventions.Standard" />.  - oppure - <paramref name="returnType" /> è un tipo per cui <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per associare il metodo dinamico a un tipo in un modulo diverso dal modulo chiamante. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi specificati quando il metodo dinamico è stato creato.</summary>
        <value>Combinazione bit per bit dei valori <see cref="T:System.Reflection.MethodAttributes" /> che rappresentano gli attributi relativi al metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, gli attributi per un metodo dinamico sono sempre <xref:System.Reflection.MethodAttributes.Public> e <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare gli attributi di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la convenzione di chiamata specificata durante la creazione del metodo dinamico.</summary>
        <value>Uno dei valori di <see cref="T:System.Reflection.CallingConventions" /> che indica la convenzione di chiamata del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, la convenzione di chiamata per un metodo dinamico è sempre <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare la convenzione di chiamata di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo delegato la cui firma corrisponde a quella del metodo dinamico.</param>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo.</summary>
        <returns>Delegato del tipo specificato, che può essere usato per eseguire il metodo dinamico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo completa il metodo dinamico. Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.  
  
 Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> per ottenere un <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Se non si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> per ottenere un <xref:System.Reflection.Emit.ILGenerator> oggetto che può essere usato per generare il corpo del metodo.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non contiene alcun corpo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> contiene un numero errato di parametri o tipi di parametro non validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo delegato la cui firma corrisponde a quella del metodo dinamico, meno il primo parametro.</param>
        <param name="target">Oggetto a cui il delegato è associato. Deve essere dello stesso tipo del primo parametro del metodo dinamico.</param>
        <summary>Completa il metodo dinamico e crea un delegato che può essere usato per eseguirlo, specificando il tipo di delegato e l'oggetto a cui il delegato è associato.</summary>
        <returns>Delegato del tipo specificato, che si può usare per eseguire il metodo dinamico con l'oggetto di destinazione specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Overload di questo metodo crea un delegato associato a un oggetto specifico. Questo tipo un delegato per essere chiuso al primo argomento. Anche se il metodo è statico, agisce come se fosse un metodo di istanza. l'istanza è `target`.  
  
 Overload di questo metodo richiede `target` per essere dello stesso tipo del primo parametro del metodo dinamico oppure per essere assegnabile al tipo (ad esempio, una classe derivata).  La firma di `delegateType` dispone di tutti i parametri del metodo dinamico, ad eccezione del primo. Ad esempio, se il metodo dinamico ha i parametri <xref:System.String>, <xref:System.Int32>, e <xref:System.Byte>, quindi `delegateType` contenente i parametri <xref:System.Int32> e <xref:System.Byte>; `target` è di tipo <xref:System.String>.  
  
 La chiamata di <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo completa il metodo dinamico. Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.  
  
 Per creare il corpo di un metodo per un metodo dinamico quando si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> per ottenere un <xref:System.Reflection.Emit.DynamicILInfo> oggetto. Se non si dispone di un generatore MSIL, chiamare il <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> per ottenere un <xref:System.Reflection.Emit.ILGenerator> oggetto che può essere usato per generare il corpo del metodo.  
  
   
  
## Examples  
 Esempio di codice seguente crea delegato che associa un <xref:System.Reflection.Emit.DynamicMethod> a un'istanza di un tipo, in modo che il metodo di agire sulla stessa istanza ogni volta che viene chiamato.  
  
 L'esempio di codice definisce una classe denominata `Example` con un campo privato, una classe denominata `DerivedFromxample` che deriva dalla prima classe, un tipo delegato denominato `UseLikeStatic` che restituisce <xref:System.Int32> e dispone di parametri di tipo `Example` e <xref:System.Int32>e un tipo delegato denominato `UseLikeInstance` che restituisce <xref:System.Int32> e ha un parametro di tipo <xref:System.Int32>.  
  
 Nell'esempio di codice crea quindi un <xref:System.Reflection.Emit.DynamicMethod> che modifica il campo privato di un'istanza di `Example` e restituisce il valore precedente.  
  
> [!NOTE]
>  In generale, la modifica dei campi interni delle classi non è valida orientata agli oggetti scrittura di codice.  
  
 Nell'esempio di codice crea un'istanza di `Example` e crea quindi due delegati. Il primo è di tipo `UseLikeStatic`, che ha gli stessi parametri del metodo dinamico. Il secondo è di tipo `UseLikeInstance`, che non è presente il primo parametro (di tipo `Example`). Questo delegato viene creato utilizzando il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload del metodo; il secondo parametro di questo overload è un'istanza di `Example`in questo caso, l'istanza appena creata, che è associato al delegato appena creato. Ogni volta che il delegato viene chiamato, il metodo dinamico agisce sull'istanza associata di `Example`.  
  
> [!NOTE]
>  Questo è un esempio di regole relaxed per associazione di delegati introdotte nel [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], insieme ai nuovi overload di <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metodo. Per altre informazioni, vedere la classe <xref:System.Delegate>.  
  
 Il `UseLikeStatic` delegato viene richiamato, passando l'istanza di `Example` associato per il `UseLikeInstance` delegato. Il `UseLikeInstance` delegato viene richiamato in modo che entrambi i delegati possano agiscono sulla stessa istanza di `Example`. Le modifiche nei valori del campo interno vengono visualizzate dopo ogni chiamata. Infine, un `UseLikeInstance` delegato è associato a un'istanza di `DerivedFromxample`, e vengono ripetute le chiamate al delegato.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non contiene alcun corpo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> non è dello stesso tipo del primo parametro del metodo dinamico e non è assegnabile al tipo.  - oppure - <paramref name="delegateType" /> contiene un numero errato di parametri o tipi di parametro non validi.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo che dichiara il metodo, che è sempre <see langword="null" /> per i metodi dinamici.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per i metodi dinamici. Anche quando un metodo dinamico è associato in modo logico con un tipo, non è dichiarato dal tipo.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il tipo dichiarante di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Posizione del parametro nell'elenco dei parametri. I parametri sono indicizzati a partire da 1 per il primo parametro.</param>
        <param name="attributes">Combinazione bit per bit di valori di <see cref="T:System.Reflection.ParameterAttributes" /> che specifica gli attributi del parametro.</param>
        <param name="parameterName">Nome del parametro. Il nome può essere una stringa di lunghezza zero.</param>
        <summary>Definisce un parametro del metodo dinamico.</summary>
        <returns>Restituisce sempre <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `position` è 0, il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo fa riferimento al valore restituito. Impostazione delle informazioni sul parametro ha effetto sul valore restituito.  
  
 Se il metodo dinamico è già stato completato, chiamando la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo non ha alcun effetto. Non viene generata alcuna eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come definire le informazioni sui parametri per un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il metodo non ha parametri.  - oppure - <paramref name="position" /> è minore di 0.  - oppure - <paramref name="position" /> è maggiore del numero dei parametri del metodo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'implementazione di base per il metodo.</summary>
        <returns>Implementazione di base del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce sempre l'attuale `DynamicMethod` oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce gli attributi personalizzati applicati al metodo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Restituisce tutti gli attributi personalizzati definiti per il metodo.</summary>
        <returns>Matrice di oggetti che rappresentano tutti gli attributi personalizzati del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` perché il metodo non è dichiarato in un tipo non ha alcun effetto.  
  
> [!NOTE]
>  Attributi personalizzati non sono attualmente supportati sui metodi dinamici. L'unico attributo restituito è <xref:System.Runtime.CompilerServices.MethodImplAttribute>; è possibile ottenere i flag di implementazione più facilmente utilizzando il <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Classe <see cref="T:System.Type" /> che rappresenta il tipo di attributo personalizzato da restituire.</param>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Restituisce gli attributi personalizzati del tipo specificato che sono stati applicati al metodo.</summary>
        <returns>Matrice di oggetti che rappresentano gli attributi del metodo di tipo <paramref name="attributeType" /> o derivano dal tipo <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` perché il metodo non è dichiarato in un tipo non ha alcun effetto.  
  
> [!NOTE]
>  Attributi personalizzati non sono attualmente supportati sui metodi dinamici. L'unico attributo restituito è <xref:System.Runtime.CompilerServices.MethodImplAttribute>; è possibile ottenere i flag di implementazione più facilmente utilizzando il <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL (Microsoft Intermediate Language).</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> che è possibile utilizzare per generare il corpo di un metodo da token di metadati, ambiti e flussi MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Reflection.Emit.DynamicILInfo> classe viene fornita per supportare la generazione di codice non gestito.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per eseguire codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un generatore MSIL che è possibile usare per generare un corpo per il metodo dinamico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con una dimensione di flusso MSIL predefinita di 64 byte.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.ILGenerator" /> per il metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo un metodo dinamico è stato completato, chiamando la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato. Non viene generata alcuna eccezione.  
  
> [!NOTE]
>  Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità totale. Vedere la sezione "Verifica" nelle note per <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un metodo dinamico che accetta due parametri. Nell'esempio viene generato il corpo di una funzione semplice che stampa il primo parametro nella console e verrà utilizzato il secondo parametro come valore restituito del metodo. Nell'esempio viene completato il metodo tramite la creazione di un delegato, richiama il delegato con parametri diversi e infine viene chiamato il metodo dinamico usando il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Dimensioni del flusso MSIL in byte.</param>
        <summary>Restituisce un generatore di Microsoft Intermediate Language (MSIL) per il metodo con le dimensioni del flusso MSIL specificate.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.ILGenerator" /> per il metodo, con le dimensioni del flusso MSIL specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo un metodo dinamico è stato completato, chiamando la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> (metodo), eventuali ulteriori tentativi di aggiungere codice MSIL viene ignorato. Non viene generata alcuna eccezione.  
  
> [!NOTE]
>  Esistono restrizioni sul codice non verificabile in metodi dinamici, anche in alcuni scenari di attendibilità totale. Vedere la sezione "Verifica" nelle note per <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato questo overload del metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i flag di implementazione per il metodo.</summary>
        <returns>Combinazione bit per bit dei valori <see cref="T:System.Reflection.MethodImplAttributes" /> che rappresentano i flag di implementazione relativi al metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente, gli attributi di implementazione di metodo per i metodi dinamici sono sempre <xref:System.Reflection.MethodImplAttributes.IL> e <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i parametri del metodo dinamico.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.ParameterInfo" /> che rappresentano i parametri del metodo dinamico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.ParameterInfo> gli oggetti restituiti da questo metodo sono solo a scopo informativo. Utilizzare il <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodo per impostare o modificare le caratteristiche dei parametri.  
  
   
  
## Examples  
 Esempio di codice seguente mostra i parametri di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le variabili locali nel metodo sono inizializzate su zero.</summary>
        <value>
          <see langword="true" /> se le variabili locali nel metodo vengono inizializzate su zero; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa proprietà è impostata su `true`, generato Microsoft intermedio language (MSIL) include l'inizializzazione delle variabili locali. Se è impostato su `false`, variabili locali non inizializzate e il codice generato non è verificabile.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> proprietà di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Questo parametro viene ignorato per i metodi dinamici, in quanto sono statici. Specificare <see langword="null" />.</param>
        <param name="invokeAttr">Combinazione bit per bit di valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Oggetto <see cref="T:System.Reflection.Binder" /> che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito. Per informazioni dettagliate, vedere <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Elenco di argomenti. Matrice di argomenti con lo stesso numero, ordine e tipo dei parametri del metodo da richiamare. In assenza di parametri, questo parametro deve essere <see langword="null" />.</param>
        <param name="culture">Istanza di <see cref="T:System.Globalization.CultureInfo" /> usata per regolare la coercizione dei tipi. Se è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />. Queste informazioni sono necessarie, ad esempio, per convertire in modo corretto un valore <see cref="T:System.String" /> che rappresenta 1000 in un valore <see cref="T:System.Double" />, in quanto 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</param>
        <summary>Richiama il metodo dinamico usando i parametri specificati, con i vincoli del binder specificato e le informazioni sulle impostazioni cultura specificate.</summary>
        <returns>Un valore <see cref="T:System.Object" /> che contiene il valore restituito del metodo richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre alle eccezioni elencate, il codice chiamante deve essere preparato per intercettare le eccezioni generate dal metodo dinamico.  
  
 L'esecuzione di un metodo dinamico con un delegato creato dal <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo è più efficiente rispetto all'esecuzione con il <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo.  
  
 La chiamata di <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metodo o <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodo completa il metodo dinamico. Qualsiasi ulteriore tenta di modificare il metodo dinamico, ad esempio modifica di definizioni di parametro o la creazione di ulteriori Microsoft intermediate language (MSIL), viene ignorato. viene generata alcuna eccezione.  
  
 Tutti i metodi dinamici sono statici, pertanto la `obj` parametro viene sempre ignorato. Per considerare un metodo dinamico, come se fosse un metodo di istanza, utilizzare il <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload che accetta un'istanza dell'oggetto.  
  
 Se il metodo dinamico ha alcun parametro, il valore di `parameters` deve essere `null`. In caso contrario, il numero, tipo e l'ordine degli elementi nella matrice di parametri deve essere identici a numero, tipo e ordine dei parametri del metodo dinamico.  
  
> [!NOTE]
>  Overload di questo metodo viene chiamato dal <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> overload del metodo ereditato dalla <xref:System.Reflection.MethodBase> classe, per le note precedenti si applicano a entrambi gli overload.  
  
 Questo metodo non richiedere autorizzazioni direttamente, ma il richiamo del metodo dinamico può causare richieste di sicurezza, a seconda del metodo. Ad esempio, non viene effettuata per metodi dinamici ospitati anonimamente vengono creati con il `restrictedSkipVisibility` parametro impostato su `false`. D'altra parte, se si crea un metodo con `restrictedSkipVisibility` impostato su `true` in modo che possa accedere a un membro nascosto di un assembly di destinazione, il metodo provocherà una richiesta per le autorizzazioni dell'assembly di destinazione più <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
> [!NOTE]
>  Nelle versioni precedenti al [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo richiesto <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.  
  
   
  
## Examples  
 Esempio di codice seguente richiama un metodo dinamico con associazione esatta, utilizzando le impostazioni cultura inglese Stati Uniti. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La convenzione di chiamata <see cref="F:System.Reflection.CallingConventions.VarArgs" /> non è supportata.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Il numero di elementi in <paramref name="parameters" /> non corrisponde al numero dei parametri del metodo dinamico.</exception>
        <exception cref="T:System.ArgumentException">Il tipo di uno o più elementi di <paramref name="parameters" /> non corrisponde al tipo del parametro corrispondente del metodo dinamico.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo dinamico è associato a un modulo, non è contenuto anonimamente ed è costruito con <paramref name="skipVisibility" /> impostato su <see langword="false" />, ma il metodo dinamico accede a membri che non sono <see langword="public" /> o <see langword="internal" /> (<see langword="Friend" /> in Visual Basic).  - oppure - Il metodo dinamico è ospitato in modo anonimo ed è costruito con <paramref name="skipVisibility" /> impostato su <see langword="false" />, ma accede a membri che non sono <see langword="public" />.  - oppure - Il metodo dinamico contiene codice non verificabile. Vedere la sezione "Verifica" nelle note per <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Classe <see cref="T:System.Type" /> che rappresenta il tipo di attributo personalizzato da ricercare.</param>
        <param name="inherit">
          <see langword="true" /> per ricercare gli attributi personalizzati nella catena di ereditarietà del metodo; <see langword="false" /> per verificare solo il metodo corrente.</param>
        <summary>Indica se il tipo di attributo personalizzato specificato è definito.</summary>
        <returns>
          <see langword="true" /> se è definito il tipo di attributo personalizzato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i metodi dinamici, specificando `true` per `inherit` non ha alcun effetto. Metodi dinamici non hanno alcuna catena di ereditarietà.  
  
> [!NOTE]
>  Attributi personalizzati non sono attualmente supportati sui metodi dinamici.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente e può pertanto eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico corrente è critico per la sicurezza o security-safe-critical; <see langword="false" /> se è trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che è associato. Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critico|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente. Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.  
  
 Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è critico per la sicurezza al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico è security-safe-critical al livello di attendibilità corrente; <see langword="false" /> se è critico per la sicurezza o trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che è associato. Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critico|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente. Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.  
  
 Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo dinamico corrente è trasparente al livello di attendibilità corrente e pertanto non può eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo dinamico è SecurityTrasparent al livello di attendibilità corrente; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo dinamico, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
 La trasparenza di un metodo dinamico dipende dal modulo che è associato. Se il metodo dinamico è associato un tipo anziché un modulo, la trasparenza dipende dal modulo che contiene il tipo. Metodi dinamici dispone di annotazioni di sicurezza, pertanto vengono assegnate la trasparenza predefinita per il modulo associato.  
  
-   Metodi dinamici ospitati anonimamente sono sempre trasparenti, perché il modulo fornita dal sistema che li contiene è trasparente.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) descritto nella tabella seguente.  
  
    |Annotazione di assembly|Trasparenza di livello 1|Trasparenza di livello 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Completamente trasparente|Trasparente|Trasparente|  
    |Completamente critico|Critico|Critico|  
    |Trasparenza mista|Trasparente|Trasparente|  
    |Indipendente dalla sicurezza|Critico per la sicurezza|Critico|  
  
     Ad esempio, se si associa un metodo dinamico a un tipo presente in mscorlib.dll, che dispone di trasparenza di livello 2 misto, il metodo dinamico è trasparente e non è possibile eseguire il codice critico. Per informazioni sui livelli di trasparenza, vedere [codice SecurityTransparent, livello 1](~/docs/framework/misc/security-transparent-code-level-1.md) e [codice SecurityTransparent, livello 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Associazione di un metodo dinamico a un modulo in un assembly attendibile di livello 1 che è indipendente dalla sicurezza, ad esempio System.dll, non supporta l'elevazione dei privilegi di attendibilità. Se il set di concessioni del codice che chiama il metodo dinamico non include il set di concessioni di System. dll (ovvero, l'attendibilità totale), <xref:System.Security.SecurityException> viene generata quando viene chiamato il metodo dinamico.  
  
-   La trasparenza di un metodo dinamico è associato a un assembly parzialmente attendibile dipende da come l'assembly viene caricato. Se l'assembly viene caricato con attendibilità parziale (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi e membri, inclusi i metodi dinamici, vengono considerati come trasparente. Il runtime presta attenzione a annotazioni di sicurezza solo se l'assembly con attendibilità parziale viene caricato con attendibilità completa (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). In tal caso, il runtime assegna il metodo dinamico la trasparenza predefinita per i metodi in base alle annotazioni dell'assembly.  
  
 Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo dinamico non dispone di un corpo del metodo.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Non supportato per metodi dinamici.</summary>
        <value>Non supportato per metodi dinamici.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non consentito per metodi dinamici.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo a cui il metodo dinamico è associato in modo logico.</summary>
        <value>Classe <see cref="T:System.Reflection.Module" /> a cui è associato il metodo dinamico corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un modulo è stato specificato quando il metodo dinamico è stato creato, questa proprietà restituisce tale modulo. Se è stato specificato un tipo come proprietario quando il metodo dinamico è stato creato, questa proprietà restituisce il modulo che contiene tale tipo.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.Module%2A> proprietà di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del metodo dinamico.</summary>
        <value>Nome semplice del metodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Non è necessario per metodi dinamici di nome.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza il nome di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classe usata nella reflection per ottenere il metodo.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per i metodi dinamici.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il tipo riflesso di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il parametro restituito del metodo dinamico.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce sempre `null` per i metodi dinamici.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di valore restituito per il metodo dinamico.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore restituito del metodo corrente; <see cref="T:System.Void" /> se il metodo non contiene tipi restituiti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `null` è stato specificato per il tipo restituito quando il metodo dinamico è stato creato, questa proprietà restituisce <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il tipo restituito di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi personalizzati del tipo restituito per il metodo dinamico.</summary>
        <value>Interfaccia <see cref="T:System.Reflection.ICustomAttributeProvider" /> che rappresenta gli attributi personalizzati del tipo restituito per il metodo dinamico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attributi personalizzati non sono supportati sul tipo restituito di un metodo dinamico, pertanto ha restituito una matrice di attributi personalizzati di <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> metodo è sempre vuoto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare gli attributi personalizzati del tipo restituito di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la firma del metodo, rappresentata come stringa.</summary>
        <returns>Stringa che rappresenta la firma del metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La firma include solo i tipi e il nome del metodo, se presente. I nomi dei parametri non sono inclusi.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene visualizza la <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> metodo di un metodo dinamico. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Emit.DynamicMethod> classe.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>