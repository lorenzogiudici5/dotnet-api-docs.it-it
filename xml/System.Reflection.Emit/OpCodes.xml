<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OpCodes.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a136bc8fb48fe619f1be21928afbfcd9094d7463.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a136bc8fb48fe619f1be21928afbfcd9094d7463</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.OpCodes">
          <source>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> class members (such as <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</source>
          <target state="translated">Fornisce le rappresentazioni dei campi delle istruzioni MSIL (Microsoft Intermediate Language) per la creazione da parte dei membri della classe <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph>, ad esempio il metodo <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Per una descrizione dettagliata dei codici operativi membro, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition III: CIL Instruction Set" e "Partition II: metadati definizione e la semantica".</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The following example demonstrates the construction of a dynamic method using <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> to emit <ph id="ph2">`OpCodes`</ph> into a <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la costruzione di un metodo dinamico utilizzando <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> per generare <ph id="ph2">`OpCodes`</ph> in un <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Somma due valori e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>58</source>
          <target state="translated">58</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two numeric values, returning a new numeric value.</source>
          <target state="translated">Aggiunge due valori numerici, restituendo un nuovo valore numerico.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene aggiunto a <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</source>
          <target state="translated">Overflow non viene rilevato per operazioni su numeri interi (per gestire l'overflow appropriato, vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Integer addition wraps, rather than saturates.</source>
          <target state="translated">Aggiunta di integer determina il passaggio al valore iniziale, anziché una saturazione.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>For example, assuming 8-bit integers where <ph id="ph1">`value1`</ph> is set to 255 and <ph id="ph2">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.</source>
          <target state="translated">Ad esempio, supponendo di valori integer a 8 bit in cui <ph id="ph1">`value1`</ph> è impostata su 255 e <ph id="ph2">`value2`</ph> è impostato su 1, il risultato sarà 0 anziché 256.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">Restituisce un overflow a virgola mobile <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) o <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</source>
          <target state="translated">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), è un non valido Microsoft Intermediate Language (MSIL) e genera un errore.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>operand</source>
          <target state="translated">Operando</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value1 type</source>
          <target state="translated">tipo di value1</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value2 type</source>
          <target state="translated">tipo di value2</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>result type</source>
          <target state="translated">Tipo di risultato</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`add`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Somma due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>D6</source>
          <target state="translated">D6</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add.ovf</source>
          <target state="translated">add.ovf</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two signed integer values with an overflow check.</source>
          <target state="translated">Aggiunge due valori integer con segno con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene aggiunto a <ph id="ph4">`value2`</ph> con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non è rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">È possibile eseguire questa operazione sui valori signed integer.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Per i valori a virgola mobile, usare <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), è un'istruzione non valida di Microsoft Intermediate Language (MSIL) e genera un errore.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>operand</source>
          <target state="translated">Operando</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value1 type</source>
          <target state="translated">tipo di value1</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value2 type</source>
          <target state="translated">tipo di value2</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>result type</source>
          <target state="translated">Tipo di risultato</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`add.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Somma due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>D7</source>
          <target state="translated">D7</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add.ovf.un</source>
          <target state="translated">add.ovf.un</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values with an overflow check.</source>
          <target state="translated">Aggiunge due valori integer senza segno con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene aggiunto a <ph id="ph4">`value2`</ph> con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non è rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">È possibile eseguire questa operazione sui valori signed integer.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Per i valori a virgola mobile, usare <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, <ph id="ph1">`int32`</ph> e <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> e <ph id="ph4">`int64`</ph>), è un'istruzione non valida di Microsoft Intermediate Language (MSIL) e genera un errore.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>operand</source>
          <target state="translated">Operando</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value1 type</source>
          <target state="translated">tipo di value1</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value2 type</source>
          <target state="translated">tipo di value2</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>result type</source>
          <target state="translated">Tipo di risultato</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">aggiunta</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`add.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Calcola l'operatore AND bit per bit di due valori e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Instruction</source>
          <target state="translated">Istruzione</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>5F</source>
          <target state="translated">5F</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>and</source>
          <target state="translated">e</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Determines the bitwise AND of two integer values.</source>
          <target state="translated">Determina l'AND bit per bit di due valori integer.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> and <ph id="ph2">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> e <ph id="ph2">`value2`</ph> vengono estratti dallo stack; viene calcolato l'AND bit per bit dei due valori.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The <ph id="ph1">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated">Il <ph id="ph1">`and`</ph> istruzione calcola l'AND bit per bit dei primi due valori nello stack e lascia il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`And`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`And`</ph> è un'operazione specifica del numero intero.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`and`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`and`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an unmanaged pointer to the argument list of the current method.</source>
          <target state="translated">Restituisce un puntatore non gestito all'elenco di argomenti del metodo corrente.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>FE 00</source>
          <target state="translated">FE 00</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>arglist</source>
          <target state="translated">arglist</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an argument list handle for the current method.</source>
          <target state="translated">Restituisce un handle di elenco di argomenti per il metodo corrente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Sullo stack di valutazione viene eseguito da questa operazione.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The <ph id="ph1">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id="ph2">`native int`</ph>) that represents the argument list of the current method.</source>
          <target state="translated">Il <ph id="ph1">`arglist`</ph> istruzione restituisce un handle opaco (un puntatore non gestito, di tipo <ph id="ph2">`native int`</ph>) che rappresenta l'elenco di argomenti del metodo corrente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>This handle is valid only during the lifetime of the current method.</source>
          <target state="translated">Questo handle è valido solo per la durata del metodo corrente.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can, however, pass the handle to other methods as long as the current method is on the thread of control.</source>
          <target state="translated">È tuttavia possibile passare l'handle ad altri metodi, purché sia il metodo corrente del thread di controllo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can only execute the <ph id="ph1">`arglist`</ph> instruction within a method that takes a variable number of arguments.</source>
          <target state="translated">È possibile eseguire solo il <ph id="ph1">`arglist`</ph> istruzione all'interno di un metodo che accetta un numero variabile di argomenti.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`arglist`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`arglist`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Transfers control to a target instruction if two values are equal.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se due valori sono uguali.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>beq <ph id="ph1">`target`</ph></source>
          <target state="translated">beq <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if the two values are equal.</source>
          <target state="translated">Branch all'istruzione di destinazione all'offset <ph id="ph1">`target`</ph> se i due valori sono uguali.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The <ph id="ph1">`beq`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`beq`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è equivale all'esecuzione di un <ph id="ph1">`ceq`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">I tipi di operando accettabili sono indicati di seguito:</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono limitati gravi e deve utilizzare il <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> istruzione alternativa).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`beq`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Transfers control to a target instruction (short form) if two values are equal.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se due valori sono uguali.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>beq.s <ph id="ph1">`target`</ph></source>
          <target state="translated">beq. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if equal, short form</source>
          <target state="translated">Branch all'istruzione di destinazione all'offset <ph id="ph1">`target`</ph> se uguale, forma breve</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The <ph id="ph1">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`beq.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è equivale all'esecuzione di un <ph id="ph1">`ceq`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">I tipi di operando accettabili sono indicati di seguito:</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono limitati gravi e deve utilizzare il <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> istruzione alternativa).</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`beq.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Transfers control to a target instruction if the first value is greater than or equal to the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>3C <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3C <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>bge <ph id="ph1">`target`</ph></source>
          <target state="translated">bge <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The <ph id="ph1">`bge`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`bge`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore o uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt.un`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bge`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>2F <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">2F <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>bge.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo, forma breve.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The <ph id="ph1">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`bge.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore o uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt.un`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bge.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>41 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">41 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>bge.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bge. un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo (valori senza segno).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The <ph id="ph1">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bge.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore o uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bge.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>bge.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo (valori senza segno), la forma breve.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The <ph id="ph1">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bge.un.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore o uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bge.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Transfers control to a target instruction if the first value is greater than the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>bgt <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The <ph id="ph1">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`bgt`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore di <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bgt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>bgt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore, la forma breve.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The <ph id="ph1">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`bgt.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore di <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bgt.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>bgt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore (valori senza segno).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The <ph id="ph1">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bgt.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore di <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt.un`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bgt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>bgt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore (valori senza segno), la forma breve.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è maggiore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The <ph id="ph1">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bgt.un.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è maggiore di <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt.un`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bgt.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>3E <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3E <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ble <ph id="ph1">`target`</ph></source>
          <target state="translated">Disattiva <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The <ph id="ph1">`ble`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ble`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore o uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt`</ph> istruzione (<ph id="ph2">`cgt.un`</ph> per valori di float) seguita da un <ph id="ph3">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ble`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>31 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">31 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ble.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo, forma breve.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The <ph id="ph1">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ble.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore o uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) instruction followed by a<ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt`</ph> istruzione (<ph id="ph2">`cgt.un`</ph> per valori di float) seguita da un<ph id="ph3">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ble.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>43 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">43 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ble.un <ph id="ph1">`target`</ph></source>
          <target state="translated">ble. un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo (valori senza segno).</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The <ph id="ph1">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`ble.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore o uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt.un`</ph> istruzione (<ph id="ph2">`cgt`</ph> per valori di float) seguita da un <ph id="ph3">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ble.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>36 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">36 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ble.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo (valori senza segno), la forma breve.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore o uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The <ph id="ph1">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`ble.un.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore o uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`cgt.un`</ph> istruzione (<ph id="ph2">`cgt`</ph> per valori di float) seguita da un <ph id="ph3">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ble.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Transfers control to a target instruction if the first value is less than the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>blt <ph id="ph1">`target`</ph></source>
          <target state="translated">blt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The <ph id="ph1">`blt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`blt`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore o uguale a <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`blt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>blt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</source>
          <target state="translated">Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo, forma breve.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The <ph id="ph1">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`blt.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore di <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`blt.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>blt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno).</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`blt.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore di <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt.un`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`blt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>blt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</source>
          <target state="translated">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno), la forma breve.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> è minore di <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`blt.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> è minore di <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`clt.un`</ph> istruzione seguita da un <ph id="ph2">`brtrue`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`blt.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione quando due valori interi senza segno o valori float non ordinati non sono uguali.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>bne.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bne. un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</source>
          <target state="translated">Ramo di destinazione istruzione in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (valori senza segno).</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> non è uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bne.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> non è uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`ceq`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bne.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve) quando due valori interi senza segno o valori float non ordinati non sono uguali.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>bne.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</source>
          <target state="translated">Ramo di destinazione dell'istruzione in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (valori senza segno), forma breve.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; se <ph id="ph3">`value1`</ph> non è uguale a <ph id="ph4">`value2`</ph>, viene eseguita l'operazione di diramazione.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated">Il <ph id="ph1">`bne.un`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value1`</ph> non è uguale a <ph id="ph3">`value2`</ph>, se confrontata mediante l'intero senza segno o valori float non ordinati.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">L'effetto è identico all'esecuzione di un <ph id="ph1">`ceq`</ph> istruzione seguita da un <ph id="ph2">`brfalse`</ph> ramo all'istruzione di destinazione specifico.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`bne.un.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Converts a value type to an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</source>
          <target state="translated">Converte un tipo di valore in un riferimento a un oggetto di tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>box <ph id="ph1">`valTypeToken`</ph></source>
          <target state="translated">box <ph id="ph1">`valTypeToken`</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Convert a value type (of the type specified in <ph id="ph1">`valTypeToken`</ph>) to a true object reference.</source>
          <target state="translated">Convertire un tipo di valore (del tipo specificato <ph id="ph1">`valTypeToken`</ph>) a un oggetto true.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type is pushed onto the stack.</source>
          <target state="translated">Un tipo di valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The value type is popped from the stack; the <ph id="ph1">`box`</ph> operation is performed.</source>
          <target state="translated">Il tipo di valore viene estratto dallo stack; il <ph id="ph1">`box`</ph> viene eseguita l'operazione.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>An object reference to the resulting "boxed" value type is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto per il tipo di valore "boxed" risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Un tipo di valore dispone di due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'raw' form used when a value type is embedded within another object or on the stack.</source>
          <target state="translated">'Non elaborato' modulo quando un tipo di valore incorporato all'interno di un altro oggetto o nello stack.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Un modulo 'boxed', in cui i dati nel tipo di valore viene inseriti (boxed) in un oggetto affinché possano esistere come entità indipendenti.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The <ph id="ph1">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id="ph2">`O`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`box`</ph> istruzione converte il tipo 'non elaborati' valore unboxed in un riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>).</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</source>
          <target state="translated">Questa operazione viene eseguita creando un nuovo oggetto e copiando i dati dal tipo di valore nell'oggetto appena allocato.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.</source>
          <target state="translated"><ph id="ph1">`valTypeToken`</ph> è un token di metadati che indica il tipo del tipo di valore nello stack.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> viene generata se la memoria è insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se la classe non può essere trovata.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando Microsoft Intermediate Language (MSIL) viene convertito in codice nativo, anziché in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`box`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`box`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Unconditionally transfers control to a target instruction.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>br <ph id="ph1">`target`</ph></source>
          <target state="translated">Brasile <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Branches to a target instruction at the specified offset.</source>
          <target state="translated">Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Sullo stack di valutazione viene eseguito da questa operazione.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The <ph id="ph1">`br`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated">Il <ph id="ph1">`br`</ph> istruzione trasferisce il controllo a un'istruzione di destinazione.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`br`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Unconditionally transfers control to a target instruction (short form).</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato (forma breve).</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>br.s <ph id="ph1">`target`</ph></source>
          <target state="translated">br.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Branches to a target instruction at the specified offset, short form.</source>
          <target state="translated">Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato, forma breve.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Sullo stack di valutazione viene eseguito da questa operazione.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The <ph id="ph1">`br.s`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated">Il <ph id="ph1">`br.s`</ph> istruzione trasferisce il controllo a un'istruzione di destinazione.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`br.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Segnala a Common Language Infrastructure (CLI) di indicare al debugger che è stato raggiunto un punto di interruzione.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>01</source>
          <target state="translated">01</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>break</source>
          <target state="translated">break</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>inform a debugger that a breakpoint has been reached.</source>
          <target state="translated">indica al debugger che è stato raggiunto un punto di interruzione.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">Sullo stack di valutazione viene eseguito da questa operazione.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction is for debugging support.</source>
          <target state="translated">Il <ph id="ph1">`break`</ph> l'istruzione è in fase di debug.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It signals the CLI to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Segnala l'interfaccia CLI di indicare al debugger che è stato raggiunto un punto di interruzione.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It has no other effect on the interpreter state.</source>
          <target state="translated">Non ha alcun altro effetto sullo stato dell'interprete.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</source>
          <target state="translated">Il <ph id="ph1">`break`</ph> istruzione è il più piccolo possibile un'istruzione dimensioni l'applicazione di patch con un punto di interruzione e la generazione di interferire con il codice circostante.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.</source>
          <target state="translated">Il <ph id="ph1">`break`</ph> istruzione può intercettare a un debugger, non eseguire alcuna operazione o generare un'eccezione di sicurezza.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The exact behavior is implementation-defined.</source>
          <target state="translated">Il comportamento esatto è definito dall'implementazione.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`break`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`break`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), or zero.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="false" /&gt;</ph>, un riferimento null (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) oppure zero.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brfalse <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brnull <ph id="ph1">`target`</ph></source>
          <target state="translated">rispettivi brnull <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brzero <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Esegue la diramazione in un'istruzione di destinazione in corrispondenza dell'offset specificato se <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack da un'operazione precedente.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack; Se <ph id="ph2">`value`</ph> è <ph id="ph3">`false`</ph>, creare un ramo a <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The <ph id="ph1">`brfalse`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`brfalse`</ph> istruzione (e i rispettivi alias <ph id="ph2">`brnull`</ph> e <ph id="ph3">`brzero`</ph>) trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph4">`value`</ph> (di tipo <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, il riferimento all'oggetto <ph id="ph7">`O`</ph>gestita puntatore <ph id="ph8">`&amp;`</ph>, puntatore temporaneo <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) è uguale a zero (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è diverso da zero (<ph id="ph2">`true`</ph>) l'esecuzione continua con l'istruzione successiva.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`brfalse`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference, or zero.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="false" /&gt;</ph>, un riferimento null oppure zero.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brfalse.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brnull.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brzero.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>, short form.</source>
          <target state="translated">Esegue la diramazione in un'istruzione di destinazione in corrispondenza dell'offset specificato se <ph id="ph1">`false`</ph>, forma breve.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack da un'operazione precedente.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack; Se <ph id="ph2">`value`</ph> è <ph id="ph3">`false`</ph>, creare un ramo a <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The <ph id="ph1">`brfalse.s`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`brfalse.s`</ph> istruzione (e i rispettivi alias <ph id="ph2">`brnull`</ph> e <ph id="ph3">`brzero`</ph>) trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph4">`value`</ph> (di tipo <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, il riferimento all'oggetto <ph id="ph7">`O`</ph>gestita puntatore <ph id="ph8">`&amp;`</ph>, puntatore temporaneo <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) è uguale a zero (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è diverso da zero (<ph id="ph2">`true`</ph>) l'esecuzione continua con l'istruzione successiva.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`brfalse.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, diverso da null o da zero.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brtrue <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brinst <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst, che rappresenta <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>).</source>
          <target state="translated">Ramo in un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (<ph id="ph1">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack da un'operazione precedente.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack; Se <ph id="ph2">`value`</ph> è <ph id="ph3">`true`</ph>, creare un ramo a <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The <ph id="ph1">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`brtrue`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value`</ph> (tipo <ph id="ph3">`native int`</ph>) è diverso da zero (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è zero (<ph id="ph2">`false`</ph>) l'esecuzione continua con l'istruzione successiva.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è un riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>) quindi <ph id="ph3">`brinst`</ph> (un alias per <ph id="ph4">`brtrue`</ph>) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento di oggetto null; vedere <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`brtrue`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Transfers control to a target instruction (short form) if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Trasferisce il controllo a un'istruzione di destinazione (forma breve), se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph>, diverso da null oppure diverso da zero.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brtrue.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brinst.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>), short form.</source>
          <target state="translated">Ramo in un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (<ph id="ph1">`true`</ph>), forma breve.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack da un'operazione precedente.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack; Se <ph id="ph2">`value`</ph> è <ph id="ph3">`true`</ph>, creare un ramo a <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The <ph id="ph1">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`brtrue.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specificato se <ph id="ph2">`value`</ph> (tipo <ph id="ph3">`native int`</ph>) è diverso da zero (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è zero (<ph id="ph2">`false`</ph>) l'esecuzione continua con l'istruzione successiva.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è un riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>) quindi <ph id="ph3">`brinst`</ph> (un alias per <ph id="ph4">`brtrue`</ph>) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento di oggetto null; vedere <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`brtrue.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls the method indicated by the passed method descriptor.</source>
          <target state="translated">Chiama il metodo indicato dal descrittore di metodo passato.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>call <ph id="ph1">`methodDesc`</ph></source>
          <target state="translated">Chiamata <ph id="ph1">`methodDesc`</ph></target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Call the method described by <ph id="ph1">`methodDesc`</ph>.</source>
          <target state="translated">Chiamare il metodo descritto da <ph id="ph1">`methodDesc`</ph>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> vengono inseriti nello stack.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> vengono estratti dallo stack; viene eseguita la chiamata al metodo con questi argomenti e il controllo viene trasferito al metodo a cui fa riferimento il descrittore del metodo.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Il valore restituito viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.</source>
          <target state="translated">Il <ph id="ph1">`call`</ph> istruzione chiama il metodo indicato dal descrittore di metodo passato con l'istruzione.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</source>
          <target state="translated">Descrittore del metodo è un token di metadati che indica il metodo da chiamare e il numero, tipo e ordine degli argomenti che sono stati inseriti nello stack deve essere passato al metodo, nonché la convenzione di chiamata da utilizzare.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction can be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.</source>
          <target state="translated">Il <ph id="ph1">`call`</ph> istruzione può essere immediatamente preceduto da un <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) per specificare che lo stato del metodo corrente deve essere rilasciata prima di trasferire il controllo del prefisso.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</source>
          <target state="translated">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine, lo stack frame non viene rilasciato.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Instead, the execution continues silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Al contrario, l'esecuzione continua automaticamente come se il <ph id="ph1">`tail`</ph> non è stato specificato.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</source>
          <target state="translated">Il token di metadati contiene informazioni sufficienti per determinare se la chiamata di un metodo statico, un metodo di istanza, un metodo virtuale o una funzione globale.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</source>
          <target state="translated">In tutti questi casi l'indirizzo di destinazione viene determinato interamente dal descrittore del metodo (confrontare questa operazione con il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> istruzione per la chiamata di metodi virtuali, in cui l'indirizzo di destinazione dipende inoltre dal tipo di runtime dell'istanza riferimento inserito prima di <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>There are three important special cases:</source>
          <target state="translated">Esistono tre importanti casi speciali:</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</source>
          <target state="translated">Le chiamate a un'istanza (o virtuali) metodo deve inserire il riferimento all'istanza prima di qualsiasi argomento visibile all'utente.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The instance reference must not be a null reference.</source>
          <target state="translated">Il riferimento all'istanza non deve essere un riferimento null.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The signature carried in the metadata does not contain an entry in the parameter list for the <ph id="ph1">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id="ph2">`this`</ph> pointer.</source>
          <target state="translated">La firma contenuta nei metadati non contiene una voce nell'elenco di parametri per il <ph id="ph1">`this`</ph> puntatore; utilizza invece un bit per indicare se il metodo richiede il passaggio di <ph id="ph2">`this`</ph> puntatore.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>It is valid to call a virtual method using <ph id="ph1">`call`</ph> (rather than <ph id="ph2">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</source>
          <target state="translated">È possibile chiamare un metodo virtuale utilizzando <ph id="ph1">`call`</ph> (anziché <ph id="ph2">`callvirt`</ph>); ciò indica che il metodo deve essere risolto utilizzando la classe specificata dal metodo, piuttosto che come specificato in modo dinamico dall'oggetto richiamato.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Note that a delegate's <ph id="ph1">`Invoke`</ph> method can be called with either the <ph id="ph2">`call`</ph> or <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Si noti che un delegato <ph id="ph1">`Invoke`</ph> metodo può essere chiamato con il <ph id="ph2">`call`</ph> o <ph id="ph3">`callvirt`</ph> (istruzione).</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction instead of emitting a <ph id="ph3">`call`</ph> instruction.</source>
          <target state="translated">Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile utilizzare il <ph id="ph1">`constrained`</ph> Anteponi il <ph id="ph2">`callvirt`</ph> istruzione invece di generare un <ph id="ph3">`call`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Questo elimina la necessità di generare un IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitare un potenziale problema di controllo delle versioni.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">È consigliabile utilizzare il <ph id="ph1">`constrained`</ph> prefisso quando si chiamano metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Questi problemi sono descritti più dettagliatamente il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`call`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`call`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall (OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id="ph2">`varargs`</ph> calls.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> metodo è fornito per <ph id="ph2">`varargs`</ph> chiamate.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> metodo per le chiamate normali.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</source>
          <target state="translated">Chiama il metodo indicato nello stack di valutazione, come un puntatore a un punto di ingresso, con gli argomenti descritti da una convenzione di chiamata.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>calli <ph id="ph1">`callSiteDescr`</ph></source>
          <target state="translated">calli <ph id="ph1">`callSiteDescr`</ph></target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method pointed to with arguments described by the calling convention.</source>
          <target state="translated">Chiama il metodo a cui puntato con gli argomenti descritti dalla convenzione di chiamata.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> vengono inseriti nello stack.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is pushed onto the stack.</source>
          <target state="translated">Il puntatore di ingresso del metodo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> e il puntatore di ingresso del metodo vengono estratti dallo stack; viene eseguita la chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Il valore restituito viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id="ph2">`arg1`</ph> through <ph id="ph3">`argN`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`calli`</ph> istruzione chiama il puntatore di ingresso del metodo con gli argomenti <ph id="ph2">`arg1`</ph> tramite <ph id="ph3">`argN`</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The types of these arguments are described by the specific calling convention (<ph id="ph1">`callSiteDesc`</ph>).</source>
          <target state="translated">I tipi di questi argomenti sono descritti dalla convenzione di chiamata specifica (<ph id="ph1">`callSiteDesc`</ph>).</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> prefix (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.</source>
          <target state="translated">Il <ph id="ph1">`calli`</ph> istruzione può essere immediatamente preceduto da un <ph id="ph2">`tail`</ph> prefisso (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) per specificare che lo stato del metodo corrente deve essere rilasciata prima di trasferire il controllo.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine, lo stack frame non essere rilasciato. al contrario, l'esecuzione continua automaticamente come se il <ph id="ph1">`tail`</ph> non è stato specificato.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</source>
          <target state="translated">Si presuppone che il puntatore di ingresso del metodo specifico puntatore a codice nativo (il computer di destinazione) che può essere chiamato in modo legittimo con gli argomenti descritti dalla convenzione di chiamata (un token di metadati per una firma autonoma).</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Such a pointer can be created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.</source>
          <target state="translated">Tale puntatore può essere creata usando il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> istruzioni, oppure passato dal codice nativo.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The calling convention is not checked dynamically, so code that uses a <ph id="ph1">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.</source>
          <target state="translated">La convenzione di chiamata non è selezionata in modo dinamico, pertanto il codice che utilizza un <ph id="ph1">`calli`</ph> istruzione non funziona correttamente se la destinazione non utilizza effettivamente la convenzione di chiamata specificati.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</source>
          <target state="translated">La sequenza di codice di compilazione di un argomento per un'istanza o un metodo virtuale deve inserire il riferimento all'istanza (che non deve essere un riferimento null) prima di qualsiasi argomento visibile all'utente.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id="ph2">`calli`</ph> instruction on the stack.</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> metodi possono essere utilizzati per eseguire un <ph id="ph2">`calli`</ph> istruzione nello stack.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Note that <ph id="ph1">`calli`</ph> should be called through the below methods rather than using the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.</source>
          <target state="translated">Si noti che <ph id="ph1">`calli`</ph> deve essere chiamato tramite i metodi che seguono anziché utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> classe per collocare l'istruzione direttamente sullo stack.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</source>
          <target state="translated">ILGenerator. EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) per chiamate che utilizzano una convenzione di chiamata gestita.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</source>
          <target state="translated">ILGenerator. EmitCalli (Opcode, CallingConvention, Type, Type[]) per chiamate che utilizzano una convenzione di chiamata non gestita.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</source>
          <target state="translated">Chiama un metodo ad associazione tardiva su un oggetto, inserendo il valore restituito nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>callvirt <ph id="ph1">`method`</ph></source>
          <target state="translated">callvirt <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a specific method associated with <ph id="ph1">`obj`</ph>.</source>
          <target state="translated">Chiama un metodo specifico associato <ph id="ph1">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`obj`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> vengono inseriti nello stack.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the object reference <ph id="ph3">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id="ph4">`obj`</ph> referred to by the method metadata token.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> e il riferimento all'oggetto <ph id="ph3">`obj`</ph> vengono estratti dallo stack; viene eseguita la chiamata al metodo con questi argomenti e il controllo viene trasferito al metodo nel <ph id="ph4">`obj`</ph> a cui fa riferimento il metodo token di metadati.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Il valore restituito viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction calls a late-bound method on an object.</source>
          <target state="translated">Il <ph id="ph1">`callvirt`</ph> istruzione chiama un metodo ad associazione tardiva su un oggetto.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the method is chosen based on the runtime type of <ph id="ph1">`obj`</ph> rather than the compile-time class visible in the method pointer.</source>
          <target state="translated">Ovvero, il metodo viene scelto in base al tipo di runtime di <ph id="ph1">`obj`</ph> anziché la classe in fase di compilazione visibile nel puntatore al metodo.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> can be used to call both virtual and instance methods.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> Consente di chiamare entrambe virtuale metodi di istanza.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.</source>
          <target state="translated">Il <ph id="ph1">`callvirt`</ph> istruzione può essere immediatamente preceduto da un <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) per specificare che lo stack frame corrente deve essere rilasciato prima di trasferire il controllo.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</source>
          <target state="translated">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo originale, lo stack frame non essere rilasciato.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The method metadata token provides the name, class and signature of the method to call.</source>
          <target state="translated">Il token di metadati del metodo fornisce il nome, una classe e firma del metodo da chiamare.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The class associated with <ph id="ph1">`obj`</ph> is the class of which it is an instance.</source>
          <target state="translated">La classe associata <ph id="ph1">`obj`</ph> è la classe di cui è un'istanza.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the class defines a non-static method that matches the indicated method name and signature, this method is called.</source>
          <target state="translated">Se la classe definisce un metodo non statico che corrisponde al nome del metodo indicato e firma, questo metodo viene chiamato.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Otherwise all classes in the base class chain of this class are checked in order.</source>
          <target state="translated">In caso contrario, tutte le classi nella catena di classe di base di questa classe vengono controllate nell'ordine.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>It is an error if no method is found.</source>
          <target state="translated">È un errore se non è stato trovato alcun metodo.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> estrae l'oggetto e gli argomenti associati dallo stack di valutazione prima di chiamare il metodo.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the method has a return value, it is pushed on the stack upon method completion.</source>
          <target state="translated">Se il metodo ha un valore restituito, viene inserito nello stack al completamento del metodo.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>On the callee side, the <ph id="ph1">`obj`</ph> parameter is accessed as argument 0, <ph id="ph2">`arg1`</ph> as argument 1, and so on.</source>
          <target state="translated">Sul lato del chiamato, il <ph id="ph1">`obj`</ph> parametro avviene come argomento 0, <ph id="ph2">`arg1`</ph> come argomento 1 e così via.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The instance reference <ph id="ph1">`obj`</ph> (always required for <ph id="ph2">`callvirt`</ph>) must be pushed before any of the user-visible arguments.</source>
          <target state="translated">Il riferimento all'istanza <ph id="ph1">`obj`</ph> (sempre necessario per <ph id="ph2">`callvirt`</ph>) deve essere inserito prima di qualsiasi argomento visibile all'utente.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</source>
          <target state="translated">La firma (contenuta nel token di metadati) non debba contenere una voce nell'elenco di parametri per questa puntatore.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Note that a virtual method can also be called using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Si noti che un metodo virtuale può essere chiamato anche utilizzando la <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id="ph2">`obj`</ph> or any of its base classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> viene generata un'eccezione se non è stato possibile trovare un metodo non statico con il nome specificato e la firma nella classe associata a <ph id="ph2">`obj`</ph> o le relative classi base.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se obj è null.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The security check may occur when the CIL is converted to native code rather than at run time.</source>
          <target state="translated">Il controllo di sicurezza può verificarsi quando il codice CIL viene convertito in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile utilizzare il <ph id="ph1">`constrained`</ph> Anteponi il <ph id="ph2">`callvirt`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Questo elimina la necessità di generare un IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitare un potenziale problema di controllo delle versioni.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">È consigliabile utilizzare il <ph id="ph1">`constrained`</ph> prefisso quando si chiamano metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Questi problemi sono descritti più dettagliatamente il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`callvirt`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`callvirt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall (OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Attempts to cast an object passed by reference to the specified class.</source>
          <target state="translated">Tenta di eseguire il cast di un oggetto passato per riferimento alla classe specificata.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>castclass <ph id="ph1">`class`</ph></source>
          <target state="translated">castclass <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Casts an object to a new object of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Esegue il cast di un oggetto in un nuovo oggetto di tipo <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The object reference is popped from the stack; the referenced object is cast as the specified <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack; l'oggetto di riferimento viene eseguito il cast dell'oggetto specificato <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If successful, a new object reference is pushed onto the stack.</source>
          <target state="translated">In caso contrario, nuovo riferimento a un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The <ph id="ph1">`castclass`</ph> instruction attempts to cast the object reference (type <ph id="ph2">`O`</ph>) atop the stack to a specified class.</source>
          <target state="translated">Il <ph id="ph1">`castclass`</ph> istruzione tenta di eseguire il cast il riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>) nella parte superiore dello stack di in una classe specificata.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The new class is specified by a metadata token indicating the desired class.</source>
          <target state="translated">La nuova classe viene specificata un token di metadati che indica la classe desiderata.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se la classe dell'oggetto all'inizio dello stack non implementa la nuova classe (presupponendo che la nuova classe è un'interfaccia) e non è una classe derivata della nuova classe di un oggetto <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the object reference is a null reference, <ph id="ph1">`castclass`</ph> succeeds and returns the new object as a null reference.</source>
          <target state="translated">Se il riferimento all'oggetto è un riferimento null, <ph id="ph1">`castclass`</ph> ha esito positivo e restituisce il nuovo oggetto come un riferimento null.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> viene generata se obj non è possibile eseguire il cast alla classe.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se non è possibile trovare la classe.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando un'istruzione di Microsoft Intermediate Language (MSIL) viene convertita in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`castclass`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`castclass`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Compares two values.</source>
          <target state="translated">Confronta due valori.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If they are equal, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se tali valori sono uguali, nello stack di valutazione viene inserito il valore intero 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>); in caso contrario, viene inserito 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>FE 01</source>
          <target state="translated">FE 01</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ceq</source>
          <target state="translated">ceq</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> equals <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Inserisce 1 se <ph id="ph1">`value1`</ph> è uguale a <ph id="ph2">`value2`</ph>; in caso contrario inserisce 0.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is compared to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene confrontato con <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è uguale a <ph id="ph2">`value2`</ph>, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The <ph id="ph1">`ceq`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ceq`</ph> istruzione confronta <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, then 1 (of type <ph id="ph3">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è uguale a <ph id="ph2">`value2`</ph>, quindi 1 (di tipo <ph id="ph3">`int32`</ph>) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Otherwise 0 (of type <ph id="ph1">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">In caso contrario, 0 (di tipo <ph id="ph1">`int32`</ph>) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>For floating-point number, <ph id="ph1">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).</source>
          <target state="translated">Per un numero a virgola mobile, <ph id="ph1">`ceq`</ph> restituirà 0 se i numeri non sono ordinati (uno o entrambi sono NaN).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The infinite values are equal to themselves.</source>
          <target state="translated">I valori infiniti sono uguali a se stessi.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ceq`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ceq`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Compares two values.</source>
          <target state="translated">Confronta due valori.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>); in caso contrario, viene inserito 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>FE 02</source>
          <target state="translated">FE 02</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>cgt</source>
          <target state="translated">cgt</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Inserisce 1 se <ph id="ph1">`value1`</ph> è maggiore di <ph id="ph2">`value2`</ph>; in caso contrario inserisce 0.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`cgt`</ph> verifica se <ph id="ph4">`value1`</ph> è maggiore di <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è maggiore di <ph id="ph2">`value2`</ph>, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The <ph id="ph1">`cgt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`cgt`</ph> istruzione confronta <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è rigorosamente maggiore <ph id="ph2">`value2`</ph>, quindi un <ph id="ph3">`int32`</ph> valore 1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">In caso contrario, un <ph id="ph1">`int32`</ph> il valore 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>For floating-point numbers, <ph id="ph1">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Per i numeri a virgola mobile, <ph id="ph1">`cgt`</ph> restituisce 0 se i numeri sono ordinati (ovvero, se uno o entrambi gli argomenti sono NaN).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`cgt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Compares two unsigned or unordered values.</source>
          <target state="translated">Confronta due valori senza segno o non ordinati.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>); in caso contrario, viene inserito 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>FE 03</source>
          <target state="translated">FE 03</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>cgt.un</source>
          <target state="translated">cgt.un</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Inserisce 1 se <ph id="ph1">`value1`</ph> è maggiore di <ph id="ph2">`value2`</ph>; in caso contrario inserisce 0 (valori senza segno).</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt.un`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`cgt.un`</ph> verifica se <ph id="ph4">`value1`</ph> è maggiore di <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è maggiore di <ph id="ph2">`value2`</ph>, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id="ph2">`true`</ph> :</source>
          <target state="translated">Un <ph id="ph1">`int32`</ph> valore 1 viene inserito nello stack, se una delle seguenti è <ph id="ph2">`true`</ph> :</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Per i numeri a virgola mobile, <ph id="ph1">`value1`</ph> non è ordinato rispetto a <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Per i valori integer <ph id="ph1">`value1`</ph> è rigorosamente maggiore <ph id="ph2">`value2`</ph> se considerati come numeri senza segno.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Otherwise an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">In caso contrario un <ph id="ph1">`int32`</ph> il valore 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`cgt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Throws <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> if value is not a finite number.</source>
          <target state="translated">Genera un'eccezione <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> se il valore non è un numero finito.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>C3</source>
          <target state="translated">C3</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ckfinite</source>
          <target state="translated">ckfinite</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.</source>
          <target state="translated">generare <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> se il valore non è un numero finito.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack..</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack...</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the <ph id="ph2">`ckfinite`</ph> instruction is performed on it.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e <ph id="ph2">`ckfinite`</ph> istruzione viene eseguita su di esso.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene nuovamente inserito nello stack se viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The <ph id="ph1">`ckfinite instruction`</ph> throws <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id="ph3">`value`</ph> (a floating-point number) is either a "not a number" value (NaN) or a <ph id="ph4">`+-`</ph> infinity value.</source>
          <target state="translated">Il <ph id="ph1">`ckfinite instruction`</ph> genera <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> se <ph id="ph3">`value`</ph> (un numero a virgola mobile) è un valore "non è un numero" (NaN) o un <ph id="ph4">`+-`</ph> valore infinito.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`Ckfinite`</ph> lascia il valore nello stack, se viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Execution is unspecified if <ph id="ph1">`value`</ph> is not a floating-point number.</source>
          <target state="translated">Esecuzione non è specificata se <ph id="ph1">`value`</ph> non è un numero a virgola mobile.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id="ph2">`value`</ph> is not a 'normal' number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> viene generata se <ph id="ph2">`value`</ph> non è un numero di 'normal'.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Note that a special exception or a derived class of <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.</source>
          <target state="translated">Si noti che una particolare eccezione o una classe derivata di <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> potrebbe essere più appropriato, passando il valore non corretto per il gestore di eccezioni.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ckfinite`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ckfinite`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Compares two values.</source>
          <target state="translated">Confronta due valori.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If the first value is less than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se il primo valore è inferiore al secondo, nello stack di valutazione viene inserito il valore intero 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>); in caso contrario, viene inserito 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>FE 04</source>
          <target state="translated">FE 04</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>clt</source>
          <target state="translated">clt</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Inserisce 1 se <ph id="ph1">`value1`</ph> è minore di <ph id="ph2">`value2`</ph>; in caso contrario inserisce 0.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The stack transitional behavior, in sequential order, is: <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è: <ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`clt`</ph> verifica se <ph id="ph4">`value1`</ph> è minore di <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è minore di <ph id="ph2">`value2`</ph>, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The <ph id="ph1">`clt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`clt`</ph> istruzione confronta <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è rigorosamente minore di <ph id="ph2">`value2`</ph>, quindi un <ph id="ph3">`int32`</ph> valore 1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">In caso contrario, un <ph id="ph1">`int32`</ph> il valore 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>For floating-point numbers, <ph id="ph1">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Per i numeri a virgola mobile, <ph id="ph1">`clt`</ph> restituisce 0 se i numeri sono ordinati (ovvero, se uno o entrambi gli argomenti sono NaN).</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`clt`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Compares the unsigned or unordered values <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> and <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</source>
          <target state="translated">Confronta i due valori senza segno o non ordinati <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> e <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, then the integer value 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> è minore di <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, nello stack di valutazione viene inserito il valore intero 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>); in caso contrario, viene inserito 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>FE 05</source>
          <target state="translated">FE 05</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>clt.un</source>
          <target state="translated">clt.un</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Inserisce 1 se <ph id="ph1">`value1`</ph> è minore di <ph id="ph2">`value2`</ph>; in caso contrario inserisce 0 (valori senza segno).</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt.un`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`clt.un`</ph> verifica se <ph id="ph4">`value1`</ph> è minore di <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Se <ph id="ph1">`value1`</ph> è minore di <ph id="ph2">`value2`</ph>, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The <ph id="ph1">`clt.un`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`clt.un`</ph> istruzione confronta <ph id="ph2">`value1`</ph> e <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:</source>
          <target state="translated">Un <ph id="ph1">`int32`</ph> valore 1 viene inserito nello stack in presenza di una delle operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> (as for <ph id="ph3">`clt`</ph>).</source>
          <target state="translated"><ph id="ph1">`value1`</ph> è minore <ph id="ph2">`value2`</ph> (come per <ph id="ph3">`clt`</ph>).</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Per i numeri a virgola mobile, <ph id="ph1">`value1`</ph> non è ordinato rispetto a <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Per i valori integer <ph id="ph1">`value1`</ph> è rigorosamente minore di <ph id="ph2">`value2`</ph> se considerati come numeri senza segno.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">In caso contrario, un <ph id="ph1">`int32`</ph> il valore 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`clt.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Constrains the type on which a virtual method call is made.</source>
          <target state="translated">Vincola il tipo su cui viene eseguita una chiamata al metodo virtuale.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 16 &amp;LT; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>constrained.</source>
          <target state="translated">vincolato.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Call a virtual method on a type constrained to be type <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Chiamata di un metodo virtuale su un tipo è vincolato per essere tipo <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is permitted only on a <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">Il <ph id="ph1">`constrained`</ph> è consentito solo in un <ph id="ph2">`callvirt`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The state of the MSIL stack at this point must be as follows:</source>
          <target state="translated">Lo stato dello stack a questo punto di codice MSIL deve essere come segue:</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A managed pointer, <ph id="ph1">`ptr`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un puntatore gestito, <ph id="ph1">`ptr`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The type of <ph id="ph1">`ptr`</ph> must be a managed pointer (<ph id="ph2">`&amp;`</ph>) to <ph id="ph3">`thisType`</ph>.</source>
          <target state="translated">Il tipo di <ph id="ph1">`ptr`</ph> deve essere un puntatore gestito (<ph id="ph2">`&amp;`</ph>) a <ph id="ph3">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Note that this is different from the case of an unprefixed <ph id="ph1">`callvirt`</ph> instruction, which expects a reference of <ph id="ph2">`thisType`</ph>.</source>
          <target state="translated">Si noti che questo è diverso da quello di un senza prefisso <ph id="ph1">`callvirt`</ph> (istruzione), che prevede un riferimento a <ph id="ph2">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Gli argomenti del metodo <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argN`</ph> vengono inseriti nello stack, proprio come con un senza prefisso <ph id="ph3">`callvirt`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is designed to allow <ph id="ph2">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id="ph3">`thisType`</ph> is a value type or a reference type.</source>
          <target state="translated">Il <ph id="ph1">`constrained`</ph> prefisso è progettato per consentire <ph id="ph2">`callvirt`</ph> istruzioni da eseguire in un uniform modo indipendentemente dal fatto che <ph id="ph3">`thisType`</ph> è un tipo di valore o un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>When a <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instruction has been prefixed by <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, the instruction is executed as follows:</source>
          <target state="translated">Quando un <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> istruzione è preceduto da <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, l'istruzione viene eseguita nel modo seguente:</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id="ph2">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id="ph3">`callvirt`</ph> of <ph id="ph4">`method`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> è un tipo di riferimento (anziché un tipo di valore), quindi <ph id="ph2">`ptr`</ph> viene dereferenziato e passato come il puntatore 'this' per il <ph id="ph3">`callvirt`</ph> di <ph id="ph4">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> implements <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruction, for the implementation of <ph id="ph7">`method`</ph> by <ph id="ph8">`thisType`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> è un tipo di valore e <ph id="ph2">`thisType`</ph> implementa <ph id="ph3">`method`</ph> quindi <ph id="ph4">`ptr`</ph> viene passato senza modifiche come il puntatore 'this' per un <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> (istruzione), per l'implementazione di <ph id="ph7">`method`</ph> da <ph id="ph8">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> does not implement <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instruction.</source>
          <target state="translated">Se <ph id="ph1">`thisType`</ph> è un tipo di valore e <ph id="ph2">`thisType`</ph> non implementa <ph id="ph3">`method`</ph> quindi <ph id="ph4">`ptr`</ph> è dereferenziato, sottoposto a boxing e passato come il puntatore 'this' per il <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>This last case can occur only when <ph id="ph1">`method`</ph> was defined on <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id="ph5">`thisType`</ph>.</source>
          <target state="translated">Quest'ultimo caso può verificarsi solo quando <ph id="ph1">`method`</ph> è stato definito in <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, o <ph id="ph4">&lt;xref:System.Enum&gt;</ph> e non esegue l'override <ph id="ph5">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>In this case, the boxing causes a copy of the original object to be made.</source>
          <target state="translated">In questo caso, la conversione boxing, una copia dell'oggetto originale da eseguire.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, because none of the methods of <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.</source>
          <target state="translated">Tuttavia, poiché nessuno dei metodi di <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modificare lo stato dell'oggetto, questo evento non può essere rilevato.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix supports IL generators that create generic code.</source>
          <target state="translated">Il <ph id="ph1">`constrained`</ph> prefisso supporta generatori IL per creare codice generico.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Normally the <ph id="ph1">`callvirt`</ph> instruction is not valid on value types.</source>
          <target state="translated">In genere il <ph id="ph1">`callvirt`</ph> istruzione non è valido nei tipi di valore.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id="ph1">`ptr`</ph> and the method being called.</source>
          <target state="translated">In alternativa è necessario che i compilatori di linguaggio intermedio svolgere in modo efficace la trasformazione 'this' descritta in precedenza in fase di compilazione, a seconda del tipo di <ph id="ph1">`ptr`</ph> e il metodo chiamato.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, when <ph id="ph1">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</source>
          <target state="translated">Tuttavia, quando <ph id="ph1">`ptr`</ph> è un tipo generico è noto in fase di compilazione non è possibile eseguire questa trasformazione in fase di compilazione.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id="ph2">`ptr`</ph> is a value type or a reference type.</source>
          <target state="translated">Il <ph id="ph1">`constrained`</ph> opcode consente ai compilatori di linguaggio intermedio di effettuare una chiamata a una funzione virtuale in un uniform modo indipendentemente dal fatto che <ph id="ph2">`ptr`</ph> è un tipo di valore o un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Although it is intended for the case where <ph id="ph1">`thisType`</ph> is a generic type variable, the <ph id="ph2">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</source>
          <target state="translated">Sebbene sia progettato per il caso in cui <ph id="ph1">`thisType`</ph> è una variabile di tipo generico, la <ph id="ph2">`constrained`</ph> prefisso anche funziona per i tipi non generici e può ridurre la complessità della generazione delle chiamate virtuali nei linguaggi che la differenza tra i tipi di valore e tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix also avoids potential versioning problems with value types.</source>
          <target state="translated">Utilizzo di <ph id="ph1">`constrained`</ph> prefisso consente anche di evitare i potenziali problemi di controllo delle versioni con tipi di valore.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</source>
          <target state="translated">Se il <ph id="ph1">`constrained`</ph> prefisso non viene utilizzato IL diverso deve essere inviato a seconda se un tipo di valore esegue l'override di un metodo System. Object.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>For example, if a value type <ph id="ph1">`V`</ph> overrides the Object.ToString() method, a <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id="ph4">`box`</ph> instruction and a <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instruction are emitted.</source>
          <target state="translated">Ad esempio, se un tipo di valore <ph id="ph1">`V`</ph> esegue l'override del metodo ToString, un <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> viene generata un'istruzione; in caso contrario, un <ph id="ph4">`box`</ph> (istruzione) e un <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> istruzione vengono generati.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</source>
          <target state="translated">Può sorgere un problema di controllo delle versioni nel primo caso, se la sostituzione verrà rimossa in seguito in quest'ultimo caso se successivamente viene aggiunto un override.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`constrained`</ph> prefisso può anche essere utilizzato per la chiamata di metodi di interfaccia sui tipi di valore, perché il metodo che implementa il metodo di interfaccia del tipo di valore può essere modificato utilizzando un <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</source>
          <target state="translated">Se il <ph id="ph1">`constrained`</ph> prefisso non viene utilizzato, il compilatore viene imposto di scegliere quale il valore metodi del tipo da associare in fase di compilazione.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</source>
          <target state="translated">Utilizzo di <ph id="ph1">`constrained`</ph> prefisso consente il codice MSIL associare il metodo che implementa il metodo di interfaccia in fase di esecuzione, anziché in fase di compilazione.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`constrained`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`constrained`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>D3</source>
          <target state="translated">D3</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>conv.i</source>
          <target state="translated">conv.i</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Convert to <ph id="ph1">`native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`native int`</ph>, inserendo <ph id="ph2">`native int`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The <ph id="ph1">`conv.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.i`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, quindi lo estende, aggiungendo spazi, a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>67</source>
          <target state="translated">67</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>conv.i1</source>
          <target state="translated">conv.i1</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int8`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The <ph id="ph1">`conv.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.i1`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, quindi lo estende, aggiungendo spazi, a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>68</source>
          <target state="translated">68</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>conv.i2</source>
          <target state="translated">conv.i2</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int16`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The <ph id="ph1">`conv.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.i2`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>69</source>
          <target state="translated">69</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>conv.i4</source>
          <target state="translated">conv.i4</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Convert to <ph id="ph1">`int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int32`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The <ph id="ph1">`conv.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.i4`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>6A</source>
          <target state="translated">6A</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>conv.i8</source>
          <target state="translated">conv.i8</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int64`</ph>, inserendo <ph id="ph2">`int64`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The <ph id="ph1">`conv.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.i8`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="native int" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>D4</source>
          <target state="translated">D4</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>conv.ovf.i</source>
          <target state="translated">conv.ovf.i</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Convert to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`native int`</ph> (sullo stack come <ph id="ph2">`native int`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The <ph id="ph1">`conv.ovf.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="native int" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>8A</source>
          <target state="translated">8A</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>conv.ovf.i.un</source>
          <target state="translated">conv.ovf.i.un</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts an unsigned value to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`native int`</ph> (sullo stack come <ph id="ph2">`native int`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The <ph id="ph1">`conv.ovf.i.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int8" /&gt;</ph> con segno e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>B3</source>
          <target state="translated">B3</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>conv.ovf.i1</source>
          <target state="translated">conv.ovf.i1</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Convert to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`int8`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The <ph id="ph1">`conv.ovf.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i1`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int8" /&gt;</ph> con segno e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>82</source>
          <target state="translated">82</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>conv.ovf.i1.un</source>
          <target state="translated">conv.ovf.i1.un</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`int8`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i1.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extending it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int16" /&gt;</ph> con segno e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>B5</source>
          <target state="translated">B5</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>conv.ovf.i2</source>
          <target state="translated">conv.ovf.i2</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Convert to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`int16`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The <ph id="ph1">`conv.ovf.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i2`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int16" /&gt;</ph> con segno e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>83</source>
          <target state="translated">83</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>conv.ovf.i2.un</source>
          <target state="translated">conv.ovf.i2.un</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`int16`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i2.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int32" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>B7</source>
          <target state="translated">B7</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>conv.ovf.i4</source>
          <target state="translated">conv.ovf.i4</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Convert to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`int32`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The <ph id="ph1">`conv.ovf.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i4`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int32" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>84</source>
          <target state="translated">84</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>conv.ovf.i4.un</source>
          <target state="translated">conv.ovf.i4.un</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`int32`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i4.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int64" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>B9</source>
          <target state="translated">B9</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>conv.ovf.i8</source>
          <target state="translated">conv.ovf.i8</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Convert to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`int64`</ph> (sullo stack come <ph id="ph2">`int64`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The <ph id="ph1">`conv.ovf.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i8`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="int64" /&gt;</ph> con segno, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>85</source>
          <target state="translated">85</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>conv.ovf.i8.un</source>
          <target state="translated">conv.ovf.i8.un</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`int64`</ph> (sullo stack come <ph id="ph2">`int64`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.i8.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>D5</source>
          <target state="translated">D5</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>conv.ovf.u</source>
          <target state="translated">conv.ovf.u</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Convert to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`unsigned native int`</ph> (sullo stack come <ph id="ph2">`native int`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The <ph id="ph1">`conv.ovf.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>8B</source>
          <target state="translated">8B</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>conv.ovf.u.un</source>
          <target state="translated">conv.ovf.u.un</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts un unsigned value to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`unsigned native int`</ph> (sullo stack come <ph id="ph2">`native int`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The <ph id="ph1">`conv.ovf.u.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>B4</source>
          <target state="translated">B4</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>conv.ovf.u1</source>
          <target state="translated">conv.ovf.u1</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Convert to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`unsigned int8`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The <ph id="ph1">`conv.ovf.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u1`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>86</source>
          <target state="translated">86</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>conv.ovf.u1.un</source>
          <target state="translated">conv.ovf.u1.un</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`unsigned int8`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u1.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>B6</source>
          <target state="translated">B6</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>conv.ovf.u2</source>
          <target state="translated">conv.ovf.u2</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Convert to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`unsigned int16`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The <ph id="ph1">`conv.ovf.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u2`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, generando un'eccezione <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>87</source>
          <target state="translated">87</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>conv.ovf.u2.un</source>
          <target state="translated">conv.ovf.u2.un</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`unsigned int16`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u2.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>B8</source>
          <target state="translated">B8</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>conv.ovf.u4</source>
          <target state="translated">conv.ovf.u4</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Convert to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`unsigned int32`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The <ph id="ph1">`conv.ovf.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u4`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>88</source>
          <target state="translated">88</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>conv.ovf.u4.un</source>
          <target state="translated">conv.ovf.u4.un</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`unsigned int32`</ph> (sullo stack come <ph id="ph2">`int32`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u4.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore con segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>BA</source>
          <target state="translated">BA</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>conv.ovf.u8</source>
          <target state="translated">conv.ovf.u8</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Convert to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Convertire un <ph id="ph1">`unsigned int64`</ph> (sullo stack come <ph id="ph2">`int64`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The <ph id="ph1">`conv.ovf.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u8`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Converte il valore senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, generando un'eccezione <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>89</source>
          <target state="translated">89</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>conv.ovf.u8.un</source>
          <target state="translated">conv.ovf.u8.un</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Converte un valore senza segno in un <ph id="ph1">`unsigned int64`</ph> (sullo stack come <ph id="ph2">`int64`</ph>) e genera un'eccezione in caso di overflow.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Se si verifica un overflow, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.ovf.u8.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.ovf.i`</ph> o <ph id="ph3">`conv.ovf.u`</ph> vengono utilizzati, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Converts the unsigned integer value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore intero senza segno all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>76</source>
          <target state="translated">76</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>conv.r.un</source>
          <target state="translated">conv.r.un</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Convert unsigned integer to floating-point, pushing <ph id="ph1">`F`</ph> on stack.</source>
          <target state="translated">Converti intero senza segno a virgola mobile, inserendo <ph id="ph1">`F`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.r.un`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting a floating-point type to an integer the <ph id="ph1">`result`</ph> returned is unspecified.</source>
          <target state="translated">Se si verifica un overflow nella conversione di un tipo a virgola mobile a un numero intero di <ph id="ph1">`result`</ph> restituito non è specificato.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id="ph2">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id="ph3">`float64`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`conv.r.un`</ph> operazione accetta un valore integer dallo stack, interpreta come senza segno e lo sostituisce con un numero a virgola mobile per rappresentare il numero intero: entrambi un <ph id="ph2">`float32`</ph>, se ciò è sufficiente per rappresentare il valore integer senza perdita di precisione, altrimenti un <ph id="ph3">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.r.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>6B</source>
          <target state="translated">6B</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>conv.r4</source>
          <target state="translated">conv.r4</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Convert to <ph id="ph1">`float32`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`float32`</ph>, inserendo <ph id="ph2">`F`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The <ph id="ph1">`conv.r4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.r4`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>6C</source>
          <target state="translated">6C</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>conv.r8</source>
          <target state="translated">conv.r8</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Convert to <ph id="ph1">`float64`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`float64`</ph>, inserendo <ph id="ph2">`F`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The <ph id="ph1">`conv.r8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.r8`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>E0</source>
          <target state="translated">E0</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>conv.u</source>
          <target state="translated">conv.u</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Convert to <ph id="ph1">`unsigned native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`unsigned native int`</ph>, inserendo <ph id="ph2">`native int`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The <ph id="ph1">`conv.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.u`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.u`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>D2</source>
          <target state="translated">D2</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>conv.u1</source>
          <target state="translated">conv.u1</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int8`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The <ph id="ph1">`conv.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.u1`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>D1</source>
          <target state="translated">D1</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>conv.u2</source>
          <target state="translated">conv.u2</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int16`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The <ph id="ph1">`conv.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.u2`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>6D</source>
          <target state="translated">6D</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>conv.u4</source>
          <target state="translated">conv.u4</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Convert to <ph id="ph1">`unsigned int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`unsigned int32`</ph>, inserendo <ph id="ph2">`int32`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The <ph id="ph1">`conv.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.u4`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Converte il valore all'inizio dello stack di valutazione in <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> e lo estende a <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>6E</source>
          <target state="translated">6E</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>conv.u8</source>
          <target state="translated">conv.u8</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Convertire <ph id="ph1">`int64`</ph>, inserendo <ph id="ph2">`int64`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e la conversione viene tentata l'operazione.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The <ph id="ph1">`conv.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`conv.u8`</ph> codice converte il <ph id="ph2">`value`</ph> all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Valori integer minore di 4 byte vengono estesi a <ph id="ph1">`int32`</ph> quando vengono caricati nello stack di valutazione (a meno che non <ph id="ph2">`conv.i`</ph> o <ph id="ph3">`conv.u`</ph> viene utilizzato, nel qual caso il risultato è <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti nel <ph id="ph1">`F`</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">Durante la conversione da un <ph id="ph1">`float64`</ph> per un <ph id="ph2">`float32`</ph>, precisione può essere persa.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è troppo grande per essere contenuta in un <ph id="ph2">`float32 (F)`</ph>, infinito positivo (se <ph id="ph3">`value`</ph> è un valore positivo) o infinito negativo (se <ph id="ph4">`value`</ph> è negativo) viene restituito.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Se il risultato è minore di un <ph id="ph1">`int32`</ph>, il valore è con segno esteso per riempire lo slot.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Non vengono mai generate eccezioni quando si utilizza questo campo.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`conv.u8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copies a specified number bytes from a source address to a destination address.</source>
          <target state="translated">Copia un numero specificato di byte da un indirizzo di origine a un indirizzo di destinazione.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>FE 17</source>
          <target state="translated">FE 17</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>cpblk</source>
          <target state="translated">cpblk</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copy data from one memory block to another.</source>
          <target state="translated">Copiare i dati da un blocco di memoria a un altro.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The destination address is pushed onto the stack.</source>
          <target state="translated">L'indirizzo di destinazione viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The source address is pushed onto the stack.</source>
          <target state="translated">L'indirizzo di origine viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes to copy is pushed onto the stack.</source>
          <target state="translated">Il numero di byte da copiare è inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</source>
          <target state="translated">Il numero di byte, l'indirizzo di origine e l'indirizzo di destinazione viene estratti dallo stack; il numero specificato di byte viene copiato dall'indirizzo di origine per l'indirizzo di destinazione.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction copies a number (type <ph id="ph2">`unsigned int32`</ph>) of bytes from a source address (of type <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, or <ph id="ph5">`&amp;`</ph>) to a destination address (of type <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, or <ph id="ph8">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`cpblk`</ph> istruzione copia un numero (tipo <ph id="ph2">`unsigned int32`</ph>) di byte da un indirizzo di origine (di tipo <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, o <ph id="ph5">`&amp;`</ph>) a un indirizzo di destinazione (di tipo <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, o <ph id="ph8">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The behavior of <ph id="ph1">`cpblk`</ph> is unspecified if the source and destination areas overlap.</source>
          <target state="translated">Il comportamento di <ph id="ph1">`cpblk`</ph> non è specificato se le aree di origine e di destinazione si sovrappongono.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> si presuppone che l'origine e destinazione risolto sono allineati alle dimensioni fisiche del computer.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction can be immediately preceded by the <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.</source>
          <target state="translated">Il <ph id="ph1">`cpblk`</ph> istruzione può essere immediatamente preceduto dal <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> per indicare che l'origine o destinazione non è allineata.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The operation of the <ph id="ph1">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`cpblk`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpblk`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`cpblk`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies the value type located at the address of an object (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> or <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) to the address of the destination object (type <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> or <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</source>
          <target state="translated">Copia il tipo di valore individuato in corrispondenza dell'indirizzo di un oggetto di tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> o <ph id="ph3">&lt;see langword="native int" /&gt;</ph> nell'indirizzo dell'oggetto di destinazione, di tipo <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> o <ph id="ph6">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>cpobj <ph id="ph1">`classTok`</ph></source>
          <target state="translated">cpobj <ph id="ph1">`classTok`</ph></target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies a value type from a source object to a destination object.</source>
          <target state="translated">Copia un valore di tipo da un oggetto di origine a un oggetto di destinazione.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The destination object reference is pushed onto the stack.</source>
          <target state="translated">Il riferimento all'oggetto di destinazione viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The source object reference is pushed onto the stack.</source>
          <target state="translated">Il riferimento all'oggetto di origine viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</source>
          <target state="translated">I riferimenti agli due oggetti vengono estratti dallo stack; il tipo di valore in corrispondenza dell'indirizzo dell'oggetto di origine viene copiato nell'indirizzo dell'oggetto di destinazione.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The behavior of <ph id="ph1">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id="ph2">`classTok`</ph> (a <ph id="ph3">`typeref`</ph> or <ph id="ph4">`typedef`</ph>), or if <ph id="ph5">`classTok`</ph> does not represent a value type.</source>
          <target state="translated">Il comportamento di <ph id="ph1">`cpobj`</ph> non è specificato se l'origine e la destinazione oggetto riferimenti non sono puntatori a istanze della classe rappresentata dal token di classe <ph id="ph2">`classTok`</ph> (un <ph id="ph3">`typeref`</ph> o <ph id="ph4">`typedef`</ph>), o se <ph id="ph5">`classTok`</ph> non rappresenta un tipo di valore.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpobj`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`cpobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values and pushes the result as a floating-point (type <ph id="ph1">&lt;see langword="F" /&gt;</ph>) or quotient (type <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Divide due valori e inserisce il risultato come valore in virgola mobile (di tipo <ph id="ph1">&lt;see langword="F" /&gt;</ph>) o quoziente (di tipo <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>5B</source>
          <target state="translated">5B</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>div</source>
          <target state="translated">div</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values to return a quotient or floating-point result.</source>
          <target state="translated">Divide due valori e restituisce un risultato a virgola mobile o il quoziente.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene diviso per <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 soddisfa le condizioni seguenti:</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</source>
          <target state="translated">&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</source>
          <target state="translated">Sign (<ph id="ph1">`result`</ph>) = +, se accedere (<ph id="ph2">`value1`</ph>) = segno (<ph id="ph3">`value2`</ph>), o-, se segno (<ph id="ph4">`value1`</ph>) ~ = segno (<ph id="ph5">`value2`</ph>)</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The <ph id="ph1">`div`</ph> instruction computes the result and pushes it on the stack.</source>
          <target state="translated">Il <ph id="ph1">`div`</ph> istruzione calcola il risultato e lo inserisce nello stack.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integer division truncates towards zero.</source>
          <target state="translated">Divisione di interi troncata a zero.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Division of a finite number by zero produces the correctly signed infinite value.</source>
          <target state="translated">Divisione di un numero finito per zero genera il valore di infinito firmato correttamente.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</source>
          <target state="translated">Divisione di zero per zero o infinito da infinito produce il valore NaN (Not-A-Number).</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Any number divided by infinity will produce a zero value.</source>
          <target state="translated">Qualsiasi numero diviso infinito produrrà un valore pari a zero.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.</source>
          <target state="translated">Le operazioni integrali generano <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>This can happen if <ph id="ph1">`value1`</ph> is the maximum negative value, and <ph id="ph2">`value2`</ph> is -1.</source>
          <target state="translated">Questa situazione può verificarsi se <ph id="ph1">`value1`</ph> è il massimo valore negativo, e <ph id="ph2">`value2`</ph> è -1.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Le operazioni integrali generano <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> è zero.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Note that on Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).</source>
          <target state="translated">Si noti che nelle piattaforme basate su Intel su un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata quando il (minint div -1).</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Floating-point operations never throw an exception (they produce NaNs or infinities instead).</source>
          <target state="translated">Operazioni a virgola mobile non generano mai un'eccezione (producono NaN o valori infiniti invece).</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`div`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two unsigned integer values and pushes the result (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Divide due valori interi senza segno e inserisce il risultato (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>5C</source>
          <target state="translated">5C</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>div.un</source>
          <target state="translated">div.un</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two values, unsigned, returning a quotient.</source>
          <target state="translated">Divide due valori senza segno, restituendo un quoziente.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene diviso per <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The <ph id="ph1">`div.un`</ph> instruction computes <ph id="ph2">`value1`</ph> divided by <ph id="ph3">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id="ph4">`result`</ph> on the stack.</source>
          <target state="translated">Il <ph id="ph1">`div.un`</ph> istruzione calcola <ph id="ph2">`value1`</ph> diviso <ph id="ph3">`value2`</ph>, entrambi come interi senza segno e inserisce il <ph id="ph4">`result`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`div.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</source>
          <target state="translated">Copia il valore corrente più in alto nello stack di valutazione e inserisce la copia nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>25</source>
          <target state="translated">25</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>dup</source>
          <target state="translated">dup</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Duplicates the value on the top of the stack.</source>
          <target state="translated">Duplica il valore all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is popped off of the stack for duplication.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene rimosso dallo stack per la duplicazione.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene nuovamente inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>A duplicate value is pushed onto the stack.</source>
          <target state="translated">Un valore duplicato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The <ph id="ph1">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.</source>
          <target state="translated">Il <ph id="ph1">`dup`</ph> istruzione Duplica l'elemento superiore dello stack e lascia primi due valori identici.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`dup`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`dup`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="filter" /&gt;</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Trasferisce il controllo dalla clausola <ph id="ph1">&lt;see langword="filter" /&gt;</ph> di un'eccezione nuovamente al gestore di eccezioni di Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>FE 11</source>
          <target state="translated">FE 11</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>endfilter</source>
          <target state="translated">endfilter</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>End filter clause of SEH exception handling.</source>
          <target state="translated">Clausola di filtro al fine di gestione delle eccezioni SEH.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is popped from the stack; <ph id="ph2">`endfilter`</ph> is executed and control is transferred to the exception handler.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack; <ph id="ph2">`endfilter`</ph> viene eseguita e il controllo viene trasferito al gestore di eccezioni.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`Value`</ph> (which must be of type <ph id="ph2">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.</source>
          <target state="translated"><ph id="ph1">`Value`</ph> (che deve essere di tipo <ph id="ph2">`int32`</ph> e fa parte di un set specifico di valori) viene restituito dalla clausola di filtro.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>It should be one of:</source>
          <target state="translated">Deve essere uno di:</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) to continue searching for an exception handler</source>
          <target state="translated"><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) per continuare la ricerca di un gestore di eccezioni</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</source>
          <target state="translated"><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) per avviare la seconda fase della gestione delle eccezioni in cui i blocchi vengono eseguiti fino a quando il gestore associato alla clausola di filtro si trova.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Upon discovery, the handler is executed.</source>
          <target state="translated">Una volta individuato, il gestore viene eseguito.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Other integer values will produce unspecified results.</source>
          <target state="translated">Altri valori integer produrrà risultati non specificati.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</source>
          <target state="translated">Il punto di ingresso di un filtro, come illustrato nella tabella delle eccezioni del metodo, deve essere la prima istruzione nel blocco di codice del filtro.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The <ph id="ph1">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id="ph2">`endfilter`</ph> for any single filter block).</source>
          <target state="translated">Il <ph id="ph1">`endfilter`</ph> istruzione deve essere l'ultima istruzione nel blocco di codice del filtro (pertanto può essere presente una sola <ph id="ph2">`endfilter`</ph> per ogni blocco di filtro).</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>After executing the <ph id="ph1">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.</source>
          <target state="translated">Dopo l'esecuzione di <ph id="ph1">`endfilter`</ph> (istruzione), il controllo passa di nuovo per il meccanismo di gestione delle eccezioni CLI.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred into a filter block except through the exception mechanism.</source>
          <target state="translated">Il controllo non può essere trasferito in un blocco di filtro solo tramite il meccanismo di eccezione.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred out of a filter block except through the use of a <ph id="ph1">`throw`</ph> instruction or by executing the final <ph id="ph2">`endfilter`</ph> instruction.</source>
          <target state="translated">Controllo non può essere trasferito all'esterno di un blocco di filtro solo tramite l'utilizzo di un <ph id="ph1">`throw`</ph> istruzione o l'esecuzione finale <ph id="ph2">`endfilter`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>You cannot embed a <ph id="ph1">`try`</ph> block within a <ph id="ph2">`filter`</ph> block.</source>
          <target state="translated">Non è possibile incorporare un <ph id="ph1">`try`</ph> blocco all'interno di un <ph id="ph2">`filter`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>If an exception is thrown inside the <ph id="ph1">`filter`</ph> block, it is intercepted and a value of 0 (<ph id="ph2">`exception_continue_search`</ph>) is returned.</source>
          <target state="translated">Se viene generata un'eccezione all'interno di <ph id="ph1">`filter`</ph> blocco, questo viene intercettato e un valore pari a 0 (<ph id="ph2">`exception_continue_search`</ph>) viene restituito.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfilter`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`endfilter`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="fault" /&gt;</ph> or <ph id="ph2">&lt;see langword="finally" /&gt;</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Trasferisce il controllo dalla clausola <ph id="ph1">&lt;see langword="fault" /&gt;</ph> o <ph id="ph2">&lt;see langword="finally" /&gt;</ph> di un blocco di eccezioni al gestore di eccezioni di Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>DC</source>
          <target state="translated">DC</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfinally</source>
          <target state="translated">endfinally</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfault</source>
          <target state="translated">endfault</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Ends the <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph> clause of an exception block.</source>
          <target state="translated">Termina il <ph id="ph1">`finally`</ph> o <ph id="ph2">`fault`</ph> clausola di un blocco di eccezioni.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Alcuni comportamenti sono caratteristici nessuno stack transizione per questa istruzione.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source><ph id="ph1">`Endfinally`</ph> and <ph id="ph2">`endfault`</ph> signal the end of the <ph id="ph3">`finally`</ph> or <ph id="ph4">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.</source>
          <target state="translated"><ph id="ph1">`Endfinally`</ph> e <ph id="ph2">`endfault`</ph> segnalare la fine del <ph id="ph3">`finally`</ph> o <ph id="ph4">`fault`</ph> clausola in modo che la rimozione dello stack può continuare finché non viene richiamato il gestore di eccezioni.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The <ph id="ph1">`endfinally`</ph> or <ph id="ph2">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.</source>
          <target state="translated">Il <ph id="ph1">`endfinally`</ph> o <ph id="ph2">`endfault`</ph> istruzione trasferisce il controllo al meccanismo delle eccezioni CLI.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The mechanism then searches for the next <ph id="ph1">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.</source>
          <target state="translated">Il meccanismo quindi Cerca successivo <ph id="ph1">`finally`</ph> clausola nella catena se il blocco protetto è stato terminato con un'istruzione leave.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>If the protected block was exited with an exception, the CLI will search for the next <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.</source>
          <target state="translated">Se il blocco protetto è stato terminato con un'eccezione, l'interfaccia CLI eseguirà la ricerca per i prossimi <ph id="ph1">`finally`</ph> o <ph id="ph2">`fault`</ph>, oppure immettere il gestore di eccezioni scelto durante la prima sessione di gestione delle eccezioni.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>An <ph id="ph1">`endfinally`</ph> instruction might only appear lexically within a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Un <ph id="ph1">`endfinally`</ph> istruzione può essere presente solo livello lessicale interno un <ph id="ph2">`finally`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Unlike the <ph id="ph1">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id="ph2">`endfinally`</ph> instruction, and there can be as many <ph id="ph3">`endfinally`</ph> instructions within the block as required.</source>
          <target state="translated">A differenza di <ph id="ph1">`endfilter`</ph> (istruzione), non è necessario che il blocco terminano con un <ph id="ph2">`endfinally`</ph> istruzioni e possono essere tante <ph id="ph3">`endfinally`</ph> istruzioni all'interno del blocco.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>These same restrictions apply to the <ph id="ph1">`endfault`</ph> instruction and the <ph id="ph2">`fault`</ph> block.</source>
          <target state="translated">Le stesse restrizioni si applicano al <ph id="ph1">`endfault`</ph> istruzione e <ph id="ph2">`fault`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred into a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the exception mechanism.</source>
          <target state="translated">Il controllo non può essere trasferito in un <ph id="ph1">`finally`</ph> (o <ph id="ph2">`fault`</ph>) blocco tranne tramite il meccanismo di eccezione.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred out of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the use of a <ph id="ph3">`throw`</ph> instruction or executing the <ph id="ph4">`endfinally`</ph> (or <ph id="ph5">`endfault`</ph>) instruction.</source>
          <target state="translated">Il controllo non può essere trasferito da un <ph id="ph1">`finally`</ph> (o <ph id="ph2">`fault`</ph>) blocco eccezione mediante l'utilizzo di un <ph id="ph3">`throw`</ph> istruzione o l'esecuzione di <ph id="ph4">`endfinally`</ph> (o <ph id="ph5">`endfault`</ph>) (istruzione).</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>In particular, you cannot "fall out" of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block or to execute a <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id="ph5">`finally`</ph> (or <ph id="ph6">`fault`</ph>) block.</source>
          <target state="translated">In particolare, è possibile "uscire da" di un <ph id="ph1">`finally`</ph> (o <ph id="ph2">`fault`</ph>) blocco oppure eseguire un <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> o <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> istruzione all'interno di un <ph id="ph5">`finally`</ph> (o <ph id="ph6">`fault`</ph>) blocco.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Note that the <ph id="ph1">`endfault`</ph> and <ph id="ph2">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.</source>
          <target state="translated">Si noti che il <ph id="ph1">`endfault`</ph> e <ph id="ph2">`endfinally`</ph> sono alias, ovvero corrispondono allo stesso codice operativo.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, as well as the <ph id="ph4">`ILGenerator`</ph> method <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</source>
          <target state="translated">Le operazioni seguenti <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, nonché il <ph id="ph4">`ILGenerator`</ph> metodo <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.EndExceptionBlock()</source>
          <target state="translated">ILGenerator.EndExceptionBlock()</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Initializes a specified block of memory at a specific address to a given size and initial value.</source>
          <target state="translated">Inizializza un blocco specificato di memoria in corrispondenza di un indirizzo specifico su una dimensione e un valore iniziale dati.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>FE 18</source>
          <target state="translated">FE 18</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>initblk</source>
          <target state="translated">initblk</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Set each location in a block of memory to a given value.</source>
          <target state="translated">Impostare ogni posizione in un blocco di memoria per un determinato valore.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>A starting address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo iniziale viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>An initialization value is pushed onto the stack.</source>
          <target state="translated">Un valore di inizializzazione viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes to initialize is pushed onto the stack.</source>
          <target state="translated">Il numero di byte da inizializzare viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</source>
          <target state="translated">Il numero di byte, il valore di inizializzazione e l'indirizzo iniziale vengono estratti dallo stack e l'inizializzazione viene eseguita in base ai relativi valori.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The <ph id="ph1">`initblk`</ph> instruction sets the number (<ph id="ph2">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) to the initialization value (of type <ph id="ph6">`unsigned int8`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`initblk`</ph> il numero di set di istruzioni (<ph id="ph2">`unsigned int32`</ph>) di byte a partire dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o <ph id="ph5">`*`</ph>) sul valore di inizializzazione (di tipo <ph id="ph6">`unsigned int8`</ph>).</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`initblk`</ph> si presuppone che l'indirizzo iniziale è allineato alle dimensioni fisiche del computer.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The operation of the <ph id="ph1">`initblk`</ph> instructions can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`initblk`</ph> istruzioni possono essere modificate da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initblk`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`initblk`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">Inizializza ciascun campo del tipo di valore in corrispondenza di un indirizzo specifico su un riferimento Null o uno 0 di tipo primitivo appropriato.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></source>
          <target state="translated"><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes a value type.</source>
          <target state="translated">Inizializza un tipo di valore.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address of the value type to initialize is pushed onto the stack.</source>
          <target state="translated">L'indirizzo del tipo di valore per inizializzare viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address is popped from the stack; the value type at the specified address is initialized as type <ph id="ph1">`typeTok`</ph>.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; il tipo di valore in corrispondenza dell'indirizzo specificato viene inizializzato come tipo <ph id="ph1">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The <ph id="ph1">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or <ph id="ph4">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">Il <ph id="ph1">`initobj`</ph> istruzione Inizializza ciascun campo del tipo di valore specificato dall'indirizzo inserito (di tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, o <ph id="ph4">`*`</ph>) su un riferimento null o uno 0 di tipo primitivo appropriato.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>After this method is called, the instance is ready for a constructor method to be called.</source>
          <target state="translated">Dopo la chiamata di questo metodo, l'istanza è pronta per un metodo del costruttore da chiamare.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>If <ph id="ph1">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id="ph2">`ldnull`</ph> followed by <ph id="ph3">`stind.ref`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`typeTok`</ph> è un tipo riferimento, questa istruzione ha lo stesso effetto <ph id="ph2">`ldnull`</ph> seguito da <ph id="ph3">`stind.ref`</ph>.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> does not call the constructor method.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> non chiama il metodo del costruttore.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`Initobj`</ph> is intended for initializing value types, while <ph id="ph2">`newobj`</ph> is used to allocate and initialize objects.</source>
          <target state="translated"><ph id="ph1">`Initobj`</ph> è destinato all'inizializzazione dei tipi di valore, mentre <ph id="ph2">`newobj`</ph> viene utilizzato per allocare e inizializzare gli oggetti.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initobj`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`initobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests whether an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) is an instance of a particular class.</source>
          <target state="translated">Verifica se un riferimento a un oggetto di tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> è un'istanza di una classe particolare.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>isinst <ph id="ph1">`class`</ph></source>
          <target state="translated">isinst <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests if an object reference is an instance of <ph id="ph1">`class`</ph>, returning either a null reference or an instance of that class or interface.</source>
          <target state="translated">Verifica se un riferimento all'oggetto è un'istanza di <ph id="ph1">`class`</ph>, che restituisce un riferimento null oppure un'istanza di tale classe o interfaccia.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack e testato per verificare se si tratta di un'istanza della classe passata <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The result (either an object reference or a null reference) is pushed onto the stack.</source>
          <target state="translated">Il risultato (un riferimento all'oggetto o un riferimento null) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">`Class`</ph> is a metadata token indicating the desired class.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> è un token di metadati che indica la classe desiderata.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the class of the object on the top of the stack implements <ph id="ph1">`class`</ph> (if <ph id="ph2">`class`</ph> is an interface) or is a derived class of <ph id="ph3">`class`</ph> (if <ph id="ph4">`class`</ph> is a regular class) then it is cast to type <ph id="ph5">`class`</ph> and the result is pushed on the stack, exactly as though <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.</source>
          <target state="translated">Se la classe dell'oggetto all'inizio dello stack implementa <ph id="ph1">`class`</ph> (se <ph id="ph2">`class`</ph> è un'interfaccia) o è una classe derivata di <ph id="ph3">`class`</ph> (se <ph id="ph4">`class`</ph> è una classe normale), quindi ne viene eseguito il cast nel tipo <ph id="ph5">`class`</ph> e il risultato viene inserito nello stack, esattamente come se <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> fosse stata chiamata.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Otherwise, a null reference is pushed on the stack.</source>
          <target state="translated">In caso contrario, un riferimento null viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the object reference itself is a null reference, then <ph id="ph1">`isinst`</ph> likewise returns a null reference.</source>
          <target state="translated">Se il riferimento all'oggetto stesso è un riferimento null, quindi <ph id="ph1">`isinst`</ph> Analogamente restituisce un riferimento null.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se non è possibile trovare la classe.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`isinst`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`isinst`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exits current method and jumps to specified method.</source>
          <target state="translated">Esce dal metodo corrente e passa a quello specificato.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>jmp <ph id="ph1">`method`</ph></source>
          <target state="translated">jmp <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exit current method and jump to specified method.</source>
          <target state="translated">Esce dal metodo corrente e passa al metodo specificato.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Alcuni comportamenti sono caratteristici nessuno stack transizione per questa istruzione.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id="ph2">`method`</ph>, which is a metadata token for a method reference.</source>
          <target state="translated">Il <ph id="ph1">`jmp`</ph> istruzione (jump) trasferisce il controllo al metodo specificato da <ph id="ph2">`method`</ph>, ovvero un token di metadati per un riferimento al metodo.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The current arguments are transferred to the destination method.</source>
          <target state="translated">Gli argomenti correnti vengono trasferiti al metodo di destinazione.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The evaluation stack must be empty when this instruction is executed.</source>
          <target state="translated">Stack di valutazione deve essere vuoto quando viene eseguita questa istruzione.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The calling convention, number and type of arguments at the destination address must match that of the current method.</source>
          <target state="translated">Convenzione di chiamata, numero e tipo di argomenti in corrispondenza dell'indirizzo di destinazione deve corrispondere a quello del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated">Il <ph id="ph1">`jmp`</ph> istruzione non può essere utilizzata per trasferire il controllo di un <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, o <ph id="ph5">`finally`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`jmp`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`jmp`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Loads an argument (referenced by a specified index value) onto the stack.</source>
          <target state="translated">Carica un argomento (a cui fa riferimento un valore di indice specificato) nello stack.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 09 &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ldarg <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Carica l'argomento in <ph id="ph1">`index`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Valore dell'argomento in <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg`</ph> istruzione inserisce l'argomento indicizzato in <ph id="ph2">`index`</ph>, in cui gli argomenti sono indicizzati da 0 in avanti, nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il <ph id="ph1">`ldarg`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> istruzioni per altri dettagli).</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Loads the argument at index 0 onto the evaluation stack.</source>
          <target state="translated">Carica l'argomento in corrispondenza dell'indice 0 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>02</source>
          <target state="translated">02</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ldarg.0</source>
          <target state="translated">ldarg.0</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Load argument 0 onto stack</source>
          <target state="translated">Carica l'argomento 0 nello stack</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The argument value at index 0 is pushed onto the stack.</source>
          <target state="translated">Il valore dell'argomento in corrispondenza dell'indice 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.0`</ph> istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 0.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.0`</ph> istruzione inserisce l'argomento dell'indice 0 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.0`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.0`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Loads the argument at index 1 onto the evaluation stack.</source>
          <target state="translated">Carica l'argomento in corrispondenza dell'indice 1 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>03</source>
          <target state="translated">03</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ldarg.1</source>
          <target state="translated">ldarg.1</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Load argument 1 onto stack.</source>
          <target state="translated">Carica l'argomento 1 nello stack.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The argument value at index 1 is pushed onto the stack.</source>
          <target state="translated">Il valore dell'argomento in corrispondenza dell'indice 1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.1`</ph> istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 1.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.1`</ph> istruzione inserisce l'argomento dell'indice 1 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.1`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Loads the argument at index 2 onto the evaluation stack.</source>
          <target state="translated">Carica l'argomento in corrispondenza dell'indice 2 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>04</source>
          <target state="translated">04</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ldarg.2</source>
          <target state="translated">ldarg.2</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Load argument 2 onto stack.</source>
          <target state="translated">Carica l'argomento 2 nello stack.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The argument value at index 2 is pushed onto the stack.</source>
          <target state="translated">Il valore dell'argomento in corrispondenza dell'indice 2 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.2`</ph> istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 2.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.2`</ph> istruzione inserisce l'argomento dell'indice 2 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.2`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Loads the argument at index 3 onto the evaluation stack.</source>
          <target state="translated">Carica l'argomento in corrispondenza dell'indice 3 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>05</source>
          <target state="translated">05</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ldarg.3</source>
          <target state="translated">ldarg.3</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Load argument 3 onto stack.</source>
          <target state="translated">Carica l'argomento 3 nello stack.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The argument value at index 3 is pushed onto the stack.</source>
          <target state="translated">Il valore dell'argomento in corrispondenza dell'indice 3 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.3`</ph> istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 3.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.3`</ph> istruzione inserisce l'argomento dell'indice 3 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.3`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.3`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</source>
          <target state="translated">Carica l'argomento (a cui fa riferimento un indice specificato in forma breve) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0E &amp;LT; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ldarg.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Carica l'argomento in <ph id="ph1">`index`</ph> nello stack, forma breve.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Valore dell'argomento in <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.s`</ph> istruzione rappresenta una codifica efficiente per il caricamento degli argomenti indicizzati da 4 a 255.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.s`</ph> istruzione inserisce l'argomento indicizzato in <ph id="ph2">`index`</ph>, in cui gli argomenti sono indicizzati da 0 in avanti, nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated">Il <ph id="ph1">`ldarg.s`</ph> istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il <ph id="ph1">`ldarg.s`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> istruzioni per altri dettagli).</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarg.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Load an argument address onto the evaluation stack.</source>
          <target state="translated">Carica l'indirizzo di un argomento nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0A &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ldarga <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Recupera l'indirizzo dell'argomento indicizzato da <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">L'indirizzo <ph id="ph1">`addr`</ph> dell'argomento indicizzato da <ph id="ph2">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The <ph id="ph1">`ldarga`</ph> instruction fetches the address (of type <ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldarga`</ph> istruzione recupera l'indirizzo (di tipo <ph id="ph2">`*`</ph>) dell'argomento indicizzato da <ph id="ph3">`index`</ph>, in cui gli argomenti sono indicizzati da 0 in avanti.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">L'indirizzo <ph id="ph1">`addr`</ph> allineato sempre a un limite naturale sul computer di destinazione.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il <ph id="ph1">`ldarga`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source><ph id="ph1">`ldarga`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph> viene utilizzato per il passaggio di parametri per riferimento.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.</source>
          <target state="translated">Per gli altri casi, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> deve essere utilizzato.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarga`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Load an argument address, in short form, onto the evaluation stack.</source>
          <target state="translated">Carica l'indirizzo di un argomento, in forma breve, nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ldarga.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Recupera l'indirizzo dell'argomento indicizzato da <ph id="ph1">`index`</ph>, forma breve.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">L'indirizzo <ph id="ph1">`addr`</ph> dell'argomento indicizzato da <ph id="ph2">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> (the short form of <ph id="ph2">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> (la versione abbreviata di <ph id="ph2">`ldarga`</ph>) è una codifica più efficiente e deve essere utilizzato per i numeri da 0 a 255 argomenti.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The <ph id="ph1">`ldarga.s`</ph> instruction fetches the address (of type<ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldarga.s`</ph> istruzione recupera l'indirizzo (di tipo<ph id="ph2">`*`</ph>) dell'argomento indicizzato da <ph id="ph3">`index`</ph>, in cui gli argomenti sono indicizzati da 0 in avanti.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">L'indirizzo <ph id="ph1">`addr`</ph> allineato sempre a un limite naturale sul computer di destinazione.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il <ph id="ph1">`ldarga.s`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> viene utilizzato per il passaggio di parametri per riferimento.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.</source>
          <target state="translated">Per gli altri casi, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> deve essere utilizzato.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldarga.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce un valore fornito di tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ldc.i4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes the value <ph id="ph1">`num`</ph> onto the stack.</source>
          <target state="translated">Inserisce il valore <ph id="ph1">`num`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Il valore <ph id="ph1">`num`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</source>
          <target state="translated">Si noti che sono disponibili speciali codifiche brevi e pertanto più efficiente, per i numeri interi da -128 a 127 e specialmente codifiche brevi per -1 e 8.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>All short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</source>
          <target state="translated">Codifiche più vengono utilizzate per i valori integer a 8 byte e 4 e 8 numeri a virgola mobile in byte, nonché i valori a 4 byte che non rientrano nei form di breve.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>There are three ways to push an 8 byte integer constant onto the stack</source>
          <target state="translated">Esistono tre modi per inserire una costante integer a 8 byte nello stack</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> istruzione per le costanti che devono essere espressi in più di 32 bit.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> istruzione seguita da un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> per le costanti che richiedono da 9 a 32 bit.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use a short form instruction followed by a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.</source>
          <target state="translated">Utilizzare un'istruzione abbreviata seguita da un <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> per le costanti che possono essere espressi con un massimo di 8 bit.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ILGenerator.Emit(OpCode, int)</source>
          <target state="translated">ILGenerator (OpCode, int)</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes the integer value of 0 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 0 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ldc.i4.0</source>
          <target state="translated">ldc.i4.0</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes 0 onto the stack.</source>
          <target state="translated">Inserisce 0 nello stack.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The value 0 is pushed onto the stack.</source>
          <target state="translated">Il valore 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.0`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes the integer value of 1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 1 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ldc.i4.1</source>
          <target state="translated">ldc.i4.1</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes 1 onto the stack.</source>
          <target state="translated">Inserisce 1 nello stack.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The value 1 is pushed onto the stack.</source>
          <target state="translated">Il valore 1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes the integer value of 2 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 2 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ldc.i4.2</source>
          <target state="translated">ldc.i4.2</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes 2 onto the stack.</source>
          <target state="translated">Inserisce 2 nello stack.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The value 2 is pushed onto the stack.</source>
          <target state="translated">Il valore 2 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes the integer value of 3 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 3 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ldc.i4.3</source>
          <target state="translated">ldc.i4.3</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes 3 onto the stack.</source>
          <target state="translated">Inserisce 3 nello stack.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The value 3 is pushed onto the stack.</source>
          <target state="translated">Il valore 3 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.3`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes the integer value of 4 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 4 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>1A</source>
          <target state="translated">1A</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ldc.i4.4</source>
          <target state="translated">ldc.i4.4</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes 4 onto the stack.</source>
          <target state="translated">Inserisce 4 nello stack.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The value 4 is pushed onto the stack.</source>
          <target state="translated">Il valore 4 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes the integer value of 5 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 5 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>1B</source>
          <target state="translated">1B</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ldc.i4.5</source>
          <target state="translated">ldc.i4.5</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes 5 onto the stack.</source>
          <target state="translated">Inserisce 5 nello stack.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The value 5 is pushed onto the stack.</source>
          <target state="translated">Il valore 5 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.5`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.5`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes the integer value of 6 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 6 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>1C</source>
          <target state="translated">1C</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ldc.i4.6</source>
          <target state="translated">ldc.i4.6</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes 6 onto the stack.</source>
          <target state="translated">Inserisce 6 nello stack.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The value 6 is pushed onto the stack.</source>
          <target state="translated">Il valore 6 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.6`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.6`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes the integer value of 7 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 7 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>1D</source>
          <target state="translated">1D</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ldc.i4.7</source>
          <target state="translated">ldc.i4.7</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes 7 onto the stack.</source>
          <target state="translated">Inserisce 7 nello stack.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The value 7 is pushed onto the stack.</source>
          <target state="translated">Il valore 7 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.7`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.7`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes the integer value of 8 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero 8 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>1E</source>
          <target state="translated">1E</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ldc.i4.8</source>
          <target state="translated">ldc.i4.8</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes 8 onto the stack.</source>
          <target state="translated">Inserisce 8 nello stack.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The value 8 is pushed onto the stack.</source>
          <target state="translated">Il valore 8 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes the integer value of -1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Inserisce il valore intero -1 nello stack di valutazione come <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ldc.i4.m1</source>
          <target state="translated">ldc.i4.m1</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes -1 onto the stack.</source>
          <target state="translated">Inserisce -1 nello stack.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The value -1 is pushed onto the stack.</source>
          <target state="translated">Il valore -1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Si tratta di una speciale codifica breve per il push dell'integer 0.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Tutte le codifiche short speciali push interi a 4 byte nello stack.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.m1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.m1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes the supplied <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, short form.</source>
          <target state="translated">Inserisce il valore fornito <ph id="ph1">&lt;see langword="int8" /&gt;</ph> nello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> (forma breve).</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ldc.i4.s <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int32`</ph>, short form.</source>
          <target state="translated">Inserisce <ph id="ph1">`num`</ph> nello stack come <ph id="ph2">`int32`</ph>, forma breve.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Il valore <ph id="ph1">`num`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source><ph id="ph1">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldc.i4.s`</ph> è una codifica più efficiente per l'inserimento di numeri interi compresi tra -128 a 127 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i4.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Inserisce un valore fornito di tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> nello stack di valutazione come <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ldc.i8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">Inserisce <ph id="ph1">`num`</ph> nello stack come <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Il valore <ph id="ph1">`num`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>This encoding pushes an <ph id="ph1">`int64`</ph> value onto the stack.</source>
          <target state="translated">Questa codifica inserisce un <ph id="ph1">`int64`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ILGenerator.Emit(OpCode, long)</source>
          <target state="translated">ILGenerator (OpCode, long)</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Inserisce un valore fornito di tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> nello stack di valutazione come tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ldc.r4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Inserisce <ph id="ph1">`num`</ph> nello stack come <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Il valore <ph id="ph1">`num`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>This encoding pushes a <ph id="ph1">`float32`</ph> value onto the stack.</source>
          <target state="translated">Questa codifica inserisce un <ph id="ph1">`float32`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ILGenerator.Emit(OpCode, single)</source>
          <target state="translated">ILGenerator (OpCode, singolo)</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Inserisce un valore fornito di tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> nello stack di valutazione come tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ldc.r8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Inserisce <ph id="ph1">`num`</ph> nello stack come <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Il valore <ph id="ph1">`num`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>This encoding pushes a <ph id="ph1">`float64`</ph> value onto the stack.</source>
          <target state="translated">Questa codifica inserisce un <ph id="ph1">`float64`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldc.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ILGenerator.Emit(OpCode, double)</source>
          <target state="translated">ILGenerator (OpCode, double)</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</source>
          <target state="translated">Carica l'elemento in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo specificato nell'istruzione.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ldelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">ldelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`typeTok`</ph>.</source>
          <target state="translated">Carica l'elemento in <ph id="ph1">`index`</ph> all'inizio dello stack come tipo <ph id="ph2">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The <ph id="ph1">`ldelem`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The type of the return value is specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">Il tipo del valore restituito è specificato il token <ph id="ph1">`typeTok`</ph> nell'istruzione.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the upper bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite superiore di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a specified array index onto the top of the evaluation stack as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>97</source>
          <target state="translated">97</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ldelem.i</source>
          <target state="translated">ldelem.i</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`native int`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The <ph id="ph1">`ldelem.i`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.i`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The return value for <ph id="ph1">`ldelem.i`</ph> is <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.i`</ph> è <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>90</source>
          <target state="translated">90</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ldelem.i1</source>
          <target state="translated">ldelem.i1</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`int8`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The <ph id="ph1">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.i1`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The return value for <ph id="ph1">`ldelem.i1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.i1`</ph> è <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>92</source>
          <target state="translated">92</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ldelem.i2</source>
          <target state="translated">ldelem.i2</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`int16`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The <ph id="ph1">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.i2`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The return value for <ph id="ph1">`ldelem.i2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.i2`</ph> è <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>94</source>
          <target state="translated">94</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ldelem.i4</source>
          <target state="translated">ldelem.i4</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`int32`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The <ph id="ph1">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.i4`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The return value for <ph id="ph1">`ldelem.i4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.i4`</ph> è <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>96</source>
          <target state="translated">96</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ldelem.i8</source>
          <target state="translated">ldelem.i8</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`int64`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The <ph id="ph1">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.i8`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The return value for <ph id="ph1">`ldelem.i8`</ph> is <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.i8`</ph> è <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>98</source>
          <target state="translated">98</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ldelem.r4</source>
          <target state="translated">ldelem.r4</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`float32`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The <ph id="ph1">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.r4`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The return value for <ph id="ph1">`ldelem.r4`</ph> is <ph id="ph2">`float32`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.r4`</ph> è <ph id="ph2">`float32`</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Valori a virgola mobile vengono convertiti nel tipo <ph id="ph1">`F`</ph> quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>99</source>
          <target state="translated">99</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ldelem.r8</source>
          <target state="translated">ldelem.r8</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`float64`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The <ph id="ph1">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.r8`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The return value for <ph id="ph1">`ldelem.r8`</ph> is <ph id="ph2">`float64`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.r8`</ph> è <ph id="ph2">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Valori a virgola mobile vengono convertiti nel tipo <ph id="ph1">`F`</ph> quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference).</source>
          <target state="translated">Carica l'elemento contenente un riferimento a un oggetto in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> (riferimento a un oggetto).</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>9A</source>
          <target state="translated">9A</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ldelem.ref</source>
          <target state="translated">ldelem.ref</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element with an object reference at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`O`</ph>.</source>
          <target state="translated">Carica l'elemento con un riferimento all'oggetto in <ph id="ph1">`index`</ph> all'inizio dello stack come tipo <ph id="ph2">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The <ph id="ph1">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.ref`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The return value for <ph id="ph1">`ldelem.ref`</ph> is type <ph id="ph2">`O`</ph> (object reference).</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.ref`</ph> è di tipo <ph id="ph2">`O`</ph> (riferimento all'oggetto).</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.ref`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>91</source>
          <target state="translated">91</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ldelem.u1</source>
          <target state="translated">ldelem.u1</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`unsigned int8`</ph> in <ph id="ph2">`index`</ph> all'inizio dello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The <ph id="ph1">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.u1`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The return value for <ph id="ph1">`ldelem.u1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.u1`</ph> è <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>93</source>
          <target state="translated">93</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ldelem.u2</source>
          <target state="translated">ldelem.u2</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`unsigned int16`</ph> in corrispondenza dell'indice di inizio dello stack come un <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The <ph id="ph1">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.u2`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The return value for <ph id="ph1">`ldelem.u2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.u2`</ph> è <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Carica l'elemento con tipo <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>95</source>
          <target state="translated">95</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ldelem.u4</source>
          <target state="translated">ldelem.u4</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Carica l'elemento con il tipo <ph id="ph1">`unsigned int32`</ph> in corrispondenza dell'indice di inizio dello stack come un <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; il valore archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Il valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The <ph id="ph1">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelem.u4`</ph> istruzione carica il valore dell'elemento con indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The return value for <ph id="ph1">`ldelem.u4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelem.u4`</ph> è <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se matrice non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelem.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (managed pointer).</source>
          <target state="translated">Carica l'indirizzo dell'elemento di matrice in corrispondenza di un indice di matrice specificato all'inizio dello stack di valutazione come tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (puntatore gestito).</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ldelema <ph id="ph1">`class`</ph></source>
          <target state="translated">ldelema <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at <ph id="ph1">`index`</ph> onto the top of the evaluation stack as type <ph id="ph2">`&amp;`</ph> (managed pointer).</source>
          <target state="translated">Carica l'indirizzo dell'elemento di matrice in <ph id="ph1">`index`</ph> all'inizio dello stack di valutazione come tipo <ph id="ph2">`&amp;`</ph> (puntatore gestito).</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice <ph id="ph1">`index`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the address stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> e <ph id="ph2">`array`</ph> vengono estratti dallo stack; l'indirizzo archiviato nella posizione <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> viene cercata.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">L'indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id="ph2">`class`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`ldelema`</ph> viene utilizzato per recuperare l'indirizzo di un oggetto in un particolare indice in una matrice di oggetti (di tipo <ph id="ph2">`class`</ph>).</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> instruction loads the address of the value at index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldelema`</ph> istruzione carica l'indirizzo del valore in corrispondenza dell'indice <ph id="ph2">`index`</ph> (tipo <ph id="ph3">`native int`</ph>) nella matrice unidimensionale in base zero <ph id="ph4">`array`</ph> e lo inserisce nella parte superiore dello stack.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The value must be of type <ph id="ph1">`class`</ph> passed with the instruction.</source>
          <target state="translated">Il valore deve essere di tipo <ph id="ph1">`class`</ph> passato con l'istruzione.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The return value for <ph id="ph1">`ldelema`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>).</source>
          <target state="translated">Il valore restituito per <ph id="ph1">`ldelema`</ph> è un puntatore gestito (tipo <ph id="ph2">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelema`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldelema`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Finds the value of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Trova il valore di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ldfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Pushes the value of a field in a specified object onto the stack.</source>
          <target state="translated">Inserisce il valore di un campo in un oggetto specificato nello stack.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto (o un puntatore) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</source>
          <target state="translated">Il riferimento all'oggetto (o un puntatore) viene estratto dallo stack; il valore del campo specificato nell'oggetto viene trovato.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The value stored in the field is pushed onto the stack.</source>
          <target state="translated">Il valore archiviato nel campo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldfld`</ph> istruzione inserisce il valore di un campo a cui si trova in un oggetto di nello stack.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">L'oggetto deve essere sullo stack come un riferimento all'oggetto (tipo <ph id="ph1">`O`</ph>), un puntatore gestito (tipo <ph id="ph2">`&amp;`</ph>), un puntatore non gestito (tipo <ph id="ph3">`native int`</ph>), un puntatore temporaneo (tipo <ph id="ph4">`*`</ph>), o un'istanza di un tipo di valore.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">L'utilizzo di un puntatore non gestito non è consentito in codice verificabile.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Il campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro di campo.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The return type is the same as the one associated with the field.</source>
          <target state="translated">Il tipo restituito è lo stesso di quello associato al campo.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The field may be either an instance field (in which case the object must not be a null reference) or a static field.</source>
          <target state="translated">Il campo può essere un campo di istanza (nel qual caso l'oggetto non deve essere un riferimento null) o un campo statico.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated">Il <ph id="ph1">`ldfld`</ph> istruzione può essere preceduta da una o entrambe le <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefissi.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se l'oggetto è null e il campo non è statico.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> viene generata se il campo specificato non viene trovato nei metadati.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldfld`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Finds the address of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Trova l'indirizzo di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ldflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Pushes the address of <ph id="ph1">`field`</ph> in a specified object onto the stack.</source>
          <target state="translated">Inserisce l'indirizzo di <ph id="ph1">`field`</ph> in un oggetto specificato nello stack.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto (o un puntatore) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</source>
          <target state="translated">Il riferimento all'oggetto (o un puntatore) viene estratto dallo stack; l'indirizzo del campo specificato nell'oggetto è stato trovato.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of the specified field is pushed onto the stack.</source>
          <target state="translated">L'indirizzo del campo specificato è inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldflda`</ph> istruzione inserisce l'indirizzo di un campo a cui si trova in un oggetto di nello stack.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">L'oggetto deve essere sullo stack come un riferimento all'oggetto (tipo <ph id="ph1">`O`</ph>), un puntatore gestito (tipo <ph id="ph2">`&amp;`</ph>), un puntatore non gestito (tipo <ph id="ph3">`native int`</ph>), un puntatore temporaneo (tipo <ph id="ph4">`*`</ph>), o un'istanza di un tipo di valore.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">L'utilizzo di un puntatore non gestito non è consentito in codice verificabile.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Il campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro di campo.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The value returned by <ph id="ph1">`ldflda`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id="ph3">`native int`</ph>).</source>
          <target state="translated">Il valore restituito da <ph id="ph1">`ldflda`</ph> è un puntatore gestito (tipo <ph id="ph2">`&amp;`</ph>), a meno che l'oggetto viene inserito nello stack come un puntatore non gestito, nel qual caso l'indirizzo del mittente è anche un puntatore non gestito (tipo <ph id="ph3">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated">Il <ph id="ph1">`ldflda`</ph> istruzione può essere preceduta da una o entrambe le <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefissi.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> viene generata se l'oggetto non è presente all'interno del dominio applicazione da cui si accede.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of a field that is not inside the accessing application domain cannot be loaded.</source>
          <target state="translated">Impossibile caricare l'indirizzo di un campo che non è all'interno di accesso al dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se l'oggetto è null e il campo non è statico.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> viene generata se il campo specificato non viene trovato nei metadati.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldflda`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldflda`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a specific method onto the evaluation stack.</source>
          <target state="translated">Inserisce un puntatore non gestito di tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> al codice nativo che implementa un metodo specifico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 06 &amp;LT; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ldftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes a pointer to a method referenced by <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Inserisce un puntatore a un metodo a cui fa riferimento <ph id="ph1">`method`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The unmanaged pointer to a specific method is pushed onto the stack.</source>
          <target state="translated">Il puntatore non gestito a un metodo specifico viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The specific method (<ph id="ph1">`method`</ph>) can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">Il metodo specifico (<ph id="ph1">`method`</ph>) può essere chiamato utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> istruzione se fa riferimento a un metodo gestito (o uno stub che esegue la transizione da gestito a codice non gestito).</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The value returned points to native code using the CLR calling convention.</source>
          <target state="translated">Il valore restituito punta al codice nativo usando il convenzione di chiamata del CLR.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">L'indicatore di misura del metodo non deve essere passato al codice nativo non gestito come una routine di callback.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldftn`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldftn`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> come <ph id="ph2">&lt;see langword="native int" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>4D</source>
          <target state="translated">4D</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ldind.i</source>
          <target state="translated">ldind.i</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads the <ph id="ph1">`native int`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`native int`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The <ph id="ph1">`ldind.i`</ph> instruction indirectly loads a <ph id="ph2">`native int`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`native int`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.i`</ph> istruzione carica indirettamente un <ph id="ph2">`native int`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ldind.i1</source>
          <target state="translated">ldind.i1</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads the <ph id="ph1">`int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`int8`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The fetched value is pushed onto the stack..</source>
          <target state="translated">Il valore recuperato viene inserito nello stack...</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The <ph id="ph1">`ldind.i1`</ph> instruction indirectly loads an <ph id="ph2">`int8`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.i1`</ph> istruzione carica indirettamente un <ph id="ph2">`int8`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ldind.i2</source>
          <target state="translated">ldind.i2</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads the <ph id="ph1">`int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`int16`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The <ph id="ph1">`ldind.i2`</ph> instruction indirectly loads an <ph id="ph2">`int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.i2`</ph> istruzione carica indirettamente un <ph id="ph2">`int16`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>4A</source>
          <target state="translated">4A</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ldind.i4</source>
          <target state="translated">ldind.i4</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads the <ph id="ph1">`int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`int32`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The <ph id="ph1">`ldind.i4`</ph> instruction indirectly loads an <ph id="ph2">`int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.i4`</ph> istruzione carica indirettamente un <ph id="ph2">`int32`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> come <ph id="ph2">&lt;see langword="int64" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>4C</source>
          <target state="translated">4C</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ldind.i8</source>
          <target state="translated">ldind.i8</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads the <ph id="ph1">`int64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`int64`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The <ph id="ph1">`ldind.i8`</ph> instruction indirectly loads an <ph id="ph2">`int64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int64`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.i8`</ph> istruzione carica indirettamente un <ph id="ph2">`int64`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> come un tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>4E</source>
          <target state="translated">4E</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ldind.r4</source>
          <target state="translated">ldind.r4</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads the <ph id="ph1">`float32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`float32`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The <ph id="ph1">`ldind.r4`</ph> instruction indirectly loads a <ph id="ph2">`float32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a type <ph id="ph5">`F`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.r4`</ph> istruzione carica indirettamente un <ph id="ph2">`float32`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un tipo <ph id="ph5">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> come un tipo <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>4F</source>
          <target state="translated">4F</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ldind.r8</source>
          <target state="translated">ldind.r8</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads the <ph id="ph1">`float64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`float64`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un tipo <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The <ph id="ph1">`ldind.r8`</ph> instruction indirectly loads a <ph id="ph2">`float64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`float64`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.r8`</ph> istruzione carica indirettamente un <ph id="ph2">`float64`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads an object reference as a type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference) onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un riferimento a un oggetto come un tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> (riferimento a un oggetto) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>50</source>
          <target state="translated">50</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ldind.ref</source>
          <target state="translated">ldind.ref</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads the object reference at address <ph id="ph1">`addr`</ph> onto the stack as a type <ph id="ph2">`O`</ph></source>
          <target state="translated">Carica il riferimento all'oggetto all'indirizzo <ph id="ph1">`addr`</ph> nello stack come un tipo <ph id="ph2">`O`</ph></target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address is popped from the stack; the object reference located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; il riferimento all'oggetto si trova in corrispondenza dell'indirizzo viene recuperato.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The fetched reference is pushed onto the stack.</source>
          <target state="translated">Il riferimento recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The <ph id="ph1">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or *) onto the stack as type <ph id="ph4">`O`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.ref`</ph> istruzione carica indirettamente il riferimento all'oggetto l'indirizzo specificato (di tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, o *) nello stack come tipo <ph id="ph4">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.ref`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ldind.u1</source>
          <target state="translated">ldind.u1</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads the <ph id="ph1">`unsigned int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`unsigned int8`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The <ph id="ph1">`ldind.u1`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int8`</ph> value from the specified address (of type<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.u1`</ph> istruzione carica indirettamente un <ph id="ph2">`unsigned int8`</ph> valore dall'indirizzo specificato (di tipo<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.u1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>49</source>
          <target state="translated">49</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ldind.u2</source>
          <target state="translated">ldind.u2</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads the <ph id="ph1">`unsigned int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`unsigned int16`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The <ph id="ph1">`ldind.u2`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.u2`</ph> istruzione carica indirettamente un <ph id="ph2">`unsigned int16`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.u2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Carica indirettamente un valore di tipo <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> come <ph id="ph2">&lt;see langword="int32" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>4B</source>
          <target state="translated">4B</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ldind.u4</source>
          <target state="translated">ldind.u4</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads the <ph id="ph1">`unsigned int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Carica il <ph id="ph1">`unsigned int32`</ph> valore all'indirizzo <ph id="ph2">`addr`</ph> nello stack come un <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Il valore recuperato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The <ph id="ph1">`ldind.u4`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`ldind.u4`</ph> istruzione carica indirettamente un <ph id="ph2">`unsigned int32`</ph> valore dall'indirizzo specificato (di tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o *) nello stack come un <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Tutti i <ph id="ph1">`ldind`</ph> istruzioni sono collegamenti a un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> istruzione che specifica la classe di valore incorporato corrispondente.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Si noti che i valori integer con meno di 4 byte sono estesi a <ph id="ph1">`int32`</ph> (non <ph id="ph2">`native int`</ph>) quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">I valori a virgola mobile vengono convertiti in <ph id="ph1">`F`</ph> tipo quando vengono caricati nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il <ph id="ph1">`ldind`</ph> vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può verificarsi (vedere il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> istruzione per misure preventive di prefisso).</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) sono allineati in modo sicuro.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> può essere generata se viene rilevato un indirizzo non valido.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldind.u4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</source>
          <target state="translated">Inserisce il numero di elementi di una matrice unidimensionale in base zero nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>8E</source>
          <target state="translated">8E</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ldlen</source>
          <target state="translated">ldlen</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the length (of type <ph id="ph1">`natural unsigned int`</ph>) of an array on the stack.</source>
          <target state="translated">Inserisce la lunghezza (di tipo <ph id="ph1">`natural unsigned int`</ph>) di una matrice nello stack.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>An object reference to an array is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto in una matrice viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The array reference is popped from the stack and the length is computed.</source>
          <target state="translated">Il riferimento alla matrice viene estratto dallo stack e la lunghezza viene calcolata.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is pushed onto the stack.</source>
          <target state="translated">La lunghezza viene inserita nello stack.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is returned as a <ph id="ph1">`natural unsigned int`</ph>.</source>
          <target state="translated">La lunghezza viene restituita come un <ph id="ph1">`natural unsigned int`</ph>.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se il riferimento alla matrice è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldlen`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldlen`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0C &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ldloc <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice <ph id="ph1">`index`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldloc`</ph> istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</source>
          <target state="translated">Le variabili locali vengono inizializzate su 0 prima del metodo solo se il flag di inizializzazione nel metodo è true.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>There are 65,535 (2^16-1) local variables possible (0-65,534).</source>
          <target state="translated">Sono disponibili 65.535 (2 ^ 16 - 1) le variabili locali possibili (0-65.534).</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</source>
          <target state="translated">Indice 65.535 non è valido in quanto implementazioni simili utilizzeranno un integer a 2 byte per tenere traccia sia un indice locale, insieme al numero totale di variabili locali per un metodo specificato.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Se un indice di 65535 è stato reso valido, sarebbe necessario un valore integer più ampio tenere traccia del numero di variabili locali in tale metodo.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, and <ph id="ph4">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.</source>
          <target state="translated">Il <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, e <ph id="ph4">`ldloc.3`</ph> istruzioni forniscono una codifica efficiente per l'accesso alle prime quattro variabili locali.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Vedere le variabili partizione i locali che sono minori di 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`ldloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator (OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>06</source>
          <target state="translated">06</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ldloc.0</source>
          <target state="translated">ldloc.0</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The local variable value at the index 0 is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice 0 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source><ph id="ph1">`ldloc.0`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph> rappresenta una codifica particolarmente efficace per <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 0.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.0`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloc.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>07</source>
          <target state="translated">07</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ldloc.1</source>
          <target state="translated">ldloc.1</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The local variable value at the index 1 is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice 1 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source><ph id="ph1">`ldloc.1`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.</source>
          <target state="translated"><ph id="ph1">`ldloc.1`</ph> rappresenta una codifica particolarmente efficace per <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 1.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloc.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>08</source>
          <target state="translated">08</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ldloc.2</source>
          <target state="translated">ldloc.2</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The local variable value at the index 2 is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice 2 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source><ph id="ph1">`ldloc.2`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.</source>
          <target state="translated"><ph id="ph1">`ldloc.2`</ph> rappresenta una codifica particolarmente efficace per <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 2.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloc.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>09</source>
          <target state="translated">09</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ldloc.3</source>
          <target state="translated">ldloc.3</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The local variable value at the index 3 is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice 3 viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source><ph id="ph1">`ldloc.3`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.</source>
          <target state="translated"><ph id="ph1">`ldloc.3`</ph> rappresenta una codifica particolarmente efficace per <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, che consente di accedere alla variabile locale in corrispondenza dell'indice 3.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.3`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloc.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ldloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Carica la variabile locale in corrispondenza dell'indice <ph id="ph1">`index`</ph> nello stack, forma breve.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The <ph id="ph1">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldloc.s`</ph> istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</source>
          <target state="translated">Prima di inserire il metodo se il flag di inizializzazione nel metodo è true, le variabili locali vengono inizializzate a 0.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id="ph1">`ldloc`</ph>.</source>
          <target state="translated">Sono disponibili 256 (2 ^ 8) variabili locali (0-255) in forma breve, ovvero una codifica più efficiente <ph id="ph1">`ldloc`</ph>.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Vedere le variabili partizione i locali che sono minori di 4 byte vengono espanse per digitare <ph id="ph1">`int32`</ph> quando vengono caricati nello stack.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`ldloc.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator (OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE OD &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ldloca <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack.</source>
          <target state="translated">Carica l'indirizzo della variabile locale in <ph id="ph1">`index`</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The <ph id="ph1">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldloca`</ph> istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">Il valore inserito nello stack è già allineato correttamente per l'utilizzo con istruzioni come <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">Il risultato è un puntatore temporaneo (tipo <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloca`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ldloca.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack, short form.</source>
          <target state="translated">Carica l'indirizzo della variabile locale in <ph id="ph1">`index`</ph> nello stack di valutazione, forma breve.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`ldloca.s`</ph> istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">Il valore inserito nello stack è già allineato correttamente per l'utilizzo con istruzioni come <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">Il risultato è un puntatore temporaneo (tipo <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.</source>
          <target state="translated">Il <ph id="ph1">`ldloca.s`</ph> istruzione fornisce una codifica efficiente per l'utilizzo con le variabili locali, tra 0 e 255.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldloca.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Pushes a null reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Inserisce un riferimento null di tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph> nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ldnull</source>
          <target state="translated">ldnull</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>push a null reference onto the stack</source>
          <target state="translated">Inserisce un riferimento null nello stack</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>A null object reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto null viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> pushes a null reference (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> Inserisce un riferimento null (tipo <ph id="ph2">`O`</ph>) nello stack.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>This is used to initialize locations before they are populated with data, or when they become deprecated.</source>
          <target state="translated">Viene utilizzato per inizializzare i percorsi prima che siano compilati con i dati oppure quando è obsoleto.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> provides a null reference that is size-independent.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> fornisce un riferimento null indipendente dalle dimensioni.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldnull`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldnull`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copies the value type object pointed to by an address to the top of the evaluation stack.</source>
          <target state="translated">Copia l'oggetto tipo di valore a cui punta un indirizzo all'inizio dello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ldobj <ph id="ph1">`class`</ph></source>
          <target state="translated">ldobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copy instance of value type <ph id="ph1">`class`</ph> to the stack.</source>
          <target state="translated">Copia un'istanza del tipo di valore <ph id="ph1">`class`</ph> allo stack.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address of a value type object is pushed onto the stack.</source>
          <target state="translated">L'indirizzo di un oggetto di tipo valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address is popped from the stack and the instance at that particular address is looked up.</source>
          <target state="translated">L'indirizzo viene estratto dallo stack e l'istanza a quell'indirizzo specifico viene cercata.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The value of the object stored at that address is pushed onto the stack.</source>
          <target state="translated">Il valore dell'oggetto archiviato in corrispondenza dell'indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction is used to pass a value type as a parameter.</source>
          <target state="translated">Il <ph id="ph1">`ldobj`</ph> istruzione consente di passare un tipo di valore come parametro.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction copies the value pointed to by <ph id="ph2">`addrOfValObj`</ph> (of type <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`native int`</ph>) to the top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldobj`</ph> istruzione copia il valore a cui puntato <ph id="ph2">`addrOfValObj`</ph> (di tipo <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`native int`</ph>) all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The number of bytes copied depends on the size of the class (as specified by the <ph id="ph1">`class`</ph> parameter).</source>
          <target state="translated">Il numero di byte copiati dipende dalle dimensioni della classe (come specificato da di <ph id="ph1">`class`</ph> parametro).</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`class`</ph> parameter is a metadata token representing the value type.</source>
          <target state="translated">Il <ph id="ph1">`class`</ph> parametro è un token di metadati che rappresenta il tipo di valore.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The operation of the <ph id="ph1">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`ldobj`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se non è possibile trovare la classe.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertito in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldobj`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Pushes the value of a static field onto the evaluation stack.</source>
          <target state="translated">Inserisce il valore di un campo statico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ldsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Push the value of <ph id="ph1">`field`</ph> on the stack.</source>
          <target state="translated">Inserire il valore di <ph id="ph1">`field`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The value of the specific field is pushed onto the stack.</source>
          <target state="translated">Il valore del campo specifico viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldsfld`</ph> istruzione inserisce il valore di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The return type is that associated with the passed metadata token <ph id="ph1">`field`</ph>.</source>
          <target state="translated">Il tipo restituito è quello associato al token di metadati passato <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated">Il <ph id="ph1">`ldsfld`</ph> istruzione può disporre di un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefisso.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsfld`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldsfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Pushes the address of a static field onto the evaluation stack.</source>
          <target state="translated">Inserisce l'indirizzo di un campo statico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ldsflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Push the address of <ph id="ph1">`field`</ph> on the stack</source>
          <target state="translated">Inserisce l'indirizzo di <ph id="ph1">`field`</ph> nello stack</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address of a specific field is pushed onto the stack.</source>
          <target state="translated">L'indirizzo di un campo specifico viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated">Il <ph id="ph1">`ldsflda`</ph> istruzione inserisce l'indirizzo di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address may be represented as a transient pointer (type <ph id="ph1">`*`</ph>) if the metadata token <ph id="ph2">`field`</ph> refers to a type whose memory is managed.</source>
          <target state="translated">L'indirizzo può essere rappresentato come un puntatore temporaneo (tipo <ph id="ph1">`*`</ph>) se il token di metadati <ph id="ph2">`field`</ph> fa riferimento a un tipo la cui memoria è gestita.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Otherwise, it corresponds to an unmanaged pointer (type <ph id="ph1">`native int`</ph>).</source>
          <target state="translated">In caso contrario, corrisponde a un puntatore non gestito (tipo <ph id="ph1">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Note that <ph id="ph1">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</source>
          <target state="translated">Si noti che <ph id="ph1">`field`</ph> può essere un valore statico globale con un indirizzo virtuale relativo assegnato (l'offset del campo dall'indirizzo di base in cui il file PE contiene viene caricato in memoria) in cui la memoria è gestita.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated">Il <ph id="ph1">`ldsflda`</ph> istruzione può disporre di un <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefisso.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> viene generata se il campo non viene trovato nei metadati.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</source>
          <target state="translated">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsflda`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldsflda`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a new object reference to a string literal stored in the metadata.</source>
          <target state="translated">Inserisce un nuovo riferimento a un oggetto in un valore letterale stringa archiviato nei metadati.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ldstr <ph id="ph1">`mdToken`</ph></source>
          <target state="translated">ldstr <ph id="ph1">`mdToken`</ph></target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a string object for the metadata string token <ph id="ph1">`mdToken`</ph>.</source>
          <target state="translated">Inserisce un oggetto stringa per il token di stringa di metadati <ph id="ph1">`mdToken`</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>An object reference to a string is pushed onto the stack.</source>
          <target state="translated">Riferimento a una stringa di un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.</source>
          <target state="translated">Il <ph id="ph1">`ldstr`</ph> istruzione inserisce un riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>) a un nuovo oggetto stringa che rappresenta la stringa letterale archiviata nei metadati.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</source>
          <target state="translated">Il <ph id="ph1">`ldstr`</ph> istruzione alloca la quantità di memoria necessaria ed esegue qualsiasi conversione di formato è necessario convertire il valore letterale stringa dal formato utilizzato nel file di formato di stringa richiesto in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The Common Language Infrastructure (CLI) guarantees that the result of two <ph id="ph1">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</source>
          <target state="translated">Common Language Infrastructure (CLI) garantisce che il risultato di due <ph id="ph1">`ldstr`</ph> istruzioni che fanno riferimento a due token di metadati che hanno la stessa sequenza di caratteri restituiscano esattamente lo stesso oggetto di stringa (un processo noto come "inserimento di stringa").</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldstr`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldstr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ILGenerator.Emit(OpCode, string)</source>
          <target state="translated">ILGenerator (OpCode, stringa)</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</source>
          <target state="translated">Converte un token di metadati nella relativa rappresentazione di runtime, inserendolo nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ldtoken <ph id="ph1">`token`</ph></source>
          <target state="translated">ldtoken <ph id="ph1">`token`</ph></target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation.</source>
          <target state="translated">Converte un token di metadati nella relativa rappresentazione di runtime.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The passed token is converted to a <ph id="ph1">`RuntimeHandle`</ph> and pushed onto the stack.</source>
          <target state="translated">Il token passato viene convertito in un <ph id="ph1">`RuntimeHandle`</ph> e inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The <ph id="ph1">`ldtoken`</ph> instruction pushes a <ph id="ph2">`RuntimeHandle`</ph> for the specified metadata token.</source>
          <target state="translated">Il <ph id="ph1">`ldtoken`</ph> istruzione inserisce un <ph id="ph2">`RuntimeHandle`</ph> per il token di metadati specificato.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>A <ph id="ph1">`RuntimeHandle`</ph> can be a <ph id="ph2">`fieldref/fielddef`</ph>, a <ph id="ph3">`methodref/methoddef`</ph>, or a <ph id="ph4">`typeref/typedef`</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">`RuntimeHandle`</ph> può essere un <ph id="ph2">`fieldref/fielddef`</ph>, <ph id="ph3">`methodref/methoddef`</ph>, o un <ph id="ph4">`typeref/typedef`</ph>.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The value pushed on the stack can be used in calls to <ph id="ph1">`Reflection`</ph> methods in the system class library.</source>
          <target state="translated">Il valore inserito nello stack può essere utilizzato nelle chiamate a <ph id="ph1">`Reflection`</ph> metodi nella libreria di classi di sistema.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>For information on runtime handles, see the following classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</source>
          <target state="translated">Per informazioni sugli handle di runtime, vedere le seguenti classi: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, e <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldtoken`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`ldtoken`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</source>
          <target state="translated">Inserisce un puntatore non gestito di tipo (<ph id="ph1">&lt;see langword="native int" /&gt;</ph>) al codice nativo che implementa un particolare metodo virtual con un oggetto specificato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 07 &amp;LT; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ldvirtftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldvirtftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes the pointer to an object's virtual method <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Inserisce il puntatore a un metodo virtual <ph id="ph1">`method`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id="ph1">`method`</ph>) is looked up.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack e l'indirizzo del punto di ingresso al metodo (come specificato dal token di metadati <ph id="ph1">`method`</ph>) viene cercata.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The pointer to <ph id="ph1">`method`</ph> is pushed onto the stack.</source>
          <target state="translated">Puntatore a <ph id="ph1">`method`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The resulting unmanaged pointer pushed onto the stack by the <ph id="ph1">`ldvirtftn`</ph> instruction can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">Il puntatore non gestito risulta inserito nello stack dal <ph id="ph1">`ldvirtftn`</ph> istruzione può essere chiamato utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> istruzione se fa riferimento a un metodo gestito (o uno stub che esegue la transizione da gestito a codice non gestito).</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The unmanaged pointer points to native code using the CLR calling convention.</source>
          <target state="translated">Il puntatore non gestito fa riferimento al codice nativo usando il convenzione di chiamata del CLR.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">L'indicatore di misura del metodo non deve essere passato al codice nativo non gestito come una routine di callback.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldvirtftn`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ldvirtftn`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator (OpCode, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</source>
          <target state="translated">Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione specifica.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>leave <ph id="ph1">`target`</ph></source>
          <target state="translated">lasciare <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code.</source>
          <target state="translated">Esce da un'area protetta di codice.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Non vi è alcun comportamento di transizione dello stack specificato per questa istruzione.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Il <ph id="ph1">`leave`</ph> istruzione trasferisce il controllo all'istruzione di destinazione specifica, rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated">Il <ph id="ph1">`leave`</ph> è simile all'istruzione il <ph id="ph2">`br`</ph> (istruzione), ma consente di uscire da un <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, o <ph id="ph5">`catch`</ph> blocco mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di .</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated">Il <ph id="ph1">`leave`</ph> istruzione svuota lo stack di valutazione e assicura che circostanti appropriati <ph id="ph2">`finally`</ph> i blocchi vengono eseguiti.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>You cannot use a <ph id="ph1">`leave`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Non è possibile utilizzare un <ph id="ph1">`leave`</ph> per uscire dall'istruzione di un <ph id="ph2">`finally`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per utilizzare un <ph id="ph1">`leave`</ph> istruzione per trasferire il controllo a qualsiasi istruzione all'interno associato <ph id="ph2">`try`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se un'istruzione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`leave`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`leave`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</source>
          <target state="translated">Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione (forma breve).</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">GERMANIA &amp;LT; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>leave.s <ph id="ph1">`target`</ph></source>
          <target state="translated">leave. s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exit a protected region of code, short form.</source>
          <target state="translated">Uscire da un'area protetta di codice, la forma breve.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Non vi è alcun comportamento di transizione dello stack specificato per questa istruzione.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Il <ph id="ph1">`leave.s`</ph> istruzione trasferisce il controllo all'istruzione di destinazione passata, rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated">Il <ph id="ph1">`leave.s`</ph> è simile all'istruzione il <ph id="ph2">`br`</ph> (istruzione), ma consente di uscire da un <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, o <ph id="ph5">`catch`</ph> blocco mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di .</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated">Il <ph id="ph1">`leave.s`</ph> istruzione svuota lo stack di valutazione e assicura che circostanti appropriati <ph id="ph2">`finally`</ph> i blocchi vengono eseguiti.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>You cannot use a <ph id="ph1">`leave.s`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Non è possibile utilizzare un <ph id="ph1">`leave.s`</ph> per uscire dall'istruzione di un <ph id="ph2">`finally`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per utilizzare un <ph id="ph1">`leave.s`</ph> istruzione per trasferire il controllo a qualsiasi istruzione all'interno associato <ph id="ph2">`try`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se un'istruzione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`leave.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`leave.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id="ph1">&lt;see langword="*" /&gt;</ph>) of the first allocated byte onto the evaluation stack.</source>
          <target state="translated">Esegue l'allocazione di un numero di byte dal pool di memoria dinamica locale e inserisce l'indirizzo (un puntatore transitorio di tipo <ph id="ph1">&lt;see langword="*" /&gt;</ph>) del primo byte allocato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>FE 0F</source>
          <target state="translated">FE 0F</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>localloc</source>
          <target state="translated">localloc</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocate space from the local heap.</source>
          <target state="translated">Allocare spazio dall'heap locale.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes to be allocated is pushed onto the stack.</source>
          <target state="translated">Il numero di byte da allocare viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</source>
          <target state="translated">Il numero di byte viene estratto dallo stack; una quantità di memoria corrispondente alla dimensione viene allocata dall'heap locale.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>A pointer to the first byte of the allocated memory is pushed onto the stack.</source>
          <target state="translated">Un puntatore al primo byte della memoria allocata viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction allocates <ph id="ph2">`size`</ph> (type <ph id="ph3">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id="ph4">`*`</ph>) of the first allocated byte.</source>
          <target state="translated">Il <ph id="ph1">`localloc`</ph> istruzione alloca <ph id="ph2">`size`</ph> (tipo <ph id="ph3">`natural unsigned int`</ph>) pool e restituisce l'indirizzo di byte da memoria dinamica locale (un puntatore temporaneo, il tipo <ph id="ph4">`*`</ph>) del primo byte allocato.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Il blocco di memoria restituito viene inizializzato su 0 solo se il flag di inizializzazione nel metodo <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>When the current method executes a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.</source>
          <target state="translated">Quando il metodo corrente esegue un <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, il pool di memoria locale è reso disponibile per il riutilizzo.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The resulting address is aligned so that any primitive data type can be stored there using the <ph id="ph1">`stind`</ph> instructions (such as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id="ph3">`ldind`</ph> instructions (such as <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</source>
          <target state="translated">L'indirizzo risulta è allineato in modo che qualsiasi tipo di dati primitivi possa essere archiviata utilizzando il <ph id="ph1">`stind`</ph> istruzioni (ad esempio <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) e caricati utilizzando il <ph id="ph3">`ldind`</ph> istruzioni (ad esempio <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction cannot occur within a <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, or <ph id="ph5">`fault`</ph> block.</source>
          <target state="translated">Il <ph id="ph1">`localloc`</ph> istruzione non può verificarsi all'interno di un <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, o <ph id="ph5">`fault`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> viene generata se la memoria è insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`localloc`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`localloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</source>
          <target state="translated">Inserisce un riferimento tipizzato a un'istanza di un tipo specifico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>mkrefany <ph id="ph1">`class`</ph></source>
          <target state="translated">mkrefany <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference of type <ph id="ph1">`class`</ph> onto the stack.</source>
          <target state="translated">Inserisce un riferimento tipizzato di tipo <ph id="ph1">`class`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>A pointer to piece of data is pushed onto the stack.</source>
          <target state="translated">Puntatore alla porzione di dati viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer is popped and converted to a typed reference of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Il puntatore viene estratto e convertito in un riferimento tipizzato di tipo <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The typed reference is pushed onto the stack.</source>
          <target state="translated">Il riferimento tipizzato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The <ph id="ph1">`mkrefany`</ph> instruction supports the passing of dynamically typed references.</source>
          <target state="translated">Il <ph id="ph1">`mkrefany`</ph> istruzione supporta il passaggio dei riferimenti tipizzati in modo dinamico.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer must be of type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, or <ph id="ph3">`native int`</ph>, and hold the valid address of a piece of data.</source>
          <target state="translated">Il puntatore deve essere di tipo <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, o <ph id="ph3">`native int`</ph>e contiene l'indirizzo di una porzione di dati valido.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Class`</ph> is the class token describing the type of the data referenced by the pointer.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> è il token di classe che descrive il tipo di dati a cui fa riferimento il puntatore del mouse.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id="ph2">`class`</ph>.</source>
          <target state="translated"><ph id="ph1">`Mkrefany`</ph> Inserisce un riferimento tipizzato nello stack, fornendo un descrittore opaco del puntatore e il tipo <ph id="ph2">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</source>
          <target state="translated">L'operazione è valida solo consentita su un riferimento tipizzato consiste nel passarlo a un metodo che richiede un riferimento tipizzato come parametro.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The callee can then use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.</source>
          <target state="translated">Il chiamato può quindi utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> istruzioni per recuperare rispettivamente il tipo (classe) e l'indirizzo.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`class`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se <ph id="ph2">`class`</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mkrefany`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`mkrefany`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values and pushes the result on the evaluation stack.</source>
          <target state="translated">Moltiplica due valori e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>5A</source>
          <target state="translated">5A</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>mul</source>
          <target state="translated">mul</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values on the stack.</source>
          <target state="translated">Moltiplica due valori nello stack.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene moltiplicato per <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The <ph id="ph1">`mul`</ph> instruction multiplies <ph id="ph2">`value1`</ph> by <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">Il <ph id="ph1">`mul`</ph> istruzione moltiplica <ph id="ph2">`value1`</ph> da <ph id="ph3">`value2`</ph> e inserisce il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Integer operations silently truncate the upper bits on overflow.</source>
          <target state="translated">Operazioni su numeri interi troncano automaticamente i bit superiori in caso di overflow.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> per un numero intero specifica operazione con la gestione dell'overflow di moltiplicazione.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>For floating-point types, 0 * infinity = NaN.</source>
          <target state="translated">Per i tipi a virgola mobile, 0 * infinito = NaN.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`mul`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Moltiplica due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>D8</source>
          <target state="translated">D8</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>mul.ovf</source>
          <target state="translated">mul.ovf</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values on the stack with an overflow check.</source>
          <target state="translated">Moltiplica due valori integer nello stack con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene moltiplicato per <ph id="ph4">`value2`</ph>, con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The <ph id="ph1">`mul.ovf`</ph> instruction multiplies integer <ph id="ph2">`value1`</ph> by integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">Il <ph id="ph1">`mul.ovf`</ph> istruzione moltiplica l'intero <ph id="ph2">`value1`</ph> da integer <ph id="ph3">`value2`</ph> e inserisce il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Se il risultato non rientra nel tipo del risultato, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`mul.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Moltiplica due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>D9</source>
          <target state="translated">D9</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>mul.ovf.un</source>
          <target state="translated">mul.ovf.un</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned values on the stack with an overflow check.</source>
          <target state="translated">Moltiplica due valori senza segno nello stack con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value1`</ph> viene moltiplicato per <ph id="ph4">`value2`</ph>, con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The <ph id="ph1">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id="ph2">`value1`</ph> by unsigned integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated">Il <ph id="ph1">`mul.ovf.un`</ph> istruzione moltiplica l'intero senza segno <ph id="ph2">`value1`</ph> dall'intero senza segno <ph id="ph3">`value2`</ph> e inserisce il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Se il risultato non rientra nel tipo del risultato, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`mul.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates a value and pushes the result onto the evaluation stack.</source>
          <target state="translated">Nega un valore e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>65</source>
          <target state="translated">65</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>neg</source>
          <target state="translated">neg</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates the value currently on top of the stack.</source>
          <target state="translated">Nega il valore attualmente all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is popped from the stack and negated.</source>
          <target state="translated">Un valore è estratto dallo stack e negazione.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The <ph id="ph1">`neg`</ph> instruction negates value and pushes the result on top of the stack.</source>
          <target state="translated">Il <ph id="ph1">`neg`</ph> istruzione Nega il valore e inserisce il risultato all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">Il tipo restituito è lo stesso tipo dell'operando.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negation of integral values is standard two's complement negation.</source>
          <target state="translated">Negazione di valori integrali è standard in complemento a due negazione.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</source>
          <target state="translated">In particolare, la negazione del numero più negativo (che non ha una controparte positiva) produce il numero più negativo.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>To detect this overflow use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).</source>
          <target state="translated">Per rilevare l'utilizzo di overflow di <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> istruzione invece (sottrazione da 0).</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</source>
          <target state="translated">La negazione di un numero a virgola mobile non è possibile overflow e la negazione di NaN restituisce NaN.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`neg`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`neg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</source>
          <target state="translated">Inserisce un riferimento a un oggetto in una matrice unidimensionale in base zero i cui elementi sono di un tipo specifico nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>newarr <ph id="ph1">`etype`</ph></source>
          <target state="translated">newarr <ph id="ph1">`etype`</ph></target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Creates a new array with elements of type <ph id="ph1">`etype`</ph>.</source>
          <target state="translated">Crea una nuova matrice con gli elementi di tipo <ph id="ph1">`etype`</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the array is pushed onto the stack.</source>
          <target state="translated">Il numero di elementi nella matrice viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements is popped from the stack and the array is created.</source>
          <target state="translated">Il numero di elementi viene estratto dallo stack e la matrice viene creata.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>An object reference to the new array is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto nella nuova matrice viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The <ph id="ph1">`newarr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id="ph3">`etype`</ph> (a metadata token describing the type).</source>
          <target state="translated">Il <ph id="ph1">`newarr`</ph> istruzione inserisce un riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>) in una nuova matrice unidimensionale in base zero i cui elementi sono di tipo <ph id="ph3">`etype`</ph> (un token di metadati che descrive il tipo).</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the new array should be specified as a <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Il numero di elementi nella nuova matrice deve essere specificato come un <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Valid array indexes range from zero to the maximum number of elements minus one.</source>
          <target state="translated">Intervallo di indici di matrice valido compreso tra zero e il numero massimo di elementi meno uno.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The elements of an array can be any type, including value types.</source>
          <target state="translated">Gli elementi della matrice possono essere qualsiasi tipo, inclusi i tipi di valore.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and so on).</source>
          <target state="translated">Le matrici unidimensionali in base zero di numeri vengono create utilizzando un token di metadati di riferimento al tipo di valore appropriato (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>e così via).</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Elements of the array are initialized to 0 of the appropriate type.</source>
          <target state="translated">Elementi della matrice vengono inizializzati a 0 del tipo appropriato.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id="ph2">`newarr`</ph>.</source>
          <target state="translated">Matrici unidimensionali a base e le matrici multidimensionali vengono create utilizzando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> anziché <ph id="ph2">`newarr`</ph>.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>More commonly, they are created using the methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.</source>
          <target state="translated">Più comunemente, vengono creati utilizzando i metodi della <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe .NET Framework.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> viene generata se la memoria è insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id="ph2">`numElems`</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se <ph id="ph2">`numElems`</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newarr`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`newarr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Creates a new object or a new instance of a value type, pushing an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Crea un nuovo oggetto o una nuova istanza di un tipo di valore, inserendo un riferimento a un oggetto (di tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>newobj <ph id="ph1">`ctor`</ph></source>
          <target state="translated">newobj <ph id="ph1">`ctor`</ph></target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Allocates an uninitialized object or value type and calls the constructor method <ph id="ph1">`ctor`</ph>.</source>
          <target state="translated">Alloca un oggetto o valore di tipo non inizializzato e chiama il metodo costruttore <ph id="ph1">`ctor`</ph>.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argn`</ph> are pushed on the stack in sequence.</source>
          <target state="translated">Argomenti <ph id="ph1">`arg1`</ph> tramite <ph id="ph2">`argn`</ph> vengono inseriti nello stack in sequenza.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`argn`</ph> through <ph id="ph2">`arg1`</ph> are popped from the stack and passed to <ph id="ph3">`ctor`</ph> for object creation.</source>
          <target state="translated">Argomenti <ph id="ph1">`argn`</ph> tramite <ph id="ph2">`arg1`</ph> vengono estratti dallo stack e passati a <ph id="ph3">`ctor`</ph> per la creazione dell'oggetto.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>A reference to the new object is pushed onto the stack.</source>
          <target state="translated">Un riferimento al nuovo oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction creates a new object or a new instance of a value type.</source>
          <target state="translated">Il <ph id="ph1">`newobj`</ph> istruzione crea un nuovo oggetto o una nuova istanza di un tipo valore.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">`Ctor`</ph> is a metadata token (a <ph id="ph2">`methodref`</ph> or <ph id="ph3">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</source>
          <target state="translated"><ph id="ph1">`Ctor`</ph> è un token di metadati (un <ph id="ph2">`methodref`</ph> o <ph id="ph3">`methoddef`</ph> che deve essere contrassegnato come costruttore) che indica il nome, una classe e firma del costruttore da chiamare.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id="ph2">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</source>
          <target state="translated">Il <ph id="ph1">`newobj`</ph> istruzione consente di allocare una nuova istanza della classe associata a <ph id="ph2">`ctor`</ph> e inizializza tutti i campi nella nuova istanza su 0 (del tipo appropriato) o riferimenti null come appropriato.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>It then calls the constructor <ph id="ph1">`ctor`</ph> with the given arguments along with the newly created instance.</source>
          <target state="translated">Viene quindi chiamato il costruttore <ph id="ph1">`ctor`</ph> con gli argomenti specificati insieme all'istanza appena creata.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>After the constructor has been called, the now initialized object reference (type <ph id="ph1">`O`</ph>) is pushed on the stack.</source>
          <target state="translated">Dopo la chiamata al costruttore, l'ora inizializzato riferimento all'oggetto (tipo <ph id="ph1">`O`</ph>) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</source>
          <target state="translated">Dal punto di vista del costruttore, l'oggetto non inizializzato è l'argomento 0 e gli altri argomenti passati a newobj seguono in ordine.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>All zero-based, one-dimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id="ph2">`newobj`</ph>.</source>
          <target state="translated">Tutte le matrici unidimensionali in base zero vengono create utilizzando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, non <ph id="ph2">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">D'altra parte, tutte le altre matrici (più di una dimensione oppure unidimensionali, ma non in base zero) vengono create utilizzando <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Value types are not usually created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">Tipi di valore non vengono in genere creati utilizzando <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>They are usually allocated either as arguments or local variables, using <ph id="ph1">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.</source>
          <target state="translated">In genere vengono allocati come argomenti o variabili locali, utilizzando <ph id="ph1">`newarr`</ph> (per matrici unidimensionali in base zero), o come campi di oggetti.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Once allocated, they are initialized using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</source>
          <target state="translated">Dopo aver allocato, vengono inizializzati utilizzando <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>However, the <ph id="ph1">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">`newobj`</ph> istruzione può essere utilizzata per creare una nuova istanza di un tipo di valore nello stack, che può quindi essere passato come argomento, archiviato in un ambiente locale e così via.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> viene generata se la memoria è insufficiente per soddisfare la richiesta.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id="ph2">`ctor`</ph> with the indicated name, class and signature could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> viene generata se un metodo del costruttore <ph id="ph2">`ctor`</ph> con il nome indicato, classe e la firma non è state trovate.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newobj`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`newobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>ILGenerator.Emit(OpCode, ConstructorInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, ConstructorInfo)</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Fills space if opcodes are patched.</source>
          <target state="translated">Riempie lo spazio se i codici operativi sono corretti.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>No meaningful operation is performed although a processing cycle can be consumed.</source>
          <target state="translated">Non viene eseguita alcuna operazione significativa sebbene possa essere usato un ciclo di elaborazione.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>00</source>
          <target state="translated">00</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>nop</source>
          <target state="translated">NOP</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Performs an operation without behavior.</source>
          <target state="translated">Esegue un'operazione senza comportamento.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>There is no stack transitional behavior defined for this instruction.</source>
          <target state="translated">Non vi è alcun comportamento di transizione dello stack definito per questa istruzione.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The <ph id="ph1">`nop`</ph> operation does nothing.</source>
          <target state="translated">Il <ph id="ph1">`nop`</ph> non esegue alcuna operazione.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>It is intended to fill in space if opcodes are patched.</source>
          <target state="translated">È progettato per riempire lo spazio se i codici operativi sono corretti.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`nop`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`nop`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</source>
          <target state="translated">Calcola il complemento bit per bit del valore intero all'inizio dello stack e inserisce il risultato nello stack di valutazione come lo stesso tipo.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>66</source>
          <target state="translated">66</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>not</source>
          <target state="translated">not</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of a value.</source>
          <target state="translated">Calcola il complemento bit per bit di un valore.</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is popped from the stack and its bitwise complement computed.</source>
          <target state="translated"><ph id="ph1">`value`</ph> viene estratto dallo stack e il bit per bit complemento calcolata.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The <ph id="ph1">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`not`</ph> istruzione calcola il complemento bit per bit di un valore integer e inserisce il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">Il tipo restituito è lo stesso tipo dell'operando.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`not`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`not`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</source>
          <target state="translated">Calcola il complemento bit per bit dei due valori interi all'inizio dello stack e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>60</source>
          <target state="translated">60</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>or</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Computes the bitwise OR of two integer values, returns an integer.</source>
          <target state="translated">Calcola il bit per bit o due valori integer, restituisce un valore integer.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise OR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack e relativo OR calcolata.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The <ph id="ph1">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`or`</ph> istruzione calcola l'OR bit per bit dei due valori sopra lo stack, inserendo il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`Or`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> è un'operazione specifica del numero intero.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`or`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`or`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Removes the value currently on top of the evaluation stack.</source>
          <target state="translated">Rimuove il valore attualmente all'inizio dello stack.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>pop</source>
          <target state="translated">pop</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Pops the top value from the stack.</source>
          <target state="translated">Estrae il valore dallo stack.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The top value is popped from the stack.</source>
          <target state="translated">Il primo valore viene estratto dallo stack.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The <ph id="ph1">`pop`</ph> instruction removes the top element from the stack.</source>
          <target state="translated">Il <ph id="ph1">`pop`</ph> istruzione rimuove il primo elemento dallo stack.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`pop`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`pop`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix1">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix2">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix3">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix4">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix5">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix6">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix7">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefixref">
          <source>This is a reserved instruction.</source>
          <target state="translated">Si tratta di un'istruzione riservata.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</source>
          <target state="translated">Specifica che la successiva operazione sull'indirizzo di matrice non comporta l'esecuzione di alcun controllo del tipo in fase di esecuzione e che viene restituito un puntatore gestito la cui modificabilità è limitata.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>FE 1E</source>
          <target state="translated">FE 1E</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>readonly.</source>
          <target state="translated">sola lettura.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</source>
          <target state="translated">Specificare che l'operazione di indirizzo matrice successivi non esegue alcun controllo di tipo in fase di esecuzione e che restituisce un puntatore gestito mutabilità è limitata.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>This prefix can only appear immediately preceding the <ph id="ph1">`ldelema`</ph> instruction and calls to the special <ph id="ph2">`Address`</ph> method on arrays.</source>
          <target state="translated">Questo prefisso può trovarsi solo immediatamente precedente il <ph id="ph1">`ldelema`</ph> di istruzioni e le chiamate a speciale <ph id="ph2">`Address`</ph> metodo sulle matrici.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Its effect on the subsequent operation is twofold:</source>
          <target state="translated">Il relativo effetto sulle operazioni successive ha un duplice:</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>At run time, no type check operation is performed.</source>
          <target state="translated">In fase di esecuzione, viene eseguita alcuna operazione di controllo di tipo.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Note that there is normally an implicit type check for the <ph id="ph1">`ldelema`</ph> and <ph id="ph2">`stelem`</ph> instructions when used on reference type arrays.</source>
          <target state="translated">Si noti che è in genere un controllo di tipo implicito per il <ph id="ph1">`ldelema`</ph> e <ph id="ph2">`stelem`</ph> matrici di tipi di istruzioni quando vengono utilizzate nel riferimento.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>There is never a run-time type check for value classes, so <ph id="ph1">`readonly`</ph> is a no-op in that case.</source>
          <target state="translated">Non è mai un controllo del tipo in fase di esecuzione per le classi di valore, in modo <ph id="ph1">`readonly`</ph> viene eseguita alcuna operazione in questo caso.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</source>
          <target state="translated">Il verificatore considera il risultato dell'operazione di indirizzo come un puntatore gestito mutabilità è limitata.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</source>
          <target state="translated">Il puntatore ha mutabilità limitata poiché il tipo di definizione controlla se il valore può essere modificato.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</source>
          <target state="translated">Per le classi di valore che non espongono campi pubblici o i metodi di aggiornamento del valore, il puntatore è di sola lettura (da qui il nome del prefisso).</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</source>
          <target state="translated">In particolare, le classi che rappresentano i tipi primitivi (ad esempio, System. Int32) espongono modificatori e pertanto sono di sola lettura.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>A managed pointer restricted in this fashion can be used only in the following ways:</source>
          <target state="translated">Un puntatore gestito limitato in questo modo può essere utilizzato solo nei modi seguenti:</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`object`</ph> parameter for the <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, or<ph id="ph6">`constrained callvirt`</ph> instructions.</source>
          <target state="translated">Come il <ph id="ph1">`object`</ph> parametro per il <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, o<ph id="ph6">`constrained callvirt`</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`pointer`</ph> parameter to the <ph id="ph2">`ldobj`</ph> instruction or to one of the <ph id="ph3">`ldind`</ph> instructions.</source>
          <target state="translated">Come il <ph id="ph1">`pointer`</ph> parametro per il <ph id="ph2">`ldobj`</ph> istruzione o a uno del <ph id="ph3">`ldind`</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`source`</ph> parameter to the <ph id="ph2">`cpobj`</ph> instruction.</source>
          <target state="translated">Come il <ph id="ph1">`source`</ph> parametro per il <ph id="ph2">`cpobj`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>All other operations disallowed, including the <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, or <ph id="ph3">`mkrefany`</ph> operations, or any of the <ph id="ph4">`stind`</ph> instructions.</source>
          <target state="translated">Tutte le altre operazioni non consentite, incluse la <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, o <ph id="ph3">`mkrefany`</ph> operazioni o uno qualsiasi del <ph id="ph4">`stind`</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The purpose of the <ph id="ph1">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.</source>
          <target state="translated">Lo scopo del <ph id="ph1">`readonly`</ph> prefisso consiste nell'evitare di un controllo del tipo durante il recupero di un elemento da una matrice in codice generico.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For example, the expression <ph id="ph1">`arr[i].m()`</ph>, where the element type of the array <ph id="ph2">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id="ph3">`m`</ph>, might compile to the following MSIL.</source>
          <target state="translated">Ad esempio, l'espressione <ph id="ph1">`arr[i].m()`</ph>, in cui il tipo di elemento della matrice <ph id="ph2">`arr`</ph> è un tipo generico che può disporre di un'interfaccia con metodo <ph id="ph3">`m`</ph>, può essere compilata nel seguente codice MSIL.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Without the <ph id="ph1">`readonly`</ph> prefix, the <ph id="ph2">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.</source>
          <target state="translated">Senza il <ph id="ph1">`readonly`</ph> prefisso, il <ph id="ph2">`ldelema`</ph> istruzione eseguirebbe un controllo del tipo nel caso in cui! 0 è un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Not only is this type check inefficient, but it is semantically incorrect.</source>
          <target state="translated">Non solo è inefficiente questo controllo di tipo, ma non è semanticamente corretto.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The type check for <ph id="ph1">`ldelema`</ph> is an exact match, which is too strong.</source>
          <target state="translated">Il controllo dei tipi per <ph id="ph1">`ldelema`</ph> è una corrispondenza esatta, che è troppo complessa.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>If the array held subclasses of type !0, the code above would fail the type check.</source>
          <target state="translated">Se nella matrice sono sottoclassi di tipo! 0, il codice precedente avrà esito negativo il controllo dei tipi.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id="ph1">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id="ph2">`constrained callvirt`</ph> instruction.</source>
          <target state="translated">L'indirizzo dell'elemento della matrice verrà recuperato, invece dell'elemento stesso, per disporre di un handle per <ph id="ph1">`arr[i]`</ph> che utilizzi entrambi i tipi di valore e tipi di riferimento e pertanto può essere passati al <ph id="ph2">`constrained callvirt`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</source>
          <target state="translated">In generale sarebbe unsafe ignora il controllo in fase di esecuzione se la matrice sono presenti elementi di un tipo riferimento.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</source>
          <target state="translated">Per maggiore sicurezza, è necessario assicurarsi che nessuna modifica nella matrice viene effettuata tramite l'indicatore di misura.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier rules ensure this.</source>
          <target state="translated">Le regole di sistema di verifica garantiscono tale requisito.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</source>
          <target state="translated">Il puntatore gestito con restrizioni può essere passato come l'oggetto di chiamate di metodo di istanza, pertanto non è in senso stretto sola lettura per i tipi di valore, ma nessun problema di sicurezza di tipo per tipi di valore.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`readonly`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`readonly`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Retrieves the type token embedded in a typed reference.</source>
          <target state="translated">Recupera il token di tipo incorporato in un riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>FE 1D</source>
          <target state="translated">FE 1D</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>refanytype</source>
          <target state="translated">refanytype</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Pushes the type token stored in a typed reference.</source>
          <target state="translated">Inserisce il token di tipo archiviato in un riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un tipo valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The typed reference is popped from the stack and its corresponding type token retrieved.</source>
          <target state="translated">Il riferimento tipizzato viene estratto dallo stack e recuperare il relativo token di tipo corrispondente.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The type token is pushed onto the stack.</source>
          <target state="translated">Il token di tipo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Un riferimento tipizzato contiene un token di tipo e un indirizzo per un'istanza dell'oggetto.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The <ph id="ph1">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.</source>
          <target state="translated">Il <ph id="ph1">`refanytype`</ph> istruzione recupera il token di tipo incorporato nel riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> istruzione per informazioni sulla creazione di riferimenti tipizzati.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanytype`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`refanytype`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Retrieves the address (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) embedded in a typed reference.</source>
          <target state="translated">Recupera l'indirizzo (di tipo <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) incorporato in un riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>refanyval <ph id="ph1">`type`</ph></source>
          <target state="translated">refanyval <ph id="ph1">`type`</ph></target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Pushes the address stored in a typed reference.</source>
          <target state="translated">Inserisce l'indirizzo archiviato in un riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un tipo valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The typed reference is popped from the stack and the corresponding address retrieved.</source>
          <target state="translated">Il riferimento tipizzato viene estratto dallo stack e recuperare l'indirizzo del corrispondente.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">L'indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Un riferimento tipizzato contiene un token di tipo e un indirizzo per un'istanza dell'oggetto.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The <ph id="ph1">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.</source>
          <target state="translated">Il <ph id="ph1">`refanyval`</ph> istruzione recupera l'indirizzo incorporato di un riferimento tipizzato.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The type embedded in the typed reference supplied on the stack must match the type specified by <ph id="ph1">`type`</ph> (a metadata token, either a <ph id="ph2">`typedef`</ph> or a <ph id="ph3">`typeref`</ph>).</source>
          <target state="translated">Il tipo incorporato nel riferimento tipizzato fornito nello stack deve corrispondere al tipo specificato da <ph id="ph1">`type`</ph> (un token di metadati, ovvero un <ph id="ph2">`typedef`</ph> o <ph id="ph3">`typeref`</ph>).</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> istruzione per il contenuto correlato.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id="ph3">`type`</ph> is the class supplied to the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> viene generata se <ph id="ph2">`type`</ph> non è identico al tipo memorizzato nel riferimento del tipo (in questo caso, <ph id="ph3">`type`</ph> specificata per la classe di <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> istruzione di costruzione ha un riferimento tipizzato).</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se <ph id="ph2">`type`</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanyval`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`refanyval`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Divides two values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Divide due valori e inserisce il resto nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>5D</source>
          <target state="translated">5D</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>rem</source>
          <target state="translated">REM</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Pushes the remainder of dividing <ph id="ph1">`value1`</ph> by <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Inserisce il resto della divisione <ph id="ph1">`value1`</ph> da <ph id="ph2">`value2`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ReplaceThisText</source>
          <target state="translated">ReplaceThisText</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>A <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Oggetto <ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack e il resto della <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> calcolato.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> soddisfa le condizioni seguenti:</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), e:</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign(<ph id="ph3">`result`</ph>) = sign(<ph id="ph4">`value1`</ph>), where <ph id="ph5">`div`</ph> is the division instruction that truncates towards zero.</source>
          <target state="translated">0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign (<ph id="ph3">`result`</ph>) = segno (<ph id="ph4">`value1`</ph>), dove <ph id="ph5">`div`</ph> è l'istruzione di divisione che troncata a zero.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is zero or <ph id="ph2">`value1`</ph> is infinity the result is NaN.</source>
          <target state="translated">Se <ph id="ph1">`value2`</ph> è uguale a zero o <ph id="ph2">`value1`</ph> è infinito, il risultato è NaN.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is infinity, the result is <ph id="ph2">`value1`</ph> (negated for <ph id="ph3">`-infinity`</ph>).</source>
          <target state="translated">Se <ph id="ph1">`value2`</ph> è infinito, il risultato è <ph id="ph2">`value1`</ph> (negato per <ph id="ph3">`-infinity`</ph>).</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Le operazioni integrali generano <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> è zero.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Note that on the Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id="ph2">`rem`</ph> -1).</source>
          <target state="translated">Si noti che nelle piattaforme basate su Intel un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata un'eccezione durante il calcolo (minint <ph id="ph2">`rem`</ph> -1).</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`rem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Divides two unsigned values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Divide due valori senza segno e inserisce il resto nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>5E</source>
          <target state="translated">5E</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>rem.un</source>
          <target state="translated">rem.un</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Pushes the remainder of dividing unsigned <ph id="ph1">`value1`</ph> by unsigned <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Inserisce il resto della divisione senza segno <ph id="ph1">`value1`</ph> da unsigned <ph id="ph2">`value2`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack e il resto della <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> calcolato.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> soddisfa le condizioni seguenti:</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x(<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x (<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), e:</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>0 = <ph id="ph1">`result`</ph><ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>, where <ph id="ph4">`div.un`</ph> is the unsigned division instruction.</source>
          <target state="translated">0 = <ph id="ph1">`result`</ph> <ph id="ph2"> &lt; </ph> <ph id="ph3">`value2`</ph>, dove <ph id="ph4">`div.un`</ph> è l'istruzione di divisione senza segno.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The <ph id="ph1">`rem.un`</ph> instruction computes <ph id="ph2">`result`</ph> and pushes it on the stack.</source>
          <target state="translated">Il <ph id="ph1">`rem.un`</ph> istruzione calcola <ph id="ph2">`result`</ph> e lo inserisce nello stack.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> considera i propri argomenti come interi senza segno, mentre <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> li considera come interi con segno.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> is unspecified for floating-point numbers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> non è specificato per i numeri a virgola mobile.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Le operazioni integrali generano <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> se <ph id="ph2">`value2`</ph> è zero.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`rem.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</source>
          <target state="translated">Restituisce il risultato del metodo corrente, inserendo il valore restituito (se presente) dallo stack di valutazione del chiamato nello stack di valutazione del chiamante.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>2A</source>
          <target state="translated">2A</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ret</source>
          <target state="translated">RET</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from method, possibly returning a value.</source>
          <target state="translated">Restituisce dal metodo, eventualmente restituendo un valore.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value is popped from the callee evaluation stack.</source>
          <target state="translated">Il valore restituito viene estratto dallo stack di valutazione del chiamato.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value obtained in step 1 is pushed onto the caller evaluation stack.</source>
          <target state="translated">Il valore restituito ottenuto nel passaggio 1 viene inserito nello stack di valutazione chiamante.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</source>
          <target state="translated">Se il valore restituito non è presente nello stack di valutazione chiamato, viene restituito alcun valore (Nessuna transizione sullo stack per il metodo chiamato o chiamante).</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</source>
          <target state="translated">Il tipo del valore restituito, se presente, il metodo corrente determina il tipo di valore da recuperare dalla parte superiore dello stack e copiare nello stack del metodo che ha chiamato il metodo corrente.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The evaluation stack for the current method must be empty except for the value to be returned.</source>
          <target state="translated">Lo stack di valutazione per il metodo corrente deve essere vuoto tranne per il valore da restituire.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The <ph id="ph1">`ret`</ph> instruction cannot be used to transfer control out of a<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated">Il <ph id="ph1">`ret`</ph> istruzione non può essere utilizzata per trasferire il controllo di un<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, o <ph id="ph5">`finally`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>From within a <ph id="ph1">`try`</ph> or <ph id="ph2">`catch`</ph>, use the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id="ph4">`ret`</ph> instruction that is outside all enclosing exception blocks.</source>
          <target state="translated">Dall'interno un <ph id="ph1">`try`</ph> o <ph id="ph2">`catch`</ph>, utilizzare il <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> istruzione con una destinazione di un <ph id="ph4">`ret`</ph> istruzione all'esterno di tutti i blocchi di eccezioni.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Because the <ph id="ph1">`filter`</ph> and <ph id="ph2">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id="ph3">`filter`</ph> or <ph id="ph4">`finally`</ph>.</source>
          <target state="translated">Poiché il <ph id="ph1">`filter`</ph> e <ph id="ph2">`finally`</ph> blocchi sono logicamente parte della gestione delle eccezioni e non il metodo in cui è incorporato il proprio codice, correttamente generate istruzioni Microsoft Intermediate Language (MSIL) non eseguono un metodo viene restituito all'interno di un <ph id="ph3">`filter`</ph> o <ph id="ph4">`finally`</ph>.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ret`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`ret`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception.</source>
          <target state="translated">Genera nuovamente l'eccezione corrente.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>FE 1A</source>
          <target state="translated">FE 1A</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>rethrow</source>
          <target state="translated">rethrow</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception</source>
          <target state="translated">Genera nuovamente l'eccezione corrente</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>No stack transition behavior is defined for this instruction.</source>
          <target state="translated">Nessun comportamento di transizione dello stack è definito per questa istruzione.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The <ph id="ph1">`rethrow`</ph> instruction is only permitted within the body of a <ph id="ph2">`catch`</ph> handler.</source>
          <target state="translated">Il <ph id="ph1">`rethrow`</ph> istruzione è consentita solo all'interno del corpo di un <ph id="ph2">`catch`</ph> gestore.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>It throws the same exception that was caught by this handler.</source>
          <target state="translated">Genera la stessa eccezione che è stata intercettata da questo gestore.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rethrow`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`rethrow`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Sposta un valore intero verso sinistra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>62</source>
          <target state="translated">62</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>shl</source>
          <target state="translated">shl</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer to the left (shifting in zeros).</source>
          <target state="translated">Sposta un valore integer a sinistra (spostando gli zeri).</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">La quantità di bit da spostare viene inserita nello stack.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</source>
          <target state="translated">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a sinistra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The <ph id="ph1">`shl`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) left by the specified number of bits.</source>
          <target state="translated">Il <ph id="ph1">`shl`</ph> istruzione sposta il valore (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> o <ph id="ph4">`native int`</ph>) a sinistra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Il numero di bit è un valore di tipo <ph id="ph1">`int32`</ph> o <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source><ph id="ph1">`Shl`</ph> inserts a zero bit in the lowest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shl`</ph> Inserisce un bit zero nella posizione più bassa su ogni turno.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shl`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`shl`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Sposta un valore intero verso destra (spostando il segno) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>63</source>
          <target state="translated">63</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>shr</source>
          <target state="translated">shr</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer to the right (shifting in sign).</source>
          <target state="translated">Sposta un valore integer a destra (spostando il segno).</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">La quantità di bit da spostare viene inserita nello stack.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a destra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated">Il <ph id="ph1">`shr.un`</ph> istruzione sposta il valore (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> o <ph id="ph4">`native int`</ph>) a destra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Il numero di bit è un valore di tipo <ph id="ph1">`int32`</ph> o <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source><ph id="ph1">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id="ph2">`result`</ph>.</source>
          <target state="translated"><ph id="ph1">`Shr`</ph> Consente di replicare il bit più significativo per ogni turno, mantenendo il segno del valore originale di <ph id="ph2">`result`</ph>.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`shr`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Sposta un valore intero senza segno verso destra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>64</source>
          <target state="translated">64</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>shr.un</source>
          <target state="translated">shr.un</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an integer to the right (shifting in zeroes).</source>
          <target state="translated">Sposta un valore integer a destra (spostando gli zeri).</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">La quantità di bit da spostare viene inserita nello stack.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a destra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated">Il <ph id="ph1">`shr.un`</ph> istruzione sposta il valore (tipo <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> o <ph id="ph4">`native int`</ph>) a destra del numero specificato di bit.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> or <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Il numero di bit è un valore di tipo <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> o <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source><ph id="ph1">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shr.un`</ph> Inserisce un bit zero nella posizione più alta in ogni turno.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`shr.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</source>
          <target state="translated">Inserisce la dimensione in byte del tipo di valore fornito nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 1C &amp;LT; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>sizeof <ph id="ph1">`valType`</ph></source>
          <target state="translated">sizeof <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Push the size, in bytes, of a value type as an <ph id="ph1">`unsigned int32`</ph>.</source>
          <target state="translated">Inserisce la dimensione in byte, di un tipo di valore come un <ph id="ph1">`unsigned int32`</ph>.</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The size (in bytes) of the supplied value type (<ph id="ph1">`valType`</ph>) is pushed onto the stack.</source>
          <target state="translated">Le dimensioni (in byte) del tipo di valore fornito (<ph id="ph1">`valType`</ph>) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source><ph id="ph1">`valType`</ph> must be a metadata token (a <ph id="ph2">`typeref`</ph> or <ph id="ph3">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.</source>
          <target state="translated"><ph id="ph1">`valType`</ph> deve essere un token di metadati (un <ph id="ph2">`typeref`</ph> o <ph id="ph3">`typedef`</ph>) che specifica un tipo di valore, un tipo di riferimento o un parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</source>
          <target state="translated">Per un tipo riferimento, la dimensione restituita è la dimensione di un valore di riferimento del corrispondente tipo (4 byte in sistemi a 32 bit), non alle dimensioni dei dati archiviati negli oggetti a cui fa riferimento il valore di riferimento.</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>A generic type parameter can be used only in the body of the type or method that defines it.</source>
          <target state="translated">Un parametro di tipo generico può essere utilizzato solo nel corpo del tipo o metodo che lo definisce.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</source>
          <target state="translated">Quando viene creata un'istanza di tipo o metodo, il parametro di tipo generico viene sostituito da un tipo di valore o tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sizeof`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`sizeof`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index.</source>
          <target state="translated">Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0B &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>starg <ph id="ph1">`num`</ph></source>
          <target state="translated">starg <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Estrae il valore dallo stack e lo archivia in uno slot di argomento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The <ph id="ph1">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`starg`</ph> istruzione estrae un valore dallo stack e lo inserisce nello slot di argomento <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti variabili, il <ph id="ph1">`starg`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack all'argomento.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`starg`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</source>
          <target state="translated">Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato, forma breve.</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>starg.s <ph id="ph1">`num`</ph></source>
          <target state="translated">starg.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>, short form.</source>
          <target state="translated">Estrae il valore dallo stack e lo archivia in uno slot di argomento <ph id="ph1">`num`</ph>, forma breve.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`starg.s`</ph> istruzione estrae un valore dallo stack e lo inserisce nello slot di argomento <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.</source>
          <target state="translated">Il <ph id="ph1">`starg.s`</ph> istruzione fornisce una codifica efficiente per l'utilizzo con i primi 256 argomenti.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">Per le procedure che accettano un elenco di argomenti variabili, il <ph id="ph1">`starg.s`</ph> istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack all'argomento.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`starg.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore presente nello stack di valutazione, il cui tipo è specificato nell'istruzione.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>stelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">st elem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at the supplied index with a value of type <ph id="ph1">`typeTok`</ph> on the stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza dell'indice specificato con un valore di tipo <ph id="ph1">`typeTok`</ph> nello stack.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An index value, <ph id="ph1">`index`</ph>, to an element in <ph id="ph2">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un valore di indice, <ph id="ph1">`index`</ph>, a un elemento in <ph id="ph2">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A value of the type specified in the instruction is pushed onto the stack.</source>
          <target state="translated">Un valore del tipo specificato nell'istruzione viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The <ph id="ph1">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id="ph2">`array`</ph> with the value.</source>
          <target state="translated">Il <ph id="ph1">`stelem`</ph> istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato in base zero nella matrice unidimensionale <ph id="ph2">`array`</ph> con il valore.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value has the type specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">Il valore è il tipo specificato dal token <ph id="ph1">`typeTok`</ph> nell'istruzione.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="native int" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="native int" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>9B</source>
          <target state="translated">9B</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>stelem.i</source>
          <target state="translated">stelem.i</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`native int`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`native int`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The <ph id="ph1">`stelem.i`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`native int`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.i`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`native int`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="int8" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>9C</source>
          <target state="translated">9C</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>stelem.i1</source>
          <target state="translated">stelem.i1</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int8`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`int8`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The <ph id="ph1">`stelem.i1`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int8`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.i1`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`int8`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int16" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="int16" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>9D</source>
          <target state="translated">9D</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>stelem.i2</source>
          <target state="translated">stelem.i2</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int16`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`int16`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The <ph id="ph1">`stelem.i2`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int16`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.i2`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`int16`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="int32" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>9E</source>
          <target state="translated">9E</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>stelem.i4</source>
          <target state="translated">stelem.i4</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int32`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`int32`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The <ph id="ph1">`stelem.i4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int32`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.i4`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`int32`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="int64" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>9F</source>
          <target state="translated">9F</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>stelem.i8</source>
          <target state="translated">stelem.i8</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int64`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`int64`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The <ph id="ph1">`stelem.i8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int64`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.i8`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`int64`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="float32" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A0</source>
          <target state="translated">A0</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>stelem.r4</source>
          <target state="translated">stelem.r4</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float32`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`float32`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The <ph id="ph1">`stelem.r4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float32`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.r4`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`float32`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <ph id="ph1">&lt;see langword="float64" /&gt;</ph> sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A1</source>
          <target state="translated">A1</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>stelem.r8</source>
          <target state="translated">stelem.r8</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float64`</ph> value on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`float64`</ph> valore nello stack.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The <ph id="ph1">`stelem.r8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float64`</ph> value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.r8`</ph> istruzione sostituisce il valore dell'elemento <ph id="ph2">`index`</ph> nella matrice unidimensionale <ph id="ph3">`array`</ph> con il <ph id="ph4">`float64`</ph> valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces the array element at a given index with the object ref value (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) on the evaluation stack.</source>
          <target state="translated">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore di un riferimento a un oggetto (di tipo <ph id="ph1">&lt;see langword="O" /&gt;</ph>) sullo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A2</source>
          <target state="translated">A2</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>stelem.ref</source>
          <target state="translated">stelem.ref</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`ref`</ph> value (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il <ph id="ph1">`ref`</ph> valore (tipo <ph id="ph2">`O`</ph>) nello stack.</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Un riferimento a una matrice, oggetto <ph id="ph1">`array`</ph>, viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Un indice valido per un elemento in <ph id="ph1">`array`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The <ph id="ph1">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id="ph2">`array`</ph> with the <ph id="ph3">`ref`</ph> (type <ph id="ph4">`O`</ph>) value pushed onto the stack.</source>
          <target state="translated">Il <ph id="ph1">`stelem.ref`</ph> istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato nella matrice unidimensionale <ph id="ph2">`array`</ph> con il <ph id="ph3">`ref`</ph> (tipo <ph id="ph4">`O`</ph>) valore inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">L'indice è di tipo <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Note that <ph id="ph1">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id="ph2">`array`</ph> before assigning the value to the array element.</source>
          <target state="translated">Si noti che <ph id="ph1">`stelem.ref`</ph> esegue il cast in modo implicito il valore fornito per il tipo di elemento di <ph id="ph2">`array`</ph> prima di assegnare il valore all'elemento della matrice.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>This cast can fail, even for verified code.</source>
          <target state="translated">Questa operazione può non riuscire, anche per il codice di verifica.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Thus the <ph id="ph1">`stelem.ref`</ph> instruction can throw <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</source>
          <target state="translated">In questo modo il <ph id="ph1">`stelem.ref`</ph> istruzione può generare <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class provides a <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.</source>
          <target state="translated">Per le matrici unidimensionali che non sono in base zero e per le matrici multidimensionali, di <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe fornisce un <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> viene generata se <ph id="ph2">`index`</ph> è negativo o maggiore del limite di <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata se <ph id="ph2">`array`</ph> non contiene elementi del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.ref`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stelem.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value stored in the field of an object reference or pointer with a new value.</source>
          <target state="translated">Sostituisce il valore archiviato nel campo di un riferimento a un oggetto o puntatore con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>stfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value of <ph id="ph1">`field`</ph> of the object with a new value.</source>
          <target state="translated">Sostituisce il valore di <ph id="ph1">`field`</ph> dell'oggetto con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>An object reference or pointer is pushed onto the stack.</source>
          <target state="translated">Un riferimento a un oggetto o puntatore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The value and the object reference/pointer are popped from the stack; the value of <ph id="ph1">`field`</ph> in the object is replaced with the supplied value.</source>
          <target state="translated">Il valore e il riferimento o puntatore all'oggetto vengono estratti dallo stack; il valore di <ph id="ph1">`field`</ph> viene sostituito con il valore fornito nell'oggetto.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id="ph2">`O`</ph>) or via a pointer (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) with a given value.</source>
          <target state="translated">Il <ph id="ph1">`stfld`</ph> istruzione sostituisce il valore di un campo di un oggetto (tipo <ph id="ph2">`O`</ph>) o tramite un puntatore (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, o <ph id="ph5">`*`</ph>) con un valore specifico.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">`Field`</ph> is a metadata token that refers to a field member reference.</source>
          <target state="translated"><ph id="ph1">`Field`</ph> è un token di metadati che fa riferimento a un riferimento al membro di campo.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction can have a prefix of either or both of <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">`stfld`</ph> istruzione può disporre di un prefisso di uno o entrambi <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se il riferimento all'oggetto o il puntatore è un riferimento null e il campo non statico.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id="ph2">`field`</ph> is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> viene generata se <ph id="ph2">`field`</ph> non viene trovato nei metadati.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</source>
          <target state="translated">Questo viene controllato in genere quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertita in codice nativo, non in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stfld`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="native int" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>DF</source>
          <target state="translated">DF</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>stind.i</source>
          <target state="translated">stind.i</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a <ph id="ph1">`native int`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`native int`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The <ph id="ph1">`stind.i`</ph> instruction stores a <ph id="ph2">`native int`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.i`</ph> istruzione archivi un <ph id="ph2">`native int`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.i`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.i`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.i`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="int8" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>52</source>
          <target state="translated">52</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>stind.i1</source>
          <target state="translated">stind.i1</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores an <ph id="ph1">`int8`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`int8`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The <ph id="ph1">`stind.i1`</ph> instruction stores an <ph id="ph2">`int8`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.i1`</ph> istruzione archivi un <ph id="ph2">`int8`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.i1`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The operation of the <ph id="ph1">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.i1`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.i1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="int16" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>53</source>
          <target state="translated">53</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>stind.i2</source>
          <target state="translated">stind.i2</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores an <ph id="ph1">`int16`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`int16`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The <ph id="ph1">`stind.i2`</ph> instruction stores an <ph id="ph2">`int16`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.i2`</ph> istruzione archivi un <ph id="ph2">`int16`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Type safe operation requires that the <ph id="ph1">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.2i`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The operation of the <ph id="ph1">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.i2`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.i2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="int32" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>54</source>
          <target state="translated">54</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>stind.i4</source>
          <target state="translated">stind.i4</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores an <ph id="ph1">`int32`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`int32`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The <ph id="ph1">`stind.i4`</ph> instruction stores an <ph id="ph2">`int32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.i4`</ph> istruzione archivi un <ph id="ph2">`int32`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.i4`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The operation of the <ph id="ph1">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.i4`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.i4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="int64" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>55</source>
          <target state="translated">55</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>stind.i8</source>
          <target state="translated">stind.i8</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores an <ph id="ph1">`int64`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`int64`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The <ph id="ph1">`stind.i8`</ph> instruction stores an <ph id="ph2">`int64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.i8`</ph> istruzione archivi un <ph id="ph2">`int64`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.i8`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.i`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.i8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="float32" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>56</source>
          <target state="translated">56</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>stind.r4</source>
          <target state="translated">stind.r4</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a <ph id="ph1">`float32`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`float32`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The <ph id="ph1">`stind.r4`</ph> instruction stores a <ph id="ph2">`float32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.r4`</ph> istruzione archivi un <ph id="ph2">`float32`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.r4`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The operation of the <ph id="ph1">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.r4`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r4`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.r4`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Memorizza un valore di tipo <ph id="ph1">&lt;see langword="float64" /&gt;</ph> in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>57</source>
          <target state="translated">57</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>stind.r8</source>
          <target state="translated">stind.r8</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a <ph id="ph1">`float64`</ph> value at a given address.</source>
          <target state="translated">Archivia un <ph id="ph1">`float64`</ph> valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The <ph id="ph1">`stind.r8`</ph> instruction stores a <ph id="ph2">`float64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.r8`</ph> istruzione archivi un <ph id="ph2">`float64`</ph> valore in corrispondenza dell'indirizzo fornito (tipo <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, o <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.r8`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The operation of the <ph id="ph1">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.r8`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r8`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.r8`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores a object reference value at a supplied address.</source>
          <target state="translated">Archivia il valore di un riferimento a un oggetto in corrispondenza di un indirizzo fornito.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>51</source>
          <target state="translated">51</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>stind.ref</source>
          <target state="translated">stind.ref</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores an object reference (type <ph id="ph1">`O`</ph>) value at a given address.</source>
          <target state="translated">Archivia un riferimento all'oggetto (tipo <ph id="ph1">`O`</ph>) valore in corrispondenza di un determinato indirizzo.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The <ph id="ph1">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stind.ref`</ph> istruzione memorizza un valore di riferimento di oggetto in corrispondenza dell'indirizzo specificato (tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, o <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Type safe operation requires that the <ph id="ph1">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Tipo di operazione provvisoria richiede che il <ph id="ph1">`stind.ref`</ph> istruzione sia utilizzata in modo coerente con il tipo del puntatore.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The operation of the <ph id="ph1">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stind.ref`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`addr`</ph> non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.ref`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stind.ref`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza di un indice specificato.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0E &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>stloc <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Estrae un valore dallo stack e la archivia nella variabile locale <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The <ph id="ph1">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`stloc`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale <ph id="ph2">`index`</ph>, in cui le variabili locali sono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id="ph1">`index`</ph> be a valid local index.</source>
          <target state="translated">Le istruzioni Microsoft Intermediate Language (MSIL) corrette richiedono che <ph id="ph1">`index`</ph> sia un indice locale valido.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>For the <ph id="ph1">`stloc`</ph> instruction, <ph id="ph2">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</source>
          <target state="translated">Per il <ph id="ph1">`stloc`</ph> (istruzione), <ph id="ph2">`index`</ph> deve essere compreso nell'intervallo tra 0 e 65.534 compreso (in particolare, 65535 non è valido).</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</source>
          <target state="translated">Il motivo di 65.535 non è valido: implementazioni simili utilizzeranno un integer a 2 byte per tenere traccia sia un indice locale, nonché il numero totale di variabili locali per un metodo specificato.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Se un indice di 65535 è stato reso valido, sarebbe necessario un valore integer più ampio tenere traccia del numero di variabili locali in tale metodo.</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`stloc`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator (OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator (OpCode, short)</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 0.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>0A</source>
          <target state="translated">0A</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>stloc.0</source>
          <target state="translated">stloc.0</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops a value from the stack into local variable 0.</source>
          <target state="translated">Estrae un valore dallo stack nella variabile locale 0.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>A value is popped off of the stack and placed in the local variable indexed by 0.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata da 0.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The <ph id="ph1">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</source>
          <target state="translated">Il <ph id="ph1">`stloc.0`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata da 0.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source><ph id="ph1">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph> è una codifica particolarmente efficace per archiviare i valori nella variabile locale 0.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.0`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stloc.0`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 1.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>0B</source>
          <target state="translated">0B</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>stloc.1</source>
          <target state="translated">stloc.1</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops a value from the stack into local variable 1.</source>
          <target state="translated">Estrae un valore dallo stack nella variabile locale 1.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>A value is popped off of the stack and placed in the local variable indexed by 1.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata in base 1.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The <ph id="ph1">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</source>
          <target state="translated">Il <ph id="ph1">`stloc.1`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata in base 1.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source><ph id="ph1">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph> è una codifica particolarmente efficace per archiviare i valori nella variabile locale 1.</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.1`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stloc.1`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 2.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>0C</source>
          <target state="translated">0C</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>stloc.2</source>
          <target state="translated">stloc.2</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops a value from the stack into local variable 2</source>
          <target state="translated">Estrae un valore dallo stack nella variabile locale 2</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>A value is popped off of the stack and placed in the local variable indexed by 2.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata per 2.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The <ph id="ph1">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</source>
          <target state="translated">Il <ph id="ph1">`stloc.2`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata per 2.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source><ph id="ph1">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph> è una codifica particolarmente efficace per archiviare i valori nella variabile locale 2.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.2`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stloc.2`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 3.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>0D</source>
          <target state="translated">0D</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>stloc.3</source>
          <target state="translated">stloc.3</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops a value from the stack into local variable 3</source>
          <target state="translated">Estrae un valore dallo stack nella variabile locale 3</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>A value is popped off of the stack and placed in the local variable indexed by 3.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata per 3.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The <ph id="ph1">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</source>
          <target state="translated">Il <ph id="ph1">`stloc.3`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata per 3.</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source><ph id="ph1">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph> è una codifica particolarmente efficace per archiviare i valori nella variabile locale 3.</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.3`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stloc.3`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (short form).</source>
          <target state="translated">Estrae il valore corrente dall'inizio dello stack di valutazione e lo memorizza nell'elenco delle variabili in corrispondenza di <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (forma breve).</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>stloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Estrae un valore dallo stack e la archivia nella variabile locale <ph id="ph1">`index`</ph>, forma breve.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Un valore viene estratto dallo stack e inserito nella variabile locale <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated">Il <ph id="ph1">`stloc.s`</ph> istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale <ph id="ph2">`index`</ph>, in cui le variabili locali sono numerate a partire da 0.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.</source>
          <target state="translated">Il <ph id="ph1">`stloc.s`</ph> istruzione fornisce una codifica efficiente per le variabili locali 0 e 255.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo <ph id="ph1">`F`</ph>) per la dimensione associata con l'argomento.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc.s`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`stloc.s`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator (OpCode, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator (OpCode, byte)</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Copies a value of a specified type from the evaluation stack into a supplied memory address.</source>
          <target state="translated">Copia un valore di un tipo specificato dallo stack di valutazione in un indirizzo di memoria fornito.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>stobj <ph id="ph1">`class`</ph></source>
          <target state="translated">stobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Stores a value of type <ph id="ph1">`class`</ph> from the stack into memory.</source>
          <target state="translated">Archivia un valore di tipo <ph id="ph1">`class`</ph> dallo stack nella memoria.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>A value type object of type <ph id="ph1">`class`</ph> is pushed onto the stack.</source>
          <target state="translated">Un oggetto di tipo di valore di tipo <ph id="ph1">`class`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The object and the address are popped from the stack; the value type object is stored at the address.</source>
          <target state="translated">L'oggetto e l'indirizzo vengono estratti dallo stack; l'oggetto di tipo valore viene archiviato in corrispondenza dell'indirizzo.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The <ph id="ph1">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated">Il <ph id="ph1">`stobj`</ph> istruzione copia l'oggetto di tipo di valore nell'indirizzo specificato dall'indirizzo (un puntatore di tipo <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, o <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The number of bytes copied depends on the size of the class represented by <ph id="ph1">`class`</ph>, a metadata token representing a value type.</source>
          <target state="translated">Il numero di byte copiati dipende dalle dimensioni della classe rappresentata dal <ph id="ph1">`class`</ph>, un token di metadati che rappresenta un tipo di valore.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The operation of the <ph id="ph1">`stobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">L'operazione del <ph id="ph1">`stobj`</ph> istruzione può essere modificato da un immediatamente precedente <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> o <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> immediatamente precedente.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se non è possibile trovare la classe.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stobj`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stobj`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value of a static field with a value from the evaluation stack.</source>
          <target state="translated">Sostituisce il valore di un campo statico con un valore dallo stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>stsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value in <ph id="ph1">`field`</ph> with a supplied value.</source>
          <target state="translated">Sostituisce il valore in <ph id="ph1">`field`</ph> con un valore fornito.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is popped from the stack and stored in <ph id="ph1">`field`</ph>.</source>
          <target state="translated">Un valore è estratto dallo stack e archiviato in <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.</source>
          <target state="translated">Il <ph id="ph1">`stsfld`</ph> istruzione sostituisce il valore di un campo statico con un valore dallo stack.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">`field`</ph> is a metadata token that must refer to a static field member.</source>
          <target state="translated"><ph id="ph1">`field`</ph> è un token di metadati che deve fare riferimento a un membro del campo statico.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction may be prefixed by <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">`stsfld`</ph> istruzione può essere preceduto da <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> viene generata se il campo non viene trovato nei metadati.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stsfld`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`stsfld`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another and pushes the result onto the evaluation stack.</source>
          <target state="translated">Sottrae un valore da un altro e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>59</source>
          <target state="translated">59</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>sub</source>
          <target state="translated">sub</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another, returning a new numeric value.</source>
          <target state="translated">Sottrae un valore da un altro, ottenendo un nuovo valore numerico.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value2`</ph> viene sottratto <ph id="ph4">`value1`</ph>.</target>       </trans-unit>
        <trans-unit id="4303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</source>
          <target state="translated">Overflow non viene rilevato per operazioni su numeri interi (per gestire l'overflow appropriato, vedere <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Integer subtraction wraps, rather than saturates.</source>
          <target state="translated">Sottrazione di integer determina il passaggio al valore iniziale, anziché una saturazione.</target>       </trans-unit>
        <trans-unit id="4306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>For example: assuming 8-bit integers, where <ph id="ph1">`value1`</ph> is set to 0 and <ph id="ph2">`value2`</ph> is set to 1, the "wrapped" result will be 255.</source>
          <target state="translated">Ad esempio: interi a 8 bit, in cui <ph id="ph1">`value1`</ph> è impostato su 0 e <ph id="ph2">`value2`</ph> è impostato su 1, il risultato di "wrapping" è 255.</target>       </trans-unit>
        <trans-unit id="4307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">Restituisce un overflow a virgola mobile <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) o <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="4308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`sub`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4310" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Sottrae un valore intero da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>DA</source>
          <target state="translated">DA</target>       </trans-unit>
        <trans-unit id="4316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>sub.ovf</source>
          <target state="translated">sub.ovf</target>       </trans-unit>
        <trans-unit id="4317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another with an overflow check.</source>
          <target state="translated">Sottrae un valore integer da un altro con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="4318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value2`</ph> viene sottratto <ph id="ph4">`value1`</ph> con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="4322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="4324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Questa operazione viene eseguita su numeri interi con segno. per i valori a virgola mobile, usare <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`sub.ovf`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4327" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Sottrae un valore intero senza segno da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>DB</source>
          <target state="translated">DB</target>       </trans-unit>
        <trans-unit id="4333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>sub.ovf.un</source>
          <target state="translated">sub.ovf.un</target>       </trans-unit>
        <trans-unit id="4334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another with an overflow check.</source>
          <target state="translated">Sottrae un valore intero senza segno da un altro con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="4335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack; <ph id="ph3">`value2`</ph> viene sottratto <ph id="ph4">`value1`</ph> con un controllo dell'overflow.</target>       </trans-unit>
        <trans-unit id="4339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Il risultato viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</target>       </trans-unit>
        <trans-unit id="4341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Questa operazione viene eseguita su numeri interi con segno. per i valori a virgola mobile, usare <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf.un`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`sub.ovf.un`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4344" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Implements a jump table.</source>
          <target state="translated">Implementa una tabella di collegamento.</target>       </trans-unit>
        <trans-unit id="4345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></source>
          <target state="translated">45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</source>
          <target state="translated">switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</target>       </trans-unit>
        <trans-unit id="4351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Jumps to one of <ph id="ph1">`N`</ph> values.</source>
          <target state="translated">Passa a uno dei <ph id="ph1">`N`</ph> valori.</target>       </trans-unit>
        <trans-unit id="4352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Un valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id="ph1">`N`</ph>.</source>
          <target state="translated">Il valore viene estratto dallo stack e l'esecuzione viene trasferita all'istruzione in corrispondenza dell'offset indicizzato per valore, il cui valore è minore di <ph id="ph1">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction implements a jump table.</source>
          <target state="translated">Il <ph id="ph1">`switch`</ph> istruzione implementa una tabella di collegamento.</target>       </trans-unit>
        <trans-unit id="4356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The format of the instruction is an <ph id="ph1">`unsigned int32`</ph> representing the number of targets <ph id="ph2">`N`</ph>, followed by <ph id="ph3">`N`</ph> int32 values specifying jump targets.</source>
          <target state="translated">Il formato dell'istruzione è un <ph id="ph1">`unsigned int32`</ph> che rappresenta il numero di destinazioni <ph id="ph2">`N`</ph>, seguito da <ph id="ph3">`N`</ph> int32 valori che specificano gli obiettivi di passaggio.</target>       </trans-unit>
        <trans-unit id="4357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id="ph1">`switch`</ph> instruction.</source>
          <target state="translated">Queste destinazioni vengono rappresentate come offset (positivo o negativo) dall'inizio dell'istruzione che segue tale <ph id="ph1">`switch`</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="4358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id="ph2">`N`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`switch`</ph> istruzione estrae un valore dallo stack e lo confronta con, come un intero senza segno a <ph id="ph2">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If value is less than <ph id="ph1">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</source>
          <target state="translated">Se il valore è minore di <ph id="ph1">`N`</ph>, l'esecuzione viene trasferita all'obiettivo indicizzato per valore, in cui le destinazioni sono numerate da 0 (ad esempio, un valore pari a 0 corrisponde alla prima destinazione, un valore di 1 accetta destinazione secondo e così via).</target>       </trans-unit>
        <trans-unit id="4360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the value is greater than or equal to <ph id="ph1">`N`</ph>, execution continues at the next instruction (fall through).</source>
          <target state="translated">Se il valore è maggiore o uguale a <ph id="ph1">`N`</ph>, l'esecuzione continua con l'istruzione successiva (passaggio).</target>       </trans-unit>
        <trans-unit id="4361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</target>       </trans-unit>
        <trans-unit id="4362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Controllare i trasferimenti in e da <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, e <ph id="ph4">`finally`</ph> blocchi non possono essere eseguiti da questa istruzione.</target>       </trans-unit>
        <trans-unit id="4363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>(Such transfers are severely restricted and must use the leave instruction instead).</source>
          <target state="translated">Tali trasferimenti sono limitati gravi e devono invece utilizzare l'istruzione leave.</target>       </trans-unit>
        <trans-unit id="4364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`switch`</ph> opcode.</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`switch`</ph> opcode.</target>       </trans-unit>
        <trans-unit id="4365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.</source>
          <target state="translated">Il <ph id="ph1">`Label[]`</ph> argomento è una matrice di etichette che rappresentano gli offset a 32 bit.</target>       </trans-unit>
        <trans-unit id="4366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>ILGenerator.Emit(OpCode, Label[])</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label[])</target>       </trans-unit>
        <trans-unit id="4367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following code sample illustrates the use of the <ph id="ph1">`Switch`</ph> opcode to generate a jump table using an array of <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato l'utilizzo del <ph id="ph1">`Switch`</ph> opcode per generare una tabella di collegamento, usare una matrice di <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</source>
          <target state="translated">Esegue un'istruzione di chiamata al metodo con suffisso tale da rimuovere lo stack frame del metodo corrente prima dell'esecuzione dell'istruzione di chiamata effettiva.</target>       </trans-unit>
        <trans-unit id="4369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>FE 14</source>
          <target state="translated">FE 14</target>       </trans-unit>
        <trans-unit id="4374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>tail.</source>
          <target state="translated">tail.</target>       </trans-unit>
        <trans-unit id="4375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Subsequent call terminates current methods</source>
          <target state="translated">La chiamata successiva termina metodi correnti</target>       </trans-unit>
        <trans-unit id="4376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>There is no stack transition behavior defined for this instruction.</source>
          <target state="translated">Non è definito per questa istruzione Nessun comportamento di transizione dello stack.</target>       </trans-unit>
        <trans-unit id="4377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The <ph id="ph1">`tail`</ph> prefix instruction must immediately precede a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.</source>
          <target state="translated">Il <ph id="ph1">`tail`</ph> deve trovarsi immediatamente prima istruzione di prefisso una <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, o <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> (istruzione).</target>       </trans-unit>
        <trans-unit id="4378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It indicates that the current method's stack frame should be removed before the call instruction is executed.</source>
          <target state="translated">Indica che stack frame del metodo corrente deve essere rimosso prima che venga eseguita l'istruzione di chiamata.</target>       </trans-unit>
        <trans-unit id="4379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</source>
          <target state="translated">Implica inoltre che il valore restituito dalla chiamata seguente è anche il valore restituito dal metodo corrente e di conseguenza, la chiamata può essere convertita in un collegamento tra metodi.</target>       </trans-unit>
        <trans-unit id="4380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The stack must be empty except for the arguments being transferred by the following call.</source>
          <target state="translated">Lo stack deve essere vuoto tranne per gli argomenti vengono trasferiti mediante la chiamata seguente.</target>       </trans-unit>
        <trans-unit id="4381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The instruction following the call instruction must be a ret. Thus the only valid code sequence is <ph id="ph1">`tail. call`</ph> (or <ph id="ph2">`calli`</ph> or <ph id="ph3">`callvirt`</ph>).</source>
          <target state="translated">Istruzione che segue l'istruzione di chiamata deve essere un'istruzione ret. È pertanto la sequenza di codice valido solo <ph id="ph1">`tail. call`</ph> (o <ph id="ph2">`calli`</ph> o <ph id="ph3">`callvirt`</ph>).</target>       </trans-unit>
        <trans-unit id="4382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id="ph1">`call`</ph> instruction, but they may branch to the subsequent <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</source>
          <target state="translated">Le istruzioni Microsoft Intermediate Language (MSIL) corrette non devono creare rami per il <ph id="ph1">`call`</ph> (istruzione), ma può creare un ramo alla successiva <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</source>
          <target state="translated">Il frame corrente non può essere eliminato quando il controllo viene trasferito da codice non attendibile a codice attendibile, in quanto questo comprometterebbe la protezione dell'identità del codice.</target>       </trans-unit>
        <trans-unit id="4384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The .NET Framework security checks can therefore cause the <ph id="ph1">`tail`</ph> to be ignored, leaving a standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Controlli di sicurezza di .NET Framework è pertanto possibile che il <ph id="ph1">`tail`</ph> venga ignorato, lasciando standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> istruzione.</target>       </trans-unit>
        <trans-unit id="4385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id="ph1">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.</source>
          <target state="translated">Analogamente, in ordine per consentire l'uscita da un'area a cui si verificano dopo la chiamata restituisce sincronizzata, la <ph id="ph1">`tail`</ph> prefisso viene ignorato se utilizzata per terminare un metodo contrassegnato come sincronizzato.</target>       </trans-unit>
        <trans-unit id="4386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`tail`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`tail`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>An instance of an Opcode object.</source>
          <target state="translated">Istanza di un oggetto Opcode.</target>       </trans-unit>
        <trans-unit id="4389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Returns true or false if the supplied opcode takes a single byte argument.</source>
          <target state="translated">Restituisce true o false se il codice operativo fornito accetta un argomento a byte singolo.</target>       </trans-unit>
        <trans-unit id="4390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">&lt;see langword="True" /&gt;</ph> or <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="True" /&gt;</ph> o <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</source>
          <target state="translated">Questo metodo può essere utilizzato per trovare codici MSIL in "forma breve", per l'utilizzo nel codice ottimizzato.</target>       </trans-unit>
        <trans-unit id="4392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">`TakesSingleByteArgument`</ph> returns <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:</source>
          <target state="translated"><ph id="ph1">`TakesSingleByteArgument`</ph> Restituisce <ph id="ph2">`true`</ph> se il <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> istanza accetta un argomento a byte singolo nei casi seguenti:</target>       </trans-unit>
        <trans-unit id="4393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode performs a branch instruction to a byte-sized address (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</source>
          <target state="translated">Il codice operativo esegue un'istruzione branch a un indirizzo dimensioni byte (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode pushes a byte value onto the stack (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</source>
          <target state="translated">Il codice operativo inserisce un valore byte nello stack (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode references a variable or argument via the byte-sized "short form" (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</source>
          <target state="translated">Il codice operativo fa riferimento a una variabile o argomento tramite il byte "forma breve" (ad esempio, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">In caso contrario restituirà <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The example below demonstrates the use of <ph id="ph1">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id="ph2">`OpCodes`</ph> class and testing to see whether each <ph id="ph3">`OpCode`</ph> field takes a single-byte argument.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo di <ph id="ph1">`TakesSingleByteArgument`</ph> tramite reflection sul <ph id="ph2">`OpCodes`</ph> classe e la verifica per vedere se ogni <ph id="ph3">`OpCode`</ph> campo accetta un argomento a byte singolo.</target>       </trans-unit>
        <trans-unit id="4398" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws the exception object currently on the evaluation stack.</source>
          <target state="translated">Genera l'oggetto eccezione attualmente nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>7A</source>
          <target state="translated">7A</target>       </trans-unit>
        <trans-unit id="4404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>throw</source>
          <target state="translated">throw</target>       </trans-unit>
        <trans-unit id="4405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws an exception.</source>
          <target state="translated">Genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="4406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>An object reference (to an exception) is pushed onto the stack.</source>
          <target state="translated">Un riferimento (eccezione) viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The object reference is popped from the stack and the exception thrown.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack e l'eccezione generata.</target>       </trans-unit>
        <trans-unit id="4409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The <ph id="ph1">`throw`</ph> instruction throws the exception object (type <ph id="ph2">`O`</ph>) currently on the stack.</source>
          <target state="translated">Il <ph id="ph1">`throw`</ph> istruzione genera l'oggetto eccezione (tipo <ph id="ph2">`O`</ph>) attualmente nello stack.</target>       </trans-unit>
        <trans-unit id="4410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se il riferimento all'oggetto è un riferimento null.</target>       </trans-unit>
        <trans-unit id="4411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`throw`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`throw`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4413" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph>, or <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> instruction.</source>
          <target state="translated">Indica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph> o <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> immediatamente successiva.</target>       </trans-unit>
        <trans-unit id="4414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>unaligned.</source>
          <target state="translated">non è allineato.</target>       </trans-unit>
        <trans-unit id="4420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that the subsequent pointer instruction may be unaligned.</source>
          <target state="translated">Indica che l'istruzione di puntatore successiva potrebbe essere non allineato.</target>       </trans-unit>
        <trans-unit id="4421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source><ph id="ph1">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id="ph2">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, or <ph id="ph10">`cpblk`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`Unaligned`</ph> Specifica che l'indirizzo (un puntatore non gestito, <ph id="ph2">`native int`</ph>) nello stack potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione immediatamente successiva <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, o <ph id="ph10">`cpblk`</ph> (istruzione).</target>       </trans-unit>
        <trans-unit id="4424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>That is, for a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.</source>
          <target state="translated">Ovvero, per un <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> istruzione l'allineamento dell'indirizzo non può essere di un limite di 4 byte.</target>       </trans-unit>
        <trans-unit id="4425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>For <ph id="ph1">`initblk`</ph> and <ph id="ph2">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</source>
          <target state="translated">Per <ph id="ph1">`initblk`</ph> e <ph id="ph2">`cpblk`</ph> l'allineamento predefinito è dipendente dall'architettura (a 4 byte su processori a 32 bit, 8 byte su processori a 64 bit).</target>       </trans-unit>
        <trans-unit id="4426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Code generators that do not restrict their output to a 32-bit word size must use <ph id="ph1">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.</source>
          <target state="translated">I generatori di codice il cui output non è limitato a una dimensione di word a 32 bit è necessario utilizzare <ph id="ph1">`unaligned`</ph> se l'allineamento non è noto in fase di compilazione a 8 byte.</target>       </trans-unit>
        <trans-unit id="4427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</source>
          <target state="translated">Il valore di allineamento deve essere 1, 2 o 4 e indica che il codice generato deve presupporre che l'indirizzo dei byte, a byte doppio o quadruplo, rispettivamente.</target>       </trans-unit>
        <trans-unit id="4428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Note that transient pointers (type <ph id="ph1">`*`</ph>) are always aligned.</source>
          <target state="translated">Si noti che temporaneo puntatori (tipo <ph id="ph1">`*`</ph>) sono sempre allineati.</target>       </trans-unit>
        <trans-unit id="4429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>While the alignment for a <ph id="ph1">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</source>
          <target state="translated">Mentre l'allineamento per un <ph id="ph1">`cpblk`</ph> istruzione logicamente richiedono due numeri, uno per l'origine e uno per la destinazione, non ha alcun impatto notevole sulle prestazioni se viene specificato il numero più basso solo.</target>       </trans-unit>
        <trans-unit id="4430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The <ph id="ph1">`unaligned`</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated">Il <ph id="ph1">`unaligned`</ph> e <ph id="ph2">`volatile`</ph> possono essere combinati in qualsiasi ordine.</target>       </trans-unit>
        <trans-unit id="4431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Devono precedere immediatamente un <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, o <ph id="ph8">`cpblk`</ph> (istruzione).</target>       </trans-unit>
        <trans-unit id="4432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Only the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Solo il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> è consentito un prefisso per il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="4433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`unaligned`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload è possibile utilizzare il <ph id="ph2">`unaligned`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="4435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(Opcode, Byte)</source>
          <target state="translated">ILGenerator.Emit(Opcode, Byte)</target>       </trans-unit>
        <trans-unit id="4436" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Converts the boxed representation of a value type to its unboxed form.</source>
          <target state="translated">Converte la rappresentazione boxed di un tipo di valore nel relativo formato unboxed.</target>       </trans-unit>
        <trans-unit id="4437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>unbox <ph id="ph1">`valType`</ph></source>
          <target state="translated">eseguire la conversione unboxing <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="4443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Extracts the value type data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Estrae i dati di tipo di valore da <ph id="ph1">`obj`</ph>, la rappresentazione boxed.</target>       </trans-unit>
        <trans-unit id="4444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Riferimento a un oggetto viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The object reference is popped from the stack and unboxed to a value type pointer.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack e unboxed e a un puntatore di tipo valore.</target>       </trans-unit>
        <trans-unit id="4447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The value type pointer is pushed onto the stack.</source>
          <target state="translated">Il puntatore di tipo valore viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Un tipo di valore dispone di due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="4449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'raw' form used when a value type is embedded within another object.</source>
          <target state="translated">'Non elaborato' modulo quando un tipo di valore incorporato all'interno di un altro oggetto.</target>       </trans-unit>
        <trans-unit id="4450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Un modulo 'boxed', in cui i dati nel tipo di valore viene inseriti (boxed) in un oggetto affinché possano esistere come entità indipendenti.</target>       </trans-unit>
        <trans-unit id="4451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The <ph id="ph1">`unbox`</ph> instruction converts the object reference (type <ph id="ph2">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id="ph3">`&amp;`</ph>), its unboxed form.</source>
          <target state="translated">Il <ph id="ph1">`unbox`</ph> istruzione consente di convertire il riferimento all'oggetto (tipo <ph id="ph2">`O`</ph>), la rappresentazione boxed di un tipo valore, in un puntatore di tipo valore (un puntatore gestito di tipo <ph id="ph3">`&amp;`</ph>), la forma unboxed.</target>       </trans-unit>
        <trans-unit id="4452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The supplied value type (<ph id="ph1">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.</source>
          <target state="translated">Tipo di valore fornito (<ph id="ph1">`valType`</ph>) è un token di metadati che indica il tipo del tipo di valore contenuto all'interno dell'oggetto boxed.</target>       </trans-unit>
        <trans-unit id="4453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id="ph2">`unbox`</ph> is not required to copy the value type from the object.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, che è necessario creare una copia di un tipo di valore per l'utilizzo dell'oggetto, <ph id="ph2">`unbox`</ph> non è necessario copiare il tipo di valore dall'oggetto.</target>       </trans-unit>
        <trans-unit id="4454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Typically it simply computes the address of the value type that is already present inside of the boxed object.</source>
          <target state="translated">In genere semplicemente calcola l'indirizzo del tipo di valore che è già presente all'interno dell'oggetto boxed.</target>       </trans-unit>
        <trans-unit id="4455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id="ph2">`valType`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> viene generata se l'oggetto non viene sottoposto a boxing come <ph id="ph2">`valType`</ph>.</target>       </trans-unit>
        <trans-unit id="4456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se il riferimento all'oggetto è un riferimento null.</target>       </trans-unit>
        <trans-unit id="4457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id="ph2">`valType`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> viene generata se il valore di tipo <ph id="ph2">`valType`</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="4458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="4459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`unbox`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Converts the boxed representation of a type specified in the instruction to its unboxed form.</source>
          <target state="translated">Converte la rappresentazione boxed di un tipo specificato nell'istruzione nel relativo formato unboxed.</target>       </trans-unit>
        <trans-unit id="4462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>unbox.any <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">unbox. Any <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="4468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Extract the data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Estrarre i dati da <ph id="ph1">`obj`</ph>, la rappresentazione boxed.</target>       </trans-unit>
        <trans-unit id="4469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Un riferimento all'oggetto <ph id="ph1">`obj`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The object reference is popped from the stack and unboxed to the type specified in the instruction.</source>
          <target state="translated">Il riferimento all'oggetto viene estratto dallo stack e unboxed e al tipo specificato nell'istruzione.</target>       </trans-unit>
        <trans-unit id="4472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The resulting object reference or value type is pushed onto the stack.</source>
          <target state="translated">Il tipo di valore o riferimento oggetto risultante viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to the boxed form of a value type, the <ph id="ph1">`unbox.any`</ph> instruction extracts the value contained within <ph id="ph2">`obj`</ph> (of type <ph id="ph3">`O`</ph>), and is therefore equivalent to <ph id="ph4">`unbox`</ph> followed by <ph id="ph5">`ldobj`</ph>.</source>
          <target state="translated">Quando applicato a formato boxed del tipo di valore, il <ph id="ph1">`unbox.any`</ph> istruzione estrae il valore contenuto in <ph id="ph2">`obj`</ph> (di tipo <ph id="ph3">`O`</ph>) ed è pertanto equivalente a <ph id="ph4">`unbox`</ph> seguito da <ph id="ph5">`ldobj`</ph>.</target>       </trans-unit>
        <trans-unit id="4474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to a reference type, the <ph id="ph1">`unbox.any`</ph> instruction has the same effect as <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</source>
          <target state="translated">Quando applicato a un tipo riferimento, il <ph id="ph1">`unbox.any`</ph> istruzione ha lo stesso effetto <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="4475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>If the operand <ph id="ph1">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</source>
          <target state="translated">Se l'operando <ph id="ph1">`typeTok`</ph> è un parametro di tipo generico, il comportamento di runtime è determinato dal tipo specificato per tale parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="4476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is not a boxed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> viene generata se <ph id="ph2">`obj`</ph> non è un tipo boxed.</target>       </trans-unit>
        <trans-unit id="4477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> viene generata se <ph id="ph2">`obj`</ph> è un riferimento null.</target>       </trans-unit>
        <trans-unit id="4478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox.any`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`unbox.any`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator (OpCode, Type)</target>       </trans-unit>
        <trans-unit id="4480" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Specifica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe essere volatile e che i risultati della lettura del percorso non possono essere memorizzati nella cache o che non è possibile eliminare archivi multipli in tale percorso.</target>       </trans-unit>
        <trans-unit id="4481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>FE 13</source>
          <target state="translated">FE 13</target>       </trans-unit>
        <trans-unit id="4486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>volatile.</source>
          <target state="translated">volatile.</target>       </trans-unit>
        <trans-unit id="4487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Indicates that the subsequent pointer reference is volatile.</source>
          <target state="translated">Indica che il riferimento al puntatore successivo è volatile.</target>       </trans-unit>
        <trans-unit id="4488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Un indirizzo viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source><ph id="ph1">`volatile`</ph>.</source>
          <target state="translated"><ph id="ph1">`volatile`</ph>.</target>       </trans-unit>
        <trans-unit id="4491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Specifica che l'indirizzo è un indirizzo volatile (vale a dire possono farvi riferimento esternamente al thread corrente di esecuzione) e i risultati della lettura che non può essere memorizzato nella cache di percorso o che non è possibile eliminare archivi multipli in tale percorso.</target>       </trans-unit>
        <trans-unit id="4492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Marking an access as <ph id="ph1">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.</source>
          <target state="translated">Uso di <ph id="ph1">`volatile`</ph> interessa solo accesso in questione; gli altri accessi nello stesso percorso devono essere contrassegnati separatamente.</target>       </trans-unit>
        <trans-unit id="4493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Access to volatile locations need not be performed atomically.</source>
          <target state="translated">Accesso a percorsi volatili non è necessario eseguire in modo atomico.</target>       </trans-unit>
        <trans-unit id="4494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> e <ph id="ph2">`volatile`</ph> possono essere combinati in qualsiasi ordine.</target>       </trans-unit>
        <trans-unit id="4495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Devono precedere immediatamente un <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, o <ph id="ph8">`cpblk`</ph> (istruzione).</target>       </trans-unit>
        <trans-unit id="4496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Only the <ph id="ph1">`volatile`</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Solo il <ph id="ph1">`volatile`</ph> è consentito un prefisso per il <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="4497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`volatile`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`volatile`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4499" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</source>
          <target state="translated">Calcola l'operazione XOR bit per bit dei primi due valori dello stack di valutazione, inserendo il risultato nello stack di valutazione.</target>       </trans-unit>
        <trans-unit id="4500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</target>       </trans-unit>
        <trans-unit id="4501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Format</source>
          <target state="translated">Formato</target>       </trans-unit>
        <trans-unit id="4502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Assembly Format</source>
          <target state="translated">Formato dell'assembly</target>       </trans-unit>
        <trans-unit id="4503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="4504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>61</source>
          <target state="translated">61</target>       </trans-unit>
        <trans-unit id="4505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>xor</source>
          <target state="translated">xor</target>       </trans-unit>
        <trans-unit id="4506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of two integer values and returns an integer.</source>
          <target state="translated">Calcola il XOR bit per bit su due valori integer e restituisce un valore integer.</target>       </trans-unit>
        <trans-unit id="4507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Il comportamento di transizione dello stack, in ordine sequenziale, è:</target>       </trans-unit>
        <trans-unit id="4508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise XOR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> vengono estratti dallo stack e i relativi bit per bit XOR calcolata.</target>       </trans-unit>
        <trans-unit id="4511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The bitwise XOR of <ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">L'operazione XOR di <ph id="ph1">`value2`</ph> e <ph id="ph2">`value1`</ph> viene inserito nello stack.</target>       </trans-unit>
        <trans-unit id="4512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The <ph id="ph1">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated">Il <ph id="ph1">`xor`</ph> istruzione calcola il XOR bit per bit dei primi due valori nello stack e lascia il risultato nello stack.</target>       </trans-unit>
        <trans-unit id="4513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`Xor`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Xor`</ph> è un'operazione specifica del numero intero.</target>       </trans-unit>
        <trans-unit id="4514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`xor`</ph> opcode:</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> overload del metodo è possibile utilizzare il <ph id="ph2">`xor`</ph> opcode:</target>       </trans-unit>
        <trans-unit id="4515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>